<title>HP2100A Assembler Reference Manual</title>
<pre>
		   ASSEMBLER REFERENCE MANUAL

                       TABLE OF CONTENTS


INTRODUCTION                                                <a href="#vi">vi</a>

CHAPTER 1  GENERAL DESCRIPTION                              <a href="#1-1">1-1</a>
           1.1    Assembly Processing                       1-1
           1.2    Symbolic Addressing                       1-1
           1.3    Program Relocation                        1-3
           1.4    Program Location Counters                 1-3
           1.5    Assembly Options                          1-4

CHAPTER 2  INSTRUCTION FORMAT                               <a href="#2-1">2-1</a>
           2.1    Statement Characteristics                 2-1
                    Field Delimiters                        2-1
                    Character Set                           2-1
                    Statement Length                        2-3
           2.2    Label Field                               2-3
                    Label Symbol                            2-3
                    Asterisk                                2-5
           2.3    Opcode Field                              2-5
           2.4    Operand Field                             2-5
                    Symbolic Terms                          2-6
                    Numeric Terms                           2-7
                    Asterisk                                2-5    ?
                    Expression Operators                    2-7
                    Evaluation of Expressions               2-8
                    Expression Terms                        2-9
                    Absolute and Relocatable
                      Expressions                           2-9
                    Literals                                2-11
                    Indirect Addressing                     2-12
                    Base Page Addressing                    2-13
                    Clear Flag Indicator                    2-13
           2.5    Comments Field                            2-13

CHAPTER 3  MACHINE INSTRUCTIONS                             <a href="#3-1">3-1</a>
           3.1    Memory Reference                          3-1
                    Jump and Increment-Skip                 3-2
                    Add, Load, and Store                    3-2
                    Logical Operations                      3-3
           3.2    Register Reference                        3-4
                    Shift-Rotate Group                      3-4
                    No-Operation Instructions               3-5
                    Alter-Skip Group                        3-6
           3.3    Input/Output, Overflow and Halt           3-7
                    Input/Output                            3-8
                    Overflow                                3-9
                    Halt                                    3-10
           3.4    Extended Arithmetic Unit                  3-11
           3.5    Floating-Point Instructions               3-13

CHAPTER 4  PSEUDO INSTRUCTIONS                              <a href="#4-1">4-1</a>
           4.1    Assembler Control                         4-1
                    NAM  ORG                                4-1
                    ORR                                     4-2
                    ORB                                     4-3
                    IFN  IFZ                                4-4
                    REP                                     4-6
                    END                                     4-7
           4.2    Object Program Linkage                    4-8
                    COM                                     4-8
                    ENT  EXT                                4-10
           4.3    Address and Symbol Definition             4-11
                    DEF                                     4-12
                    ABS  EQU                                4-15
           4.4    Constant Definition                       4-17
                    ASC                                     4-17
                    DEC                                     4-18
                    DEX                                     4-20
                    OCT                                     4-22
           4.5    Storage Allocation                        4-23
                    BSS                                     4-23
           4.6    Assembly Listing Control                  4-23
                    UNL                                     4-23
                    LST  SUP  UNS                           4-24
                    SKP  SPC  HED                           4-25
           4.7    Arithmetic Subroutine Calls               4-26
                    MPY  DIC  FMP  FDV                      4-26
                    FAD  FSB  DLD  DST                      4-27

CHAPTER 5  ASSEMBLER INPUT AND OUTPUT                       <a href="#5-1">5-1</a>
           5.1    Control Statement                         5-1
                    A  R  B  L                              5-1
                    T  H  Z  F                              5-2
           5.2    Source Program                            5-3
           5.3    Binary Output                             5-3
           5.4    List Output                               5-3

APPENDIX A HP CHARACTER SET                                 <a href="#a-1">A-1</a>
           BINARY CODED DECIMAL FORMAT                      A-2
               Kennedy 1406/1506 ASCII -- BCD               A-2
               HP 2020A/B ASCII - BCD                       A-3

APPENDIX B ASSEMBLER INSTRUCTIONS                           <a href="#b-1">B-1</a>
           MACHINE INSTRUCTIONS
               Memory Reference                             B-2
               Register Reference                           B-2
               Input/Output, Overflow, and Halt             B-4
               Extended Arithmetic Unit                     B-5
           PSEUDO INSTRUCTIONS
               Assembler Control                            B-6
               Object Program Linkage                       B-6
               Address and Symbol Definition                B-6
               Constant Definition                          B-7
               Arithmetic Subroutine Calls Requests         B-7
               Assembly Listing Control                     B-8

APPENDIX C ALPHABETIC LIST OF INSTRUCTIONS                  <a href="#c-1">C-1</a>

APPENDIX D SAMPLE PROGRAMS                                  <a href="#d-1">D-1</a>
               File Parts Update                            D-1
                 Sample Assembler Symbol
                   Table Output                             D-3
                 Sample Assembler List Output               D-4
               Calculating Distance                         D-9

APPENDIX E SYSTEM INPUT/OUTPUT SUBROUTINES                  <a href="#e-1">E-1</a>
               Memory Allocation                            E-1
               Operation and Calling Sequence:
                 Paper Tape Devices                         E-2
                   Register Contents                        E-2
               Operation and Calling Sequence:
                 Magnetic Tape Driver                       E-3
                   Register Contents                        E-3
                   Linkage Address                          E-4
               Magnetic Tape Operations                     E-4
                   Read                                     E-4
                   Write                                    E-5
                   Write End-of-File                        E-6
                   Rewind                                   E-6
                   Position                                 E-6
                   Rewind/Standby                           E-7
                   Gap                                      E-7
                   Status                                   E-7
                   Additional Linkage Addresses             E-10
               Buffer Storage Area                          E-10
                   Record Formats                           E-10
               2020 7-Level Tape                            E-12
               3030 9-Level Tape                            E-12
               Operating and Calling Sequence:
                 Mark Sense Card Reader                     E-13
                   Register Contents                        E-13

APPENDIX F FORMATTER                                        <a href="#f-1">F-0</a>
               Calling Sequences                            F-0
               Format Specifications                        F-2
               Example                                      F-3


APPENDIX G ASSEMBLY ERROR MESSAGES                          <a href="#g-1">G-1</a>


APPENDIX H CONSOLIDATED CODING SHEET                        <a href="#h-1">H-1</a>

<hr>
<a name="vi">
                            INTRODUCTION

The Assembler and the Extended Assembler translate symbolic
source language instructions into an object program for execution
on the computer. The source language provides mnemonic machine
operation codes, assembler directing pseudo codes, and symbolic
addressing. The assembled program may be absolute or relo-
catable.

The source program may be assembled as a complete entity or it
may be subdivided into several subprograms (or a main program
and several subroutines), each of which may be assembled separ-
ately. The relocating loader loads the program and Links the
subprograms as required. The Basic Binary Loader or Basic
Binary Disc Loader loads absolute programs.

Input for the Assembler is prepared on paper tape or cards; the Assem-
bler punches the binary program on paper tape in a format acceptable
to the loader.

                      GENERAL DESCRIPTION

<a name="#1-1">
1.1  ASSEMBLY PROCESSING

The Assembler is a two pass system, or, if both punch and
list output are requested, a three pass system on a minimum
configuration. A pass is defined as a processing cycle of the
source program input.

In the first pass, the Assembler creates a symbol table from
the names used in the source statements. It also checks for
certain possible error conditions and generates diagnostic
messages if necessary.

During pass two, the Assembler again examines each state-
ment in the source program along with the symbol table and
produces the binary program and a program listing. Addition
diagnostic messages may also be produced.

If only one output device is available and if both the binary
output and list output are requested, the listing function is
deferred and performed as pass three.

When using the Assembler with a mass storage device the source
program is written on the device during the first pass; the second
pass of the source is read from the mass storage.

1.2  SYMBOLIC ADDRESSING

Symbols may be used for referring to machine instructions,
data, constants, and certain other pseudo operations. A sym-
bol represents the address for a computer word in memory.
A symbol is defined when it is used as a label for a location in
the program, a name of a common storage segment, the label
of a data storage area or constant, the label of an absolute or
relocatable value, or a location external to the program.

Through use of simple arithmetic operators, symbols may be
combined with other symbols or numbers to form an expres-
sion which may identify a location other than that specifically
named by a symbol. Symbols appearing in operand expres-
sions, but not specifically defined, and symbols that are
defined more than once are considered to be in error by the
Assembler.

                                                                          1-1
<hr>


                            [IMAGE]

                       HP ASSEMBLER PROCESSING

                                                                          1-2
<hr>
1.3  PROGRAM RELOCATION

Relocatable programs may be relocated in core by the relocating
loader; the location of the program origin and all subsequent
instructions is determined at the time the program is loaded.

A relocatable program is assembled assuming a starting
location of zero. All other instructions and data areas are
assembled relative to this zero base. When the program is
loaded, the relocatable operands are adjusted to correspond
with the actual locations assigned by the loader.

The starting locations of the common storage area and the
base page portion of the program are always established by
the loader. References to the common area are common re-
locatable. Reference to the base page portion of the program
are base page relocatable. If a program refers to the common
area or makes use of the base page via the ORB pseudo in-
struction, the program must also be relocatable.

If a program is to be relocatable, all subprograms comprising
the program must be relocatable; all memory reference
operands must be relocatable expressions or literals, or have
an absolute value of less than 100(8).

1.4  PROGRAM LOCATION COUNTERS

The Assembler maintains a counter, called the program loca-
tion counter, that assigns consecutive memory addresses to
source statements.

The initial value of the program location counter is estab-
lished according to the use of either the NAM or ORG psuedo
operation at the start of the program. The NAM operation
causes the program location counter to be set to zero for a
relocatable program; the ORG operation specifies the absolute
starting location for an absolute program.

Through use or the ORB pseudo operation a relocatable pro-
gram may specify that certain operations or data areas be
allocated to the base page. If so, a separate counter, called
the base page location counter, is used in assigning these
locations.

                                                                          1-3
<hr>
1.5  ASSEMBLY OPTIONS

Parameters specified with the first statement, the control
statement, define the output to be produced by the assembler: [1]

    Absolute - The addresses generated by the Assembler
    are to be interpreted as absolute locations in memory.
    The program is a complete entity; external symbols,
    common storage references, and entry points are not
    permitted.

    Relocatable - The program may be located anywhere in
    memory. All operands which refer to memory locations
    are adjusted as the program is loaded. Operands, other
    than those referring to the first 64 locations, must be re-
    locatable expressions. Subprograms may contain external
    symbols and entry points, and may refer to common
    storage.

    Binary output - An absolute or relocatable program is
    to be punched on the paper tape.

    List output - A program listing is produced either during
    pass two or pass three.

    Table print - List the symbol table at the end of the first
    pass.

    Selective assembly - Sections of the program may be
    included or excluded at assembly time depending on the
    option used.





-----------------
[1] See Chapter 5 for complete details.

                                                                          1-4
<hr>
                         INSTRUCTION FORMAT

A source language statement consists of a label, an operation
code, an operand, and comments. The label is used when needed
as a reference by other statements. The operation code may
be a mnemonic machine operation or an assembly directing
pseudo code. An operand may be an expression consisting of
an alphanumeric symbol, a number, a special character, or
any of these combined by arithmetic operations. (For the
Extended Assembler, an operand may also be a literal.)
Indicators may be appended to the operand to specify certain
functions such as indirect addressing. The comments portion
of the statement is optional.

<a name="#2-1">
2.1  STATEMENT CHARACTERISTICS

The fields of the source statement appear in the following
order:

    Label
    Opcode
    Operand
    Comments

FIELD DELIMITERS

One or more spaces separate the fields of a statement.  An
end-of-statement mark terminates the entire statement. On
paper tape this mark is a return, (CR), and a line feed, (LF).  [1]
A single space following the end-of-statement mark from the
previous source statement is the null field indicator of the
label field.

CHARACTER SET

The characters that may appear in a statement are as follows:

    A  through  Z
    0  through  9
    .  (period)
    *  (asterisk)

---------------------
[1] A circled symbol, e.g. (CR), represents an ASCII code or
    Teleprinter key.
                                                                          2-1
<hr>

                    HEWLETT-PACKARD ASSEMBLER CODING FORM
 ----------------------------------------------------------------------------
| PROGRAMMER:               | DATE:       | PROGRAM:         | PAGE:   OF    |
 ----------------------------------------------------------------------------

 ----------------------------------------------------------------------------
| Label   Operation   Operand             Comments                           |
|----------------------------------------------------------------------------|
|       |           |                   |                                    |
|       |           |                   |                                    |
|       |           |                   |                                    |
|       |           |                   |                                    |
|       |           |                   |                                    |
|       |           |                   |                                    |
|       |           |                   |                                    |
|       |           |                   |                                    |
 ----------------------------------------------------------------------------


                             SAMPLE CODING FORM
                          (Actual Size 11 x 13 1/2)


                                                                          2-2
<hr>

    +  (plus)
    -  (minus)
    ,  (comma)
    =  (equals)
   ()  (parenthesis)
       (space)

Any other ASCII characters may appear in the Remarks field
(See Appendix A).

The letters A through Z, the numbers 0 through 9, and the
period may be used in an alphanumeric symbol. In the first
position in the Label field, an asterisk indicates a comment;
in the Operand field, it represents the value of the program
location counter for the current instruction. The plus and
minus are used as operators in arithmetic address expres-
sions. The comma separates several operation codes, or an
expression and an indicator in the Operand field. An equals
sign indicates a literal value. The parentheses are used only
in the COM pseudo instruction.

Spaces separate fields of a statement. They may also be used
to establish the format of the output list. Within a field they
may be used freely when following +, -, ,, or (.

STATEMENT LENGTH

A statement may contain up to 80 characters including blanks,
but excluding the end-of-statement mark. Fields beginning in
characters 73-80 are not processed by the Assembler.

2.2 LABEL FIELD

The Label field identifies the statement and may be used as a
reference point by other statements in the program.

Te field starts in position one of the statement; the first
position following an end-of-statement mark for the preceding
statement. It is terminated by a space. A space in position
one is the null field indicator for the label field; the statement
is unlabeled.

LABEL SYMBOL

A label must be symbolic. It may have one to five characters
consisting of A through Z, 0 through 9, and the period. The

                                                                          2-3
<hr>
first character must be alphabetic or a period. A label of
more than five characters could be entered on the source lan-
guage tape, but the Assembler flags this condition as an error
and truncates the label from the right to five characters.

Examples:

1   5   10   15   20   25   30   35   40
----------------------------------------
      LDA           NO LABEL
.ABCD               VALID LABEL
.1234               VALID LABEL
A.123               VALID LABEL
.                   VALID LABEL
1.AB                ILLEGAL LABEL - FIRST CHARACTER NUMERIC
ABC123              ILLEGAL LABEL - TRUNCATED TO ABC12
A*BC                ILLEGAL LABEL - ASTERISK NOT ALLOWED IN LABEL
 ABC                NO LABEL - THE ASSEMBLER ATTEMPTS TO INTERPRET
                               ABC AS AN OPERATION CODE

Each label must be unique within the program; two or more
statements may not have the same symbolic name. Names
which appear in the Operand field of an EXT or COM pseudo
instruction may not also be used as statement labels in the
same subprogram.

Examples:

1   5   10   15   20   25   30   35   40
----------------------------------------
      COM ACOM(20),BC(30)
LB    EQU 160       VALID LABEL
      EXT XL1,XL2
START LDA LB        VALID LABEL
N25                 VALID LABEL
XL2                 ILLEGAL LABEL - USED IN EXT
BC                  ILLEGAL LABEL - USED IN COM
N25                 ILLEGAL LABEL - PREVIOUSLY DEFINED

                                                                          2-4
<hr>
ASTERISK

An asterisk in position one indicates that the entire statement
is a comment. Positions 2 through 80 are available; however,
positions 1 through 68 only are printed as part of the assembly
listing on the 2672A Teleprinter. An asterisk within the Label
field is illegal in any position other than one.

2.3  OPCODE FIELD

The operation code defines an operation to be performed by
the computer or the Assembler. The Opcode field follows the
Label field and is separated from it by at least one space. If
there is no label, the operation code may begin anywhere after
position one. The Opcode field is terminated by a space im-
mediately following an operation code. Operation codes are
organized in the following categories:

    Machine operation codes
        Memory Reference
        Register Reference
        Input/Output, Overflow, and Halt
        Extended Arithmetic Unit
    Pseudo operation codes
        Assembler control
        Object program linkage
        Address and symbol definition
        Constant definition
        Storage allocation
        Arithmetic subroutine calls
        Assembly Listing Control (Extended Assembler)

Operation codes are discussed in detail in Chapters 3 and 4.

2.4  OPERAND FIELD

The meaning and format of the Operand field depend on the
type of operation code used in the source statement. The field
follows the Opcode field and is separated from it by at least
one space. It is terminated by a space except when the space
follows , + - ( or, if there are no comments, by an end-of-
statement mark.

                                                                          2-5
<hr>
The operand field may contain an expression consisting of one
of the following:

    Single symbolic term

    Single numeric term

    Asterisk

    Combination of symbolic terms, numeric terms, and the
    asterisk joined by the arithmetic operators + and -.

    An expression may be followed by a comma and an
    indicator.

    Programs being assembled by the Extended Assembler
    may also contain a literal value in the Operand field.

SYMBOLIC TERMS

A symbolic term may be one to five characters consisting of
A through Z, 0 through 9, and the period. The first character
must be alphabetic or a period.

Examples:

1   5   10   15   20   25   30   35   40
----------------------------------------
      LDA A1234     VALID IF DEFINED
      ADA B.1       VALID IF DEFINED
      JMP ENTRY     VALID IF DEFINED
      STA 1ABC      ILLEGAL OPERAND - FIRST CHARACTER NUMERIC
      STB ABCDEF    ILLEGAL OPERAND - MORE THAN FIVE CHARACTERS

A symbol used in the Operand field must be a symbol that is
defined elsewhere in the program in one of the following ways:

    As a label in the Label field of a machine operation

    As a label in the Label field of a BSS, ASC, DEC, OCT,
    DEF, ABS, EQU or REP pseudo operation

    As a name in the Operand field of a COM or EXT pseudo
    operation

    As a label in the Label field of an arithmetic subroutine
    pseudo operation.

                                                                          2-6
<hr>
The value of a symbol is absolute or relocatable depending on
the assembly option selected by the user. The assembler as-
signs a value to a symbol as it appears in one of the above
fields of a statement. If a program is to be loaded in absolute
form, the values assigned by the assembler remain fixed. If
the program is to be relocated, the actual value of a symbol is
established on loading. A symbol may also be made absolute
through use of the EQU pseudo instruction.

A symbolic term may be preceded by a plus or minus sign. If
preceded by a plus or no sign, the symbol refers to its associ-
ated value. If preceded by a minus sign, the symbol refers to
the two's complement of its associated value. A single nega-
tive symbolic operand may be used only with the ABS pseudo
operation.

NUMERIC TERMS

A numeric term may be decimal or octal. A decimal number
is represented by one to five digits within the range 0 to
32767. An octal number is represented by one to six octal
digits followed by the letter B; (0 to 177777B).

If a numeric term is preceded by a plus or no sign, the binary
equivalent of the number is used in the object code. If pre-
ceded by a minus sign, the two's complement of the binary
equivalent is used. A negative numeric operand may be used
only with the DEX, DEC, OCT, and ABS pseudo operations.

In an absolute program, the maximum value of a numeric
operand depends on the type of machine or psuedo instruction.
In a relocatable program, the value or a numeric operand may
not exceed 77B. Numeric operands are absolute. Their value
is not altered by the assembler or the loader.

ASTERISK

An asterisk in the Operand field refers to the value in the
program location counter (or base page location counter) at the
time the source program statement is encountered. The
asterisk is considered a relocatable term in a relocatable
program.

EXPRESSION OPERATORS

The asterisk, symbols, and numbers may be joined by the
arithmetic operators + and - to form arithmetic address ex-
pressions. The Assembler evaluates an expression and pro-
duces an absolute or relocatable value in the object code.

                                                                          2-7
<hr>
Examples:

If P1 and P2 are program relocatable terms; B1 and B2, base
page relocatable; C1 and C2, common relocatable; and A, an
absolute term; then the following are absolute terms:

    A-C1+C2       A-P1+P2       C1-C2+A
    A+A           P1-P2         B1-B2
    *-P1          B1-B2-A       -C1+C2+A
    B1-*          -P1+P2        -A-P1+P2

The asterisk is base page relocatable or program relocatable
depending on the location of the instruction.

RELOCATABLE EXPRESSIONS

A relocatable expression is one whose value is changed by the
loader. All relocatable expressions must have a positive
value.

A relocatable expression may contain any odd number of relo-
catable terms, alone, or in combination with absolute terms.
All relocatable terms must be of the same type. Terms must
be paired by sign with the odd term being positive.

A relocatable expression reduces to a single positive relo-
catable term, adjusted by the valued represented by the abso-
lute terms and paired relocatable terms associated with it.

Examples:

If P1, P2 and P3 are program relocatable terms; B1, B2 and
B3, base page relocatable; C1, C2 and C3, common relocatable;
and A, an absolute term, then the following are relocatable
terms:

    P1-A          C1-A          B1+A
    P1-P2+P3      C1-C2+C3      C1+A
    *+A           *-P1+P2       *-A
    A+B1          A+C1          -A-P1+P2+P3
    B1-B2+B3-A    C1-C2+C3-A    A+*
    *+P1-*        P1-P2+*       -C1+C2+C3

                                                                          2-10
<hr>
LITERALS

Actual literal values may be specified as operands in re-
locatable programs to be assembled by the Extended Assembler.
The Extended Assembler converts the literal to its binary
value, assigns an address to it, and substitutes this address
as the operand. Locations assigned to literals are those
immediately following the last location used by the program.

A literal is specified by using an equal sign and a one-
character identifier defining the type of the literal. The actual
literal value is specified immediately following this identifier;
no spaces may intervene.

The identifiers are:

    =D  a decimal integer, in the range -32767 to 32767,
        including zero. [1]

    =F  a floating-point number; any positive or negative
        real number in the range 10**-38 to 10**38, including
        zero. [1]

    =B  an octal integer, one to six digits, b1b2b3b4b5b6,
        where b1 may be 0 or 1, and b2-b7 may be 0 to 7. [1]

    =A  two ASCII characters. [1]

    =L  an expression which, when evaluated, will result
        in an absolute value.  All symbols appearing in the
        expression must be previously defined.

If the same literal is used in more than one instruction,
only one value is generated, and all instructions using this
literal refer to the same location.

Literals may be specified only in the following memory
reference instructions and pseudo instructions:

    ADA  DSB  AND  MPY   \
    LDA  LDB  XOR  DIV    &gt;  may use =D, =B, =A, =L
    CPA  CPB  IOR        /

    DLD  FAD   \
    FMP  FSB    &gt;  may use =F
    FDV        /

---------------------
[1] See CONSTANT DEFINITION, Section 4.4.

                                                                          2-11
<hr>
Examples:

    LDA =D7980          A-Register is loaded with the binary equiv-
                        alent of 7980 base 10.

    IOR =B777           Inclusive "or" is performed with contents of
                        A-Register and 777 base 8

    LDA =ANO            A-Register is loaded with binary representa-
                        tion of ASCII characters NO.

    LDB =LZETZ-ZOOM+68  B-Register is loaded with the value resulting
                        from the absolute expression

    FMP =F39.75         Contents of A- and B-Registers multiplied
                        by floating-point constant 39.75.

INDIRECT ADDRESSING

The HP computers provide an indirect addressing capability
for Memory Reference instructions. The operand portion of
an indirect instruction contains an address of another location
rather than an actual operand. The secondary location may be
the operand or it may be indirect also and give yet another
location, and so forth. The chaining ceases when a location is
encountered that does not contain an indirect address. Indirect
addressing provides a simplified method of address modifi-
cations as wall as allowing access to any location in core.

The Assembler allows specification of indirect addressing by
appending a comma and the letter I to any Memory Reference
operand other than one referring to an external symbol. The
actual operand of the instruction may be given in a DEF pseudo
operation; this pseudo operation may also be used to indicate
further levels of indirect addressing.

Examples:

1   5   10   15   20   25   30   35   40
----------------------------------------
AB    LDA SAM,I     EACH TIME THE ISZ IS EXECUTED,
AC    ADA SAM,I     THE EFFECTIVE OPERAND OF AB AND
AD    ISZ SAM       AC CHANGE ACCORDINGLY.
       .
       .
       .
SAM   DEF ROGER

                                                                          2-12
<hr>
A relocatable assembly language program, however, may be
designed without concern for the pages in which it will be
stored; indirect addressing is not required in the source lan-
guage. When the program is being loaded, the loader provides
indirect addressing whenever it detects an operand which does
not fall in the current page or the base page. The loader sub-
stitutes a reference to the base page and then stores an indirect
address in this referenced location. References to the same
operand from other pages will be linked through the same loca-
tion in the base page.

BASE PAGE ADDRESSING

The computer provides a capability which allows the Memory
Reference instructions to address either the current page or
the base page. The Assembler or the loader adjusts all instruc-
tions in which the operands refer to the base page; specific nota-
tion defining an operand as a base page reference is not required
in the source program.

CLEAR FLAG INDICATOR

The majority of the input/output instructions can alter the
status of the input/output interrupt flag after execution or
after the particular test is performed. In source language,
this function is selected by appending a comma and a letter C
to the Operand field.

Examples:

1   5   10   15   20   25   30   35   40
----------------------------------------
      STC IO7,C     CLEAR FLAG IO7 AFTER CONTROL BIT IS SET
      OTB IO5,C     CLEAR FLAT IO5 AFTER MOVE

2.5  COMMENTS FIELD

The comments field allows the user to transcribe notes on the
program that will be listed with source language coding on the
output produced by the Assembler. The field follows the
Operand field and is separated form it by at least one space.
The end-of-statement mark, (CR)(LF), or the 80th character
in the entire statement terminates the field. If the listing is to
be produced on the 2752A Teleprinter, the total statement
length, excluding the end-of-statement mark, should not ex-

                                                                          2-13
<hr>
ceed 52 characters, the width of the source language portion
of the listing. Statements consisting solely of comments may
contain up to 68 characters including the asterisk in the first
position. On the list output, statements consisting entirely
of comments begin in position 5 rather than 21 as with other
source statements.

If there is no operand present, the Comments field should be
omitted in the NAM and END pseudo operations and in the input/
output statements SOC, SOS and HLT instruction. If a comment
is used, the Assembler attempts to interpret it as an operand.


                                                                          2-14
<hr>
                      MACHINE INSTRUCTIONS

The HP Assembler language machine instruction codes take the
form of three-letter mnemonics. Each source statement cor-
responds to a machine operation in the object program pro-
duced by the assembler.

Notation used in representing source language instruction is
as follows:

    label       Optional statement label

    m           Memory location -- an expression

    I           Indirect addressing indicator

    sc          Select code -- an expression

    C           Clear interrupt flag indicator

    comments    Optional comments

    [ ]         Brackets defining a field or portion of a
                field that is optional

    { }         Braces indicating that one of the set
                may be selected

    lit         literal

<a name="#3-1">
3.1  MEMORY REFERENCE

Memory Reference instructions perform arithmetic, logical
and jump operations on the contents of the locations in core
and the registers. An instruction may directly address the
2048 words of the current and base pages. If required, in-
direct addressing may be utilized to refer to all 32,768 words
of memory.  Expressions in the operand field are evaluated
modulo 2**10.

If the program is to be assembled in relocatable form, the
operand field may contain relocatable expressions or absolute
expressions which are less than 100(8) in value. If the program
is to be absolute, the operands may be any expressions con-
sistent with the location of the program. Literals may not be
used in an absolute program. Absolute programs must be
complete entities; they may not refer to external subroutines
or common storage.

                                                                          3-1
<hr>
JUMP AND INCREMENT-SKIP

Jump and Increment-Skip instructions may alter the normal
sequence of program execution.

------+-----+---------+--------
label   JMP   m[,I]     comments

Jump to m. Jump indirect inhibits interrupt until the transfer
of control is complete.

------+-----+---------+--------
label   JSB   m[,I]     comments

Jump to subroutine. The address for label_1 is placed into
the location represented by m and control transfers to m+1.
On completion of the subroutine, control may be returned to
the normal sequence by performing a JMP m,I.

------+-----+---------+--------
label   ISZ   m[,I]     comments

Increment, then skip if zero. ISZ adds 1 to the contents of m.
If m then equals zero, the next instruction in memory is by-
passed.

ADD, LOAD, AND STORE

Add, Load, and Store instructions transmit and alter the con-
tents of memory and of the A- and B-Registers. A literal,
indicated by "lit", may be either =D, =B, =A, or =I type.

------+-----+---------+--------
label   ADA   m[,I]     comments
              lit

Add the contents of m to A.

------+-----+---------+--------
label   ADB   m[,I]     comments
              lit

Add the contents of m to B.

------+-----+---------+--------
label   LDA   m[,I]     comments
              lit

Load A from m.

------+-----+---------+--------
label   LDB   m[,I]     comments
              lit

Load B from m.

                                                                          3-2
<hr>
------+-----+---------+--------
label   STA   m[,I]     comments

Store contents of A in m.

------+-----+---------+--------
label   STB   m[,I]     comments

Store contents of B in m.

In each instruction, the contents of the sending location is un-
changed after execution.

LOGICAL OPERATIONS

The Logical operations allow bit manipulation and the com-
parison of two computer words.

------+-----+---------+--------
label   AND   m[,I]     comments

The logical product of the contents of m and the contents of A
are placed in A.

------+-----+---------+--------
label   XOR   m[,I]     comments

The modulo-two sum (exclusive "or") of the bits in m and the
bits in A is placed in A.

------+-----+---------+--------
label   IOR   m[,I]     comments

The logical sum (inclusive "or") of the bits in m and the bits
in A is placed in A.

------+-----+---------+--------
label   CPA   m[,I]     comments

Compare the contents of m with the contents of A. If they
differ, skip the next instruction; otherwise, continue.

------+-----+---------+--------
label   CPB   m[,I]     comments

Compare the contents of m with the contents of B. If they
differ, skip the next instruction; otherwise, continue.
                                                                          3-3
<hr>
3.2  REGISTER REFERENCE

The Register Reference instructions include a Shift-Rotate
group, an Alter-Skip group, and NOP (no-operation). With
the exception of NOP, they have the capability of causing
several actions to take place during one memory cycle. Mul-
tiple operations within a statement are separated by a comma.

SHIFT-ROTATE GROUP

This group contains 19 basic instructions that can be combined
to produce more then 500 different single cycle operations.

    CLE    Clear E to zero

    ALS    Shift A left one bit, zero to least significant bit.
           Sign unaltered

    BLS    Shift B left one bit, zero to least significant bit.
           Sign unaltered

    ARS    Shift A right one bit, extend sign; sign unaltered.

    BRS    Shift B right one bit, extend sign; sign unaltered.

    RAL    Rotate A left one bit

    RBL    Rotate B left one bit

    RAR    Rotate A right one bit

    RBR    Rotate B right one bit

    ALR    Shift A left one bit, clear sign, zero to least
           significant bit

    BLR    Shift B left one bit, clear sign, zero to least
           significant bit

    ERA    Rotate E and A right one bit

    ERB    Rotate E and B right one bit

    ELA    Rotate E and A left one bit

    ELB    Rotate E and B left one bit

    ALF    Rotate A left four bits

    BLF    Rotate B left four bits

    SLA    Skip next instruction if least significant bit in A
           is zero

    SLB    Skip next instruction if least significant bit in B
           is zero
                                                                          3-4
<hr>
These instructions may be combined as follows:

------+-----------------------+-------
        ALS               ALS
        ARS               ARS
        RAL               RAL
label   RAR , CLE , SLA , RAR   comments
        ALF               ALF
        ERA               ERA
        ELA               ELA

------+-----------------------+-------
        BLS               BLS
        BRS               BRS
        RBL               RBL
label   RBR , CLE , SLB , RBR   comments
        BLF               BLF
        ERB               ERB
        ELB               ELB

CLE, SLA or SLB appearing alone or in any valid combination
with each other are assumed to be a Shift-Rotate machine
instruction.

The Shift-Rotate instructions must be given in the order
shown. At least one and up to four are included in cone state-
ment. Instructions referring to the A-register may not be
combined in the same statement with those referring to the
B-register.

NO-OPERATION INSTRUCTION

When a no-operation is encountered in a program, no action
takes place; the computer goes on to the next instruction. A
full memory cycle is used in executing a no-operation instruc-
tion.

------+-----+---------+--------
label   NOP             comments

A subroutine to be entered by a JSB instruction should have a
                                                                          3-5
<hr>
NOP as the first statement. The return address can be stored
in the location occupied by the NOP during execution of the
program. A NOP statement causes the Assembler to generate
a word of zeros.

ALTER-SKIP GROUP

The Alter-Skip group contains 19 basic instructions that can
be combined to produce more than 700 different single cycle
operations.

    CLA    Clear the A-Register

    CLB    Clear the B-Register

    CMA    Complement the A-Register

    CMB    Complement the B-Register

    CCA    Clear, then complement the A-Register (set to
           ones)

    CCB    Clear, then complement the B-Register (set to
           ones)

    CLE    Clear the E-Register

    CME    Complement the E-Register

    CCE    Clear, then complement the E-Register

    SEZ    Skip next instruction if E is zero

    SSA    Skip if sign of A is positive (0)

    SSB    Skip if sign of B is positive (0)

    INA    Increment A by one.

    INB    Increment B by one.

    SZA    Skip if contents of A equals zero

    SZB    Skip if contents of B equals zero

    SLA    Skip if least significant bit of A is zero

    SLB    Skip if least significant bit of B is zero

    RSS    Reverse the sense of the skip instructions. If
           no skip instructions precede in the statement,
           skip the next instruction.
                                                                          3-6
<hr>
These instructions may be combined as follows:

------+-----------------------------------------------+-------
        CLA         CLE
label   CMA , SEZ , CME , SSA , SLA , INA , SZA , RSS   comments
        CCA         CCE

------+-----------------------------------------------+-------
        CLB         CLE
label   CMB , SEZ , CME , SSB , SLB , INB , SZB , RSS   comments
        CCB         CCE

The Alter-Skip instructions must be given in the order shown.
At least one and up to eight are included in one statement. In-
structions referring to the A-register may not be combined in
the same statement with those referring to the B-register.
When two or more skip functions are combined in a single
operation, a skip occurs if any one of the conditions exists.
If a word with RSS also includes both SSA and SLA (or SSB and
SLB) a skip occurs only when sign and least significant bit are
both set (1).

3.3  INPUT/OUTPUT, OVERFLOW, AND HALT

The input/output instructions allow the user to transfer data
to and from an external device via a buffer, to enable or dis-
able external interrupt, or to check the status of I/O devices
and operations. A subset of these instructions permits check-
ing for an arithmetic overflow condition.

Input/Output instructions require the designation of a select
code, sc, which indicates one of 64 input/output channels or
functions. Each channel consists of a connect/disconnect con-
trol bit, a flag bit, and a buffer of up to 16 bits. The setting
of the control bits indicates that a device associated with the
channel is operable. The flag bit is set automatically when
transmission between the device and the buffer is completed.
Instructions are also available to test or clear the flag bit for
the particular channel. If the interrupt system is enabled,
setting of the flag causes program interrupt to occur; control
transfers to the interrupt location related to the channel.

                                                                          3-7
<hr>
Expressions used to represent select codes (channel numbers)
must have a value of less than 2**6. The value specifies the de-
vice or operation referenced. Instructions which transfer data
between the A or B register and a buffer, access the Switch
register when sc = 1. The character C appended to such an
instruction clears the overflow bit after the transfer from the
Switch register is complete.

INPUT/OUTPUT

Prior to any input/output data transmission, the control bit is
set. The instruction which enables the device may also trans-
fer data between the device and the buffer.

------+-----+---------+--------
label   STC   sc [,C]   comments

Set I/O control bit for channel specified by sc. STC transfers
or enables transfer of an element of data from an input device
to the buffer or to an output device from the buffer. The exact
function of STC depends on the device; for the 2752A Teleprinter,
an STC enables transfer of a series of bits. If sc = 1,
this statement is treated as NOP. The C option clears the flag
bit for the channel.

------+-----+---------+--------
label   CLC   sc [,C]   comments

Clear I/O control bit for channel specified by sc. When the
control bit is cleared, interrupt on the channel is disabled,
although the flag may still be set by the device. If sc = 0,
control bits for all channels are cleared to zero; all devices
are disconnected. If sc - 1 this statement is treated as NOP.

------+-----+---------+--------
label   LIA   sc [,C]   comments

Load into A the contents of the I/O buffer indicated by sc.

------+-----+---------+--------
label   LIB   sc [,C]   comments

Load into B the contents of the I/O buffer indicated by sc.

------+-----+---------+--------
label   LIA   sc [,C]   comments

Merge (inclusive "or") the contents of the I/O buffer indicated
by sc into A.
                                                                          3-8
<hr>
------+-----+---------+--------
label   MIA   sc [,C]   comments

Merge (inclusive "or") the contents of the I/O buffer indicated
by sc into B.

------+-----+---------+--------
label   OTA   sc [,C]   comments

Output the contents of A to the I/O buffer indicated by sc.

------+-----+---------+--------
label   OTB   sc [,C]   comments

Output the contents of B to the I/O buffer indicated by sc.

------+-----+---------+--------
label   STF   sc        comments

Sets the flag bit of the channel indicated by sc. If sc = 0, STF
enables the interrupt system. A sc code of 1 causes the over-
flow bit to be set.

------+-----+---------+--------
label   CLF   sc        comments

Clear the flag bit to zero for the channel indicated by sc. If
sc = 0, CLF disables the interrupt system, If sc = 1, the
overflow bit is cleared to zero.

------+-----+---------+--------
label   SFC   sc        comments

Skip the next instruction if the flag bit for channel sc is clear.
If sc = 1, the overflow is tested.

------+-----+---------+--------
label   SFS   sc        comments

Skip the next instruction if the flag bit for channel sc is set.
If sc = 1, the overflow is tested.

OVERFLOW

In addition to the use of a select code of 1, the overflow bit
may be accessed by the following instructions:
                                                                          3-9
<hr>
------+-----+---------+--------
label   CLO             comments

Clear the overflow bit.

------+-----+---------+--------
label   STO             comments

Set the overflow bit.

------+-----+---------+--------
label   SOC  [C]        comments

Skip the next instruction if the overflow bit is clear. The C
option clears the bit after the test is performed.

------+-----+---------+--------
label   SOS  [C]        comments

Skip the next instruction if the overflow bit is set. The C
option clears the bit after the test is performed.

The C option is identified by the sequence 'space C space' follow-
ing either 'SOC' or 'SOS'. Anything else is treated as a comment.

HALT

------+-----+---------+--------
label   HLT   [sc[,C]]  comments
              [C]

Halt the computer. The machine instruction word is displayed
in the T-Register.  If the C option is used, the flag bit associ-
ated with channel sc is cleared.

If neither the select code nor the C option is used, the com-
ments portion must be omitted.

                                                                          3-10
<hr>
3.4  EXTENDED ARITHMETIC INSTRUCTIONS

Ten instructions are used with the extended arithmetic version of the
Assembler or Extended Assembler to increase the computer's overall
efficiency. They provide for integer multiply and divide and for loading
and storing double-length words to and from the accumulators.

------+-----+---------+--------
label   MPY   m[,I]     comments
              lit

The MPY instruction multiplies the contents of the A-Register
by the contents of M. The product is stored in registers B
and A. B contains the sign of the product and the 15 most
significant bits; A contains the least significant bits.

------+-----+---------+--------
label   DIV   m[,I]     comments
              lit

The DIV instruction divides the contents of registers B and A
by the contents of m. The quotient is stored in A and the
remainder in B. Initially B contains the sign and the 15 most
significant bits of the dividend; A contains the least significant
bits.

------+-----+---------+--------
label   DLD   m[,I]     comments
              lit

The DLD instruction loads the contents of locations m and
m + 1 into registers A and B, respectively.

------+-----+---------+--------
label   DST   m[,I]     comments

The DST instruction stores the contents of registers A and
B in locations m and m + 1, respectively.

MPY, DIV, DLD, DST results in two machine words: a word
for the instruction code and one for the operand.

                                                                          3-11
<hr>
The above four instructions are available without the extended arithmetic
instructions as software subroutines. [1]  However, by using the extended
arithmetic group, they require less core storage and can be executed in
less time.

The following shift-rotate instructions provide the capability to shift or
rotate the B- and A- Registers n number of bit positions, where
1 &lt;= n &lt;= 16.

------+-----+---------+--------
label   ASR   n         comments

The ASR instruction arithmetically shifts the B- and A-
Registers right n bits. The sign bit (bit 15 of B) is extended.

------+-----+---------+--------
label   ASL   n         comments

The ASL instruction arithmetically shifts the B- and A-
Registers left n bits. Zeroes are placed in the least significant
bits. The sign bit (bit 15 of B) is unaltered. The overflow bit
is set if bit 14 differs from bit 15 before each shift, otherwise,
exit with Overflow bit cleared.

------+-----+---------+--------
label   RRR   n         comments

The RRR instruction rotates the B- and A-Registers right n bits.

------+-----+---------+--------
label   RRL   n         comments

The RRL instruction rotates the B- and A-Registers left n bits.

------+-----+---------+--------
label   LSR   n         comments

The LSR instruction logically shifts the B- and A-Registers
right n bits. Zeroes are placed in the most significant bits.

------+-----+---------+--------
label   LSL   n         comments

The LSL instruction logically shifts the B- and A-Registers
left n bits. Place zeroes in the least significant bits.


---------------------
[1] See ARITHMETIC SUBROUTINE CALLS, Section 4.7.

                                                                          3-12
<hr>
3.5  FLOATING-POINT INSTRUCTIONS

Floating-point instructions provide a means of performing calcu-
lations on floating-point values. Computers with the hardware
floating-point option should use assemblers and libraries with
floating-point capabilities. The floating-point assembler gener-
ates calls to the appropriate hardware function instead of the
library subroutines. If the computer does not have the hardware
floating-point option, then non-floating-point assemblers and
libraries should be used.

------+-----+---------+--------
label   FAD   m[,I]     comments
              lit

FAD performs an addition between a floating-point number stored
in the A- and B-Registers and a floating-point number stored in
memory locations m and m + 1. The result is returned in the
A- and B-Registers.

------+-----+---------+--------
label   FSB   m[,I]     comments
              lit

The FSB instruction subtracts a floating-point value in memory
locations m and m + 1 from a floating-point value in the A- and
B-Registers. The result is returned in the A- and B-Registers.

------+-----+---------+--------
label   FMP   m[,I]     comments
              lit

The FMP instruction multiplies a floating-point value in memory
locations m and m + 1 with a floating-point value in the A- and
B-Registers. The result is returned in the A- and B-Registers.

------+-----+---------+--------
label   FDV   m[,I]     comments
              lit

The FDV instruction divides a floating-point value in memory
locations m and m + 1 into a floating-point value in the A- and
B-Registers. The result is returned in the A- and B-Registers.

                                                                          3-13
<hr>

------+-----+---------+--------
label   FIX             comments

The FIX instruction converts a floating-point number contained
in the A- and B-Registers to a fixed point number. The result is
returned in the A-Register. The contents of the B-Register are
meaningless.

------+-----+---------+--------
label   FLT             comments

The FLT instruction converts a fixed-point number contained in the
A-Registers to a floating-point value. The result is returned in
the A- and B-Registers.

                                                                          3-14
<hr>
                       PSEUDO INSTRUCTIONS

The pseudo instructions control the Assembler, establish pro-
gram relocatability, and define program linkage as well as
specify various types of constants, blocks of memory, and
labels used in the program. With the Extended Assembler,
pseudo instructions also control listing output.

<a name="#4-1">
4.1  ASSEMBLER CONTROL

The Assembler control pseudo instructions establish and alter
the contents of the base page and program location counters,
and terminate assembly processing. Labels may be used but
they are ignored by the assembler. NAM records produced
by the Assemblers are accepted by the DOS, DOS-M, and BCS
Loaders.

------+-----+---------+--------
        NAM  [name]     comments

NAM defines the name of a relocatable program. A relocatable
program must begin with a NAM statement.[1]  A relocat-
able program is assembled assuming a starting location of
zero (i.e., zero relative). The name may be a symbol of one
to five alphanumeric characters the first of which must be
alphabetic or a period. The program name is printed on the
list output. The name is optional and if omitted, the comments
must be omitted also.

------+-----+---------+--------
        ORG   m         comments

The ORG statement defines the origin of an absolute program,
or the origin of subsequent sections of absolute or relocatable
programs.

An absolute program must begin with an ORG statement. [1]
The operand m, must be a decimal or octal integer specifying
the initial setting of the program location counter.

--------------------
[1] The Control Statement, the HED instruction, and comments
    may appear prior to the NAM or ORG statements. If the
    Control Statement (ASMB,...) does not appear on tape pre-
    ceding the program it must be entered from the Teleprinter.

                                                                          4-1
<hr>
ORG statements may be used elsewhere in the program to
define starting addresses for portions of the object code. For
absolute programs the Operand field, m, may be any expres-
sion. For relocatable programs, m, must be a program
relocatable expression; it may not be base page or common
relocatable or absolute. An expression is evaluated modulo
2**15.  Symbols must be previously defined. All instructions
following an ORG are assembled at consecutive addresses
starting with the value of the operand.

------+-----+---------+--------
        ORR             comments

ORR resets the program location counter to the value existing
when an ORG or ORB instruction was encountered.

Example:

1   5   10   15   20   25   30   35   40
----------------------------------------
      NAM RSET      SET PLC TO VALUE OF ZERO, ASSIGN
FIRST ADA           RSET AS NAME OF PROGRAM.
       .
       .
       .
      ADA CTRL      ASSUME PLC AT FIRST+2280
      ORG FIRST+2926 SAVE PLC VALUE OF FIRST+2280
       .            AND SET PLC TO FIRST+2926
      JMP EVEN+1    ASSUME PLC AT FIRST+3004
      ORR           RESET PLC TO FIRST+2280

More than one ORG or ORB statement may occur before an
ORR is used. If so, when the ORR is encountered, the pro-
gram location counter is reset to the value it contained when
the first ORG or ORB of the string occurred.

                                                                          4-2
<hr>
Example:

1   5   10   15   20   25   30   35   40
----------------------------------------
      NAM RSET      SET PLC TO ZERO
FIRST ADA
       .
       .
       .
      LDA WYZ       ASSUME PLC AT FIRST+2250
      ORG FIRST+2500 SET PLC TO FIRST+2500
       .
       .
       .
      LDB ERA       ASSUME PLC AT FIRST+2750
      ORG FIRST+2900 SET PLC TO FIRST+2900
       .
       .
       .
      CLE           ASSUME PLC AT FIRST+2920
      ORR           RESET PLC TO FIRST+2250

If a second ORR appears before an intervening ORG or ORB,
the second ORR is ignored.

ORR cannot be used to reset the location counter for locations
in base page that are governed by the ORB statement.

------+-----+---------+--------
        ORB             comments

ORB defines the portion of a relocatable program that must be
assigned to the base page by the Assembler. The Label field
(if given) is ignored, and the statement requires no operand. All
statements that follow the ORB statement are assigned con-
tiguous locations in the base page. Assignment to the base
page terminates when the Assembler detects an ORG, ORR, or
END statement.

When more than one ORB is used in a program, each ORB
causes the Assembler to resume assigning base page locations
at the address following the last assigned base page location.

An ORB statement in an absolute program has no significance
and is flagged as an error.

                                                                          4-3
<hr>
Example:

1   5   10   15   20   25   30   35   40
----------------------------------------
      NAM PROG      ASSIGN ZERO AS RELATIVE STARTING
       .            LOCATION FOR PROGRAM PROG
       .
       .
      ORB           ASSIGN ALL FOLLOWING STATEMENTS
                    TO BASE PAGE
IAREA BSS 100
       .
       .
       .
      ORR           CONTINUE MAIN PROGRAM
       .
       .
      ORB           RESUME ASSIGNMENT AT NEXT
       .            AVAILABLE LOCATION IS BASE PAGE
       .
       .
      ORR           CONTINUE MAIN PROGRAM

The IFN and IFZ pseudo instructions cause the inclusion of
instructions in a program provided that either an "N" or "Z",
respectively, is specified as a parameter for the ASMB control
statement.[1]  The IFN or IFZ instructions precedes the set of
statements that are to be included. The pseudo instruction XIF
serves as a terminator. If XIF is omitted, END act as a
terminator to both the set of statements and the assembly. IFN
and IFZ may be used only when the source program is trans-
lated by the Extended Assembler which is provided for 8K or
larger machines.

1   5   10   15   20   25   30   35   40
----------------------------------------
      IFN           comments
       .
       .
       .
      XIF

All source language statements appearing between the IFN and
the XIF pseudo instructions are included in the program if the
character "N" is specified on the ASMB control statement.

All source language statements appearing between the IFZ and
the XIF pseudo instruction are included in the program if the
character "Z" is specified on the ASMB control statement.

1   5   10   15   20   25   30   35   40
----------------------------------------
      IFZ           comments
       .
       .
       .
      XIF


----------------------
[1] See CONTROL STATEMENT, Section 5.1

                                                                          4-4
<hr>
When the particular letter is not included on the control state-
ment, the related set of statements appears on the Assembler
output listing but is not assembled.

Any number of IFN-XIF and IFZ-XIF sets may appear in a
program, however, they may not overlap. An IFZ or IFN
intervening between and IFZ or IFN and the XIF terminator
results in a diagnostic being issued during compilation; the
second pseudo instruction is ignored.

Both IFN-XIF and IFZ-XIF pseudo instructions may be used
in the program; however, only one type will be selected in a single
assembly. Therefore, if both characters "N" and "Z" appear
in the control statement, the character which is listed last will
determine the set of coding that is to be included in the program.

Example:

1   5   10   15   20   25   30   35   40
----------------------------------------
      NAM TRAVL
       .
       .
       .
      IFZ
      LDA CAR
      CMA,SZA
      JMP NO.GO
      LDA MILES
      DIV SPEED
      STA GAS
      XIF
       .
       .
       .
      IFN
      LDA PLANE
      CMA,SZA
      JMP NO.GO
      LDA TIME
      CPA COST
      XIF
NO.GO HLT 77
       .
       .
       .
      END

Program TRAVL will perform computations involving either
or neither CAR or PLANE considerations depending on the pres-
ence or absence of Z or N parameters in the Control Statement.

                                                                          4-5
<hr>
Example:

1   5   10   15   20   25   30   35   40
----------------------------------------
      NAM WAGE
       .
       .
       .
      JSB HOUR
      MPY TIME1
      IFZ
      JMP OVTIM
      MPY TIME2
       .
       .
       .
TIME1 DEC 40
TIME2 BSS 1
      END

Program WAGES computes a weekly wage value. Overtime
consideration will be included in the program if "Z" is included
in the parameters of the Control Statement.

The REP pseudo instruction, available in the Extended Assem
bler only, causes the repetition of the statement immediately
following it a specified number of times.

------+-----+---------+--------
label   REP   n         comments

The statement following the REP in the source program is
repeated n times. The n may be any absolute expression.
Comment lines (indicated by an asterisk in character position 1)
are not repeated by REP. If a comment follows a REP instruc-
tion, the comment is ignored and the instruction following the
comment is repeated.

A label specified in the REP pseudo instruction is assigned to
the first repetition of the statement. A label cannot be part of
the instruction to be repeated; it would result in a doubly defined
symbol error.

                                                                          4-6
<hr>
Example:

      CLA
TRIPL REP 3
      ADA DATA

The above source code would generate the following:

      CLA
TRIPL ADA DATA
      ADA DATA
      ADA DATA

Example:

FILL  REP 100B
      NOP

The example above loads 100(8) memory locations with the NOP
instruction. The first location is labeled FILL.

Example:

      REP 2
      MPY DATA

The above source code would generate the following:

      MPY DATA
      MPY DATA

------+-----+---------+--------
        END  [m]        comments

This statement terminates the program; it marks the physical
end of the source language statements. The Operand field, m,
may contain a name appearing as a statement label in the cur-
rent program or it may be blank. If a name is entered, it
identifies the location to which the loader transfers control after
a relocatable program is loaded. A NOP should be stored at
that location; the loader transfers control via a JSB.

                                                                          4-7
<hr>
If the Operand field is blank, the Comments field must be blank
also, otherwise, the Assembler attempts to interpret the first
five characters of the comments as the transfer address
symbol.

The label field of the END statement is ignored.

4.2  OBJECT PROGRAM LINKAGE

Linking pseudo instructions provide a means for communica-
tion between a main program and its subroutines or among
several subprograms that are to be run as a single program.
These instructions may be used only in a relocatable program.

The Label field of this class is ignored in all cases. The
Operand field is usually divided into many subfields, separated
by commas. The first space not preceded by a comma or a
left parenthesis terminates the entire field.

------+-----+------------------------------------+--------
        COM   name[(size1)][,name2[(size2)],...]   comments

COM reserves a block of storage locations that may be used
in common by several subprograms. Each name identifies a
segment of the block for the subprogram in which the COM
statement appears. The sizes are the number of words allotted
to the related segments. The size is specified as an octal or
decimal integer. If the size is omitted, it is assumed to be
one.

Any number of COM statements may appear in a subprogram.
Storage locations are assigned contiguously; the length of the
block is equal to the sum of the lengths of all segments named
in all COM statements in the subprogram.

To refer to the common block, other subprograms must also
include a COM statement. The segment names and sizes may
be the same or they may differ. Regardless of the names and
sizes specified in the separate subprograms, these is only one
common block for the combined set. It has the same relative
origin; the content of the nth word of common storage is the
same for all subprograms.

                                                                          4-8
<hr>
Example:

1   5   10   15   20   25   30   35   40
----------------------------------------
PROG1 COM ADDR1(5),ADDR2(10),ADDR3(10)
       .
       .
      LDA ADDR2+1   PICK UP SECOND WORD OF SEGMENT
       .            ADDR2+1
       .
      END
       .
       .
PROG2 COM AAA(2),AAB(2),AAC,AAD(20)
       .
       .
      LDA AAD+1     PICK UP SECOND WORD OF SEGMENT
                    AAD+1

Organization of common block:

    PROG1       PROG2          Common
    name        name           Block
    -----       -----          ------
    ADDR1       AAA          (location 1)
                             (location 2)
                AAB          (location 3)
                             (location 4)
                AAC          (location 5)
    ADDR2       AAD          (location 6)
                             (location 7)
                             (location 8)
                             (location 9)
                             (location 10)
                             (location 11)
                             (location 12)
                             (location 13)
                             (location 14)
                             (location 15)
    ADDR3                    (location 16)
                             (location 17)
                             (location 18)
                             (location 19)
                             (location 20)
                             (location 21)
                             (location 22)
                             (location 23)
                             (location 24)
                             (location 25)


                                                                          4-9
<hr>
The LDA instructions in the two subprograms each refer to
the same location in common storage, location 7.

The segment names that appear in the COM statements can be
used in the Operand fields of DEF, ABS, EQU, or any Memory
Reference statement; they may not be used as labels elsewhere
in the program.

The loader establishes the origin of the common block; the
origin cannot be set by the ORG or ORB pseudo instruction.
All references to the common area are relocatable.

Two or more subprograms may declare common blocks which
differ is size. The subprogram that defines the largest block
must be the first submitted for loading.

------+-----+------------------------+--------
        ENT   name1 [, name2 , ... ]   comments

ENT defines entry points to the program or subprogram. Each
name is a symbol that is assigned as a label for some machine
operation in the program. Entry points allow another sub-
program to refer to this subprogram. All entry points must be
defined in the program.

Symbols appearing in an ENT statement may not also appear
in EXT or COM statements in the same subprogram.

------+-----+-----------------------+--------
        EXT   name1 [, name2 , ...]   comments

This instructions designates labels from other subprograms which
are referenced in this subprogram. The symbols must be defined
as entry points by the other subprograms.

The symbols defined in the EXT statement may appear in Mem-
ory Reference statements, the EQU or DEF pseudo instructions.
An external symbol must appear alone; it may not be in a mul-
tiple term expression or be specified as indirect. References
to external locations are processed by the BCS loader as indirect
addresses linked through the base page.

                                                                          4-10
<hr>
Symbols appearing in EXT statements may not also appear in
ENT or COM statements in the same subprogram. The label
field is ignored.

Example:

1   5   10   15   20   25   30   35   40
----------------------------------------
PROGA NOP
      LDA SAMD      SAMD AND SAND ARE REFERENCED IN
       .            PROGA, BUT ARE ACTUALLY
       .            LOCATIONS IN PROGB
       .
      JMP SAND
      EXT SAMD,SAND
      ENT PROGA
      END

PROGB NOP
       .
       .
SAMD  OCT 767
SAND  STA SAMD
       .
       .
      ENT SAMD,SAND
       .
       .
      JSB PROGA
       .
       .
      EXT PROGA
       .
       .
      END

4.3 ADDRESS AND SYMBOL DEFINITION

The pseudo operations in this group assign a value or a word
location to a symbol which is used as an operand elsewhere in
the program.

                                                                          4-11
<hr>
------+-----+---------+--------
label   DEF   m,[I]     comments

The address definition statement generates one word of mom-
ory as a 15-bit address which may be used as the object of an
indirect address found elsewhere in the source program. The
symbol appearing in the label is that which is referenced; it
appears in the Operand field of a Memory Reference instruc-
tion.

The operand field of the DEF statement may be any positive ex-
pression in an absolute program; in a relocatable program it
may be a relocatable expression or an absolute expression with
a value of less than 100(8). Symbols that do appear in the Oper-
and field, may appear as operands of EXT or COM statements,
in the same subprogram and as entry points in other sub-
programs.

The expression in the Operand field may itself be indirect and
make reference to another DEF statement elsewhere in the
source program.

Example:

1   5   10   15   20   25   30   35   40
----------------------------------------
      NAM PROGN     ZERO-RELATIVE START OF PROGRAM
      EXT SINE,SQRT
      COM SCMA(20),SCMB(50)
       .
       .
      JSB SINE      EXECUTE SINE ROUTINE
       .
       .
      LDA XCMA,I    PICK UP COMMON WORD INDIRECTLY
       .
       .
XCMA  DEF SCMA      SCMA IS A 15-BIT ADDRESS
       .
       .
      JSB XSQ,I     GET SQUARE ROOT USING TWO-LEVEL
XSQ   DEF XSQR,I    INDIRECT ADDRESSING
       .
       .
XSQR  DEF SQRT      SQRT IS A 15-BIT ADDRESS
      END PROGN

                                                                          4-12
<hr>
The DEF statement provides the necessary flexibility to
perform address arithmetic in programs which are to be
assembled in relocatable form. Relocatable programs should
not modify the operand of a memory reference instruction.

In the example below, if TBL and LDTBL are in different
pages, the BCS Loader processes TBL as an indirect address
linked through the base page. The ISZ erroneously increments
the loader provided reference to the base page rather than the
value of TBL.

Example:

1   5   10   15   20   25   30   35   40
----------------------------------------
LDTBL LDA TBL
       .
       .
       .
      ISZ LDTBL
       .
       .
       .
       .
TBL   BSS 100

Assuming the loader might assign absolute locations compara-
ble to the following octal values:

    Page      Loc      Opcode      Reference
    ----      ---      ------      ---------
     (0)     (700)      DEF           4000

     (1)     (200)      LDA        (0) 700(I)

     (1)     (300)      ISZ        (1) 200

     (2)      (0)                     (TBL)

                                                                          4-13
<hr>
It can be seen that the ISZ instruction would increment the
quantity 700 rather than the address of the table (4000).

The following assures correct address modification during
program execution.

Example:

1   5   10   15   20   25   30   35   40
----------------------------------------
ITBL  DEF TBL
LDTBL LDA ITBL,I
       .
       .
       .
      ISZ ITBL
       .
       .
       .
TBL   BSS 100

This sequence might be stored by the loader as:

    Page      Loc      Opcode      Reference
    ----      ---      ------      ---------
     (1)     (200)      DEF           4000
     (1)     (201)      LDA            200(I)
     (2)     (300)      ISZ        (1) 200
     (2)      (0)                     (TBL)

                                                                          4-14
<hr>
The value of 4000 is incremented; each execution of LDA will
access successive locations in the table.

------+-----+---------+--------
label   ABS   m         comments

ABS defines a 16-bit absolute value to be stored at the location
represented by the label. The Operand field, m, may be any
absolute expression; a single symbol must be defined as abso-
lute elsewhere in the program.

Example:

1   5   10   15   20   25   30   35   40
----------------------------------------
AB    EQU 35        ASSIGNS THE VALUE OF 35
                    TO THE SYMBOL AB

M35   ABS -AB       M35 CONTAINS -35
P35   ABS AB        P35 CONTAINS 35
P70   ABS AB+AB     P70 CONTAINS 70
P30   ABS AB-5      P30 CONTAINS 30

------+-----+---------+--------
label   EQU   m         comments

The EQU pseudo operation assigns to a symbol a value other
than the one normally assigned by the program location coun-
ter. The symbol in the Label field is assigned the value
represented by the Operand field. The Operand field may
contain any expression. The value of the operand may be
common, base page or program relocatable as well as abso-
lute, but it may not be negative. Symbols appearing in the
operand must be previously defined in the source program.

The EQU instruction may be used to symbolically equate two
locations in memory; or it may be used to give a value to a
symbol. The EQU statement does not result in a machine
instruction.

                                                                          4-15
<hr>
Examples:

1   5   10   15   20   25   30   35   40
----------------------------------------
      NAM FAM
       .
       .
       .
J3    DEF
       .
       .
       .
      LDA J3        THE SYMBOLS JFOUR AND J3+1 BOTH
      ADA ONE       IDENTIFY THE SAME LOCATION. THE
      STA J3+1      AND OPERATION IS PERFORMED ON
JFOUR EQU J3+1      THIS LOCATION
       .
       .
       .
MWH   AND JFOUR
       .
       .
       .

Examples:

1   5   10   15   20   25   30   35   40
----------------------------------------
      NAM STQTB
       .
       .
       .
      COM TABLA(10) DEFINES A 10 WORD TABLE, TABLA
       .
       .
       .
TABLB EQU TABLA+5   NAMES WORDS 6 THROUGH 10 OF
       .            TABLA AS TABLB
       .
       .
      LDA TABLB+1   LOADS CONTENTS OF 7TH WORD
       .            COMMON INTO A. THE STATEMENT LDA
       .            TABLA+6 WOULD PERFORM THE SAME
       .            OPERATION
       .
      NAM REG
       .
       .
       .
A     EQU 0         DEFINES SYMBOL A AS 0 (LOCATION
B     EQU 1         OF A-REGISTER), AND SYMBOL B AS
       .            1 (LOCATION OF B-REGISTER).
       .
      LDA B         LOADS THE CONTENTS OF B-REGISTER
                    INTO A-REGISTER.


                                                                          4-16
<hr>
4.4  CONSTANT DEFINITION

The pseudo instructions in this class enter a string of one or
more constant values into consecutive words of the object pro-
tram. The statements may be named by labels so that other
program statements can refer to the fields generated by them.

------+-----+-------------------+--------
label   ASC   n,&lt;2n characters&gt;   comments

ASC generates a string of 2n alphanumeric characters in
ASCII code into n consecutive words.[1]  One character is right
justified in each eight bits; the most significant bit is zero.
n may be any expression resulting in an unsigned decimal
value in the range 1 through 28. Symbols used in an expres-
sion must be previously defined. Anything in the Operand field
following 2n characters is treated as comments. If less than 2n
characters are detected before the end-of-statement mark,
the remaining characters are assumed to be spaces, and are
stored as such. The label represents the address of the first
two characters.

Example:

1   5   10   15   20   25   30   35   40
----------------------------------------
TTYP  ASC 3,ABCDE

causes the following:

                                 ALPHABETIC

         15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
         ---------------------------------------------------------------
        |///|           A               |///|             B             |
         ---------------------------------------------------------------
        |///|           C               |///|             D             |
         ---------------------------------------------------------------
        |///|           E               |///|             sp            |
         ---------------------------------------------------------------


                        EQUIVALENT IN OCTAL NOTATION

         15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
         ---------------------------------------------------------------
        |///|    1        0        1    |///|    1        0        2    |
         ---------------------------------------------------------------
        |///|    1        0        3    |///|    1        0        4    |
         ---------------------------------------------------------------
        |///|    1        0        5    |///|    0        4        0    |
         ---------------------------------------------------------------


--------------------
[1] To enter the code for the ASCII symbols which perform some
    action, e.g., (CR) and (LF), the OCT pseudo instruction
    must be used.

                                                                          4-17
<hr>
------+-----+----------------+--------
label   DEC   d1 [, d2, ...]   comments

DEC records a string of decimal constants into consecutive
words. The constants may be either integer or real (floating
point), and positive or negative. If no sign is specified, posi-
tive is assumed. The decimal number is converted to its
binary equivalent by the Assembler. The label, if given,
serves as the address of the first word occupied by the
constant.

A decimal integer must be in the range of 0 to 2**15-1; it may
assume positive, negative, or zero values. It is converted
into one binary word and appears as follows:


         15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
         ---------------------------------------------------------------
        | s |     number                                                |
         ---------------------------------------------------------------
         /
        /
     sign


Example:

1   5   10   15   20   25   30   35   40
----------------------------------------
INT   DEC 50,+328,-300

causes the following (octal representation)


         15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
         ---------------------------------------------------------------
        | 0 |     0     |     0     |     0     |     6     |     2     |
         ---------------------------------------------------------------
        | 0 |     0     |     0     |     5     |     1     |     0     |
         ---------------------------------------------------------------
        | 1 |     7     |     7     |     3     |     2     |     4     |
         ---------------------------------------------------------------

A floating point number has two components, a fraction and an
exponent. The fraction is a signed or unsigned number which
may be written with or without a decimal point. The exponent is
indicated by the letter E and follows a signed or unsigned decimal
integer. The floating-point number may have any of the following
formats:

         +-n.n    +-n.    +-n.nE+-e    +-.nE+-e    +-nE+-e

                                                                          4-18
<hr>
The number is converted to binary, normalized (leading bits
differ), and stored in two computer words. If either the frac-
tion or the exponent is negative, that part is stored in two's
complement form.


   Word 1:

         15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
         ---------------------------------------------------------------
        | s |     fraction (most significant bits)                      |
         ---.-----------------------------------------------------------
           \ \
            \  binary point                                                            4-20
             \
               sign of fraction                                                           4-22


   Word 2:

         15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
         ---------------------------------------------------------------
        |    fraction                   |          exponent         | s |
         ---------------------------------------------------------------
                                                                     /
                                                                    /
                                                   sign of exponent


The floating-point number is made up of a 7-bit exponent with
sign and a 23-bit fraction with sign. The number must be in
the approximate range of 10**-38 and zero.

Examples:

1   5   10   15   20   25   30   35   40
----------------------------------------
      DEC .45E1
      DEC 45.00E-1
      DEC 4500E-3
      DEC 4.5

are all equivalent to

      .45 * 10**1

and are stored in normalized form as:

         15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
         ---------------------------------------------------------------
        | 0 | 1   0   0   1   0   0   0   0   0   0   0   0   0   0   0 |
         ---------------------------------------------------------------

         15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
         ---------------------------------------------------------------
        | 0   0   0   0   0   0   0   0 | 0   0   0   0   0   1   1 | 0 |
         ---------------------------------------------------------------


                                                                          4-19
<hr>
1   5   10   15   20   25   30   35   40
----------------------------------------
      DEC -.695,400E-4

are stored as:


         15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
         ---------------------------------------------------------------
        | 1 | 0   1   0   0   1   1   1   0   0   0   0   1   0   1   0 |
         ---------------------------------------------------------------

         15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
         ---------------------------------------------------------------
        | 0   0   1   1   1   0   1   1 | 0   0   0   0   0   0   0 | 0 |
         ---------------------------------------------------------------



         15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
         ---------------------------------------------------------------
        | 0 | 1   0   1   0   0   0   1   1   1   1   0   1   0   1   1 |
         ---------------------------------------------------------------

         15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
         ---------------------------------------------------------------
        | 1   0   0   0   0   1   0   1 | 1   1   1   1   1   0   0 | 1 |
         ---------------------------------------------------------------


------+-----+----------------+--------
label   DEX   d1 [, d2, ...]   comments

DEX, for the Extended Assembler, records a string of
extended precision decimal constants into consecutive words
within a program. Each such extended precision constant
occupies three words as shown below:


   Word 1:

         15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
         ---------------------------------------------------------------
        |Sm |    Mantissa  ----------------------------------&gt;          |
         ---.-----------------------------------------------------------

   Word 2:

         15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
         ---------------------------------------------------------------
        |    ------------------------------------------------&gt;          |
         ---------------------------------------------------------------

   Word 3:

         15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
         ---------------------------------------------------------------
        |    --------------------&gt;      |          exponent         |Se |
         ---------------------------------------------------------------


                                                                          4-20
<hr>
Legend:

   Sm = Sign of the mantissa (fraction)

   Se = Sign of the Exponent

NOTE:   A value is entered only if normalizing of the
        Mantissa is needed.

An extended precision floating-point number is made up
of a 39-bit Mantissa (fraction) and sign and a 70bit ex-
ponent and sign.  The exponent and sign will be zero if
the Mantissa does not have to be normalized.

This is the only form used for DEX. All values, whether
they be floating-point, integer, fraction, or integer and
fraction, will be stored in three words as just described.
This storage format is basically an extension of that used
for DEC, as previously described.

Examples:

    DEX 12,-.45

are stored as:

           WORD 1                  WORD 2                  WORD 3
     ------------------      ------------------      ------------------
    | 0110000000000000 |    | 0000000000000000 |    | 0000000000001000 |
     ------------------      ------------------      ------------------


           WORD 4                  WORD 5                  WORD 6
     ------------------      ------------------      ------------------
    | 1000110011001100 |    | 1100110011001100 |    | 1001101111111111 |
     ------------------      ------------------      ------------------


                                                                          4-21
<hr>
------+-----+----------------+--------
label   OCT   o1 [, o2, ...]   comments

OCT stores one or more octal constants in consecutive words
of the object program. Each constant consists of one to six
octal digits (0 to 177777). If no sign is given, the sign is
assumed to be positive. If the sign is negative, the two's com-
plement of the binary equivalent is stored. The constants are
separated by commas; the last constant is terminated by a
space. If less than six digits are indicated for a constant, the
data is right justified in the word.A label, if used, acts as
the address of the first constant in the string. The letter B
must not be used after the constant in the Operand field; it is
significant only when defining an octal term in an instruction
other than OCT.

Examples:

1   5   10   15   20   25   30   35   40
----------------------------------------
      OCT +0
      OCT -2
NUM   OCT 177,20405,-36
      OCT 51,77777,-1,10101
      OCT 107642,177077
      OCT 1976                ILLEGAL: CONTAINS DIGIT 9
      OCT -177777
      OCT 177B                ILLEGAL: CONTAINS CHARACTER B

The previous statements are stored as follows:

         15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
         ---------------------------------------------------------------
        | 0 |     0     |     0     |     0     |     0     |     0     |
         ---------------------------------------------------------------
        | 1 |     7     |     7     |     7     |     7     |     6     |
         ---------------------------------------------------------------
   NUM  | 0 |     0     |     0     |     1     |     7     |     7     |
         ---------------------------------------------------------------
        | 0 |     2     |     0     |     4     |     0     |     5     |
         ---------------------------------------------------------------
        | 1 |     7     |     7     |     7     |     4     |     2     |
         ---------------------------------------------------------------
        | 0 |     0     |     0     |     0     |     5     |     1     |
         ---------------------------------------------------------------
        | 0 |     7     |     7     |     7     |     7     |     7     |
         ---------------------------------------------------------------
        | 1 |     7     |     7     |     7     |     7     |     7     |
         ---------------------------------------------------------------
        | 0 |     1     |     0     |     1     |     0     |     1     |
         ---------------------------------------------------------------
        | 1 |     0     |     7     |     6     |     4     |     2     |
         ---------------------------------------------------------------
        | 1 |     7     |     7     |     0     |     7     |     7     |
         ---------------------------------------------------------------
        | X |     X     |     X     |     X     |     X     |     X     |
         ---------------------------------------------------------------  \
        | 0 |     0     |     0     |     0     |     0     |     1     |  \
         ---------------------------------------------------------------    |
        | X |     X     |     X     |     X     |     X     |     X     |   |
         ---------------------------------------------------------------  \ |
                                                                           \|
                                                                           /
                                                          The result of   /
                                                          attempting to
                                                          define an illegal
                                                          constant is un-
                                                          predictable

                                                                          4-22
<hr>
4.5  STORAGE ALLOCATION

The storage allocation statement reserves a block of memory
for data or for a work area.

------+-----+---------+--------
label   BSS   m         comments

The BSS pseudo operation advances the program or base page
location counter according to the value of the operand. The
Operand field may contain any expression that results in a
positive integer. Symbols, if used, must be previously de-
fined in the program. The label, if given, is the name as-
signed to the storage area and represents the address of the
first word. The initial content of the area set aside by the
statement is unaltered by the loader.

4.6  ASSEMBLY LISTING CONTROL

Assembly listing control pseudo instructions allow the user to
control the assembly listing output during pass2 or 3 of the
assembly process. These pseudo instructions may be used only
with the source program is translated by the Extended Assem-
bler provided for 8K or larger machines (8,192-word memory
or larger).

------+-----+---------+--------
        UNL             comments

Output is suppressed from the assembly listing, beginning with
the UNL pseudo instruction and continuing for all instructions
and comments until either an LST or END pseudo instruction is
encountered. Diagnostic messages for errors encountered by
the assembler will be printed, however, The source statement
sequence numbers (printed in columns 1-4 of the source
program listing) are incremented for the instructions skipped.

                                                                          4-23
<hr>
------+-----+---------+--------
        LST             comments

The LST pseudo instruction causes the source program listing,
terminated by a UNL, to be resumed.

A UNL following a UNL, a LST following a LST, and a LST not
preceded by a NUL are not considered errors by the Assembler.

------+-----+---------+--------
        SUP             comments

The SUP pseudo instruction suppresses the output of additional
code lines from the source program listing. Certain pseudo
instructions, because they result in using subroutines, generate
more than one line of coding. These additional code lines are
suppressed by a SUP instruction until a UNS or the END pseudo
instruction is encountered. SUP will suppress additional code
lines in the following pseudo instructions:

    ASC   DIV   FAD   FSB
    OCT   DLD   FDV   MPY
    DEC   DST   FMP

The SUP pseudo instruction may also be used to suppress the
listing of literals at the end of the source program listing.

------+-----+---------+--------
        UNS             comments

The UNS pseudo instruction causes the printing of additional
coding lines, terminated by a SUP, to be resumed.



                                                                          4-24
<hr>
A SUP preceded by another SUP, UNS preceded by UNS, or
UNS not preceded by a SUP are not considered errors by the
Assembler.

------+-----+---------+--------
        SKP             comments

The SKP pseudo instruction causes the source program listing
to be skipped to the top of the next page. The SKP instruction
is not listed, but the source statement sequence number is
incremented for the SKP.

------+-----+---------+--------
        SPC   n         comments

The SPC pseudo instruction causes the source program listing
to be skipped a specified number of lines. The list output is
skipped n lines, or to the bottom of the page, whichever occurs
first. The n may be any absolute expression. The SPC
instruction is not listed but the source statement sequence
number is incremented for the SPC.

------+-----+---------+--------
        HED   m (heading)

The HED pseudo instruction allows the programmer to specify
a heading to be printed at the top of each page of the source
program listing.

The heading, m, a string of up to 56 ASCII characters, is printed
at the top of each page of the source program listing following
the occurrence of the HED pseudo instruction. If HED is
encountered before the NAM or ORG at the beginning of a
program, the heading will be used on the first page of the
source program listing. A HED instruction placed elsewhere
in the program causes a skip to the top of the next page.

The heading specified in the HED pseudo instruction will be
used on every page until it is changed by a succeeding HED
instruction.

The source statement containing the HED will not be listed, but
the source statement sequence number will be incremented.

                                                                          4-25
<hr>
4.7  ARITHMETIC SUBROUTINE CALLS

The members of this group of pseudo instructions request
the Assembler to generate calls to arithmetic subroutines [1]
external to the source program. These pseudo instructions
may be used in relocatable programs only. The Operand
field may contain any relocatable expression or an absolute
expression resulting in a value of less than 100(8).

------+-----+---------+--------
        MPY   m[,I]     comment
              =Dn
              =Bn

Multiply the contents of the A-register by the contents of m
or the quantity defined by the literal and store the product in
registers B and A. B contains the sign of the product and the
15 most significant bits; A contains the least significant bits.

------+-----+---------+--------
        DIV   m[,I]     comment
              =Dn
              =Bn

Divide the contents of registers B and A by the contents of m
or the quantity defined by the literal. Store the quotient in A
and the remainder in B. Initially B contains the sign and the 15
most significant bits of the dividend; A contains the least
significant bits.

------+-----+---------+--------
        FMP   m[,I]     comment
              =Fn

Multiply the two-word floating-point quantity in registers A
and B by the two-word floating-point quantity in locations m
and m+1 or the quantity defined by the literal. Store the two-
word floating-point product in registers A and B.

------+-----+---------+--------
        FDV   m[,I]     comment
              =Fn

Divide the two-word floating-point quantity in registers A and
B by the two-word floating-point quantity in locations m and
m+1 or the quantity defined by the literal. Store the two-
word floating-point quotient in A and B.

----------------------
[1] Not intended for use with DEX formatted numbers. For
such numbers JSB's to double precision subroutines must
be used. See Relocatable Subroutines Manual (02116-91780).

                                                                          4-26
<hr>
------+-----+---------+--------
        FAD   m[,I]     comment
              =Fn

Add the two-word floating point quantity in registers A and B
to the two-word floating point quantity in locations m and m+1
or the quantity defined by the literal. Store the two-word
floating point sum in A and B.

------+-----+---------+--------
        FSB   m[,I]     comment
              =Fn

Subtract the two-word floating point quantity in m and m+1
or the quantity defined by the literal from the two-word
floating point quantity in registers A and B and store the
difference in A and B.

------+-----+---------+--------
        DLD   m[,I]     comment
              =Fn

Load the contents of locations m and m+1 or the quantity
defined by the literal into registers A and B respectively.

------+-----+---------+--------
        DST   m[,I]     comment
              =Fn

Store the contents of registers A and B in locations m and m+1
respectively.

Each use of a statement from this group generates two words
of instructions. Symbolically, they could be represented as
follows:

        JSB   &lt;.arithmetic pseudo operation&gt;
        DEF   m[,I]

An EXT &lt;.arithmetic pseudo operation&gt; is implied preceding
the JSB operation.

In the above operations, the Overflow bit is set when one of
the following conditions occurs:

        Integer overflow
        Floating-point overflow or underflow
        Division by zero.

Execution of any of the subroutines alters the contents
of the E-Register.

                                                                          4-27
<hr>
                 ASSEMBLER INPUT AND OUTPUT

The Assembler accepts as input a paper tape containing
a control statement and a source language program. A relocat-
able source language program may be divided into several
subroutines; the designation of these elements is optional.
The output produced by the Assembler may include a punched
paper tape containing the object programs, an object program
listing, and diagnostic messages.

<a name="#5-1">
5.1  CONTROL STATEMENT

The control statement specifies the output to be produced:

ASMB,p1,p2,...,pn

"ASMB," is entered in positions 1-5. Following the comma
are one or more parameters, in any order, which define the
output to be produced. The control statement must be termi-
nated by an end-of-statement mark, (CR)(LF).

The parameters may be any legal combinations of the follow-
ing starting in position 6:

A     Absolute: The addresses generated by the Assembler
      are to be interpreted as absolute locations in memory.
      The program is a complete entity. It may not include
      NAM, ORB, COM, ENT, EXT, arithmetic pseudo
      operation statements or literals. The binary output
      format is that specified for the Basic Binary Loader.

R     Relocatable: The program may be located anywhere in
      memory. Instruction operands are adjusted as neces-
      sary. The binary output format is that specified for
      the BCS Relocating loader.

B     Binary output: A program is to be punched according
      to one of the above parameters.

L     Listing output: A program listing is to be produced either
      during pass two or pass three (if binary output se-
      lected) according to one of the above parameters.

                                                                          5-1
<hr>

T     Table print: List the symbol table at the end of the
      first pass. For the Extended Assembler: List
      the symbol table in alphabetic order in three sections:
      section 1 for on- character symbols, section 2 for
      two- and three- character symbols, and section 3
      for four- and five- character symbols.

N     Include sets of instructions following the IFN pseudo
      instruction.

Z     Include sets of instructions following the IFZ pseudo
      instruction.

F     Accepted by the Assembler to provide compatibility with
      DOS or DOS-M Assembler programs. F causes no action
      in any other assemblers.

      (F = Extended Arithmetic Unit/Floating Point;
       X = Nonextended Arithmetic Unit;
       No parameter - Extended Arithmetic Unit)

Either A or R must be specified in addition to any combination of
B, L, or T.

If a programmer wishes to assemble pass 1 of a source program to check
for errors, he can specify only an A or R to be the sole parameter of
the Assembler control statement, executing only pass 1. (This produces
pass 1 error messages without listing the program or providing an object
tape). Extended Assembler only.

The Assembler control statement must specifically request pass 2
operations (list or punch) in order for pass 2 to be executed. Lack of
pass 2 option information causes processing only of pass 1 errors. If a
C option is also provided, an automatic cross-reference symbol table is
done after pass 1 when operating in the MTS environment.

The control statement may be on the same tape as the source
program, or on a separate tape; or it may be entered via the
Teleprinter keyboard.

                                                                          5-2
<hr>
5.2  SOURCE PROGRAM

The first statement of the program (other than remarks or
a HED statement) must be a NAM statement for a relocatable
program or an ORG statement for indicating the origin of an
absolute program.  The last statement must be an END state-
ment and may contain a transfer address for the start of a
relocatable program. Each statement is followed by an
end-of-statement mark.

5.3  BINARY OUTPUT

The punch output is defined by the ASMB control statement.
The punch output includes the instructions translated from the
source program. It does not include system subroutines re-
ferenced within the source program (arithmetic subroutine
calls, .IOC., .DIO., .ENTR, etc.)

5.4  LIST OUTPUT

Fields of the object program are listed in the following print
columns.

        Columns              Content
        -------              -------
         1-4                 Source statement sequence number gener-
                             ated by the Assembler

         5-6                 Blank

         7-11                Location (octal)

         12                  Blank

         13-18               Object code word in octal

         19                  Relocation or external symbol indicator

         20                  Blank

         21-72               First 52 characters of source statement.

                                                                          5-3
<hr>
Lines consisting entirely of comments (i.e. * in column 1) are
printed as follows:

        Columns              Content
        -------              -------
         1-4                 Source statement sequence number

         5-72                Up to 68 characters of comments

A Symbol Table listing has the following format:

        Columns              Content
        -------              -------
         1-5                 Symbol
         6                   Blank
         7                   Relocation or external symbol indicator
         8                   Blank
         9-14                Value of the symbol

The characters that designate an external symbol or type of
relocation for the Operand field or the symbol are as follows:

        Columns              Content
        -------              -------
         Blank               Absolute
         R                   Program relocatable
         B                   Base page relocatable
         C                   Common relocatable
         X                   External symbol

At the end of each pass, the following is printed:

         ** NO ERRORS*
            or
         ** nnnn ERRORS*

The value nnnn, indicates the number of errors.

NOTE: For complete operating instructions for the HP Assem-
      bler or the extended Assembler, consult Software Operat-
      ing Procedures, SIO Subsystems module (5931-1390)

                                                                          5-4
<hr>
                      ASSEMBLER INSTRUCTIONS

    Symbols                            Meaning
    -------                            -------
    label            Symbolic label, 1-5 alphanumeric characters and periods

    m                Memory location represented by an expression

    I                Indirect addressing indicator

    C                Clear flag indicator

    (m,m+1)          Two-word floating-point value in m and m+1

    comments         Optional comments

    [ ]              Optional portion of field

    { }              One of set may be selected

    P                Program Counter

    ( )              Contents of location

    /\               Logical product

    -\/-             Exclusive "or"

    \/               Inclusive "or"

    A                A-register

    B                B-register

    E                E-register

    A.n              Bit n of A-register

    B.n              Bit n of B-register

    b                Bit positions in B- and A-register
    ___
    (A)              Complement of contents of Register A
    ___
    (B)              Complement of contents of Register B

    (AB)             Two-word floating-point value in registers A and B

    sc               Channel select code represented by an expression

    d                Decimal constant

    o                Octal constant

    r                Repeat count

    n                Integer constant

    lit              Literal value

                                                                          B-1
<hr>
                         MACHINE INSTRUCTIONS

MEMORY REFERENCE

  Jump and Increment-Skip

    ISZ   m[,I]      (m)+1 -&gt; m; then if (m) = 0, execute P+2
                     otherwise execute P+1

    JMP   m[,I]      Jump to m; m -&gt; P

    JSB   m[,I]      Jump subroutine to m; P + 1 -&gt; m; m + 1 -&gt; P

  Add, Load and Store

    ADA   m[,I]      (m) + (A) -&gt; A
          lit

    ADB   m[,I]      (m) + (B) -&gt; B
          lit

    LDA   m[,I]      (m) -&gt; A
          lit

    LDB   m[,I]      (m) -&gt; B
          lit

    STA   m[,I]      (A) -&gt; m

    STB   m[,I]      (B) -&gt; m

  Logical

    AND   m[,I]      (m) /\ (A) -&gt; A
          lit

    XOR   m[,I]      (m) -\/- (A) -&gt; A
          lit

    IOR   m[,I]      (m) \/ (A) -&gt; A
          lit

    CPA   m[,I]      If (m) != (A), execute P + 2, otherwise
          lit        execute P + 1

    CPB   m[,I]      If (m) != (B), execute P + 2, otherwise
          lit        execute P + 1

REGISTER REFERENCE

  Shift-Rotate

    CLE              0 -&gt; E
    ALS              Shift (A) left one bit, 0 -&gt; A.0, A.15 unaltered
    BLS              Shift (B) left one bit, 0 -&gt; B.0, B.15 unaltered
    ARS              Shift (A) right one bit, (A.15) -&gt; A.14
    BRS              Shift (B) right one bit, (B.15) -&gt; B.14
    RAL              Rotate (A) left one bit
    RBL              Rotate (B) left one bit

                                                                          B-2
<hr>
  Shift-Rotate (Continued)

    RAR              Rotate (A) right one bit
    RBR              Rotate (B) right one bit
    ALR              Shift (A) left one bit, 0 -&gt; A.15
    BLR              Shift (B) left one bit, 0 -&gt; B.15
    ERA              Rotate E and A right one bit
    ERB              Rotate E and B right one bit
    ELA              Rotate E and A left one bit
    ELB              Rotate E and B left one bit
    ALF              Rotate A left four bits
    BLF              Rotate B left four bits
    SLA              If (A.0) = 0, execute P + 2, otherwise execute P + 1
    SLB              If (B.0) = 0, execute P + 2, otherwise execute P + 1

  Shift-Rotate instructions can be combined as follows:

           ALS                     ALS
           ARS                     ARS
           RAL                     RAL
           RAR  ,  CLE  ,  SLA  ,  RAR
           ALR                     ALR
           ALF                     ALF
           ERA                     ERA
           ELA                     ELA

           BLS                     BLS
           BRS                     BRS
           RBL                     RBL
           RBR  ,  CLE  ,  SLB  ,  RBR
           BLR                     BLR
           BLF                     BLF
           ERB                     ERB
           ELB                     ELB

  No-operation

    NOP              Execute P + 1

  Alter-Skip

    CLA              0's -&gt; A

    CLB              0's -&gt; B
                     ___
    CMA              (A) -&gt; A
                     ___
    CMB              (B) -&gt; B

    CCA              1's -&gt; A

    CCB              1's -&gt; B

    CLE              0 -&gt; E
                     ___
    CME              (E) -&gt; E
                                                                          B-3
<hr>
    CCE              1 -&gt; E
    SEZ              If (E) = 0, execute P + 2, otherwise execute P + 1
    SSA              If (A.15) = 0, execute P + 2, otherwise execute P + 1
    SSB              If (B.15) = 0, execute P + 2, otherwise execute P + 1
    INA              (A) + 1 -&gt; A
    INB              (B) + 1 -&gt; B
    SZA              If (A) = 0, execute P + 2, otherwise execute P + 1
    SZB              If (B) = 0, execute P + 2, otherwise execute P + 1
    SLA              If (A.0) = 0, execute P + 2, otherwise execute P + 1
    SLB              If (B.0) = 0, execute P + 2, otherwise execute P + 1
    RSS              Reverse sense of skip instructions. If no skip
                     instructions precede, execute P + 2

  Alter-Skip instructions can be combined as follows:

           CLA             CLE
           CMA  ,  SEZ  ,  CME  ,  SSA  ,  SLA  ,  INA  ,  SZA  ,  RSS
           CCA             CCE

           CLB             CLE
           CMB  ,  SEZ  ,  CME  ,  SSB  ,  SLB  ,  INB  ,  SZB  ,  RSS
           CCB             CCE

INPUT/OUTPUT, OVERFLOW, and HALT

  Input/Output

    STC   sc [,C]    Set control bit.sc, enable transfer of one element of
                     data between device.sc and buffer.sc

    CLC   sc [,C]    Clear control bit.sc; If sc = 0 clear all control bits

    LIA   sc [,C]    (buffer.sc) -&gt; A

    LIB   sc [,C]    (buffer.sc) -&gt; B

    MIA   sc [,C]    (buffer.sc) \/ (A) -&gt; A

    MIB   sc [,C]    (buffer.sc) \/ (B) -&gt; B

    OTA   sc [,C]    (A) -&gt; buffer.sc

    OTB   sc [,C]    (B) -&gt; buffer.sc

    STF   sc         Set flag bit.sc; If sc = 0, enable interrupt system.
                     sc = 1 sets overflow bit.

    CLF   sc         Clear flag bit.sc; If sc = 0, disable interrupt system.
                     If sc = 1, clear overflow bit.

    SFC   sc         If (flag bit.sc) = 0, execute P + 2, otherwise execute
                     P + 2. If sc = 1, test overflow bit.

    SFS   sc         If (flag bit.sc) = 1, execute P + 2, otherwise execute
                     P + 2. If sc = 1, test overflow bit.

                                                                          B-4
<hr>
  Overflow

    CLO              0 -&gt; overflow bit

    STO              1 -&gt; overflow bit

    SOC   [C]        If (overflow bit) = 0, execute P + 2,
                     otherwise execute P + 1

    SOS   [C]        If (overflow bit) = 1, execute P + 2,
                     otherwise execute P + 1

  Halt

    HLT   [sc [,C]]  Halt computer


EXTENDED ARITHMETIC UNIT (requires EAU version of Assembler or
                          Extended Assembler)

    MPY   m[,I]      (A) * (m) -&gt; (B and A)
          lit

    DIV   m[,I]      (B and A) / (m) -&gt; A, remainder -&gt; B
          lit

    DLD   m[,I]      (m) and (m+1) -&gt; A and B
          lit

    DST   m[,I]      (A) and (B) -&gt; m and m+1
          lit

    ASR   b          Arithmetically shift (BA) right b bits,
                     B.15 extended

    ASL   b          Arithmetically shift (BA) left b bits,
                     B.15 unaltered, 0's to A.0

    RRR   b          Rotate (BA) right b bits

    RRL   b          Rotate (BA) left b bits

    LSR   b          Logically shift (BA) right b bits, 0's to B.15

    LSL   b          Logically shift (BA) left b bits, 0's to A.0

                                                                          B-5
<hr>
                         PSEUDO INSTRUCTIONS

ASSEMBLER CONTROL

    NAM   [name]     Specifies relocatable program and its name.

    ORG   m          Gives absolute program origin or origin for a segment
                     of relocatable or absolute program.

    ORR              Reset main program location counter at value existing
                     when first ORG or ORB of a string was encountered.

    ORB              Defines base page portion of relocatable program.

    END   [m]        Terminates source language program. Produces transfer
                     to program starting location, m, if given.

    REP   r          Repeat immediately following statement r times.
  &lt;statement&gt;

    IFN              Include statements in program if control statement
  &lt;statements&gt;       contains N.
    XIF

    IFZ              Include statements in program if control statement
  &lt;statements&gt;       contains Z.
    XIF


OBJECT PROGRAM LINKAGE

    COM   name1 [ (size1) ] [, name2 [ (size2) ] [ , ... ]
                     Reserves a block of common storage locations. name
                     identifies segments of block, each of length size.

    ENT   name1 [ , name2 ] [ , ... ]
                     Defines entry points, name, that may be referred to
                     by other programs

    EXT   name1 [ , name2 ] [ , ... ]
                     Defines external locations, name, which are labels
                     of other programs, referenced by this program.

ADDRESS AND SYMBOL DEFINITION

  label  DEF  m[,I]  Generates a 15-bit address which may be referenced
                     indirectly through the label.

  label  ABS  m      Defines a 16-bit absolute value to be referenced
                     by the label.

  label  EQU  m      Equates the value, m, to the label.

                                                                          B-6
<hr>
CONSTANT DEFINITION

    ASC   n,&lt;2n characters&gt;
                     Defines a string of 2n ASCII characters

    DEC   d1 [, d2 ] [, ... ]
                     Records a string of decimal constants of the form:
                         Integer:  +/-n
                         Floating-point:  +/-n.n  +/-n.  +/-nE+/-e
                                          +/-n.E+/-e  +/-.nE+/-e
    DEX   d1 [, d2 ] [, ...]
                     Records a string of extended precision
                     decimal constants of the form:
                         Floating-point:  +/-n        +/-n.n
                                          +/-n.       +/-.n
                                          +/-nE+/-e   +/-n.nE+/-e
                                          +/-n.E+/-e  +/-.nE+/-e
    OCT   o1 [, o2 ] [, ...]
                     Records a string of octal constants of the
                     form: +/-oooooo

STORAGE ALLOCATION

    BSS   m          Reserves a storage area of length, m.

ARITHMETIC SUBROUTINE CALLS REQUESTS [2]

    MPY   m[,I]      (A) * (m) -&gt; (BA)                     [1]
          lit

    DIV   m[,I]      (BA) / (m) -&gt; A , remainder -&gt; B      [1]
          lit

    FMP   m[,I]      (AB) * (m,m+1) -&gt; AB
          lit

    FDV   m[,I]      (AB) / (m,m+1) -&gt; AB
          lit

    FAD   m[,I]      (AB) + (m,m+1) -&gt; AB
          lit

    FSB   m[,I]      (AB) - (m,m+1) -&gt; AB
          lit

    DLD   m[,I]      (m) and (m+1) -&gt; A and B              [1]
          lit

    DST   m[,I]      (A) and (B) -&gt; (m) and (m+1)          [1]


------------------------
[1] For configurations including Extended Arithmetic Unit, these mnemonics
    generate hardware instructions when the EAU version of the Assembler
    or Extended Assembler is used.

[2] Not intended for use with DEX formatted numbers. For such numbers,
    JSB Machine Instructions must be used.

                                                                          B-7
<hr>
ASSEMBLY LISTING CONTROL

    UNL              Suppress assembly listing output.

    LST              Resume assembly listing output.

    SKP              Skip listing to top of next page.

    SPC   n          Skip n lines on listing.

    SUP              Suppress listing of extended code lines (e.g.
                     as produced by subroutine calls).

    UNS              Resume listing of extended code lines.

    HED  &lt;heading&gt;   Print &lt;heading&gt; at top of each page, where &lt;heading&gt;
                     is up to 56 ASCII characters.

                                                                          B-8
<hr>
               ALPHABETIC LIST OF INSTRUCTIONS

    ABS              Define absolute value
    ADA              Add to A
    ADB              Add to B
    ALF              Rotate A left 4
    ALR              Shift A left 1, clear sign
    ALS              Shift A left 1
    AND              "AND" to A
    ARS              Shift A right 1, sign carry
    ASC              Generate ASCII characters
    ASL              Arithmetic long shift left
    ASR              Arithmetic long shift right
    BLF              Rotate B left 4
    BLR              Shift B left 1, clear sign
    BLS              Shift B left 1
    BRS              Shift B right 1, carry sign
    BSS              Reserve a block of storage start at symbol
    CCA              Clear and complement A (1's)
    CCB              Clear and complement B (1's)
    CCE              Clear and complement E (set E = 1)
    CLA              Clear A
    CLB              Clear B
    CLC              Clear I/O control bit
    CLE              Clear E
    CLF              Clear I/O flag
    CLO              Clear overflow bit
    CMA              Complement A
    CMB              Complement B

                                                                          C-1
<hr>
    CME              Complement E
    COM              Reserve block of common storage
    CPA              Compare to A, skip if unequal
    CPB              Compare to B, skip if unequal
    DEC              Defines decimal constants
    DEF              Defines address
    DEX              Defines extended precision constants
    DIV              Divide
    DLD              Double load
    DST              Double store
    ELA              Rotate E and A left 1
    ELB              Rotate E and B left 1
    END              Terminate program
    ENT              Entry point
    ERA              Rotate E and A right 1
    ERB              Rotate E and B right 1
    EQU              Equate symbol
    EXT              External reference
    FAD              Floating add
    FDV              Floating divide
    FMP              Floating multiply
    FSB              Floating subtract
    HED              Print heading at top of page
    HLT              Halt
    IFN              When N appears in Control Statement, assemble
                     ensuing instructions
    IFZ              When Z appears in Control Statement, assemble
                     ensuing instructions
    INA              Increment A by 1
    INB              Increment B by 1
    IOR              Inclusive "or" to A
    ISZ              Increment, then skip if zero
    JMP              Jump

                                                                          C-2
<hr>
    JSB              Jump to subroutine
    LDA              Load into A
    LDB              Load into B
    LIA              Load into A from I/O channel
    LIB              Load into B from I/O channel
    LSL              Logical long shift left
    LSR              Logical long shift right
    LST              Resume list output (follows a UNL)
    MIA              Merge "or" into A from I/O channel
    MIB              Merge "or" into B from I/O channel
    MPY              Multiply
    NAM              Names relocatable program
    NOP              No operation
    OCT              Defines octal constant
    ORB              Establish origin in base page
    ORG              Establish program origin
    ORR              Reset program location counter
    OTA              Output from A to I/O channel
    OTB              Output from B to I/O channel
    RAL              Rotate A left 1
    RAR              Rotate A right 1
    RBL              Rotate B left 1
    RBR              Rotate B right 1
    REP              Repeat next statement
    RRL              Rotate A and B left
    RRR              Rotate A ad B right
    RSS              Reverse skip sense
    SEZ              Skip if E = 0
    SFC              Skip if I/O flag = 0 (clear)
    SFS              Skip if I/O flag = 1 (set)
    SKP              Skip to top of next page

                                                                          C-3
<hr>
    SLA              Skip if LSB of A = 0
    SLB              Skip if LSB of B = 0
    SOC              Skip if overflow bit = 0 (clear)
    SOS              Skip of overflow bit = 1 (set)
    SPC              Space n lines
    SSA              Skip if sign A = 0
    SSB              Skip if sign B = 0
    STA              Store A
    STB              Store B
    STC              Set I/O control bit
    STF              Set I/O flag
    STO              Set overflow bit
    SUP              Suppress list output of additional code lines
    SWP              Switch the (A) and (B)                              ???
    SZA              Skip if A = 0
    SZB              Skip if B = 0
    UNL              Suppress list output
    UNS              Resume list output of additional code lines
    ZIF              Terminate an IFN or IFZ group of instructions
    XOR              Exclusive "or" to A

                                                                          C-4
<hr>
                       SAMPLE PROGRAMS

Following are two sample programs, the second of which implements
several options of the Extended Assembler.

PARTS FILE UPDATE

A master file of parts is updated by a parts usage list to produce a
new master parts file. A report, consisting of the parts used and their
cost, is also produced.

The organization of the files is a follows:

Parts Master Files (PRTSM)

     ---------------------------------------------
    |  Identification  |  Quantity  |  Cost/Item  |
     ---------------------------------------------

Identification fields of the Parts Master Files exists in ASCII although
the entire record is read ans written in binary.

Parts Usage FIle (PRTSU)

     -------------------------------
    |  Identification  |  Quantity  |
     -------------------------------

The parts usage file has been recorded in ASCII.

Parts Cost Report (PRTSC)

     -----------------------------------------------------------------------
    |  Identification  | //// |  Quantity used  | //// | $ |  Cost for Qty  |
     -----------------------------------------------------------------------

The Parts Cost Report is recorded in ASCII with spacing and editing for
printing.

The sample program reads and writes the files, adjusts the new stock levels,
and calculates the cost. External subprograms perform the binary-to-decimal
and decimal-to-binary conversions and handle unrecoverable input/output
errors, invalid data conditions, and normal program termination. Input/output
operations are performed using the Basic Control System input/output sub-
routine, .IOC.

                                                                          D-1
<hr>
                             SAMPLE PROGRAM
                           GENERAL FLOW CHART

                                                                          D-2
<hr>
                    SAMPLE ASSEMBLER SYMBOL TABLE OUTPUT

                                                                          D-3
<hr>
                        SAMPLE ASSEMBLER LIST OUTPUT

                                                                          D-4
<hr>
      NAM UPDTE
START NOP
      JMP OPEN
      ORB           ASSIGN STORAGE & CONSTANTS TO BP
PRTSM BSS 4         MASTER PARTS FILE - BINARY.
PRTSU BSS 4         PARTS USAGE LIST - ASCII.
PRTSC BSS 11        PARTS USAGE REPORT - ASCII.
EOTS1 JMP READM
EOTS2 JMP WRITN
MTEMP BSS 1
UTEMP BSS 1
SWTMP BSS 2
SPACS ASC 2,
DLRSG ASC 1, $
A     EQU 0
B     EQU 1
      EXT .IOC.     PERFORM I/O OPERATIONS USING BCS
*                                   I/O CONTROL ROUTINE.
      EXT BCONV     ENTRY POINT FOR DECIMAL(ASCII)
*                                   TO BINARY CONVERSION SUBPROGRAM.
      EXT DCONV     ENTRY POINT FOR BINARY TO
*                                   DECIMAL(ASCII) CONVERSION SUB-
*                                   PROGRAM
      EXT ABORT     ENTRY POINT FOR SUBPROGRAM WHICH
*                                   HANDLES UNRECOVERABLE I/O ERRORS
*                                   OR INVALID DATA.
      EXT HALT      END OF PROGRAM SUBROUTINE.
      COM DTOBI(2),DTOBO,BTODI(2),BTODO(2)
*                                   COMMON STORAGE LOCATIONS USED TO
*                                   PASS DATA BETWEEN MAIN PROGRAM
*                                   AND CONVERSION SUBPROGRAMS.
      ORR           RESETS PLC AFTER USE OF ORB AT
*                                   BEGINNING OF PROGRAM
OPEN  NOP
SPCFL DLD SPACS     STORES EDITING CHARACTERS IN
      DST PRTSC+2   OUTPUT AREA FOR PARTS COST
      DST PRTSC+6   REPORT.
      LDA DLRSG
      STA PRTSC+8
READU JSB .IOC.     READ ONE RECORD FROM USAGE LIST
      OCT 10001     LOCATED ON STANDARD UNIT 1
      JMP RJCTU     (TELEPRINTER INPUT). PRTUS IS
      DEF PRTSU     ADDRESS OF STORAGE AREA; AREA IS
      DEC 4         4 WORDS LONG.
CXSTU JSB .IOC.     CHECK STATUS OF UNIT 1.
      OCT 40001
      RAL
      SSA
      JMP CHKSTU    IF BUSY, LOOP UNTIL FREE.
      RAL
      SSA
      JMP *+2
      JMP READM     IF COMPLETE, TRANSFER TO SECTION
*                                 WHICH READS MASTER FILE RECORD.
      ALF,ALF       TEST END OF TAPE STATUS BIT
      RAL           (ORIGINAL BIT 05).
      SSA
      JMP EOTU      IF SET, GO TO EOT PROCEDURE.
      JMP ABORT     IF NOT SET, SOME ERROR CONDITION
*                                 (UNRECOVERABLE) EXISTS.
RJCTU SSB           CHECK CAUSE OF REJECT. IF UNIT
      JMP READU     BUSY LOOP UNTIL FREE. ANY OTHER
      JMP ABORT     CAUSE IS UNRECOVERABLE ERROR.
EOTU  LDA OETS1     IF END OF USAGE FILE, ALTER
      STA OPEN      PROGRAM SEQUENCE TO BYPASS
      LDA EOTS2     SECTIONS THAT READ AND PROCESS
      STA COMPR     USAGE FILE. PRINT MESSAGE ON
      JSB .IOC.     TELEPRINTER INDICATING EOT.
      OCT 20002
      JMP EOTU+4
      DEF MSGU
      DEC 9
MSGU  ASC 9,END OF USAGE FILE
      JMP READM
READM JSB .IOC.     READ A RECORD FROM MASTER PARTS
      OCT 10105     FILE ON STANDARD UNIT 05(PUNCHED
      JMP RJCTM     TAPE READER). PRTSM  IS ADDRESS
      DEF PRTSM     OF STORAGE AREA; AREA IS 4 WORDS
      DEF 4         LONG. RECORD IS IN BINARY FORMAT
CKSTM JSB .IOC.     CHECK STATUS OF UNIT 5.
      OCT 40005
      SSA
      JMP CKSTM     IF BUSY, LOOP UNTIL FREE.
      RAL
      SSA
      JMP *+2
      JMP COMPR     IF COMPLETE, TRANSFER TO EITHER
      ALF,ALF       PROCESSING OR WRITE OUTPUT
      RAL           DEPENDING ON SETTING OF COMPR.
      SSA           TEST FOR END OF TAPE.
      JMP EOTM      IF END, GO TO EOT PROCEDURE.
      JMP ABORT     IF NOT, AN UNRECOVERABLE ERROR
*                              EXISTS.
RJTCM SSB           CHECK CONTENTS OF B FOR CAUSE OF
      JMP READM     REJECT. IF UNIT BUSY, LOOP UNTIL
      JMP ABORT     FREE, OTHERWISE I/O ERROR EXISTS
EOTM  LDA HLTSW     ALTER PROGRAM SEQUENCE TO HALT
      STA CKSTN+7   EXECUTION AFTER LAST RECORD IS
      JSB .IOC.     WRITTEN  PRINT MESSAGE
      OCT 20002     INDICATING END OF MASTER INPUT.
      JMP EOTM+2
      DEF MSGM
      DEC 15
MSGM  ASC 15,END OF MASTER PARTS FILE INPUT
      JMP COMPR
HLTSW JMP HALT      END OF PROGRAM SUBROUTINE
COMPR NOP
      JSB CONUI     CONVERT ID NUMBER FIELDS OF
      JSB CONVM     MASTER AND USAGE FILES TO BIN.
      LDA UTEMP     LOAD THESE FIELDS FROM TEMPORARY
      LDB MTEMP     STORAGE.
      CPA B         COMPARE
      JMP PROCM     IF EQUAL, JUMP TO PROCESSING
      CMB,INB       IF ID NUMBER OF MASTER GREATER
      ADA B         THAN ID NUMBER OF USAGE, DATA IN
      SSA           USAGE FILE ERRONEOUS. TERMINATE
      JMP ABORT     RUN.
      LDA *+3       IF ID MASTER LESS THAN ID USAGE,
      STA CKSTN+7   ALTER SEQUENCE: READ NEXT MASTER
      JMP WRITN     RECORD IMMEDIATELY AFTER WRITING
      JMP READM     CURRENT MASTER RECORD.
PROCM JSB CONU2     CONVERT QUANTITY FIELD OF USAGE
      LDA PRTSM+2   FILE TO BINARY AND SUBTRACT FROM
      LDB UTEMP+1   QUANTITY FIELD OF MASTER AND
      CMB,INB       STORE RESULT
      ADA B
      STA PRISM+2
PROCC DLD PRTSU     STORE ID OF PARTS USED IN REPORT
      DST PRTSC     FILE STORAGE AREA.
      DLD PRTSU+2   STORE QUANTITY OF PARTS USED IN
      DST PRTSC+4   REPORT FILE STORAGE AREA
      LDA PRTSM+3   COMPUTE COST OF PARTS USED.
      MPY UTEMP+1
      STA SWTMP+1
      STB SWTMP
      JSB CONVC     CONVERT RESULT TO DECIMAL
      DLD SWTMP
      DST PRTSC+9   STORE IN REPORT FILE AREA.
      LDA *+3       ALTER SEQUENCE: READ NEXT USAGE
      STA CKSTN+7   RECORD AFTER WRITING CURRENT
      JMP WRITC     MASTER RECORD.
      JMP READU
CONVM NOP
      DLD PRTSM     STORE ID FIELDS IN COMMON
      DST DTOBI     LOCATIONS TO BE PROCESSED BY
      JSB BCONV     CONVERSION SUBPROGRAM. ON
      LDA DTOBO     COMPLETION, STORE RESULTS IN
      STA MTEMP     LOCATIONS USED BY PROCESSING
      JMP CONVM,I   SECTIONS. CONVM APPLIES TO ID OF
CONU1 NOP           MASTER PARTS FILE; CONU1, TO ID
      DLD PRTSU     OF USAGE; CONU2, TO QUANTITY OF
      DST DTOBI     USAGE; AND CONVC, TO COST OF
      JSB BCONV     PARTS(THIS IS A BINARY TO
      LDA DTOBO     DECIMAL CONVERSION).
      STA UTEMP
      JMP CONU1,I
CONU2 NOP
      DLD SWTMP
      DST BTODI
      JSB DCONV
      DLD BTODO
      DST SWTMP
      JSB CONVC,I
WRITC JSB .IOC.     WRITE ONE RECORD OF PARTS COST
      OCT 20102     REPORT ON STANDARD UNIT 2
      JMP RJCTC     (TELEPRINTER OUTPUT). PRTSC IS
      DEF PRTSC     ADDRESS IN STORAGE AREA; AREA IS
      DEC 11        11 WORDS LONG. RECORD IS IN ASCII
CKSTC JSB .IOC.     CHECK STATUS OF UNIT 2
      OCT 40002
      SSA
      JMP CKSTC
      RAL
      SSA
      JMP ABORT     TERMINATE IF ANY I/O ERROR.
      JMP WRITN     IF COMPLETE, TRANSFER TO WRITN
RJCTC SSB           IF BUSY, LOOP UNTIL FREE.
      JMP WRITC     TERMINATE ON ANY OTHER REJECT
      JMP ABORT     CONDITION
WRITN JSB .IOC.     WRITE ONE RECORD (BINARY) OF
      OCT 20104     NEW MASTER PARTS LIST ON UNIT 4
      JMP RJCTN     (TAPE PUNCH). PRTSM (INPUT AREA)
      DEF PRTSM     IS ALSO USED AS OUTPUT AREA.
      DEC 4
CKSTN JSB .IOC.     CHECK STATUS OF UNIT 4.
      OCT 40004
      SSA
      JMP CKSTN     IF BUSY, LOOP UNTIL FREE.
      RAL
      SSA
      JMP ABORT
      JMP READU
RJCTN SSB           IF BUSY, LOOP UNTIL FREE, OTHER-
      JMP WRITN     WISE TERMINATE.
      JMP ABORT
      END START
