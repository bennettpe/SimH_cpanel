ASMB,R,B,L
      HED RTE DRIVER FOR HP 1300 SCOPE WITH 12555 DIGITAL TO ANALOG CARD
* 
*     PGMR:   ROBERTO SANCHO, APR 2017
* 
* 
      NAM DVR13,0 
*
      ENT I.13,C.13 
*
*
*           *********************************************** 
*           *                                             * 
*           *    HP-2331A X-Y DISPLAY SUBSYSTEM DRIVER    * 
*           *                                             * 
*           *                  -- BY --                   * 
*           *                                             * 
*           *               STEVEN A. STARK               * 
*           *               HEWLETT-PACKARD               * 
*           *                PARAMUS, N.J.                * 
*           *                                             * 
*           *    MODIFIED BY ROBERTO SANCHO ON APR/2017   * 
*           *    TO BE USED ON RTE-B.                     * 
*           *    BASED ON 22217-80001 Rev-B FOR PAPER     *
*           *    TAPE HP-BASIC. AND 22505-80001 Rev-A     *
*           *    HP-1331C STORAGE SCOPE DRIVER FOR RTE    *
*           *    DVR47                                    *
*           *                                             * 
*           *                                             * 
*           *********************************************** 
*
*    I. IDENTIFICATION - SAS 0044   REV. 4   9/15/71
*                        REV 1 FOR RTE-B    APR/2017
*    -----------------
* 
*    II. LANGUAGE - ASSEMBLY LANGUAGE
*    ------------ 
* 
*    III. TYPE - BASIC CALLABLE SUBROUTINE VIA MNEMONICS TABLE 
*    ---------
* 
*    V. SPECIAL HARDWARE REQUIRED - 
*    ---------------------------- 
* 
*       A. HP-2331A X-Y DISPLAY SUBSYSTEM CONSISTING OF:
*          1. HP-1300A X-Y DISPLAY
*          2. HP-12555A DUAL D/A CONVERTER INTERFACE CARD 
* 
*    VI. DESCRIPTION -
*    ---------------
* 
*    IN ORDER TO UTILIZE THE X-Y DISPLAY SUBSYSTEM DRIVER, IT 
*    MUST FIRST BE CALLED TO SET UP THE PLOT BUFFER, IN WHICH 
*    CASE, IT WILL PROCESS THE D/A CARD SELECT I/O CODE, THE
*    BUFFER ADDRESS AND LENGTH AND SAVE THEM FOR USE BY THE 
*    INTERRUPT SERVICE ROUTINE. THE DRIVER THEN RETURNS TO THE 
*    CALLING PROGRAM.
* 
*    ONCE THE PLOT BUFFER HAS BEEN SET UP,THE DRIVER MAY THEN 
*    BE CALLED TO ENTER POINTS TO BE DISPLAYED. IN THIS CASE, 
*    IT WILL PROCESS THE X AND Y VALUES, DETERMINING IF THEY
*    ARE IN THE CORRECT RANGE AND MERGING THEM INTO A SINGLE
*    WORD.IT WILL THEN STORE THIS WORD IN THE PLOT BUFFER AND 
*    RETURN TO THE CALLING PROGRAM. IN THE EVENT THAT EITHER
*    THE X OR Y VALUE IS OUTSIDE THE PROPER RANGE, THE DRIVER 
*    RETURNS TO THE CALLING PROGRAM WITHOUT STORING THE POINT 
*    IN THE PLOT BUFFER.
* 
*    THE DRIVER MAY ALSO BE CALLED TO CLEAR THE PLOT BUFFER,
*    IN WHICH CASE,IT WILL FIRST DETERMINE IF THE PLOT BUFFER 
*    HAS BEEN SET UP. IF IT HAS, THE DRIVER THEN CLEARS IT BY 
*    SETTING EACH LOCATION TO A 0 AND IT WILL THEN RETURN TO
*    THE CALLING PROGRAM.IF THE DRIVER IS CALLED TO CLEAR THE 
*    PLOT BUFFER BEFORE IT HAS BEEN SET UP,IT WILL IGNORE THE 
*    REQUEST AND RETURN IMMEDIATELY TO THE CALLING PROGRAM. 
* 
*    THE KEY SEGMENT OF THIS DRIVER IS THE INTERRUPT SERVICE
*    SUBROUTINE, WHICH IS EXECUTED EACH TIME THE D/A CONVERTER 
*    INTERRUPTS (ABOUT EVERY TWENTY MILLISECONDS). WHEN THIS
*    INTERRUPT OCCURS, THIS SUBROUTINE WILL DISPLAY THE 
*    CONTENTS OF THE PLOT BUFFER, INITIALIZE THE D/A 
*    CONVERTER AND RETURN TO THE PROGRAM IN PROGRESS. 
* 
*    VII. ENTRY POINTS - PLOTB, ERASE, DISPT, LINES, CHAR, CHARS
*    -----------------
* 
*    VIII. CHANGES TO ORIGINAL PROGRAM
*    ---------------------------------
*    - CONVERTED TO RTE STANDARD DRIVER WORKING ON INTERRUPTS
*    - ALLOW PLOTB TO HAVE LU (LOGICAL UNIT) 
*    - REMOVED GRAPH (CALL (3,...)) AXIS DRAWING ROUTINE. 
*    - ADDED LINES TO DRAW LINES WITH THE ABILITY TO DRAW
*      DISCONTIUOS LINES TO REDUCE THE BUFFER USAGE
*    - ADDED CHAR AND CHARS TO DISPLAY CHARACTER STRINGS. 
*      (LINES AND CHARS BORROWED FROM DVR47)
* 
*    IX. CALLING INFORMATION -
*    -----------------------
* 
*    TO SET UP THE PLOT BUFFER, AND DISPLAY IT THE DRIVER 
*    IS CALLED FROM BASIC AS:
* 
*       CALL PLOTB(LU, A[1], N) 
* 
*          WHERE        LU - LOGICAL UNIT FOR DAC WHERE SCOPE
*                            IS ATTACHED
* 
*                       A - AN ARRAY USED TO STORE THE
*                           POINTS TO BE DISPLAYED. 
* 
*                       N - A VARIABLE OR CONSTANT WHICH
*                           SPECIFIES THE NO. OF POINTS 
*                           TO BE DISPLAYED.
* 
*    TO TURN THE X-Y DISPLAY OFF, THE DRIVER IS CALLED FROM 
*    BASIC AS:
* 
*       CALL PLOTB(LU, A[1], 0) 
* 
*    TO SET THE PLOT BUFFER WITHOUT DISPLAYING IT USE 0 AS LU.
*    THIS ALLOWS TO PREPARE THE POINTS TO DISPLAY AFTERWARDS:
* 
*       CALL PLOTB(0, A[1], N) 
* 
*    TO STORE A POINT IN THE PLOT BUFFER, THE DRIVER IS 
*    CALLED FROM BASIC AS:
* 
*       CALL DISPT(X, Y)
* 
*          WHERE        X - A VARIABLE OR CONSTANT, IN
*                           THE RANGE 1 TO 255, WHICH 
*                           REPRESENTS THE X-COORDINATE 
*                           VALUE.
* 
*                       Y - A VARIABLE OR CONSTANT, IN
*                           THE RANGE 1 TO 255, WHICH 
*                           REPRESENTS THE Y-COORDINATE 
*                           VALUE.
* 
* 
*    TO CLEAR THE PLOT BUFFER, THE DRIVER IS CALLED FROM
*    BASIC AS:
* 
*       CALL ERASE
* 
*
*    TO DRAW A LINE IN THE BUFFER, USE:
* 
*       CALL LINES(IX1, IY1, IX2, IY2, MODE)
*
*       WHERE IX1, IY1 = COORDINATES OF FIRST POINT. 
*
*             IX2, IY2 = COORDINATES OF SECOND POINT.
*
*             MODE = 0 -> DRAW A CONTINUOUS LINE
*                  > 0 -> DRAW A DISCONTINUOUS LINE:
*                      = 1 -> LINE WITH ONE DOT DRAW, ONE SKIPPED
*                      = 2 -> LINE WITH ONE DOT DRAW, THREE SKIPPED
*                      = 3 -> LINE WITH ONE DOT DRAW, SEVEN SKIPPED
*
*
*    TO DISPLAY AN ASCII BUFFER:
* 
*       CALL CHAR(IX, IY, IASC, NUM)
*
*       WHERE IX, IY = COORDINATES OF UPPER LEFT POINT OF FIRST CHAR
*
*             IASC = ADDRESS OF ASCII BUFFER (PACKED CHARS)
*
*             NUM  = NUMBER OF CHARACTERS
*
*
*    TO DISPLAY AN ASCII STRING (TO BE CALLED FROM BASIC)
* 
*       CALL CHARS(IX, IY, IASC)
*
*       WHERE IX, IY = COORDINATES OF UPPER LEFT POINT OF FIRST CHAR
*
*             IASC = BASIC LITERAL OR STRING VARIABLE ADDR 
*                    (NUM OF ASCII CHARS IN STRING IS FIRST WORD)
*
*
* ***********************************
* INITIATION SECTION
* ***********************************
*
I.XY  NOP 
      STA DACSC     SAVE THE SELECT CODE
      LDA EQT5,I    IS THE EQT
      SSA             BUSY? 
      JMP PFAIL         YES - MUST BE AUTO RESTART
      JSB SETIO     ASSIGN DAC CARD SC TO IO INSTR
      LDA EQT4,I    SHOW RTE THAT TIMEOUT AND 
      IOR PS         PWR FAIL WILL BE HANDLED HERE. 
      STA EQT4,I
      LDA EQT6,I    REQUEST CODE WITH EXEC CALL 
      AND B3         TYPE IN LOW BITS.
      CPA B3
      JMP CNTRL 
      SLA           IF A=1,RETURN CODE IS RIGHT 
      JMP I.XY,I     TO SHOW ILLEGAL READ.
      SPC 1 
      LDA EQT7,I    GET BUFFER ADDRESS 
      STA DIBUF     SAVE FOR POINTER 
      LDA EQT8,I    GET BUFFER LENGTH 
      SSA,RSS       IS IT < OR = 0? 
      SZA,RSS 
      JMP TRNOF      YES, TURN DISPLAY OFF
      CMA,INA       MAKE BUF LEN NEGATIVE 
      STA DILEN      SAVE FOR COUNTERS
      SPC 1 
      JSB DION      TURN DISPLAY ON
      JMP IEXIT
TRNOF JSB DIOFF
IEXIT CLB
      LDA B4        OPERATION COMPLETED 
      JMP I.XY,I
*
DION  NOP           DISPLAY ON
IN1   STC SCGEN,C   INITIALIZE D/A CONVERTER
      LDA B1        SET INTERRUPT STATUS TO 1
      STA INTST      TO ALLOW INT PROCESSING
      JMP DION,I
DIOFF NOP           DISPLAY OFF
      CLA           SET INTERRUPT STATUS TO 0
      STA INTST      TO DISALLOW INT PROCESSING
IN2   CLC SCGEN     TURN D/A CONVERTER OFF
      JMP DIOFF,I
*
SETIO NOP
      LDA ISTRT   INITIALIZE INSTRUCTION ADDRESS
      STA IPNTR    POINTER
STIO1 LDB IPNTR,I GET INSTRUCTION ADDDRESS
      SZB
      RSS
      JMP STIO2
      LDA B,I      GET INSTRUCTION
      AND XMASK     MASK OUT OLD SELECT CODE
      IOR DACSC      MERGE IN NEW ONE 
      STA B,I         SET IN PROGRAM
      ISZ IPNTR   INDEX ADDRESS POINTER 
      JMP STIO1
STIO2 JMP SETIO,I

*
* CONTROL REQUEST CHECK IF IT IS A “CLEAR” CONTROL REQUEST
* IF SO, ASSUME IT WAS ISSUED BY SYSTEM, CLEAR DEVICE, AND RETURN
*
CNTRL LDA EQT6,I    ACCESS CONTROL WORD
      AND B3700     ISOLATE SUBFUNCTION
      SZA           “CLEAR” REQUEST?
      JMP REJCT     NO, SO REJECT REQUEST AS ILLEGAL
      JSB DIOFF
      CLA
      JMP I.XY,I
REJCT LDA B2        SET A=2=ILLEGAL CONTROL REQUEST
      JMP I.XY,I    AND RETURN
PFAIL LDA B4          REGISTER AND DO IMMEDIATE 
      JMP I.XY,I       COMPLETION 
*
DACSC NOP           STORE CURRENT DAC IO SELECT CODE. 
DIBUF OCT 0         DISPLAY BUFFER
DILEN BSS 1         DISPLAY BUFFER LENGHT
INTST OCT 0         STORE INTERRUPT STATUS. 
*                    0=NO INT ALLOWED,1=ALLOWED
*                    2=INT PROCESSING ONGOING
PNTR  BSS 1 
CNTR  BSS 1 
*
IPNTR BSS 1 
ISTRT DEF *+1       TABLE OF IO INSTR TO SET THE
      DEF IN1        SELECT CODE
      DEF IN2         TABLE ENDS WITH ZERO
      DEF IN3 
      DEF IN4
      OCT 0
XMASK OCT 177700
BIT15 OCT 100000
PS    OCT 30000 
EQ5   OCT 177400
B1    OCT 1 
B3    OCT 3 
B2    OCT 2
B4    OCT 4 
B5    OCT 5 
B100  OCT 100 
B300  OCT 300 
B1200 OCT 1200
B3700 OCT 3700
B5000 OCT 5000
B5600 OCT 5600
BIT11 OCT 4000
MASK  OCT 2700
MASK2 OCT 137771
      SKP 
*
* ***********************************
* * CONTINUATION/COMPLETION SECTION *
* ***********************************
*      
C.XY  NOP 
      LDA INTST     CHECK INT STATUS. 
      CPA B1        =1?
      RSS
      JMP NODIS      NO, DO NOT DISPLAY IGNOT INT
      JSB DI.RE      YES, SEND REFRESH DATA TO SCOPE
      ISZ C.XY       CONTINUATION RETURN
      JMP C.XY,I
NODIS LDB EQT1,I
      SZB,RSS 
      JMP EXTRA     SPURIOUS INTERRUPT. 
      LDA EQT4,I    EXAMINE BIT 11 FOR A
      AND BIT11      TIME-OUT ENTRY.
      SZA 
      JMP TMOUT 
      LDB EQT8,I    GET TRANSMISSION LOG
      JMP C.XY,I    A ALREADY CLEAR.
      SPC 1 
TMOUT XOR EQT4,I    BIT 11 IS SET, SO CLEAR 
      STA EQT4,I     IT AND STORE BACK. 
      CLA           HANDLE TIME-OUT HERE TO 
      JMP C.XY,I     PREVENT A CLC BY SYSTEM, 
      SPC 1          AND DOWNED DEVICE. 
EXTRA STB EQT15,I   IGNORE INTERRUPT AND
      ISZ C.XY       PREVENT TIMEOUT FROM IT. 
      JMP C.XY,I
      SPC 3 
B     EQU 1 
SCGEN EQU 0 
DMA   EQU 6         NOMINAL DMA CHANNEL 
TBL   EQU 1650B 
CHAN  EQU TBL+23B 
INTBA EQU TBL+4 
EQTBL EQU TBL+7 
EQT1  EQU EQTBL+1 
EQT4  EQU EQTBL+4 
EQT5  EQU EQTBL+5 
EQT6  EQU EQTBL+6 
EQT7  EQU EQTBL+7 
EQT8  EQU EQTBL+8 
EQT15 EQU 1774B 
      SPC 2 
*
DI.RE NOP           DISPLAY REFRESH 
      LDA B2      SET INT STATUS=2 TO PREVENT DI.RE
      STA INTST    INTERRUPT ITSELF
      LDA DIBUF   INITIALIZE PLOT BUFFER POINTER
      STA PNTR
      LDA DILEN   INITIALIZE PLOT BUFFER COUNTER
      STA CNTR
DI1   LDA PNTR,I  GET POINT FROM PLOT BUFFER
      SZA,RSS     IS IT 0-0?
      JMP DI2     YES, GET OUT OF LOOP 
IN3   OTA SCGEN   DISPLAY IT
      ISZ PNTR    INDEX POINTER TO NEXT POINT 
      ISZ CNTR    INDEX POINT CNTR, IS IT = 0?
      JMP DI1      NO, RETURN & DISPLAY NEXT POINT
DI2   LDA B1      SET INT STATUS=1 AGAIN TO ALLOW NEXT 
      STA INTST    INTERRUPT 
IN4   STC SCGEN,C INITIALIZE D/A CONVERTER TIMER
      JMP DI.RE,I
*
C.13  EQU C.XY
I.13  EQU I.XY
*
      END 
