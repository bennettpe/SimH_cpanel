ASMB,R,B,L,Z,C ASSEMBLE FOR RTE 
      HED *** DOS/RTE ASMB  FALL 1971 *** 
      NAM ASMB,3,99 
*              *******************************
*              * NOTE: ON CONTROL STATEMENT; *
*              *  N = DISK O.S. USAGE        *
*              *  Z = REAL TIME USAGE        *
*              *******************************
      ENT ASMB
      EXT ?HA3Z,?LITI,?SKPR,?SPCR,?BREC,?ART,?LKLI
      EXT ?CMQ,?ENP,?EXP,?INSR,?INS?,EXEC 
      ENT ?ASCN,?ASMB,?BNCN,?BPKU,?CHOP,?CHPI,?DCOD 
      ENT ?ENDS,?ERPR,?MSYS,?GETC,?MOVE,?MSYM,?RLUN 
      ENT ?AFLG,?LSTL,?LUNI,?RFLG,?Z,?ASM1,?LABE
      ENT ?OKOL,?ORRP,?PNLE,?SETM,?SUP,?LPER,?PERL
      ENT ?LOUT,?LTFL,?DRFL,?LTSA,?LTSB,?ORGS,?CNTR 
      ENT ?TSTR,?ASII,?ICSA,?FLGS,?BFLG,?LFLG,?TFLG 
      ENT ?X,?MESX,?ASCI,?LINC,?LINS,?LIST,?LUNP
      ENT ?OPLK,?OPER,?PKUP,?PLIT,?PNCH,?PRNT,?RSTA 
      ENT ?LWA,?RDSC,            ?WEOF,?WRIF,?LGFL
      ENT ?SEGM,?SYMK,?V,?ARTL,?LST,?PLIN,?PCOM,?SECT 
      ENT ?NEAU,?HA38,?XRFI 
      ENT ?FPT,?FP
      SUP  SUPPRESS EXTENDED LISTING
*             ******************************
*             * OPCODE AND PSEUDO-OP TABLE *
*             ******************************
OPT OCT 40502,51421,0,     40504,40416,42001 ABS/ADA
    OCT 40504,41016,46001, 40514,43060,31700 ADB/ALF
    OCT 40514,51060,31400, 40514,51460,31000 ALR/ALS
    OCT 40516,42016,12001, 40522,51460,31100 AND/ARS
    OCT 40523,41407,0,     41114,43060,25700 ASC/BLF
    OCT 41114,51060,25400, 41114,51460,25000 BLR/BLS
    OCT 41122,51460,25100, 41123,51412,0     BRS/BSS
    OCT 41503,40461,53400, 41503,41061,47400 CCA/CCB
    OCT 41503,42463,42300, 41514,40461,52400 CCE/CLA
    OCT 41514,41061,46400, 41514,41450,106700 CLBCLC
    OCT 41514,42463,0,     41514,43052,103100 CLECLF
    OCT 41515,40461,53000, 41514,47430,103101 CMACLO
    OCT 41515,41061,47000, 41515,42463,42200 CMB/CME
    OCT 41517,46403                          COM
      DEF ?CMQ
    OCT 41520,40416,52001, 41520,41016,56001 CPA/CPB
    OCT 42105,41410,0,     42105,43020,0     DEC/DEF
      OCT 42105,54025,0                    DEX
    OCT 42514,40460,131600, 42516,52004      ELA/ENT
      DEF ?ENP
    OCT 42514,41060,125600, 42516,42014,0    ELB/END
    OCT 42522,40460,131500, 42521,52413,0    ERA/EQU
    OCT 42522,41060,125500, 42530,52005      ERB/EXT
      DEF ?EXP
      OCT 44114,52051,102000,46111,40450,102500  HLT/LIA
      OCT 46111,41050,106500,46511,40450,102400  LIB/MIA
?FPT  EQU * 
      OCT 43101,42006     FAD 
      DEF ?HA38 
      OCT 43104,53006    FDV
      DEF ?HA38 
      OCT 43115,50006    FMP
      DEF ?HA38 
      OCT 43123,41006    FSB
      DEF ?HA38 
    OCT 44516,40466,52004, 44516,41066,46004 INA/INB
    OCT 44517,51016,32001, 44523,55016,36000 IOR/ISZ
    OCT 45115,50016,26000, 45123,41016,16000 JMP/JSB
    OCT 46104,40416,62001, 46104,41016,66001 LDA/LDB
    OCT 46511,41050,106400, 47101,46415,0    MIB/NAM
    OCT 47117,50030,0,     47503,52011,0     NOP/OCT
    OCT 47524,40450,102600, 47522,43401      OTA/ORG
    DEF ORGP
    OCT 47524,41050,106600, 47522,51002      OTB/ORR
    DEF ORRP
    OCT 51101,46060,31200, 51101,51060,31300 RAL/RAR
    OCT 51102,46060,25200, 51102,51060,25300 RBL/RBR
    OCT 51123,51470,42001, 51505,55062,42040 RSS/SEZ
  OCT 51506,41452,102200, 51506,51452,102300 SFC/SFS
    OCT 51514,40465,10010, 51514,41065,4010  SLA/SLB
  OCT 51517,41453,102201, 51517,51453,102301 SOC/SOS
    OCT 51523,40464,52020, 51523,41064,46020 SSA/SSB
    OCT 51524,40416,72000, 51524,41016,76000 STA/STB
  OCT 51524,41450,102700, 51524,43052,102100 STC/STF
   OCT 51524,47430,102101, 51532,40467,52002 STO/SZA
    OCT 51532,41067,46002, 54117,51016,22001 SZB/XOR
      OCT 46123,52024,0,  51513,50022        LST/SKP
      DEF ?SKPR 
      OCT 51525,50040,1,  44105,42017        SUP/HED
      DEF HEDSB 
      OCT 52516,46024,1,  51105,50035        UNL/REP
      DEF REPSB 
      OCT 52516,51440,0,  44506,47031,116    UNS/IFN
      OCT 54111,43031,0,  44506,55031,132    XIF/IFZ
      OCT 51520,41423 
      DEF ?SPCR                                 SPC 
?NEAU EQU *        START OF NON-EAU OPTABLE SWAP AR.
  OCT 42111,53026,100400, 42114,42026,104200 DIV/DLD
  OCT 42123,52026,104400, 46520,54426,100200 DST/MPY
  OCT 40523,46027,100020, 40523,51027,101020 ASL/ASR
  OCT 46123,46027,100040, 46123,51027,101040 LSL/LSR
  OCT 51122,46027,100100, 51122,51027,101100 RRL/RRR
  OCT 51527,50030,101100,51101,46451,105000 SWP/RAM 
?FP   EQU * 
      OCT 0,54030,105100,43114,52030,105120 FIX/FLT 
      OCT 0 
       SKP
*              *************************************
*              * PUT OUT A MESSAGE TO THE OPERATOR *
*              *************************************
MESSX NOP 
      STA MESS      SET MESSAGE LOCN
      STB MESS+1    SET MESSAGE LENGTH
      JSB EXEC
      DEF *+5 
      DEF .1+1      OUTPUT REQ. CODE
      DEF .1        OUTPUT ON SYSTEM TTY
      DEF MADDR     MESSAGE ADDRESS 
      DEF .1+6      MESSAGE LENGTH
      JSB EXEC      GO SET EOT ON INPUT DEVICE
      DEF *+3 
      DEF .1+2
      DEF EOTIN     SETS EOT STATUS ON INPUT DEVICE 
      JMP MESSX,I   EXIT
SEGNM ASC 3,ASMB
MADDR ASC 5,$END ASMB 
MESS  ASC 2,
      IFN 
XREF  ASC 3,XREF
      XIF 
?XRFI NOP CROSS REFERENCE INPUT FLAG
* 
*              *******************************
*              * GO TO LOAD THE NEXT SEGMENT *
*              *******************************
SEGMT STA SEGNM+2   SET CORRECT DIGIT (1,2,OR 3)
      JSB EXEC
      DEF *+3 
      DEF .8        SEGMENT REQ. CODE 
      DEF SEGNM     LOC'N OF 5 CHAR SEGM'T NAME 
      SPC 1 
*                   *********************** 
*                   * EXIT FROM ASSEMBLER * 
*                   *********************** 
ABORT LDA *+4       SET UP END MESSAGE FOR EOF ABORT
      LDB *+4 
      JSB MESSX     GO PRINT KESSAGE
      JMP ASMEX     GO TO COMPLETION
      ASC 2,XEND
ASMBX LDA BLNS
      LDB BLNS
      JSB MESSX     "$END ASMB" MESSAGE 
      IFN 
      LDA CFLAG 
      SZA,RSS      IS CROSS REF TABLE REQUESTED?
      JMP *+3       NO
      LDA DRFLG 
      SZA           IS DISK OK FOR XREF USAGE?
      JMP *+6      NO,  GO TO PROGRAM CONPLETION
      JSB EXEC     YES, SCHEDULE XREFERENCE GENERTR.
      DEF *+4 
      DEF .10 
      DEF XREF
      DEF ?XRFI 
      XIF 
ASMEX EQU * 
      IFZ 
      JSB EXEC     GO RELEASE ALL TRACKS
      DEF *+3 
      DEF .1+4      RCODE =5
      DEF ..M1     -1 = RELEASE ALL TRACKS
      XIF 
      JSB EXEC      PROGRAM COMPLETION
      DEF *+2 
      DEF .1+5      COMPLETION REQ CODE 
.8    DEC 8 
      SKP 
*         ********************************************* 
*         * OPLK: OPCODE TABLE LOOKUP  - WALDY HACCOU * 
*         *  CALLING SEQUENCE:  L  JSB OPLK,I         * 
*         *                    L+1 ERROR RETURN       * 
*         *                    L+2 NORMAL RETURN      * 
*         *  OUTPUT VALUES: VALUE IN A REG. AND 'CODE'* 
*         *               INSTR.FORMAT IN B AND 'INST'* 
*         ********************************************* 
DOPL  DEF TEMP+5
      DEF OPT       LOC'N OF OPCODE TABLE 
OPLK  NOP 
      JSB BPKUP    GET OPCODE POSN
      STB SCN1+1
      CLA 
      STA TEMP+6   CLEAR TEMP+6 
      LDA 1           B REG TO A REG
      JSB GETA    GET OPCODE ADDRESS
      STB *+4 
      LDA ...1+2 (3)
      LDB DOPL      L(TEMP+5) 
      JSB MOVE
      NOP     MOVE ORIGIN HERE
      LDB DOPL+1    L(OPCODE TABLE) 
      LDA 1,I  (FROM *+7) 
     INB
      CPA TEMP+5  CHECK 1ST 2 CHARS.
      JMP K 
J     ADB ...1+1 (2)
      LDA 1,I 
      SZA   END OF TABLE? 
      JMP *-7  NO 
* 
*             * ERROR EXIT HERE * 
      LDA .OP       'OP' OPCODE ERROR 
      JSB ERPR
      JMP OPLK,I    EXIT HERE ON 'CD' ERROR 
K     LDA 1,I  CHECK LAST CHAR OF OPCODE
      AND UMSK
      CPA TEMP+6  COMPARE IT
      JMP *+2    OPCODE FOUND ,SKIP 
      JMP J  NOT FOUND, TRY NEXT ENTRY
      LDA 1,I 
      AND LMASK     SET 'A' = OPCODE TYPE 
      INB 
      LDB 1,I 
      STB INST   = INSTRUCTION FORMAT 
      STA CODE   = VALUE OF CODE
      ISZ OPLK
      JMP OPLK,I    EXIT ALPHA+2
      SKP 
*             ******************************************************
*             * EVALUATE OPERAND; TEST/PROCESS 'C' OR 'I' MODIFIER *
*             ******************************************************
CLER  DEF RELC      START OF 5 WORD CLEAR AREA
CHOP  NOP 
*        * ON ENTRY A = MODIF.PARAMETER (I,C,0=NONE,2=ASC)
*        *     B= MASK NECESSARY FOR I OR C MODIFIER
      STA FLAG
      STB FLAQ
      SPC 1 
*         * CLEAR CHOP PARAMS IN T, RELC, SIGN, SUMP & TERM.. * 
      LDA ...1+4  (5) 
      LDB CLER      START OF CLEAR AREA 
     JSB SETM 
ZERO  NOP           TO SET MEMORY TO ZERO 
     ISZ SIGN  SET SIGN = + (+1=+,-1=-) 
      LDA SCN1+2  OPER.POSN.
      STA PNTR
     SZA,RSS
     JMP HD22  ERROR**NO OPERAND
* 
*             * GET THE 1ST CHARACTER * 
     JSB GETC 
      CPA L+3  PLUS?
      JMP HD32+2   YES
      CPA L+5  MINUS? 
      JMP HD32     YES
      JMP HD32+3  NO
* 
*             * PROCESS AN ASTERISK '*' * 
HD26  CLA,INA       SET A=1 
      CPA SYMP      IS THE '*' ALONE? 
      RSS           YES - GOOD
      JMP HD22      NO - IT'S AN ERROR
      LDB AFLAG     GET ABS. ASSMBL. FLAG 
      SZB           IS THIS AN ABS. ASSEMBLY? 
      CLA           YES, CLEAR A(WILL BE RELOC. BIT)
      LDB PLCN  PROG LOCN CNTR TO B REG 
      JMP HD50+2
* 
*             * CHOP LOOP PROCESSING HERE * 
HD30  LDA PEEK
      CPA L+4 TEST PEEK FOR A 
      JMP HD36  COMMA, GO TO TEST MODIFIERS 
     CPA BLNK 
     JMP HD40  =BLNK
     CLB,INB  SET 'SIGN' FOR +
      CPA L+3  PLUS?
      RSS           YES 
* 
*             * PROCESS SIGNS HERE *
HD32 CCB   SET 'SIGN' FOR - 
      STB SIGN  (HD32+1)
      ISZ PNTR
* 
*             * PICK UP NEXT SET OF CHARS.IN BUFFER * 
      JSB BPKUP GET POSN OF NXT NON-BLNK CHAR.HD32+3
      STA PEEK
     STB PASCN  SAVE PNTR FOR ASCN RTN
      JSB MSYMS MEAS.SYMBOL, SET SYMP/SYMN
      ADA PNTR
      STA PNTR
* 
*             * TEST FOR NUMERIC OR SYMBOLIC SET *
      LDA PEEK   FIRST CHAR OF SET TO A FOR TESTING 
     LDB TEST 
      STB PEEK  SAVE CHAR.FOR LATER TEST
      CPA L+2  ASTERISK?
     JMP HD26 TO '*' PROC 
      ADA .M58      -58 
      SSA,RSS       TEST FOR SYMBOLIC TERM
      JMP HD50  PROCESS THE SYMBOL
      ADA LPDG+3 (10) 
     SSA
      JMP HD50  PROCESS THE SYMBOL
* 
*             * PROCESS NUMERIC SET HERE *
      LDB SYMP
      ADB ..M1
      LDA LAST IS B LAST -
      CPA .B        CHARACTER?
     JMP *+2
*             * SET B REG FOR ASCN ROUTINE
      ADB .401B 
     LDA PASCN
      JSB ASCN      TO AXCII CONVERSION TO BINARY 
      JMP CHOP,I    ERROR EXIT FROM ASCII CONV. 
     JMP HD61+1  A REG CONTAINS THE VALUE 
* 
*        * TEST INFORMATION FOLLOWING COMMA, IF LEGAL 
*        * -USES FLAG AND FLAQ
*        * -IF C OR I, SET CORRECT BIT IN INSTRUC. USING FLAQ AS MASK 
* 
HD36 LDB FLAG 
     SZB,RSS  IS COMMA LEGAL
     JMP HD37 -NO- ERROR
      CPB ...1+1  'ASC'?
     JMP HD40 -YES- 
     ISZ PNTR  POINT TO CHAR.FOLLOWING COMMA
     JSB BPKUP SEARCH FOR NON-BLANK 
     JSB MSYM  MEASURE SYMBOL 
     CPA ...1  1 CHAR SYMBOL? 
     JMP *+3   YES
*            *   NO - ERROR 
HD37 JSB OPERR OPERAND ERROR
     JMP HD40 
     LDA TEST 
     CPA BLNK  BLANK TERMINATOR?
     JMP *+2  -YES- 
     JMP HD37 -NO- ERROR
     LDA LAST  CHAR TO A
      LDB RELC      GET THE RELOCATION FLAG 
      CPA FLAG =I/C?
      CPB .1+3      YES, IS OPERAND EXTERNAL? 
      JMP HD37      EROOR IF NO 'I' OR 'C' OR EXT OP
     LDA INST 
     IOR FLAQ  SET I OR C BIT 
     STA INST 
     LDA CODE 
      CPA L+2  STF OR CLF? (52) 
     JMP HD37  -YES- ERROR
* 
*             * CHOP TERMINATION PROCESSOR *
* 
HD40  LDA SUMP  SUM TO A
     LDB CODE 
     SSA   TEST SUMP
      JMP HD44+2
     LDA RELC 
     SZA,RSS  RELOCATBLE? 
      JMP HD42  .NO.
* 
*             * VALUE IS RELOCATABLE, TEST FOR VALIDITY * 
      LDA T  IS RELOC.NO. 
     SZA,RSS  CANCELLED?
     JMP HD42+1   -YES- 
     CPA ...1 LEG'L RELOC?
     RSS         -YES- SKIP 
     JMP HD22 NO,ERROR. 
      CPB ...1  ORG?
      JMP E  YES
*             *CHECK FOR EQU,END,TYPE 1 OR DEF(ALSO CODE=17B)*
      ADB .M11      -11 
      SSB       CODE<13B? 
      JMP HD22   YES, ERROR 
      ADB ..M1+5  -6
      SSB,RSS   CODE>20B? 
     JMP HD22 **ILL.RELOC.**
E     LDA RELC
      CPA ...1+3  EXTERNAL? 
     JMP HD44   YES 
* 
*             * NORMAL EXIT FROM CHOP, HERE * 
* 
HD42 LDA RELC 
     STA RELC  RELOC.CODE IN A AND RELC 
      LDB SUMP   SUM IN B REG ON EXIT 
      ISZ CHOP
      JMP CHOP,I    EXIT ALPHA+2
* 
*             * TEST FOR MORE THAN 1 EXT TERM * 
* 
HD44  LDB TERM
      ADB .12+4 (16)
* 
*        * NEG. OPERAND OK IF ABS OPCODE *
      CPB .12+5 (17)'ABS'OR 1 EXT TERM? 
     JMP HD42 -YES- 
* 
*       *CHOP ERROR EXIT* 
* 
HD22  LDA .MBLN     'M' FOR M TERM ERROR
      JSB ERPR  ERROR PRINT 
      JMP CHOP,I    EXIT ALPHA+1
* 
*             * PROCESS SYMBOLIC TERM HERE *
* 
HD50  JSB SYMK      GO TO SYMBOL TABLE LOOKUP 
      JMP HD6  ERR0R
      STB SAVB   SAVE VALUE FOUND IN B    (HD50+2)
      AND .1+6      TYPE MASK 
      SZA,RSS       RELOCATABLE TYPE? 
      JMP HD61      NO, ABSOLUTE OF UNDEF ENTRY PT. 
* 
*              * TEST FOR EXTERNAL EQU (RELC=5) 
      CPA ...1+4 RELOC=5? 
      LDA ...1+3 YES, SET FOR 4 
     LDB RELC 
     SZB,RSS
     STA RELC 
     CPA RELC TEST FOR SAME RELOC.TYPE
     RSS      SAME
     JMP HD22 ERROR-DIFFERENT 
* 
*             *UPDATE SIGN SAVER
     LDB SIGN 
      ADB T 
      STB T 
HD61 LDA SAVB  VALUETO A
     ISZ TERM  UPDATE NO OF TERMS 
     LDB SIGN 
     SSB  IS SIGN NEGATIVE? 
     CMA,INA  -YES- COMPLEMENT
     ADA SUMP -UPDATE RUNNING SUM 
     STA SUMP 
     JMP HD30 
* 
*             * UNDEFINED SYMBOL EXIT * 
* 
HD6   LDA .UN       'UN' UNDEFINED SYMBOL 
      JMP HD22+1  TO ERPR 
.M11  DEC -11 
.401B OCT 401 
.50   DEC 50
.M58  DEC -58 
   SKP
*             ********************
*             * READ A STATEMENT *
*             ********************
RSTA NOP
      LDA REP 
      SZA,RSS  ARE WE REPEATING A STATE?
      JMP RXT   NO -
      ISZ REP  YES, ARE WE DONE?
      JMP RZP  NO 
RXT   LDB FBOI
      LDA .50       FOR 50 WORDS
      JSB SETM   SET I/O BUFF TO BLANKS 
BLNS  ASC 1,
RXC   JSB %READ     GO READ A STATEMENT 
      DEF *+5 
      DEF LUNIN     LUN 
FFUB  DEF BUFF
      DEF .M72      72 CHARACTERS INPUT 
      JMP ABORT     EOF RETURN - NOT POSSIBLE 
      STB SCN1      SAVE ACTUAL CHARACTER COUNT 
      CMB,INB 
      STB PNTR      SAVE NEG. CHAR COUNT
*              ******************************************** 
*              * DWRIT - WRITE A STATEMENT ONTO THE DISC. * 
*              ******************************************** 
      LDA LUNIN     GET INPUT LUN 
      CPA .1+1      IS IT THE DISK? 
      JMP DWDUN     YES, SKIP DISK WRITE
      LDA DRFLG          GET FLAG 
      SZA           IS DISK FULL? 
      JMP DWDUN     YES, SKIP FURTHER WRITING 
      JSB %WRIS     GO TO WRITE ON DISC 
      DEF *+4 
      DEF BUFF      BUFFER
      DEF PNTR      NEG. CHAR COUNT 
      ISZ DRFLG     DISC FULL - TURN OFF DISC FLAG
DWDUN LDB SCN1
      SZB,RSS       END OF TAPE? (B=0?) 
      JMP TAPN      YES - GO SET PARAMETERS 
      ISZ SEQN  BUMP SEQ.NO.
      CLB,INB   1 TO B
      STB PNTR SET PNTR = 1 
      ADB SCN1      GET TOATL LENGTH
*             * SET CHARS FOLLOWING STATE.TO BLANKS * 
     BRS
     ADB FFUB 
     LDA BLNS 
     STA 1,I
RXL   CLA    (ENTER FOR REP PROCESSOR)
     STA BYFLG  CLR PUNCH BYTE FLAG 
      STA SCN1+3
     STA TEST 
      ISZ ASM1  CONTROL STATE.? 
      JMP *+6       NO..
      LDA ...1+4  YES, SET LIST CODE
      JSB LIST
      CLA,INA       SET A = 1 
      STA TAPE      SET TAPE COUNT = 1, IN CASE OF ?
      JMP RSTA,I   EXIT 
* 
*             *  CHECK LABEL AREA  *
      JSB PKUP  PICK UP NEXT CHAR; BUMP PNTR
      CPA L+2    *? 
     JMP HI24  -YES-
* 
*             * IS LABEL PRESENT? * 
     CPA BLNK 
     JMP HS50  -YES-
      JSB LBL  TEST FOR ILLEGAL CHAR
      LDA TEST  -OK- TEST FOR NUMERIC 1ST CHAR
      ADA .M48      -48 
      SSA     LESS THAN ZERO? 
      JMP HS20  YES 
      ADA .M15     (-15) NO 
      SSA    >77B ? 
      JMP HLB   NO- ERR0R 
HS20 JSB PKUP  GET NEXT LABEL CHAR
      CPA BLNK  END OF LABEL? 
      JMP HS49  -YES
      JSB LBL   -NO, TEST FOR LEGALITY
      JMP HS20  -OK 
* 
*             * TEST FOR ILLEGAL CHAR. IN LABEL * 
*             * THEY ARE ' ( ) * + , -           *
* 
LBL  NOP
      ADA .M46      -56B
      SSA,RSS  GRTR THAN OCT 55?
      JMP LBL,I  YES,LEGAL
      ADA ...1+6 (7)
      SSA      LESS THAN OCT 47 ? 
      JMP LBL,I  YES,LEGAL
* 
*             * ERROR EXIT *
* 
HLB   LDA .SY       'SY'= ILLEGAL LABEL CHARACTER 
      JSB ERPR
      JMP HS20
* 
*          * 'REP' PROCESSING * 
RZP   ISZ REQ  1ST REP PASS?
      JMP RXT   YES,READ STATEMENT
      CCA 
      STA REQ   SET REQ = -1
      CLA,INA 
      STA PNTR  SET PNTR=1
      JMP RXL 
* 
*             * LABEL POST-PROCESSOR *
* 
HS49 LDA PNTR 
      ADA ..M1+1 (-2) SET LABEL LENGTH
      STA SCN1+3
* 
*             * PROCESS OPCODE *
* 
HS50  JSB OPLK    SEARCH FOR OPCODE 
     JMP HSERR   ERROR EXIT 
      JSB PKUP  GET NEXT CHAR (_*+5)
     CPA BLNK  BLANK? 
     JMP *+4    YES?
      CPA L+4  COMMA? 
     JSB BPKUP  YES-GET NEXT NON-BLANK
      JMP *-5  GET NEXT CHAR. 
* 
*             * TEST FOR OPCODE LENGTH LEGAL *
     LDB PNTR 
     CMB,INB  (POINTS TO BLNK FOLLOWING OPCODE) 
      ADB SCN1+1
      CPB ..M1+3  (-4)
     JMP HS54  LENGTH OK (=3) 
     LDA CODE 
      ADA .M48      CODE-60B
     SSA,RSS   MICRO-OP ? 
     JMP HS54  YES
* 
*             * ERROR PROCESSOR FOR OPCODE *
      LDA .OP       'OP'= OPCODE HAS TOO MANY CHARS.
     JSB ERPR 
HSERR LDA ASM1
      LDB IFUSE 
      CPB .1        SKIP CODE BECAUSE OF IFZ/IFN? 
      JMP IFPRN     YES - GO PRINT THE STATEMENT. 
      SSA           IS THIS AN INITIAL READ REQUEST?
      JMP HI24  -IT'S FROM INIT, SKIP OUTPUT BELOW. 
      LDA PASS
     SZA,RSS
      JSB ?LABE     INSERT LABEL FOR OPCODE ERROR 
      JSB LOUT   TO BREC
      JSB LIST
      ISZ PLCN   BUMP LOCN.CNTR 
      JMP RXT  READ NEXT STATE. 
HI24  LDA ...1+2  (3) REMARK PROC.
      JSB LIST
      JMP RXT       READ NEXT STATEMENT 
* 
*             * PICK UP OPERAND LOCN, THEN EXIT * 
* 
HS54  LDB CODE
      CPB .31B      IS THIS IFZ/IFN/XIF?
      JMP IFZN      YES 
      LDA IFUSE     GET 'IF' USE FLAG 
      CPA .1        SKIP ASSEMBLING?
      CPB .12      IS IT AN 'END'?
      RSS           YES - DON'T SKIP IT 
      JMP HI24+1    GO ON AND PRINT THE STATEMENT 
      JSB BPKUP     GO SKIP BLANKS IF NECESSARY.
      ADB .M73     (-73) TEST FOR PNTR< 73
     CLA      SET A=0 
      STA LTFLG     CLEAR LITERAL FLAG
     SSB   SKIP IF FIELD OUT OF RANGE 
     LDA PNTR PNTR TO A 
      STA SCN1+2  OPERND POSN 
      SZA           OPERAND PRESENT?
* 
*           * TEST FOR LITERAL *
      JSB  PKUP     YES - GET 1ST CHAR. 
      LDB AFLAG     GET FLAG FOR 'ABS' TEST 
      CPA EQ        IS THE OPERAND A LITERAL? 
      SZB           YES, BUT EXIT IF ABSOLUTE ASS'Y.
      JMP RSTA,I    NO   EXIT FROM READER HERE. 
      JSB PKUP      GET THE LITERAL TYPE, NOW.
      LDB SCN1+2    GET OPERAND PNTR
      ADB .1+1      ADD 2 
      STB SCN1+2    RESET PNTR TO LETERAL VALUE 
      STA LTFLG     SET LIT.FLAG(=LITERAL TYPE) 
      JMP RSTA,I    EXIT FROM RSTA HERE 
      SPC 2 
*         * PROCESS 'IFZ', 'IFN', OR 'XIF' CODES..* 
      SPC 1 
IFZN  LDA INST      GET INSTR.FORMAT(HAS IF CHAR IN)
      CLB 
      SZA,RSS       IS INST = 0? (IS IT XIF) ?
      JMP IFZN3     YES 
      CPB IFUSE     IFUSE = 0?
      JMP IFZN2     YES - GO ON WITH PROCESSING 
IFZNR LDA IF        NO, ERROR, WE'RE IN IF OR REP 
      JSB ERPR      PRINT 'IF' ERROR
      JMP IFZN3+1   YES, GO ON WITH PROGRAM 
IFZN2 CLB,INB       SET B = 1 
      CPA IFTST     IS 'IF' CHARACTER MATCHED?
      CMB,INB       YES - SET B = -1
IFZN3 STB IFUSE     SET 'IFUSE' FLAG
      CLB 
      CPB REP       IN RANGE OF A REPEAT? 
      JMP *+3       NO - OK 
      STB REP       YES - CLEAR 'REP' FLAG
      JMP IFZNR     GO PRINT ERROR DIAG.
IFPRN CLA,INA       SET UP FOR NO INST, NO LOC'N PRNT 
      JMP HI24+1    GO TO LIST AND CONTINUE 
      SPC 1 
IF    ASC 1,IF      ERROR IN IFZ OR IFN 
EQ    OCT 75  EQUAL SIGN(=) 
.31B  OCT 31        =IFZ,IFN,XIF TYPE 
.M72  DEC -72 
.M46  DEC -46 
.M73  DEC -73 
ASM1  OCT -1 CONTROL STATE.FLAG 
.SY   ASC 1,SY
HEDR  DEF HEADP 
UMSK  OCT 177400    MASK FOR UPPER CHARACTER
LMASK OCT 377       MASK FOR LOWER CHARACTER
TAPE  OCT 1        COUNT SOURCE TAPES 
      SPC 1 
*             * SET SEQN TO ZERO, BUMP AND CONVERT SEQN. NO. *
      SPC 1 
TAPN  STB SEQN      SET SEQ. NO. TO ZERO
      ISZ TAPE ADD 1 TO TAPE #
      LDA TAPE
      CCE      CONVERT TO ASCII 
      JSB BNCN      CONVERT TO ASCII OCTAL
      LDA ASCI+2
      STA ASCI+4    STORE IT INTO THE HEADER
      JMP RXC 
* 
*              * TEST FOR LABEL PRESENT AND INSERT IN SYMBOL TABLE
*              *  SET CORRECT RELOC.CODE BEFORE INSERTION.
?LABE NOP 
      LDA SCN1+3  GET LABEL LENGTH
      SZA,RSS      LABEL PRESENT ?
      JMP ?LABE,I   NO, DONE, EXIT..
      STA SYMP      SET CHAR COUNT
      LDB FFUB
      STB SYMP+1  SET LABEL ADDR. 
      LDB LTFLG 
      STB FLAQ  SAVE LTFLG
      CLA 
      STA LTFLG  LTFLG_0
      LDA AFLAG 
      SZA           IS THIS AN ABSOLUTE ASSEMBLY? 
      JMP LABEX     YES 
      CLA,INA       SET A = 1 
      LDB PLCN
      JSB ?INSR   INSERT LABEL INTO SYMBOL TABLE
      NOP      ERROR EXIT 
      LDB FLAQ
      STB LTFLG RESTORE LTFLG 
      JMP ?LABE,I   EXIT
LABEX JSB ?INS?     GO TO INSERT RTN IN ASMB4 
      NOP           ERROR EXIT
      JMP ?LABE,I     EXIT
      SKP 
*             **************************************
*             * MOVE: MOVES A STRING OF CHARACTERS *
*             * LINKAGE: A = NO.OF CHARS TO MOVE   *
*             *          B = DESTINATION ADDRESS   *
*             *      L   JSB  MOVE,I               *
*             *     L+1   SOURCE ADDRESS           *
*             *     L+2   RETURN                   *
*             * ADDR.TRUE IF STARTS ON LEFT        *
*             *    2'S COMPL.IF STARTS ON RIGHT    *
*             **************************************
MOVE  NOP 
      SZA  IS CHAR.COUNT = 0? 
      JMP *+3  NO 
      JSB OPERR  YES
      JMP MOVX
      CMA,INA 
      STA GTEM+3  =-A 
*             * SET UP DESTINATION
     OCT 6120 
     OCT 7304 
     ELB
      STB GTEM+1
      LDB MOVE,I    GET SOURCE ADDRESS
*             * SET UP SOURCE 
     OCT 6120 
     OCT 7304 
     ELB
      STB GTEM+2
*             * NOW MOVE THE CHARACTERS * 
$     LDB GTEM+2
     OCT 4065 E_0BIT
      LDA 1,I   B,I TO A
     OCT 2041 E=0?
     OCT 1727 ROT. A
      AND LMASK     MASK OUT UPPER 8 BITS 
*             * LOWER 8 BITS OF A CONTAINS CHAR.TO BE MOVED.* 
     STA GTEM 
      LDB GTEM+1  DEST TO B 
     OCT 4065 E_0BIT
      LDA 1,I  B,I TO A 
     OCT 2041 E=0?
     OCT 1727 ROT. A
     AND UMSK 
     IOR GTEM 
*             * CHAR.NOW IN A, WITH  OTHER HALF OF DEST.WORD.*
*              * SINCE IT'S ON RIGHT WE MAY HAVE TO ROTATE   *
     OCT 2041 E=0?
     OCT 1727 ROT. A
      STA 1,I   A TO B,I
*             * NOW IT'S IN OK, BUMP COUNTERS AND PROCEED * 
      ISZ GTEM+2
      ISZ GTEM+1
      ISZ GTEM+3
      JMP $ 
MOVX  ISZ MOVE
      JMP MOVE,I    RETURN TO L+2 OF LINKAGE
*        *********************************************
*        * SYMK: LOOKUP SYMBOL TABLE ENTRY; W HACCOU *
*        *    LINKAGE: INPUT; SYMP=NO CHARS;SYMN=FWA *
*        *             OF NAME..OUTPUT;A=TYPE,B=VALUE*
*        *            L    JSB SYMK,I                *
*        *           L+1   UNDEF.SYMBOL EXIT         *
*        *           L+2   NORMAL RETN               *
*        *********************************************
SYMK  NOP 
     CLA           INITIALIZE NAME(4),
     STA NAME      0 TO 1ST, BLANKS TO
      LDA BLNS  OTHER WORDS 
     STA NAME+1 
     STA NAME+2 
      LDA SYMP  NO.OF CHARS 
      ADA ..M1+5 (-6) 
     SSA
      JMP *+5 
* 
*             * SYMBOL TOO LONG, PRINT DIAG.; SET LENGTH = 5 *
      LDA .SY       'SY' TOO MANY CHARS IN SYMBOL 
     JSB ERPR 
      LDA ...1+4  (5) 
      STA SYMP
      LDA SYMP  (FROM *-5)
      LDB SYMP+1 ADDR.OF 1ST CHAR.
      STB *+4 
     LDB NAMI 
     OCT 7004      CMB,INB
      JSB MOVE
      NOP  (SET AT *-4) 
      LDA SYMP   NO.OF CHARS. 
     ARS           STORE NUMBER OF
     INA           WORDS IN ENTRY-1 
      STA TEMP+2  INTO TEMP+2 
     INA
      STA TEMP+3  AND TEMP+3
     OCT 1727      ALF,ALF
     ALF
     ADA NAME      SET NUMBER OF WORDS
     STA NAME      TO COMPARE FIRST WORDS 
      LDA X     IN THE
     STA SYMI      SYMBTAB ADDR.COUNTER 
LP2   LDA NAMI
      STA SALU        RESET NAME ADDR. COUNTER
     LDA SYMI 
      STA TEMP+4  SAVE FWA OF SYMB.TBL.ENTRY
     LDA SYMI,I 
     OCT 2003      SZA,RSS
      JMP SYMK,I    UNDEFINED EXIT FROM HERE
      STA FLEX  SAVE 1ST WORD OF ENTRY
      AND SMASK     70377B
     CPA NAME      COMPARE 1ST WORDS
      JMP *+6 
     ALF
      AND .12+3 (17B)MASK NO.WRDS IN ENTRY
      ADA SYMI
LP3   STA SYMI BUMP ADDR.CNTR 
      JMP LP2 
      LDA TEMP+2  (FROM *-6)
     ADA SYMI     SET LIMIT=LWA-1 
      STA VAL0  OF SYMTAB ENTRY 
      ISZ SYMI  BU,P ADDR CNTR (FROM *+7) 
     LDA SYMI 
      CPA VAL0  END OF ENTRY? 
      JMP *+8   YES 
       ISZ SALU        NO 
     LDA SYMI,I    COMPARE NEXT 2 CHARS.
       CPA SALU,I 
      JMP *-7  =, COMPARE NEXT 2
LP4   LDA TEMP+3
      ADA TEMP+4    SET FWA OF NEXT ENTRY 
      JMP LP3  CHK NXT SYMTAB ENTRY 
      LDA FLEX  GET 1ST ENTRY WRD (FROM *-8)
     OCT 1727      ALF,ALF
      AND .12+3 (17B) 
      LDB LTFLG 
      SZB,RSS    LITERAL IN OPERAND?
      JMP *+6  NO 
      CPB ...1 ARITH MACRO WITH LITERAL?
      JMP *+4  YES
      CPA ...1+6 YES, RELC=7? 
      JMP *+4    YES, DONE. 
      JMP LP4    NO, GO BACK
      CPA ...1+6    LITERAL?
      JMP LP4    YES, GO BACK(OPERAND IS'NT LITERAL)
     LDB SYMI,I    B=VALUE
      ISZ SYMK
      JMP SYMK,I    EXIT ALPHA+2 HERE 
SMASK OCT 70377 
.400B OCT 400 
.M16  DEC -16 
.M48  DEC -48 
SALU  NOP            TEMPORARY FOR NAME ADDR. COUNTER 
   SKP
*        *************************
*        * PUNCH A BINARY RECORD *
*        *************************
PNCH  NOP 
      LDB BFLAG     GET 'B' FLAG
      ADB LGFLG     LOAD/GO 
      SZB,RSS       PUNCH FLAG ON?
      JMP PNCH,I    NO - EXIT 
* 
*              * COMPUTE CHECKSUM * 
     LDB FUBP 
     LDA PBUF 
     ALF,ALF
     STA CNTB 
     CMA,INA
     INA
      STA GTEM STORE CHKSUM CNTR
     CLA       CLEAR
      STA PBUF+2   CLEAR CHECKSUM SLOT
     ISZ 1     BUMP REC.ADDR. 
     ADA 1,I   ADD TO CHK SUM 
      ISZ GTEM  DONE? 
     JMP *-3   -NO
     STA PBUF+2 -YES- STORE SUM 
      LDA BFLAG     GET PUNCH FLAG
      SZA,RSS       PUNCH BIN. TAPE 
      JMP PNLGO     NO, SKIP BINARY OUTPUT
* 
*              * GO TO SYS PUNCH *
      JSB EXEC      GO PUNCH BIN RECORD 
      DEF *+5 
      DEF .1+1     'OUTPUT' REQ CODE
      DEF LUNPN 
FUBP  DEF PBUF
      DEF CNTB      WORD COUNT
      LDA LGFLG 
      SZA,RSS       LOAD AND GO?
      JMP PNCHX     NO
PNLGO JSB %WRIT     GO WRITE IN JOB BIN. AREA 
      DEF *+3 
      DEF PBUF      BUFFER
      DEF CNTB      WORD COUNT
PNCHX CLA 
      STA PBUF
*              * EXIT HERE
     JMP PNCH,I 
       SKP
*         ********************************************
*         * ASCN - CONVERT AN ASCII NUMBER TO BINARY *
*         * -ENTRY: A CONTAINS POSITION OF 1ST CHAR. *
*         *         B(LOWER) CONTAINS NO. OF CHARS.  *
*         *         B(UPPER): MODE(BELOW)            *
*         *          0 = OCTAL                       *
*         *          1 = FIXED DECIMAL               *
*         *          2 = FLOATING DECIMAL            *
*         *          3 = EXTENDED FLTG. DECIMAL      *
*         * -EXIT : L+1 = ERROR RETURN ON ILLEGAL    *
*         *               CHARACTER OR OVERFLOW.     *
*         *         L+2 = NORMAL RETURN              *
*         *          MODE=0 OR 1, VALUE IN A         *
*         *          MODE=2, VALUE IN A AND B        *
*         *          MODE=3, VALUE IN A, B AND VALU  *
*         *  NOTE: FOR MODES 2 AND 3 VALUES IN A AND *
*         *        B ARE ALSO IN VAL0 AND VAL1 RESP. *
*         ********************************************
ASCNP NOP 
ASCN  EQU ASCNP 
      STA SYMI      CHAR POS. IN SYMI 
      LDA LMSK
      AND 1 
      CMA,INA 
      STA DCNT      CHAR COUNT IN DCNT
      LDA 1 
      ALF,CLE,ALF   POSITION THE MODE 
      AND LMSK
      STA MODE      SET MODE IN MODE
      ERA,SLA       INTEGER CONVERSION? 
      JMP ASCN2     NO - GO TO FLOATING PT ROUTINE
      JSB INTEG     GO TO INTEGER CONVERSION
XNORM ISZ ASCNP     SET UP FOR NORMAL RETURN
      JMP ASCNP,I   EXIT
*         ***************************************** 
*         * FLOATING POINT PROCESSING STARTS HERE * 
*         ***************************************** 
ASCN2 CLA 
      STA VAL0      CLEAR NUMBER SLOTS
      STA VAL1
      STA VALU
      STA DEXP      CLEAR DEC. OVERFLOW SLOT
      CCA 
      STA DSIG      SET SIGN(-1) FIR +
      STA CNVT      SET FLAG FOR SIGN IN 1ST POSN.
      LDA BIT15 
      STA DFCNT     SET DFCNT = 100000B 
FDCN1 JSB CNVRT     CONVERT A CHARACTER 
      JMP FDCN3     NON DIGIT RETURN
      ISZ DFCNT     BUMP FRAC. COUNT
      LDA DEXP
      SZA           OVERFLOW? 
      JMP DCOV      YES 
      LDA VALU      NO, PROCESS DIGIT 
      STA VALUS 
      LDA VAL1
      LDB VAL0
      JSB SHFT1 
      JSB SHFT1     NUM TIMES 4 AT THIS POINT 
      SEZ,SSB,RSS   OVERFLOW? 
      RSS           NO
      JMP DCOV      YES 
      LDB VALU
      ADB VALUS 
      JSB CHK       OVERFLOW FROM VALU? 
      STB VALUS 
      LDB VAL0S 
      ADA VAL1
      JSB CHKB      IF VAL1 OV, BUMP B
      ADB VAL0      NUM TIMES 5 AT THIS POINT 
      JSB SHFT1     NUM TIMES 10 HERE 
      SEZ,SSB,RSS   OVERFLOW? 
      JMP *+3       NO
DCOV  ISZ DEXP      YES, BUMP OVERFLOW DIGIT COUNT
      JMP FDCN7 
      LDB VALUS 
      ADB CNVT      FINALLY ADD LATEST DIGIT TO NUM 
      JSB CHK       IF OV, BUMP VAL1
      STB VALUS 
      LDB VAL0S 
      JSB CHKB      IF VAL1 OV, BUMP VAL0 
      SEZ,SSB,RSS   OVERFLOW? 
      JMP FDCN6     NO
      JMP DCOV      YES 
FDCN3 CPA L+6       DEC PNT? (NON DIG.FROM CNVRT) 
      JMP FDCN5     YES 
      CPA .E        'E'?
      JMP *+3       YES 
ILEX  LDA .IL       NO, GO GET 'IL' 
      JMP OVEX+1    GO TO ERROR DIAG EXIT 
      ISZ DCNT      LAST CHARACTER? 
      JMP FDHOP     NO - GO TO PROCESS EXPONENT 
FDCN5 LDA DFCNT 
      SSA,RSS       IS THIS A SECOND DEC.PNT? 
      JMP ILEX      YES 
      CLA 
      STA DFCNT     CLEAR COUNTER FOR DIGITS AFTER .
      JMP FDCN7 
FDCN6 STB VAL0      SAVE NEW VALUE IN VAL0,VAL1,VALU
      STA VAL1
      LDA VALUS 
      STA VALU
FDCN7 ISZ DCNT      LAST CHARACTER? 
      JMP FDCN1     NO- GET NEXT CHAR.
*         ************************************* 
*         * PROCESS EXPONENT, IF PRESENT, AND * 
*         *  FINISH THE NUMBER(NORMALIZE, ETC)* 
*         ************************************* 
FDHOP LDB DFCNT 
      CMB,SSB,INB,RSS   WAS A DEC POINT PRESENT?
      CLB          NO, CLEAR B
      ADB DEXP
      STB DEXP     SET CURRENT COUNT FOR DEC EXPONENT 
      LDA DSIG
      STA SDSIG     SAVE SIGN OF MANTISSA 
      CLA           NO - CONTINUE PROCESSING
      LDB TEST
      CPB .E        IS EXPONENT THERE?
      JSB INTEG     YES - EVALUATE IT 
      ADA DEXP      A+OVERFLOW CHARS
      STA DEXP      SET VALUE OF DECIMAL EXPONENT 
      LDA VAL0      CHECK FOR A VALUE OF ZERO 
      IOR VAL1
      IOR VALU
      SZA,RSS       IS THE VALUE=0? 
      JMP UNDTF     YES, NORMAL EXIT FROM ASCN RTN. 
      LDA .47 
      STA FEXP      SET BINARY EXPONENT = 47
*         * NORMALIZE THE NUMBER(IN VAL0,VAL1,VALU)  *
FDHP2 LDB VAL0
      LDA VAL1
      SSB           IS BIT 15=0?
      JMP FDHP3     NO- GO SHIFT THEM ALL BACK 1
      LDB VALU
      CLE,ELB       SHIFT FROM VALU TO VAL1 
      ELA 
      STB VALU
      STA VAL1
      LDB VAL0
      ELB           SHIFT FROM VAL1 TO VAL0 
      STB VAL0
      CCA 
      ADA FEXP
      JMP FDHP2-1   FEXP-1 TO 'A' 
FDHP3 CLE,ERB       SHIFT THEM ALL 1 RIGHT
      ERA 
      STB VAL0
      LDB VALU
      ERB 
      STA VAL1
      STB VALU
      ISZ FEXP
      NOP 
* 
      LDA DEXP
      CLE,SZA,RSS 
      JMP FDHPX     DONE IF EXPONENT=0
      SSA           IS EXPONENT POSITIVE? 
      JMP FDHP6     NO - GO TO DIVIDE BY 10 
      ADA ..M1      YES - MULTIPLY NUMBER BY 10 HERE
      STA DEXP      DEXP=DEXP-1 
      LDA .1+2
      ADA FEXP
      STA FEXP      FEXP=FEXP+3 
      LDA VAL0
      STA VAL0S 
      LDA VALU
      STA VALUS 
      LDB VAL1
      JSB SHFR1     SHIFT VAL0,VAL1,VALU -
      JSB SHFR1         -RIGHT 2 PLACES 
      ADA VALUS 
      STA VALU      NEW VALU
      JSB CHKB      IF OV, BUMP B REG.
      LDA VAL0S 
      ADB VAL1
      JSB CHK       OVERFLOW? 
FDHP5 ADA VAL0
      STA VAL0      NEW VAL0
      STB VAL1      NEW VAL1
      JMP FDHP2     GO BACK TO RE-NORMALIZE 
*         * DIVIDE NUMBER IN VAL0,VAL1,VAL2 BY 10 * 
FDHP6 INA 
      STA DEXP      DEXP=DEXP+1 
      LDA ..M1+2
      ADA FEXP
      STA FEXP      FEXP=FEXP-3 
*              * GO TO DIVIDE BY 10 HERE *
      LDA UVAL
FDHP7 ADA ..M1+2    -3
      CPA VSTOP     LAST SECTION PROCESSED? 
      JMP FDHP9     YES, LEAVE DIVIDE PROC NOW
      STA CNVT      CONTAINS ADDR OF SECTION VEING DON
*                   * DIVIDE 'A' BY 10
*                   * RESULT IN A AND B(=LEAST SIG.)
      LDB .M16
      STB TEMP
      LDB TENTH 
      CLA 
      CLE,SLB       CHECK FOR ANOTHER ADD 
      ADA CNVT,I
      ERA 
      ERB 
      ISZ TEMP      ALL DONE? 
      JMP *-5       NO - CONTINUE 
      STA CNVT,I    SAVE 'A' VALUE
      ISZ CNVT      BUMP ADDRESS
      STB CNVT,I    SAVE 'B' VALUE
      LDA CNVT      GET ADDRESS READY TO RESET
      JMP FDHP7 
FDHP9 JSB COL45     PROCESS COL. 5
      JSB COL45     PROCESS COLUMN 4
      ADB VAL1
      JSB CHK 
      ADB VAL0S 
      JSB CHK 
      JSB COL32     PROCESS COLUMN 3
      ADB VALU
      JSB CHK 
      ADB VAL1S 
      JSB CHK 
      STB VALU      VALU COMPUTED 
      JSB COL32     PROCESS COLUMN 2
      JMP FDHP5     GO STORE VAL0 AND VAL1. CONTINUE
*         ******************************
*         * SET UP FLTG DECIMAL RESULT *
*         *  FOR EXIT FROM CONVERSION  *
*         ******************************
FDHPX LDA VAL1
      LDB VAL0
      JSB CHKM      IS MODE EXT.DEC?
      JMP *+3       NO
      LDA VALU
      LDB VAL1
      ADA .200B     ROUND THE LEAST SIGNIF. WORD
      JSB CHKB      BUMP B IF E=1 
      JSB CHKM      MODE=EXT.DEC? 
      JMP *+4       NO
      STB VAL1      YES 
      LDB VAL0
      JSB CHKB      BUMP VAL0 IF E=1
      SSB,RSS       VAL0<0? 
      JMP *+4       NO
      RBR,CLE       IT WAS A POWER OF 2 
      ISZ FEXP      BUMP EXPONENT 
      NOP 
      STB VAL0      SAVE MOST SIF.
      JSB CHKM      MODE = EXTEN.DEC? 
      JMP *+2 
      LDB VAL1      YES 
      AND UMSK
      STA DSIG      CLEAR LOW 8 BITS OF 'A' AND SAVE
      ISZ SDSIG     IS SIGN OF MANTISSA=+ 
      JMP FDHR4     NO, GO PROCESS NEG. MANTISSA
FDHRT LDA FEXP      GET FRACTIONAL EXPONENT IN A/B
      LDB FEXP
      AND .1776     CLEAR LOWER 7 BITS
      SZA           POSITIVE OVERFLOW?
      CPA .1776     MAYBE, NEG. OVERFLOW? 
      CPB .1776     MAYBE, IS EXPON,=-200B? 
      JMP FDHR3     YES, ALSO OTHER OVERFLOWS.. 
      LDA FEXP      GET THE EXPONENET AGAIN 
      RAL           POSITION IT 
      AND LMSK      CLEAR BITS 15-8 
      ADA DSIG      ADD IN THE LEAST SIG.PART 
      JSB CHKM      IS IT EXTEND.DEC? 
UNDTF STA VAL1      NO,SET VAL1=LEAST 
      STA VALU      YES, SET VALU=LEAST SIGN. 
      LDB VAL1      GET WORD 2
      LDA VAL0      GET MOST SIGNIF.
      JMP XNORM     GO OUT THE NORMAL EXIT
FDHR3 SSB,RSS       IS IT REALLY AN UNDERFLOW?
      JMP OVEX      NO
      CLA           YES, SET NO. = ZERO 
      STA VAL0      CLEAR VAL0
      JMP UNDTF 
FDHR4 CMA,INA       START GETTING COMPLEMENT
      CMB 
      JSB CHKB
      AND UMSK
      STA DSIG      SAVE LEAST SIGNIFICANT BITS 
      JSB CHKM      IS IT EXTEND.DEC? 
      JMP *+5       NO
      STB VAL1
      LDB VAL0
      CMB 
      JSB CHKB
      CLE,ELB 
      LDA ..M1
      SSB,RSS       WAS N0. A POWER OF 2? 
      JMP *+4       NO
      ADA FEXP      YES 
      STA FEXP      SUBTRACT 1 FROM EXPONENT. 
      RSS 
      ERB           RESET B 
      STB VAL0
      JMP FDHRT 
*         ************************* 
*         * CHECK MODE OF NUMBER  * 
*         *  L+2 EXIT IF EXTENDED * 
*         *  ELSE L+1             * 
*         ************************* 
CHKM  NOP 
      STB DEXP      SAVE THE 'B' REG. 
      LDB MODE
      CPB .1+2      IS MODE EXTEND.DEC? 
      ISZ CHKM      YES, BUMP RETURN ADDRESS
      LDB DEXP      RESTORE THE 'B' REG.
      JMP CHKM,I
*                   * PROCESS PARAMETERS FOR COLS. 4 AND 5 *
COL45     NOP 
      LDB 0         LOAD 'B' WITH 'A' (OVERFLOW BITS) 
      CLA,CLE 
      ADB VALU
      JSB CHK 
      ADB VALUS 
      JSB CHK 
      ADB VAL1S 
      JSB CHK 
      JMP COL45,I 
*                   * PROCESS PARAMETERS FOR COLS 2 AND 3 * 
COL32 NOP 
      LDB 0         SET B=A(OVERFLOW FROM PREV COL.)
       CLA,CLE
      ADB VAL1
      JSB CHK 
      ADB VAL0
      JSB CHK 
      ADB VAL0S 
      JSB CHK 
      JMP COL32,I 
*                   * CHECK FOR OVERFLOW FROM 'B' * 
CHK   NOP 
      SEZ           OVERFLOW? 
      CLE,INA       YES, BUMP 'A', CLEAR 'E'
      JMP CHK,I 
*         * CHECK FOR OVERFLOW- IF TRUE, BUMP 'B' * 
CHKB  NOP 
      SEZ 
      CLE,INB 
      JMP CHKB,I
*         * SHIFT NUMBER IN VAL0,VAL1,VALU RIGHT U *
SHFR1 NOP 
      LDA VAL0
      CLE,ERA       VAL0 RIGHT 1
      ERB           VAL1 RIGHT 1
      STA VAL0
      LDA VALU
      ERA,CLE       VALU RIGHT 1
      STA VALU
      JMP SHFR1,I   RETURN
*              ********************************** 
*              * CNVRT - CONVERT AN ASCII CHAR. * 
*              *  TO BINARY.                    * 
*              * - MODE = 0,OCTAL; ELSE DECIMAL * 
*              * - L+1 RETURN IF NON-NUMBERIC   * 
*              ********************************** 
CNVRT NOP 
      LDA SYMI      GET POS'N.OF CHARACTER
      JSB GETC      GET CHARACTER 
      ISZ SYMI      BUMP POS'N
      LDB MODE
      SZB           OCTAL CONVERSION? 
      LDB ..M1+1    NO - SET FOR DEC.CONV 
      ADB .M8       B=-8 HERE, IF OCTAL CONVERSION
      ADA .M48      -60B + A
      SSA           IS VALUE LESS THAN ZERO?
      JMP CNVR2     YES 
      ADB 0         NO - ADD IN MAX DIGIT VALUE.
      SSB           IS IT A VALID NUMBER? 
      JMP CNVRX     YES- GO TO EXIT WITH NO. IN A.
CNVR2 LDA TEST      NO - TEST FOR + OR -
      CPA L+3       PLUS? 
      JMP CNVR4     YES 
      CPA L+5       NO - IS IT MINUS ?
      CLA,RSS       YES 
      JMP CNVRT,I   NO - TAKE L+1 EXIT
      STA DSIG
CNVR4 CLA 
      ISZ CNVT      HAS SIGN BEEN ENCOUNTERED BEFOR?
      JMP ILEX      YES- 'IL' EXIT FROM ASCN
CNVRX STA CNVT
      ISZ CNVRT 
      JMP CNVRT,I 
*              ************************************** 
*              * INTEG - CONVERT A STRING OF ASCII  * 
*              *         CHARS TO AN OCTAL(MODE=0)  * 
*              *         OR DECIMAL INTEGER.        * 
*              *-IF OTHER THAN A LEADING SIGN OR    * 
*              *  NUMBER IS FOUND 'IL' EXIT IS TAKEN *
*              *-'OV' EXIT IF OVERFLOW.             * 
*              ************************************** 
INTEG NOP 
      CCB 
      STB DSIG      SET SIGN FLAG FOR PLUS
      STB CNVT      SET 1ST CHAR FLAG(FOR SIGN CHK) 
*        *ON ENTRY A=0(USED FOR THE INITIAL VALUE.) *** 
INTG2 STA VALUS     SAVE CURRENT VALUE
      JSB CNVRT     CONVERT A CHARACTER 
      JMP ILEX      ERROR - NON NUMERIC 
      LDA VALUS 
      CLE,ELA 
      JSB OVTST     TEST 4 TIMES A FOR OVERFLOW 
      LDB MODE      NO OVERFLOW 
      SZB           MODE = OCTAL
      ADA VALUS     NO - 5 TIMES A(IT'S DECIMAL)
      JSB OVTST     TEST 8(OR 10) TIMES A FOR OV
      ADA CNVT      NO - ADD IN NEW DIGIT 
      SEZ           OVERFLOW? 
      JMP OVEX      YES 
      ISZ DCNT      LAST CHAR IN STRING?
      JMP INTG2     NO - GET ANOTHER
      SZB,RSS       MODE = OCTAL? 
      JMP INTG6     YES - OK
      CPA BIT15     IS NO. + OR - 32768?
      JMP INTG6     YES - OK
      SSA           IS SIGN NEG?
      JMP OVEX      YES - OVERFLOW
INTG6 ISZ DSIG      IS SIGN NEGATIVE? 
      CMA,INA       YES - COMPLEMENT A. 
      JMP INTEG,I   EXIT
*              ***************************
*              * SHIFT FOR MULTIPLY BY 2 *
*              ***************************
SHFT1 NOP 
      STB VAL0S     SAVE VAL0S
      LDB VALUS     GET VALUS 
      CLE,ELB 
      ELA           SHIFT VAL1,VALUS
      STB VALUS     SAVE VALUS
      LDB VAL0S     GET VAL0S 
      ELB           SHIFT VAL0S,VAL1
      STB VAL0S     SAVE VAL0S
      JMP SHFT1,I   RETURN
*         ******************************************
*         * TEST ZERO BIT AND 'E' BIT FOR OVERFLOW *
*         ******************************************
OVTST NOP 
      ELA           2 TIMES ENTRY VALUE OF 'A'
      SEZ,SLA,RSS   OVERFLOW? 
      JMP OVTST,I   NO - RETURN 
OVEX  LDA .OV       GET 'OV' FOR ERROR DIAGNOSTIC.
      JSB ERPR
      JMP ASCNP,I  LEAVE VIA RERROR EXIT
UVAL  DEF VALU+3    ASCN 1ST PICKUP FOR DVD BY 10 
VSTOP DEF VAL0S-3   ASCN LAST PICKUP FOR DIV BY 10
.47   DEC 47
.1776 OCT 177600     177600 
TENTH OCT 146314    146314
.200B OCT 200       200B
LMSK  EQU LMASK 
LMDG DEF *+1  (ASCN)
      DEC -1000,-100,-10
LPDG  DEF *+1  (ASCN) 
      DEC 1000,100,10 
.10   EQU LPDG+3
*          ************************************** 
*          * BINARY TO ASCII CONVERSION ROUTINE * 
*          *  A = NUMBER TO BE CONVERTED        * 
*          *  E = 0  CONVERT TO OCTAL           * 
*          *  E = 1  CONVERT TO DECIMAL         * 
*          ************************************** 
      OCT 30060 
BNCN  NOP 
      LDB ICSA     GET LOC'N OF ACSI BUFFER 
      STB SYMI
      CCB 
      STB VALUS     START UPPER 
      LDB BNCN-1    SET BUFFER=ASCII ZERO'S 
      STB ASCI
      STB ASCI+1
      STB ASCI+2
      SEZ         TEST E BIT (=0,OCTAL  =1,DECIMAL) 
      JMP % DEC CONVERSION
      LDB ..M1+5  (-6)
      STB DCNT
     OCT 66           CLE,ELA 
     STA VALU 
     CLA
     ELA              SIGN BIT IS SIXTH DIGIT 
     JSB DPCK 
     LDA VALU 
     OCT 1723         ALF,RAR 
     STA VALU 
      AND ...1+6 (7) MASK 1 DIGIT 
     ISZ DCNT         END 
     JMP *-6
      JMP BNCN,I    EXIT
DPCK NOP
      ADA SYMI,I
      ISZ VALUS 
     JMP *+4
     OCT 1727           ALF,ALF 
      STA SYMI,I
     JMP DPCK,I 
      STA SYMI,I
      ISZ SYMI
     CCA
      STA VALUS 
     JMP DPCK,I        EXIT 
%     LDB ..M1+2 (-3) DEC. CONVERSION RTN 
      STB DCNT
     LDB LMDG 
      STB VAL0
     LDB LPDG 
      STB VAL1
      LDB 0    A TO B 
      ISZ SYMI
DPCR  CLA,RSS 
      INA  (FROM *+3) 
      ADB VAL0,I  COUNT NO.OF TIMES GT 10**N
      SSB,RSS 
      JMP *-3 
      ADB VAL1,I  <10**N, RESTORE VALUE 
     JSB DPCK            PACK DIGIT 
      ISZ VAL1
      ISZ VAL0
     ISZ DCNT 
     JMP DPCR              RETURN FOR 10**N-1 
      LDA 1 
     JSB DPCK 
      JMP BNCN,I    EXIT
   SKP
*          *****************
*          * ORR PROCESSOR *
*          *****************
ORRP  NOP 
      LDA *+5  (OR$ PARAMETER)
      JSB OR$    TO PRE-PROC
      STA ORRSV  0 TO ORRSV 
      LDA ORRS      GET THE SAVED MAIN PLCN 
      STA PLCN  SET PLCN TO MAIN LOC CNT. 
      JMP ORRP,I  EXIT(PICKED UP AT *-5)
* 
*           * ORG/ORR PRE-PROCESSOR * 
* 
OR$   NOP 
      STA *+4  SET EXEC.PARAMETER 
      LDB PLCN
      LDA ORRSV  GET ORRSV
      SZA,RSS  WERE WE IN MAIN PROG?
      NOP  YES, EXIT IF ORRP; SAVE LOC CNTR IF ORGP:
      LDA ORGSV   LAST ADDR GENERATED DURING ORGP 
      CMA,INA 
      ADA 1    A REG _ LAST PLCN VALUE
      SSA,RSS    GREATER ?
      STB ORGSV  NO! USE PLCN VALUE FOR HI ORG LOCN.
      CLA 
      JMP OR$,I 
*          *****************
*          * ORG PROCESSOR *
*          *****************
      STB ORRS    THIS IS A PARAMETER 
ORGP  NOP 
      LDA *-2  GET OR$ PARAM.(IN ORBP)
      JSB OR$ 
      CCA 
      STA ORRSV   SET ORRSV = -1
* 
*          * GO TO EVALUATE OPERAND * 
      JSB CHOPI 
      JMP ORGP,I ERROR EXIT 
      STB PLCN
      LDB AFLAG 
      SZB,RSS       SKIP OU IF ABSOLUTE ASSEMBLY
      CPA ...1  RELOC?
      JMP ORGP,I  YES,OK
      JSB OPERR 'M' ERROR 
      JMP ORGP,I  EXIT
      SKP 
*         ******************************* 
*         * LIST ROUTINE: PARAMETERS;   * 
*         *  IF A=0 OR 4, B=RELOC CODE  * 
*         *   A=0  FULL LINE            * 
*         *   A=1  NO INST OR LOCN      * 
*         *   A=2  NO INST              * 
*         *   A=3  COMMENT              * 
*         *   A=4  NO SEQ.NO., NO STATE.* 
*         *   A=5 PRINT 'ASMB' STATEMENT* 
*         ******************************* 
LISTD DEC 52,-53
LISTK DEF IOBF+6    INSTRUCTION LOC'N 
      DEF IOBF+3    LOCATION LOC'N
      DEF IOBF+2    LIST COMMENT LOC'N
LIST  NOP 
      STB SAVB  SAVE ASCII RELOC CODE 
      STA SAVB+1 SAVE LIST PARAM. 
      CPA ...1+4  CONTROL STATE.? 
      JMP HI82      YES 
      LDB LFLAG     GET LIST FLAG 
      SZB,RSS       PUNCH ONLY? 
      JMP LIST,I    YES, EXIT 
      LDB PASS
      SZB,RSS    PASS 1 
      JMP LIST,I    YES, EXIT 
      LDA LST 
      SZA      LIST FLAG=0 ?
      JMP LIST,I    NO, EXIT
      LDA LPDG+3  (10)
      LDB FBOI
      JSB SETM SET BUFFER TO
      ASC 1,   BLANKS 
      LDA SAVB+1
      CPA ...1  A=1?
      JMP HI82  YES 
      CPA ...1+1 A=2? 
      JMP HI80  YES 
* 
*          * CONVERT INSTRUCTION *
      LDB SAVB
      STB IOBF+9 SET RELOC INDIC
      LDA INST
      CLE     E=0 
      JSB BNCN      CONVERT TO ASCII OCTAL
      LDB LISTK     L(IOBF+6) 
      JSB V   MOVE NO.TO BUFFER 
* 
*          * CONVERT LOCATION CNTR *
HI80  LDA PLCN
      CLE     E=0 
      JSB BNCN      CONVERT TO ASCII OCTAL
      LDB LISTK+1   L(IOBF+3) 
      LDA ...1+4 (5)
      JSB MOVE
LISTL NOP           -ASCI GOES IN HERE
      LDA SAVB+1
      CPA ...1+3 A=4? 
      JMP HX8   YES 
* 
*          * CONVERT SEQ.NO. *
HI82  LDA SEQN
      CCE     E=1 
      JSB BNCN      CONVERT IT TO ASCII DECIMAL 
      LDA ASCI+1
      STA IOBF
      LDA ASCI+2
      STA IOBF+1
* 
*          * SET UP BUFFER LENGTH, ADJUST IF >72 CHARS *
      LDB SAVB+1
      CPB ...1+4  CONTROL STATE.? 
      STA ASCI+4    SET TAPE # =1 
      LDA SCN1 STATE.LENGTH 
      CPB ...1+2  REMARK? 
      JMP HI19   YES
HI17  STA 1    LENGTH TO B
      ADA LISTD+1   -53 
      SSA,RSS   LENGTH>52 ? 
      LDB LISTD     YES, SET B=52 
      ADB ...1+3  ADD 4 
      STB 0    NEW LENGTH TO A
HI18  ADA .12+4 LENGTH+16 
      LDB FBOI
      JSB PRNT   *PRINT THE LINE OF OUTPUT *
      JMP LIST,I    EXIT
* 
*         * SET UP FOR LIST COMMENT * 
HI19  LDB LISTK+2   L(IOBF+2) 
      JSB MOVE
      DEF BUFF
      LDA SCN1
      ADA .M16      LENGTH-16 
      JMP HI17
* 
*         * TEST FOR EXTENDED SUP * 
HX8   LDB SUP 
      SZB      SUP=0? 
      JMP LIST,I    NO, EXIT
      JMP HI18
FBOI DEF IOBF 
   SKP
*             ******************
*             * SKIP 'A' LINES *
*             ******************
LINS NOP
      STA DSIG  SET LINES TO SKIP INTO CNTR.
      JSB EXEC      SKIP LINES
      DEF *+4 
      DEF .1+2     'CONTROL' REQ CODE 
      DEF PRSPC 
      DEF DSIG      LINE COUNT
     JMP LINS,I YES.
*             ******************************* 
*             * FIND NUM.OF CHARS IN A TERM * 
*             ******************************* 
MSYM NOP
     STB SAVB 
     STB PNTR 
     CLA  START CNTR
      STA DSIG  ZERO TO CNTR
     STA TEST 
HI42 STA LAST   LAST
     LDA SAVB 
     JSB GETC 
      CPA L+2   * ? 
      JMP HI43  YES 
      CPA BLNK  END OF SYMBOL?
      JMP *+7   -YES- 
      ADA .M46      -46 = -56B
     OCT 2021  SSA,R
     JMP HI44 
      ADA ...1+6 (7)
      SSA       TERMINATOR? 
      JMP HI44  NO
*             *  SET UP FOR EXIT  * 
     LDA PNTR 
     JSB GETA 
      LDA DSIG  NO.OF SYMBOLS TO A
     JMP MSYM,I EXIT
HI43  LDA DSIG
      CPA ...1 IS '*' ALONE?
      JSB OPERR  NO, ERROR
HI44 ISZ DSIG  BUMP CNTR. 
     ISZ SAVB 
     LDA TEST 
     JMP HI42 
*        ******************************** 
*        * PRINT OUTPUT AND COUNT LINES * 
*        ******************************** 
PRNT NOP
      CMA,INA       SET CHAR COUNT NEG. FOR I/O 
      STA SAVB      SAVE THE CHARACTER COUNT
      STB PRLOC     GIVE THE BUFFER ORIGIN
     ISZ LINC END OF
      JMP I  PAGE? - NO 
      CCA           SET A=-1
      LDB PLINE 
      STB LINC      RESET THE LINE COUNTER
      CPB PCOMP     LIST ON TELETYPE? 
      CMA,INA       YES, LINE SPACE(CARR RETURN)
      JSB LINS      SKIP LINE OR GO TO TOP OF FORM
      LDA .1+5      A=6 
      LDB PLINE 
      CPB PCOMP     LIST ON TELETYPE? 
      JSB LINS      YES, SKIP 6 LINES 
      ISZ LINC+1  BUMP PAGE NO. 
      CCE     FOR DECIMAL NO. 
      LDA LINC+1  CONV. PAGE NO.
      JSB BNCN      CONVERT TO ASCII OCTAL
* 
*             * SET UP PAGE HEADER *
      LDA RC  'E' 
      STA ASCI
      LDA LPDG+3  OUTPUT 10 CHARS.
      LDB PASS
      SZB,RSS       LIST PASS?
      JMP *+3     NO
      ADA ...1+3  (4) SET UP FOR HEADER 
      ADA HED 
      CMA,INA 
      STA DSIG      SET CHAR COUNT
      JSB EXEC      GO TO PRINT THE HEADER
      DEF *+5 
      DEF .1+1
      DEF LUNPR 
      DEF HEADP     HEADER LOC'N
      DEF DSIG      COUNT 
      LDA .1+1      TO SKIP 2 LINES 
     JSB LINS    2. 
I     JSB EXEC      GO OUTPUT A LINE
      DEF *+5 
      DEF .1+1
      DEF LUNPR 
PRLOC NOP           BUFFER ORIGIN 
      DEF SAVB      CHARACTER COUNT 
     JMP PRNT,I  PRINT EXIT 
LINC  OCT -1,0      LINE CNTR/PAGE CNTR 
PCOMP NOP           =0 IF PRINTER,  =-56 IF TTY 
   SKP
*        *******************
*        * SET UP A HEADER *
*        ******************** 
HEDSB NOP 
      LDA SCN1+2
      SZA,RSS    HEADER PRESENT?
      JMP HXD      NO-RETURN
      ADA ..M1
      CMA,INA 
      ADA SCN1
      STA HED   HEADER LENGTH IN 'HED'
      LDB .56 
      ADA .M57     -57
      SSA,RSS      IS HEADER TOO LONG (MORE THAN 56 CHARS)
      STB HED      SET HEADER LENGTH TO 56
      LDA SCN1+2
      JSB GETA  GET ADDRESS OF HEADER 
      LDA HED 
      STB *+3 
      LDB HXD. GET L(HEDR+9)
      JSB MOVE
      NOP   ADDR OF HEADER
      LDA HED 
      ADA ...1+1
HXD   STA HED 
      JMP HEDSB,I 
.56   DEC 56
.M57  DEC -57 
HXD.  DEF HXBUF     LOCATION OF HEADER
HED   NOP    HEADER FLAG(LENGTH)
ICSA  DEF ASCI     LOC'N OF ASCI BUFFER 
*             **************************
*             * PRINT ERROR DIAGNOSTIC *
*             **************************
      DEF IOBF+5
ERPR NOP
      ISZ ERRCN  BUMP ERROR COUNTER 
     LDB BLNS 
      STA IOBF+5   ERROR DIAG.
      STB IOBF+6   BLANKS 
      STB IOBF+9    BLANK OUT RELOC INDIC.
      LDA SEQN
      CCE 
      JSB BNCN      CONVERT TO ASCII OCTAL
      LDA ASCI+1  FOR USE IN
      STA IOBF+7     THE
      LDA ASCI+2       DIAGNOSTIC 
      STA IOBF+8
      JSB PRPAG     GO PRINT PREVIOUS PAGE NO.
      LDA SCN1  GET STATEMENT LENGTH
      ADA LPDG+3  (+10) 
      LDB ERPR-1    GET STATE,ORIGIN (IOBF+5) 
     JSB PRNT  PRINT
      LDA LINC+1
      STA PRERR     SET PREV. PAGE = CURRENT PAGE 
     JMP ERPR,I EXIT
*            *PRINT PREVIOUS PAGE CONTAINING ERROR ** 
PRPAG NOP           USED IN 'ERPR' AND 'ENDSB'
      CLA,INA       SET UP TO EMIT A BLANK LINE 
      LDB HEDR
      JSB PRNT      GO TO PROINT ROUTINE
      LDA LINC      GET CURRENT LINE VALUE
      CPA ..M1      IS IT SET FOR A PAGE EJECT? 
      JMP *-5       YES, GO OUTPUT ANOTHER BLANK LIN
      LDB PASS
      LDA TAPE      GET SOURCE TAPE NO. 
      SZB           FIRST PASS? 
      LDA PRERR     GET PREVIOUS PAGE(=0 IF 1ST ERR)
      CCE 
      JSB BNCN      CONVERT PAGE TO DECIMAL 
      LDA .TNO      GET ' #'
      LDB PASS
      SZB           FIRST PASS? 
      LDA .PG       GET "PG" FOR PAGE POINTER 
      STA ASCI      SET IN '**' 
      LDA ASCI+1
      AND .2077     MAKE 1ST DIGIT BLANK
      STA ASCI+1
      LDA .1+5      GET PARAM FOR 6 CHARS 
      LDB ICSA      BUFFER ORG
      JSB PRNT      GO PRINT "**PAGE" 
      JMP PRPAG,I   EXIT
.PG   ASC 1,PG
.2077 OCT 20077 
*             **************************************
*             * PRINT ERROR COUNT AT END OF A PASS *
*             *  SPACE TO BOTTOM OF PAGE           *
*             *  INIT.LINE,ERROR AND SEQUENCE CNTRS*
*             *  SET CONTROL STATEMENT FLAG = -1   *
*             **************************************
ENDSB NOP 
      LDA ERRCN    ANY ERRORS?
      SZA,RSS 
      JMP ENDSR     NO ERRORS.. 
      LDB PASS
      SZB           FIRST PASS? 
      JSB PRPAG     NO, PUT OUT THE PAGE POINTER
      LDA ERRCN     GET THE TOTAL ERROR COUNT 
      CCE 
      JSB BNCN      CONVERT TO ASCII OCTAL
      LDA ASCI+1
      LDB ASCI+2
      JMP *+3 
ENDSR LDA BLNS
*                  * 'NO'ERROR SETUP *
      LDB .NO       FOR 'NO' ERRORS 
    STA PAU+1 
    STB PAU+2 
      LDA .12+2   (14) NO OF CHARS IN MESSG.
      LDB PAU-1        BUFF ADDR
      JSB PRNT    PRINT DIAG. 
      JSB OKOLE 
      STA ASM1  SET CONT.STATE.FLG
      CLA,INA       SET A=1 
      STA TAPE      SET TAPE COUNTER = 1
      JMP ENDSB,I   EXIT END SUBROUTINE 
      DEF PAU   LOC OF PASSOVER STATE.
PAU   ASC 7,**0000 ERRORS*
?PERL DEF REP 
REP   NOP    REPEAT COUNTER 
REQ   NOP    FLAG FOR 1ST STATE AFTER REP 
LST   NOP    LST/UNL FLAG 
LTFLG NOP   LITERAL FLAG(0=NO LIT.) 
ERRCN NOP    ERROR COUNTER
ORRSV NOP           =0 IN REG. PROG;=-1 IN ORG SECTN
ORRS  NOP           SAVE LAST PLCN VAL FOR ORR SET
ORGSV NOP           HIGHEST PLCN VAL IN AN ORG SECTN
PRERR NOP           PREV. PAGE # CONTAINING ERROR.
SUP   NOP    SUP/UNS FLAG 
IFUSE NOP      =1, SKIP ASSMBL.; =-1, IN 'IF' RANGE 
SEQN  NOP           SEQUENCE COUNTER
?LPER ABS *-REP     LENGHT OF AREA TO BE CLEARED
*           *********************************** 
*           * SPACE TO BOTTOM OF CURRENT PAGE * 
*           * (USED BY HED AND PROC.ABOVE)    * 
*           *********************************** 
OKOLE NOP 
      CLB           SET B=0 
      LDA LINC  LINE COUNT -
      INA,SZA     =-1 ? 
      LDB PLINE     NO, SET B=STAN.LINE COUNT 
      CPB PCOMP     TTY OUT?(IF COUNT=-1, WON'T COMP) 
      JSB LINS  NO-GO TO PAGER
      CCA 
      STA LINC  SET LINC = -1 
      JMP OKOLE,I   EXIT
* 
*             * PICK UP NEXT CHAR, ADD 1 TO PNTR *
PKUP NOP
     LDA PNTR 
     JSB GETC 
     ISZ PNTR 
     JMP PKUP,I 
* 
*             * SEARCH FOR NON-BLANK CHAR, SET PNTR AT IT * 
BPKUP NOP 
      JSB PKUP
      CPA BLNK  BLANK?
      JMP *-2  YES - GET NEXT CHAR. 
      LDB PNTR NO  - SET PNTR TO LAST NON-BLANK 
      ADB ..M1
      STB PNTR
      JMP BPKUP,I 
*             ***************************** 
*             * PUNCH AND SET UP FOR LIST * 
*             ***************************** 
LOUT  NOP 
      CLA      0 TO A 
      CLB,INB  1 TO B 
      CPB PASS      SKIP PUNCH IF IN PASS 1 
      JSB ?BREC 
      CLA      0 TO A 
      LDB BLNS  BLANKS TO B 
      JMP LOUT,I    EXIT
      SKP 
*             ****************************
*             * PROCESS ARITHMETIC MACRO *
*             ****************************
      DEF TEMP+4
HA38  JSB ARTLT    GO TO LITERAL PROCESSOR
      LDA L+6      (PERIOD) 
      STA TEMP+4
      LDB HA38-1    =L(TEMP+4) LOWER
      CMB,INB 
      STB SYMP+1 LOC.OF SYMBOL
      LDA ...1+3 (4) EXT RELOC CODE 
      STA SYMP  NO.OF CHARS.
      LDB PASS
      SZB 
      JMP ?ART      GO TO ARITH('ART') ROUTINE
     LDB CNTR   EXT.NUMBER
      JSB ?INSR     INSERT INTO SYMBOL TABLE
     RSS       ERROR- SKIP NEXT 
     ISZ CNTR  BUMP EXT CNTR
      LDA .1+1     2
      JMP ?HA3Z 
CNTR  OCT 1         EXT COUNTER,FOR PASS 1. 
*          ************************** 
*          * MEASURE LITERAL LENGTH * 
*          ************************** 
MSYML NOP 
      LDA SCN1+2   GET OPERAND POSITION 
      STA SAVB
      SPC 1 
*         *  SET UP AND TEST NEXR CHARACTER 
      ISZ SAVB     SAVB = OPDRND POS'N+1
      LDA SAVB     GET  CURRENT POSITION
      JSB GETC     GET THE CHATACTER
      CPA BLNK     IS IT A SPACE? 
      RSS          YES,  END OF LITERAL 
      JMP *-5      NO, GO EXAMEINE THE NEXT CHARACT.
      LDB SCN1+2   GET STARTING POSITION
      CMB,INB      COMPLEMENT IT. 
      ADB SAVB     RESULTS IN THE LITERAL LENGTH
      JMP MSYML,I   EXIT
*         ********************
*         * PROCESS LITERALS *
*         ********************
PLITS NOP 
      LDA LTFLG  LITERAL FLAG 
      CPA .F   =F ? 
      JMP PER 
      CPA .A   =A ? 
      JMP P.A 
      CPA .L        =L? 
      JMP P.L 
      JSB MSYML =B OR D  GET SYMB LNG.
      LDA LTFLG 
      CPA .B        =B? 
      JMP *+6 YES 
      CPA .D   =D?
      JMP *+3 YES 
PER   JSB OPERR  'M' ERROR
      JMP PLITS,I  EXIT 
      ADB .400B 
      LDA SCN1+2
      JSB ASCN    CONVERT TO BINARY 
      JMP PLITS,I ERROR RETURN
P.1   STA ASCI
      LDA ...1+1
      STA SYMP
      LDA PASS
      SZA    PASS 1 ? 
      JMP *+4  NO 
      JSB ?LITI     YES, INSERT LIT.INTO SYMBOL TABL
      JMP PLITS,I ERROR RETURN
      RSS 
      JSB ?LKLI     LOOKUP LITERAL IN SYMBOL TABLE
      ISZ PLITS 
      JMP PLITS,I  NORMAL RETURN
P.L   CLA         EXPRESSION PROCESSOR
      STA LTFLG 
      JSB CHOPI  EVALUATE OPERAND 
      JMP PLITS,I ERROR EXIT
      SZA     ABSOL.VALUE?
      JMP PER  NO-ERROR 
      LDA 1    VALUE TO A REG 
      JMP P.1 
P.A   LDA SCN1+2
      JSB GETA
      STB *+4  ADDR OF OPERAND
      LDA ...1+1 2 CHARS
      LDB ICSA     GET LOC'N OF ACSI BUFFER 
      JSB MOVE
      NOP    OPERAND ADDR.
      JMP P.1+1 
.A    OCT 101       ASCII 'A' 
.D    OCT 104    D
.F    OCT 106    F
.L    OCT 114 
   SKP
*          *************************
*          * ARITH MACRO PROCESSOR *
*          *************************
ARTLT NOP 
      LDA LTFLG    GET LITERAL FLATG
      SZA,RSS  LITERAL PRESENT? 
      JMP ARTLT,I   NO LITERAL, EXIT
      LDB TEMP+6
      STB ARTSV+1 
      LDB TEMP+5 1ST 2 OPCODE CHARS FOR TEST
      STB ARTSV 
      CPB .MP   MPY?
      JMP LTAR    YES 
      CPB .DI  DIV? 
      JMP LTAR   YES
      CPB .DS   DST?
      JMP *+3   YES, ERROR
      CPA .F   =F?  FLTG PT LIT PROC
      JMP LERR+3
      JSB OPERR NO,'M'ERROR 
LERR  CLB        B=0
      CLA,INA    A=1
      JMP LTAR+2
      JSB MSYML PROC.LIT.LNG. 
      ADB .1000     2 TO 'B' UPPER
      LDA SCN1+2  OPERND PNTR 
      JSB ASCN   CONVRT ASCII TO FLTG.PT. 
      JMP LERR  ERROR RETURN
      STA ASCI
      STB ASCI+1
      LDA ...1+3 (4)
      STA SYMP  SET SYMK/INSR PARAMS. 
      LDA PASS
      SZA,RSS  PASS 1 
      JMP *+3  YES
      JSB ?LKLI     NO, LOOKUP LIT. IN SYMBL TABLE
      JMP LTAR+2  EXIT
      JSB ?LITI     INSERT LITERAL INTO SYMBOL TABLE
      JMP LTARZ  ERROR EXIT(OK) 
      ISZ PLEN
      JMP LTARZ 
LTAR  JSB PLITS 
      JMP LERR  ERROR RETURN
      STA LTSVA  SAVE A 
      STB LTSVB  SAVE B 
LTARZ CLA,INA 
      STA LTFLG  SET LTFLG=1 FOR LIT.IN ARITH MACRO.
      LDA ARTSV   SET OPCODE CHARS BACK 
      STA TEMP+5    FOR FURTHER PROCESSING
      LDA ARTSV+1 
      STA TEMP+6
      JMP ARTLT,I   EXIT FROM LIT. PROC. HERE 
      SPC 1 
.MP   ASC 1,MP
.DI   ASC 1,DI
.DS   ASC 1,DS
ARTSV OCT 0,0 
LTSVA NOP      FOR ART USE
LTSVB NOP 
*        ******************** 
*        * SETUP FOR REPEAT * 
*        ******************** 
REPSB NOP 
      LDA REP 
      SZA      IN 'REP' RANGE?
      JMP RXP  YES, ERROR 
      JSB CHOPI  EVAL NO.OF REP'S 
      JMP RXP+2  ERROR EXIT 
      SZA    VAL RELOC? 
      JMP RXR  YES, ERROR 
      SZB,RSS  VAL=0? 
      JMP RXP+2 YES 
      INB 
      CMB,INB  NO   -B TO B 
      LDA ..M1+1
      STA REQ   SET REQ=-2(FOR SEQNO PROC)
RXX   STB REP       B TO REP (NO.OF REPEATS)
      JMP REPSB,I 
RXP   LDA .OP       'OP' ERROR(IN RANGE OF 'REP') 
      JSB ERPR
      CLB        O TO B (FOR NO REP)
      JMP RXX 
RXR   JSB OPERR  RELC.VAL(ERROR) 'M'
      JMP RXP+2 
* 
*              * SET UP FOR EVALUATION OF OPERAND IN WHICH A COMMA
*              *  IS ILLEGAL. 
* 
CHOPI NOP 
      CLA 
      JSB CHOP
      JMP CHOPI,I 
      ISZ CHOPI 
      JMP CHOPI,I 
*         ************************************* 
*         * GET BREC CODE AND LIST RELOC CHAR * 
*            BREC CODE IN A, LIST CHAR IN B.
*         ************************************* 
DCOD  NOP 
      LDB BLNS
      SZA,RSS    ABSOLUTE REL.? 
      JMP DCOD,I  YES,DONE
      STA SAVB    SAVE RELC CODE
      CPA ...1+4  IS IT EQU EXT ? 
      ADA ..M1    YES, SET = 4. 
      ADA RC-1    POINT TO CORR.RELC.CHAR.
      LDB 0,I     PICK IT UP
      LDA BYFLG 
      SZA,RSS 
      LDA SAVB    PICK UP RELC CODE IF NECESSARY. 
      JMP DCOD,I  RETURN
* 
*             * MOVE CHARS.TO A BUFFER FROM ASCI *
*             *  BUFFER ADDR.IN B REG.           *
* 
V     NOP 
      LDA ...1+5
      JSB MOVE
      DEF ASCI
      JMP V,I 
* 
*             * SET UP AND PRINT 'M' DIAG. FOR OPERAND ERROR *
* 
OPERR NOP 
      LDA .MBLN     'M'= OPERAND ERROR
      JSB ERPR
      JMP OPERR,I 
*        ****************************** 
*        * GET BUFFER ADDRESS OF ITEM * 
*        ****************************** 
GETA NOP
      ADA ..M1   A-1 TO A 
     CLE,ERA
     ADA FFUB 
     SEZ     UPPER ADDR?
      CMA,INA  NO - COMPLEMENT IT.
     STA 1   A TO B 
     JMP GETA,I 
*        ************************ 
*        * GET AN OPERAND CHAR. * 
*        ************************ 
GETC NOP
     JSB GETA 
      STB *+5 
      LDB TS  ADDR OF 'TEST' TO B REG 
     OCT 7004 
     OCT 2404 A=1 
      JSB MOVE
      NOP   (FROM *-5)
      LDA TEST
     JMP GETC,I 
TS DEF TEST 
* 
*        * MEASURE SYMBOL AND SET 
*        *         SYMP = SYMBOL CHAR COUNT 
*        *         SYMP+1 = SYMBOL POSITION 
MSYMS NOP 
      JSB MSYM
      STA SYMP
      STB SYMP+1
      JMP MSYMS,I 
*        *****************************
*        * SET MEMORY TO GIVEN VALUE *
*        *****************************
SETM NOP
      CMA,INA     SET VALUE FOR COUNTER 
      STA DSIG
      LDA SETM,I  GET PARAMETER TO BE STORED IN AREA
      STA 1,I     - PLACE PARAMETER IN MEMORY 
     ISZ 1
      ISZ DSIG
     JMP *-3
     ISZ SETM 
     JMP SETM,I 
      SKP 
*%WRIS WRITES SOURCE ONTO DISK. RECORD FORMAT:1ST WORD=-N,IT IS 
*FOLLOWED BY N CHARACTERS. RECORDS ARE PACKED WITHIN TRACKS,
*TRACKS ARE LINKED. INITIALIZATION IS ACCOMPLISHED BY CALLING 
*%WRIN. IT WILL ASK FOR A TRACK, INITIALIZE %WRIS,AND RETURN
*A WORD=LUN,FIRST TRACK NO. 
* 
*CALLING SEQUENCES: 
*                        JSB %WRIS
*                        DEF *+4
*                        DEF BUFFR      FWA OF OUTPUT BUFFER
*                        DEF RLEN       -(NO OF CHARS), 0 FOR EOT 
*                        ERROR RETURN (DISK FULL) 
*                        NORMAL RETURN WITH (A)= LUN,TRACK NO 
* 
*                        JSB %WRIN
*                        ERROR RETURN (NO MORE TRACKS)
*                        NORMAL RETURN WITH (A)= LUN,TRACK NO 
* 
*TO END A FILE, CALLING SEQUENCE IS: JSB %WEOF
* 
* 
*GETRK REQUESTS A TRACK FROM EXEC. IF NO TRACKS ARE AVAILABLE,
*THE ERROR RETURN WILL BE TAKEN 
*CALLING SEQUENCE:       JSB GETRK
*                        ERROR RETURN 
*                        NORMAL RETURN
GETRK NOP 
      JSB EXEC      GET TRACK 
      DEF *+6 
      DEF .1+3      GET TRACK 
      DEF TCONS     GET 1 TRACK, DO NOT SUSPEND.
      IFN 
      DEF WTRAC     TRK NO. 
      DEF WLUN      LUN 
      XIF 
      IFZ 
      DEF NTRAC 
      DEF NLUN
      XIF 
      DEF S/TRK     GIVES # TRACKS/SECTOR 
      IFN 
      LDA WTRAC 
      XIF 
      IFZ 
      LDA NTRAC 
      XIF 
      SSA           TRACK HERE ?
      JMP GETRK,I   NO, ERROR RETURN
      ISZ GETRK     BUMP FOR
      JMP GETRK,I   NORMAL RETURN 
WINIT NOP 
      IFN 
      LDA WTRAC 
      LDB WLUN
      XIF 
      IFZ 
      LDA NTRAC 
      STA WTRAC 
      LDB NLUN
      STB WLUN
      XIF 
      BLF,BLF 
      ADA 1         (A)= LUN,TRACK NO.
      STA LUNTR     LUN,TRACK TO RETURN ON EXIT 
      LDB WBFWA 
      STB WBFAD     BUFFER ADDR= BUFFER FWA 
      LDB .M64      -64 
      STB BCOUN     BUFFER COUNT
      CLB 
      STB WSECT     SECTOR NO =0
      JMP WINIT,I   NORMAL EXIT 
%WRIS NOP 
      LDA %WRIS,I 
      STA EXIT      EXIT POINT
      ISZ %WRIS 
      LDA %WRIS 
      LDA 0,I 
      RAL,CLE,SLA,ERA    TEST I-BIT AND CLEAR 
      JMP *-2       INDIRECT,CONTINUE THRU I-CHAIN
      STA SBUFR     SOURCE-BUFFER ADDR
      ISZ %WRIS 
      LDA %WRIS,I 
      LDA 0,I       -(NO OF CHARS)
      ISZ %WRIS 
      ARS 
      STA 1 
      CMB,INB 
      BLF,BLF 
      ADA ..M1      -1
      STA ACOUN     -(NO OF WORDS +1) 
      STB WBFAD,I   NO. OF WORDS IN UPPER 
      JMP WRIS1+3 
WRIS0 EQU * 
      IFN 
      JSB WOUT      OUTPUT SECTOR 
      XIF 
      LDA WSECT     SECTOR NO.
      INA 
      CPA S/TRK     END OF TRACK ?
      JMP WRIS3     YES 
      IFZ 
      JSB WOUT      NO,OUTPUT SECTOR
      XIF 
      ISZ WSECT     BUMP SECTOR NO. 
      LDA WBFWA 
      STA WBFAD     BUFFER ADDR = BUFFER FWA
      LDA .M64      -64 
      STA BCOUN     BUFFER COUNT = -64
      JMP WRIS2 
WRIS3 EQU * 
      IFZ 
      STB TEMP      SAVE CURRENT WORD 
      XIF 
      JSB GETRK     GET TRACK 
      JMP %WRIS,I   ERROR RETURN,NO TRACKS AVAILABLE
      IFN 
      JSB WINIT     INITIALIZE FOR NEW TRACK
      JMP WRIS2 
      XIF 
      IFZ 
      LDA NLUN      NEW LUN 
      ALF,ALF 
      ADA NTRAC     SET LUN/TRACK 
      STA BUFFR+63  LUN,TRACK NO. TO LAST WORD OF TRK 
      JSB WOUT      OUTPUT LAST SECTOR
      JSB WINIT     INITIALIZE FOR NEW TRACK
      LDA TEMP
      STA WBFAD,I   WORD TO DISK
      JMP WRIS1+3 
      XIF 
WRIS1 LDB SBUFR,I 
      STB WBFAD,I   WORD TO DISK
      ISZ SBUFR     BUMP SOURCE POINTER 
      ISZ WBFAD     BUMP OUTPUT-BUFFER POINTER
      ISZ BCOUN     END OF SECTOR ? 
      RSS           NO
      JMP WRIS0 
WRIS2 ISZ ACOUN     END OF TRANSFER ? 
      JMP WRIS1     NO, CONTINUE
      CCA 
      STA WBFAD,I   SET CURRENT EOF 
      LDA LUNTR     (A)= LUN,TRACK NO.
      JMP EXIT,I    RETURN
WOUT  NOP 
      JSB EXEC
      DEF *+7 
      DEF .1+1      +2 = CODE FOR WRITE 
      DEF WLUN      LUN OF CURRENT WRITE-TRACK
WBFWA DEF BUFFR     WRITE BUFFER
      DEF B100      =64 
      DEF WTRAC     TRACK NO
      DEF WSECT     SECTOR NO 
      JMP WOUT,I
WTRAC NOP           CURRENT TRACK 
WSECT NOP           CURRENT SECTOR
WLUN  NOP           LUN FOR CURRENT TRACK 
SBUFR NOP           SOURCE BUFFER ADDR
ACOUN NOP           SOURCE COUNT
LUNTR NOP           LUN, TRACK NO.FOR RETURN
S/TRK NOP           # OF SECTORS PER TARACK 
TCONS OCT 100001
?WEOF EQU WOUT
      SKP 
*%WRIT WRITES RELOCATABLE RECORDS ON DISK. TRACKS ARE ASSUMED 
*CONSECUTIVE, CURRENT SECTOR NO. IS ASSUMED AVAILABLE IN BASE 
*PAGE. RECORD-FORMAT IS AS IN BCS.
*CALLING SEQUENCE:
*                   JSB %WRIT 
*                   DEF *+3 
*                   DEF BUFFR      FWA OF WRITE-BUFFER
*                   DEF RLEN       NO OF WORDS
* 
      IFN 
WROVF CCA 
      LDB .A        PICK UP JBINS 
      JSB EXEC      SET JBINS=-1
      DEF *+2 
      DEF .M19      -19 
      JSB EXEC
      DEF *+5 
      DEF .1+1      +2 = CODE FOR WRITE 
      DEF .1        LUN=1 FOR SYSTEM TTY
      DEF OVMES     FWA OF MESSAGE
      DEF .M8       -8 FOR 8 CHARS
      JMP %WRIF,I   EXIT FROM %WRIF OR %WRIT..
OVMES ASC 4,JBIN OVF
.WRIN NOP 
      LDA 102B      JBINC 
      SZA,RSS       IS A JBIN TRACK AVAILABLE?
      JMP WROVF     NO, GO TO OVERFLOW ROUTINE
      CLB 
      LSL 8         SHIFT TRACK NO INTO B 
      ALF,ALF       (A)= SECTOR NO
      STB TRACK 
      XIF 
      IFZ 
.177  OCT 177 
.WRIN NOP 
      LDA 1766B     CURRENT LOAD AND GO FLAG
      LDB .1+1      2 
      SSA 
      INB 
      STB WLUN      LUN=2 IF SIGN=0, =3 OTHERWISE 
      ALF,ALF 
      RAL 
      AND LMASK     A=TRACK # 
      STA TRACK     SET TRACK NO. 
      LDA 1766B 
      AND .177      A=SECTOR #
      XIF 
      STA SECTR 
      LDA .M64
      STA BCOUN     SECTOR-BUFFER COUNT=-64 
      LDA BFWA
      STA BFRAD     SECTOR-BUFFER ADDR= FWA BUFFER
      JMP .WRIN,I 
*%WRIF OUTPUTS THE WRITE-BUFFER TO THE CURRENT SECTOR 
*ON DISK, UPDATES THE CURRENT SECTOR NO.
*%WRIF IS USUALLY CALLED AT THE END OF EACH SUBPROGRAM OUTPUT.
%WRIF NOP 
     IFN
      LDA 101B
      CPA ..M1      IS JBIN TRACK IN USE? 
      JMP %WRIF,I   NO, RETURN FROM %WRIF 
     XIF
      CLA 
      STA BFRAD,I   CLEAR NEXT WORD IN SECTOR 
      JSB EXEC      WRITE SECTOR
      DEF *+7 
      IFN 
      DEF ..M1+1    -2 = CODE FOR WRITE 
      DEF .1+1      =LUN 2
      XIF 
      IFZ 
      DEF .1+1      CODE FOR WRITE=2
      DEF WLUN      LUN 
      XIF 
BFWA  DEF BUFFR     FWA OF BUFFER 
      DEF B100      64 WORDS
      DEF TRACK     TRACK NO
      DEF SECTR     SECTOR NO 
      IFN 
      LDA 102B      LGOC WORD 
      INA 
      ISZ SECTR     BUMP SECTOR NO
      LDB SECTR 
      CPB 116B      NO OF SECTORS IN TRACK
      CLB,RSS 
      JMP WRIF2 
      RRL 8         TRACK NO TO B 
WRIF1 ADB ..M1      TRK-1 = NEXT JBIN TRK 
      STB TRACK     NEW TRACK NO
      JSB EXEC      STATUS REQUEST
      DEF *+5 
      DEF .12+4     CODE=+16
      DEF .1        1 TRACK 
      DEF TRACK     STARTING TRACK NO.
      DEF STRAK     ACTUAL AVAIL GOOD TRACK RETURNED
      LDA STRAK 
      SZA,RSS       OVERFLOW ?
      JMP WROVF     YES 
      LDB TRACK 
      CPB STRAK     IS IT A GOOD TRACK? 
      CLA,RSS       YES, GO TEST IT FURTHER 
      JMP WRIF1     NO, TRY NEXT LOWER TRACK
      CPB RTRAK,I   IS THE SOURCE FILE ON THIS TRAC?
      JMP WROVF     YES, GO TO JBIN OVERFLOW..
      RRR 8         GOOD TRACK TO UPPER A 
WRIF2 LDB .B        =LOC 102B (JBINC) 
      JSB EXEC      SET JBINC = TRACK/0 (AT 102B )
      DEF *+2 
      DEF .M19      -19 
      XIF 
      JSB .WRIN     RE-INITIALIZE FOR NEXT WRITE
      JMP %WRIF,I   EXIT
      OCT -1        -1= FIRST TIME; 
%WRIT NOP 
      LDA %WRIT,I 
      STA EXIT      SET RETURN ADDR 
      STA %WRIF     SET EXIT FROM 'WROVF' IF NEEDED.
      ISZ %WRIT-1   FIRST TIME IN THIS ROUTINE? 
      RSS           NO
      JSB .WRIN     INITIALIZE
      IFN 
      LDA 101B      JBINS 
      CPA ..M1      NO JBIN LEFT? 
      JMP EXIT,I    YES, EXIT 
      XIF 
      ISZ %WRIT 
      LDA %WRIT 
      LDA 0,I 
      RAL,CLE,SLA,ERA    TEST I-BIT AND CLEAR 
      JMP *-2 
      STA WBFAD     SOURCE-BUFFER FWA 
      ISZ %WRIT 
      LDA %WRIT,I 
      LDA 0,I 
      CMA,INA 
      STA RCOUN     SET COUNT 
WMOVE LDA WBFAD,I 
      STA BFRAD,I   MOVE WORD 
      ISZ BFRAD          POINTERS 
      ISZ BCOUN     BUMP SECTOR-BUFFER COUNT
      RSS 
      JSB %WRIF     END OF BUFFER, WRITE SECTOR 
      ISZ WBFAD     BUMP
      ISZ RCOUN     BUMP COUNTER
      JMP WMOVE     CONTINUE TRANSFER 
      JMP EXIT,I
EXIT  NOP           RETURN ADDR 
STRAK NOP           TEMP FOR NEXT GOOD TRACK NO 
.M19  DEC -19 
TRACK NOP           CURRENT TRACK NO
SECTR NOP           CURRENT SECTOR NO 
BCOUN NOP           COUNT FOR WRITE-BUFFER
BFRAD NOP           CURRENT ADDR IN WRITE-BUFFER
WBFAD NOP           CURRENT SOURCE-BUFFER ADDR
      SKP 
*READS SOURCE FROM DISK (IF LUN= 2) OR OTHER DEVICE 
*CALLING SEQUENCE FOR %READ:  JSB %READ 
*                             DEF *+5 
*                             DEF LUNIN  LUN FOR INPUT
*                             DEF BUFR   FWA OF READ BUFFER 
*                             DEF RLEN  -(NO OF CHARS)
*                             EOF RETURN
*                             NORMAL RETURN 
*RETURNS WITH: (B) = NO.OF CHARS. 
%READ NOP 
      LDA %READ,I 
      STA EXIT      RETURN ADDRESS
      ISZ %READ 
      LDA %READ,I 
      STA LUNAD     ADDR FOR LUN OF INPUT 
      ISZ %READ 
      LDA %READ 
      LDA 0,I 
      RAL,CLE,SLA,ERA    TEST I-BIT AND CLEAR 
      JMP  *-2      INDIRECT, GO ON THRU INDIR.CHAIN
      STA RBFAD     FWA OF READ-BUFFER
      ISZ %READ 
      LDA %READ,I 
      STA RLGTH     RECORD-LENGTH ADDR
      ISZ %READ     BUMP RETURN ADDR FOR EOF RETURN 
      LDA LUNAD,I 
      CPA .1+1      READ FROM DISK(LUN=2)?
      JMP READ1     YES 
      JSB EXEC      READ FROM OTHER THAN DISK 
      DEF *+5 
      IFN 
      DEF ..M1      -1 = CODE FOR READ
      XIF 
      IFZ 
      DEF .1        CODE = 1 FOR READ 
      XIF 
LUNAD NOP           ADDR OF INPUT-LUN OF CONTROL CARD 
RBFAD NOP           ADDR OF READ-BUFFER 
RLGTH NOP           ADDR OF ASKED-FOR RECD LENGTH 
      JMP EXIT,I    EXIT
READ1 JSB GETWD     GET RECORD HEAD 
      ALF,ALF       (A)= NO OF WORDS
      LDB 0 
      SZA,RSS       END OF TAPE ? 
      JMP EXIT,I    YES, EXIT WITH (B)=0
      SSA           EOF ? 
      JMP %READ,I   YES, EOF RETURN 
      CMA,INA       -( NO OF WORDS IN RECORD) 
      RBL 
      STB SBUFR     RECORD LENGTH IN CHARS. 
      LDB RLGTH,I   ASKED-FOR RECORD-LENGTH (-) 
      BRS           CONVERT TO -(WORD COUNT)
      STA RCOUN     SET CURRENT-RECORD COUNT
      STB ACOUN     SET ASKED-FOR RECORD COUNT
      JSB GETWD     GET WORD FROM DISK
      STA RBFAD,I   WORD TO USER-S BUFFER 
      ISZ RBFAD     BUMP BUFFER ADDR
      ISZ ACOUN     BUMP COUNT
      RSS 
      JMP READ2     READY,FINISH UP 
      ISZ RCOUN     BUMP RECORD COUNT 
      JMP *-7       CONTINUE
      LDB SBUFR     RETURN ACTUAL REC. LENGTH 
      IFN 
      JMP EXIT,I    RETURN
      XIF 
      IFZ 
      JMP *+6 
      XIF 
      JSB GETWD     GET NEXT WORD 
READ2 ISZ RCOUN     SKIP TO END OF RECORD 
      JMP *-2 
      LDB RLGTH,I   READY, RETURN ASKED-FOR REC.LGTH
      CMB,INB      COMPLEMENT ASKED FOR CHAR. COUNT 
      IFZ 
      LDA RCODE     CODE-WORD TO A
      XIF 
      JMP EXIT,I
GETWD NOP 
      LDA BFRA,I
      ISZ BFRA
      ISZ BCOU      BUMP BUFFER COUNTER 
      JMP GETWD,I   EXIT
      STA TEMP      SAVE A IN TEMP
      ISZ SECT
      IFN 
      LDB SECT
      CPB 116B      END OF TRACK ?
      CLB,RSS       YES, SECTOR NO.= 0
      JMP GETW1 
      STB SECT      SECTOR NO. = 0
      ISZ TRAK      BUMP TO NEXT TRACK NUMBER 
      JSB EXEC      STATUS CHECK
      DEF *+5 
      DEF .M16     CODE= -16 FOR USER AREA STATUS 
      DEF .1        1 TRACK 
      DEF TRAK      STARTING TRACK
      DEF TRAK      NEXT GOOD TRACK 
      XIF 
      IFZ 
      LDB .1755 
      ADB RLUN
      LDB 1,I 
      CPB SECT      END OF TRACK ?
      CLB,RSS       YES, SECTOR NO.= 0
      JMP GETW1 
      STA RCODE     SAVE CODE-WORD
      STB SECT      SECTOR NO =0
      LSL 8         LUN TO B
      ALF,ALF 
      STA TRAK      SET TRACK NO
      STB RLUN      SET LUN 
      JSB READS     READ SECTOR 
      JMP GETWD+1   GET RECORD WORD 
      XIF 
GETW1 JSB READS     READ NEXT SECTOR
      LDA TEMP      RESTORE LAST WORD FROM TEMP 
      JMP GETWD,I 
READS NOP 
      LDA BFW 
      STA BFRA      BUFFER-PNTR.=FWA OF BUFFER
      LDA .M64      -64 
      STA BCOU      BUFFER COUNTER
      JSB EXEC      READ SECTOR 
      DEF *+7 
      IFN 
      DEF ..M1      -1 = CODE FOR READ
      XIF 
      IFZ 
      DEF .1        1= CODE FOR READ
      XIF 
      DEF RLUN      LUN 
BFW   DEF BUFR      FWA OF READ BUFFER
      DEF B100      64 WORDS
      DEF TRAK      TRK. NO.
      DEF SECT      SECTOR NO.
      JMP READS,I   EXIT
      IFZ 
NLUN  NOP           SAVES NEW LUN 
NTRAC NOP           SAVES NEW TRACK 
RCODE NOP           SAVE CODE/WORD IN HERE
.1755 OCT 1755
      XIF 
RCOUN BSS 1         CURRENT-RECORD COUNT
TRAK  NOP           CURRENT TRACK 
SECT  NOP           CURRENT SECTOR
BCOU  NOP           SECTOR-BUFFER COUNTER 
RLUN  NOP           LUN OF CURRENT TRACK
BFRA  NOP POINTER FOR INTERNAL BUFFER 
B100 OCT  100 
.M64  DEC -64 
* 
*%RDSC READS A SECTOR 
*CALLING SEQUENCE:       LDA CODE 
*                        JSB %RDSC
*                        RETURN (A)= LAST WORD IN SECTOR
%RDSC NOP 
      LDB ?SECT     GET STARTING SECTOR # 
      STB SECT      SECTOR NO.
      CLB 
      LSL 8         SHIFT LUN TO B
      STB RLUN      LUN= 2 OR 3 
      ALF,ALF 
      STA TRAK
      JSB READS      READ SECTOR
      JMP %RDSC,I 
* 
?SECT NOP     SAVE STARTING SECTOR #(FROM %JFILE).
      SKP 
*             * ASSEMBLY OPTION FLAGS * 
FLAGS DEF *+1       POINTS AT BFLAG 
BFLAG NOP           PUNCH REQUEST 
LFLAG NOP           LIST
RFLAG NOP           RELOCATABLE ASMBLY(OPTIONAL FLG)
TFLAG NOP           SYMBOL TABLE PRINT REQ. 
IFTST NOP           CONTAINS 'IF' FLAG(N,Z, OR 0) 
AFLAG NOP           ABSOLUTE ASMBLY.
CFLAG NOP          CROSS REFERENCE TABLE FLAG 
LGFLG NOP           LOAD/GO FLG(=99 WHEN ON)
DRFLG NOP           FULL DISC IF NON ZERO 
TSTRT NOP           STARTING TRACK
PLINE DEC -56       STANDARD LINE COUNT 
LUNIN OCT 5         LUN, INPUT   (READ CW)
EOTIN OCT 705       CW TO SET EOT STATUS
LUNPN OCT 104       PUNCH CW(=LUN OF PUNCH) 
LUNPR OCT 6         PRINTER LUN 
PRSPC OCT 1106      FUNC CODE TO SPACE PRINTER
PNLED OCT 1004      CW TO OUTPUT LEADER/TRAILER 
?LWA  NOP           LAST WORD ADDR. OF AVAIL. MEMORY
X     DEF TEMP+1440B  RELOC LENGTH OF HPAP/RT/DOS 
Z     DEF TEMP+1315B  ABS LENGTH OF RT/DOS ASMB 
HEADP ASC 2, PAG
ASCI  BSS 3  DEST. OF CONVRTED DEC. NOS.
.TNO  ASC 3, #      PART OF HEADER
HXBUF EQU * 
ASCI1 EQU ASCI+1
GTEM  EQU HXBUF+28
BUFFR EQU GTEM+4
BUFR  EQU BUFFR+65  SECTOR BUFFER 
B     EQU 1 
      SPC 1 
*      **** THE FOLLOWING 64 WORDS OF CODE SHOULD NOT BE SHIFTED. 
.700B OCT 700 
D99  DEC  99
.13   OCT 15,77,12
B1100     OCT  1100 
.D.   ASC 1,D 
* 
%WRIN NOP 
      JSB GETRK     GET TRACK 
      JMP %WRIN,I   ERROR RETURN,NO TRACKS LEFT 
      ISZ %WRIN     BUMP FOR NORMAL RETURN
      JSB WINIT     INITIALIZE FOR NEW TRACK
      JMP %WRIN,I   EXIT
* 
*%JFIL GETS SOURCE-FILE CODEWDRD FROM BASE PAGE, FORMS A WORD=
*LUN,TRACK AND CALLS %RDIN WITH IT. 
%JFIL NOP 
      LDB JFILS     JFILS=1ST TRACK NO,SECTR NO 
      IFN 
      LDA .1+1      LUN = 2 
      RRL 8         TRACK NO TO A 
      BLF,BLF       SECTOR NO TO LOW B
      STB ?SECT     SAVE STARTING SECTOR #
      XIF 
      IFZ 
      CLA 
      RRL 1 
      ADA .1+1      LUN=2 OR 3
      RRL 8         TRACK # TO A
      STA RCODE     SET CODE-WORD(LUN/TRACK #)
      XIF 
      STA ?TSTR     SAVE FOR PASS 2 CODE WORD 
      JSB ?RDSC 
      JMP %JFIL,I 
* 
GOGO  CPA .1+1      SOURCE INPUT FROM DISC? 
      JMP ASMJF     YES 
      JSB %WRIN     NO - INITIALIZE *WRIS 
      CLA           ERROR - DISC FULL 
      STA ?TSTR     SET STARTING LUN/TRACK
      SZA,RSS       IS THE DISC FULL? 
      ISZ DRFLG     YES, SET THE DISC FLAG FOR FULL 
      RSS 
ASMJF JSB %JFIL     INITIALIZE DISC FILE
      LDA .D.       GET CHAR TO LOAD THE DATA 
      JMP SEGMT     GO LOAD THE DATA SEGMENT
ASMB  JSB BM        INPUT LUN?
      JMP *+4       NO
      STA LUNIN     YES- SET UP 
      ADA .700B 
      STA EOTIN     SET EOT STATUS CW 
      JSB BM        LIST LUN? 
      JMP *+4       NO
      STA LUNPR     YES - SET UP
      ADA B1100 
      STA PRSPC     SET SPACE CW
      JSB BM        PUNCH LUN?
      JMP *+5       NO
      ADA B100      YES 
      STA LUNPN 
      ADA .700B 
      STA PNLED     SET LEADER/TRAILER CW 
      JSB BM        LINE COUNT? 
      JMP *+3       NO
      CMA,INA 
      STA PLINE     SET LINE COUNT
      JSB BM        LOAD/GO?
      RSS           NO
ASMLG STA LGFLG     SET FLAG
      IFN 
      CLA           TO SET RTRAK(IN BASE PAGE)=0
      LDB RTRAK     GET ADDRESS OF RTRAK
      JSB EXEC
      DEF *+2 
      DEF .M19      -19=STORE IN BASE PAGE
      RSS           SKIP OVER RTRAK ADDRESS STORAGE 
RTRAK OCT 267       ADDRESS OF RTRAK IN BASE PAGE 
      LDA 100B      LWA AVAIL. MEM. IN DOS
      XIF 
      IFZ 
      LDA 1777B     LWA AVAIL. MEM. IN REAL TIME
      XIF 
      STA ?LWA      SAVE IT FOR USE IN SEGMENTS 
      JSB EXEC      GO CHECK FOR LIST EQUIPMENT TYPE
      DEF *+4 
      DEF .13       STATUS REQUEST
      DEF LUNPR 
      DEF TEMP
      LDA TEMP
      ALF,ALF 
      AND .13+1     MASK OUT EQT TYPE 
      LDB PLINE     B=-NO. OF LINES PER PAGE
      CPA .13+2     IS IT  A PRINTER? 
      CLB           YES, CLEAR B
      STB PCOMP     SET TTY TEST FLAG.
      CLA,INA 
      STA .1        SET 1 
      INA 
      STA .1+1      SET 2 
      INA 
      STA .1+2      SET 3 
      INA 
      STA .1+3      SET 4 
      INA 
      STA .1+4      SET 5 
      INA 
      STA .1+5      SET 6 
      INA 
      STA .1+6      SET 7 
      CCA 
      STA ..M1      SET -1
      LDA LUNIN         GET LUN TO SEE IF IT IS =2. 
      LDB JFILS     GET SOURCE ORG ON DISK. 
      CPA .2             IS SOURCE INPUT FROM DISC? 
      SZB           YES.. IS JFILE IN CORE? 
      JMP GOGO      GO TO COMPLETION FO INIT SECTION
      LDA *+3       PICK UP DIAG. MESSAGE 
      LDB *+3 
      JMP *+3       GO EXIT VIA ERROR DIAGNOSTIC
      ASC 2,NPRG    NO PROG IN JFILE WHEN INPUT=2 
      JSB MESSX     PRINT DIAGNOSTIC
      JMP ASMEX     GO TO COMPLETION
      SPC 1 
BM    NOP 
      LDA B,I       GET RUN PARAMETER 
      CPA D99       LOAD/GO?
      JMP ASMLG     YES - DONE
      INB           NO - BUMPPOINTER
      SZA           PARAMETER PRESENT?
      ISZ BM        YES - BUMP FOR L+2 EXIT 
      JMP BM,I
.2    OCT 2 
      IFN 
JFILS EQU 124B      LOC'N OF JFILE IN DOS 
      XIF 
      IFZ 
JFILS EQU 1767B 
      XIF 
      SPC 1 
      BSS BUFFR-*+129 
?AFLG EQU AFLAG 
?ARTL EQU ARTLT 
?ASCI EQU ASCI
?ASCN EQU ASCN
?ASII EQU ASCI1 
?ASM1 EQU ASM1
?ASMB EQU ASMBX 
?BFLG EQU BFLAG 
?BNCN EQU BNCN
?BPKU EQU BPKUP 
?CHOP EQU CHOP
?CHPI EQU CHOPI 
?CNTR EQU CNTR
?DCOD EQU DCOD
?DRFL EQU DRFLG 
?ENDS EQU ENDSB 
?ERPR EQU ERPR
?FLGS EQU FLAGS 
?GETC EQU GETC
?HA38 EQU HA38
?ICSA EQU ICSA
?LFLG EQU LFLAG 
?LGFL EQU LGFLG 
?LINC EQU LINC
?LINS EQU LINS
?LIST EQU LIST
?LOUT EQU LOUT
?LST  EQU LST 
?LSTL EQU LISTL 
?LTFL EQU LTFLG 
?LTSA EQU LTSVA 
?LTSB EQU LTSVB 
?LUNI EQU LUNIN 
?LUNP EQU LUNPN 
?MESX EQU MESSX 
?MOVE EQU MOVE
?MSYM EQU MSYM
?MSYS EQU MSYMS 
?OKOL EQU OKOLE 
?OPER EQU OPERR 
?OPLK EQU OPLK
?ORGS EQU ORGSV 
?ORRP EQU ORRP
?PCOM EQU PCOMP 
?PKUP EQU PKUP
?PLIN EQU PLINE 
?PLIT EQU PLITS 
?PNCH EQU PNCH
?PNLE EQU PNLED 
?PRNT EQU PRNT
?RDSC EQU %RDSC 
?RFLG EQU RFLAG 
?RLUN EQU RLUN
?RSTA EQU RSTA
?SEGM EQU SEGMT 
?SETM EQU SETM
?SUP  EQU SUP 
?SYMK EQU SYMK
?TFLG EQU TFLAG 
?TSTR EQU TSTRT 
?V    EQU V 
?WRIF EQU %WRIF 
?X    EQU X 
?Z    EQU Z         FWA AVAIL. FOR ABSOLUTE ASS'YS. 
      SKP 
*             ****************************
*             * TEMPORARY AND FLAG REGION*
*             ****************************
TEMP  EQU *         TEMP AT START OF OVERLAY AREA 
#     EQU TEMP     SAME AS DATA ORIGIN
      SPC 1 
VAL0  EQU TEMP+1    ASCN - MOST SIGNIFICANT 1/3 
VAL0S EQU TEMP+2    ASCN
VAL1  EQU TEMP+3    ASCN - MIDDLE 1/3 
VAL1S EQU TEMP+4    ASCN
VALU  EQU TEMP+5    ASCN - LEAST SIGNIFICANT 1/3
VALUS EQU TEMP+6    ASCN
DCNT  EQU VAL1S     ASCN
PASCN EQU TEMP+2 NUMBER PNTR SAVE(CHOP) 
...1  EQU TEMP+7
.1    EQU ...1
.12   EQU .1+7
..M1  EQU .12+6 
L     EQU ..M1+6
.M8   EQU #+43B 
.M15  EQU #+44B 
BLNK  EQU #+46B     =40B(LOWER BLANK) 
.IL   EQU #+47B 
.MBLN EQU #+50B 
.NO   EQU #+51B 
.OP   EQU #+52B 
.OV   EQU #+53B 
.UN   EQU #+54B 
.1000 EQU #+57B 
BIT15 EQU #+60B 
.E    EQU #+61B 
.B    EQU #+62B 
RC    EQU #+64B 
NAMI  EQU #+71B    LOC'N FOR TEMP SYMBOL STORAGE
NAME  EQU #+72B    FOR USE BY 'OPLK'
*         * FOLLOWING 5 LOC'S ARE CLEARED IN CHOP ROUTINES *
RELC  EQU #+76B     RELOCATION FLAG 
SIGN  EQU #+77B 
SUMP  EQU #+100B   RUNNING SUM FOR 'CHOP' 
TERM  EQU #+101B   NO. OF TERMS IN AN OPERAND 
T     EQU #+102B
BYFLG EQU #+104B   BYTE FLAG FOR 'BREC' 
FLEX  EQU #+105B   'ASCN' 
MODE  EQU FLEX
CNTB  EQU #+106B
CODE  EQU #+107B   OPCODE TYPE(FROM OPTABLE)
DSIG  EQU #+110B    'ASCN'
FLAG  EQU #+111B
FLAQ  EQU #+112B
INST  EQU #+113B   OPCODE FORMAT
LAST  EQU #+114B
PASS  EQU #+115B   PASS FLAG(0=PASS 1  AND 1=PASS2) 
PEEK  EQU #+116B   LAST CHAR PICKED UP
PLCN  EQU #+117B   PROGRAM LOCATION COUNTER 
PLEN  EQU #+120B LIT LENGTH PASS 1/LIT ORG PASS 2 
PNTR  EQU #+121B L POINTS AT LAST OER CURRENT CHAR. 
SAVB  EQU #+123B
SCN1  EQU #+125B   STATE LNG/OPCODE/OPERAND/LABEL(4)
SYMI  EQU #+132B   ADDR CNTR FOR SYMBOL TBL (SYMK)
FEXP  EQU SYMI
SYMP  EQU #+133B   SYMBOL LNG/ AND LOC'N
TEST  EQU #+135B   TEST CHARACTER 
ENT.  EQU #+137B
ENTC  EQU #+140B
ENTV  EQU #+141B
DEXP  EQU ENT.
CNVT  EQU ENTC      ASCN
SDSIG EQU ENTV      ASCN - SAVE SIGN OF MANTISSA
DFCNT EQU ENTV
*             * I/O STATEMENT BUFFER *
IOBF  EQU #+142B    50 WORDS + END OF STATEMENT BUFF
*             *(INPUXFFER(BUFF) STARTS IN 11TH WORD)* 
BUFF EQU IOBF+12B 
PBUF  EQU #+225B    60 WORD PUNCH BUFFER
      END ASMB
