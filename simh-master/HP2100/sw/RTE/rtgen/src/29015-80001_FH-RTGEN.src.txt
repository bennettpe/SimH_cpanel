ASMB,A,B,L,C     FH-RTGEN 
      HED FH-RTGEN  REAL TIME SYSTEM GENERATOR
**************************************************
***** AMD ***** MARCH,72 ***** REV.LWH *****
* 
* THIS GENERATOR WILL, WITH SW REG 14 ON, CREATE
*  CURRENT PAGE LINKS WHEN POSSIBLE TO SAVE BASE PAGE 
* 
**************************************************
      ORG 100B
A     EQU 0 
B     EQU 1 
      SUP 
***************** - HIGH CORE - ******************
*                                                *
*             SIO DRIVERS (TTY, PT, HSP)         *
*                                                *
**************************************************
*                    - IDENTS -                  *
*                    ----------                  *
*                                                *
*                                                *
*                     -------                    *
*                     - LST -                    *
**************************************************
*                                                *
*           LOAD, LINKAGE SUBROUTINES            *
*                                                *
*                   DISK DRIVERS                 *
*                                                *
****************** - 10000 - *********************
*                                                *
*                                                *
*           PROGRAM LOADING CONTROL              *
*                                                *
*                                                *
****************** - 6000 - **********************
*                                                *
*               I/O TABLE GENERATION             *
*                                                *
*                  PARAMETER INPUT               *
*                                                *
****************** - 4000 - **********************
*                                                *
*                                                *
*          RELOCATABLE PROGRAM INPUT             *
*                                                *
*                INITIALIZATION                  *
*                                                *
*                                                *
****************** - 2200 - **********************
*                                                *
*                                                *
*                    DATA AREAS                  *
*                                                *
*                                                *
**************************************************
      SKP 
* 
* 
*  IDENT FORMAT 
* 
*  WORD 1: ID1 - NAME 1,2 
*  WORD 2: ID2 - NAME 3,4 
*  WORD 3: ID3 - NAME 5, USAGE FLAG 
*  WORD 4: ID4 - COMMON LENGTH
*  WORD 5: ID5 - CURRENT DISK ADDRESS 
*  WORD 6 (15): ID6 - M/S 
*  WORD 6 (08-14): ID6 - PRIORITY 
*  WORD 6 (00-06): ID6 - TYPE 
*  WORD 7: ID7 - EXECUTION INTERVAL (1) 
*  WORD 8: ID8 - EXECUTION INTERVAL (2) 
*  WORD 9: ID9 - EXECUTION INTERVAL (3) 
*  WORD 10: ID10 - DISK LENGTH, BG MAIN ADDRESS (BS ONLY) 
* 
* 
*  LST FORMAT 
* 
*  WORD 1: LST1 - NAME 1,2
*  WORD 2: LST2 - NAME 3,4
*  WORD 3: LST3 - NAME 5, ORDINAL 
*  WORD 4: LST4 - IDENT ADDRESS 
*  WORD 5: LST5 - BP LINK ADDRESS 
* 
* 
*  PROGRAM TYPES
* 
*  0: SYSTEM
*  1: RT RESIDENT 
*  2: RT DISK RESIDENT
*  3: BG DISK RESIDENT
*  4: BG RESIDENT 
*  5: BG SEGMENT
*  6: LIBRARY 
*  7: UTILITY 
*  8-99: UNUSED 
      SKP 
* 
*  ERROR CODES
* 
*  1: INVALID TTY REPLY TO INITIALIZATION PARAMETERS
*  2: CHECKSUM ERROR
*  3: RECORD OUT OF SEQUENCE
*  4: INVALID RECORD TYPE 
*  5: DUPLICATE ENTRY POINTS
*  6: INVALID BP CODE IN PROGRAM
*  7: LST/IDENT OVERFLOW
*  8: DUPLICATE PROGRAM NAMES 
*  9: PARAMETER NAME ERROR
*  10: PARAMETER TYPE ERROR 
*  11: PARAMETER PRIORITY ERROR 
*  12: PARAMETER EXECUTION INTERVAL ERROR 
*  13: BG SEGMENT PRECEDES BG DISC RESIDENT 
*  14: SYS AV MEM OR BG BOUNDARY ERRORS 
*  15: ILLEGAL CALL BY A TYPE 6 PROGRAM (MAY CALL TYPE 0 AND 6 ONLY)
*  16: BP LINKAGE AREA OVERFLOW 
*  17: DISK OVERFLOW (NEXT DISK ADDR EXCEEDS LAST AVAIL DISK ADDR)
*  18: MEMORY OVERFLOW
*  19: DBL RECORD ORDER/ PROGRAM OVERLAY
*  20: DBL LIST OVERFLOW (MORE THAN 675 DBL RECORDS)
*  21: '$CIC' NOT FOUND IN LOADER SYMBOL TABLE
*  22: DISK READ PARITY/DECODE ERROR
*  23: INVALID FWA BP LINKAGE REPLY 
*  24: INVALID CHANNEL NO. IN EQT RECORD
*  25: INVALID DRIVER NAME IN EQT RECORD
*  26: INVALID D, B, U, OPERANDS IN EQT RECORD
*  27: INVALID DEVICE REFERENCE NO. 
*  28: INVALID INTERRUPT REC CHANNEL NO.
*  29: INVALID INTERRUPT REC CHANNEL NO. ORDER
*  30: INVALID INT RECORD MNEMONIC
*  31: INVALID EQT NO. IN INT RECORD
*  32: INVALID PROGRAM NAME IN INT RECORD 
*  33: INVALID ENTRY POINT IN INT RECORD
*  34: INVALID ABSOLUTE VALUE IN INT RECORD 
*  35: BP INTERRUPT LOCATION OVERFLOW 
*  36: INVALID TERMINATING OPERAND IN INT RECORD
*  37: INVALID COMMON LENGTH IN SYSTEM, LIBRARY, OR UTILITY 
*  38: ABSOLUTE SYSTEM HAS OVERLAYED A RELOCATABLE PROGRAM
*  39: ILLEGAL CALL BY A SYSTEM PROGRAM OF A TYPE SIX PROGRAM 
      SKP 
*     RESTARTS AND INITAL STARTS COME TO THIS ROUTINE WHICH 
*     CHECKS THE SWITCH REG. AND INSURES THAT IT IS CLEARED.
      SPC 2 
      ORG 10B 
BEGIN CLA           ATTEMT TO CLEAR THE SWITCH REG. 
      OTA 1         SEND ZERO 
      LIA 1         GET THE SWITCH REG
      SZA,RSS       IF ZERO THEN
      JMP TRANS,I   START THE GENERATER 
      JSB SPACE       PUT THE WORD ON A NEW LINE
      LDA P18       ELSE ASK FOR HELP 
      LDB MES01     CLEAR SR  PUSH RUN
      JSB DRKEY,I   TO THE TTY
      HLT 1 
      JMP BEGIN     TEST AGAIN
      SPC 1 
MES01 DEF *+1 
      ASC 9,CLEAR SR  PUSH RUN
MS2   ASC 9,CHANGE BP LINKAGE?
      SKP 
      ORG 100B
      JMP BEGIN     GO TEST THE SR
DRPTR BSS 1         PT READER DRIVER ADDRESS
DRKEY BSS 1         KEYBOARD OUPUT DRIVER ADDRESS 
DRHSP BSS 1         HS PUNCH DRIVER ADDRESS 
DRTTY BSS 1         TELETYPE INPUT DRIVER ADDRESS 
FWAM  DEF END 
LWAM  BSS 1         END AVAIL. MEM - SET BY DRIVERS 
DRMAG OCT 000000    (TEMP MAG TAPE DRIVER ADDR) 
.     EQU 1650B     DEFINE ORGIN OF SYS COMM AREA 
LWSBP ABS .         LAST WORD +1 OF LINKAGE AREA
EOBP  ABS -.        NEGATIVE OF ABOVE 
* 
TRANS DEF RTGEN     TRANSFER ADDR TO RTGEN
AINPT DEF INPUT     ADDRESS OF PROGRAM INPUT CODE 
IPARM DEF IPARS     ADDR OF PARAMETER INITIALIZATION
APARS DEF PARAM     ADDRESS OF PARAMETER INPUT CODE 
AGNIO DEF GENIO     ADDR OF I/O GENERATOR CODE
AGETA DEF GETAL     ADDR OF GETAL SUB.
AGETN DEF GETNA     ADDRESS OF GETNA SUB. 
AGETO DEF GETOC     ADDRESS OF GETOC SUB. 
AGINI DEF GINIT     ADDR OF GINIT SUB.
AFWAP DEF FWENT     ADDR OF FWA BP LINKAGE CODE 
INDAD DEF DISKA     ADDRESS OF DISK ADDRESS MODIFIER
ADIN  DEF DISKI     DISK INPUT DRIVER ADDRESS 
ADOUT DEF DISKO     DISK OUTPUT DRIVER ADDRESS
ALOAD DEF LOAD      ADDRESS OF MAIN LOAD BEGIN
ALODS DEF LOADS     ADDRESS OF SUB-LOAD BEGIN 
ABPOT DEF BPOUT     ADDR OF BP OUTPUT CODE
ACLRT DEF CLRLT     ADDR OF LOCAL LST CLEARING CODE 
ACLID DEF CLID3      CLEAR PROGRAM-LOADED FLAGS 
AIDSN DEF IDSCN     ADDR OF SCAN IDENT CODE 
ALABD DEF LABDO     ADDR OF ABSOLUTE OUTPUT SECTION 
AREMD DEF REMDO     ADDRESS OF REMAINING OUTPUT DRIVER
ACONV DEF CONVD     ADDRESS OF DECIMAL/ASCII CONVERTER
ARECO DEF RECOR     ADDRESS OF RECORD OR-ING CODE 
AREDO DEF REDOR     ADDRESS OF SPECIAL OR-ING CODE
AMOVE DEF MOVER     ADDRESS OF MOVE-DBUF CODE 
AGEND DEF GENID     ADDR OF ID SEGMENT GENERATOR
AOUTD DEF OUTID     ADDR OF ID SEG OUTPUT CONTROL 
AZOUT DEF ZOUT      ADDR OF ZERO OUTPUT TO ID SEG 
ADSET DEF DTSET     ADDR OF DISK TACK TABLE CODE
ANOTS DEF NOTST     ADDR OF PROGRAMS-LOADED TEST
BLODR DEF RLOAD     ADDRESS OF 0,0 LOADER 
ABASC DEF DMS       CORE ADDR FOR DOS LOADER      $$
ARTEX DEF RT/TS     CORE ADDR FOR RT OR TS LOADER $$
ABOOT DEF START     ADDRESS OF BOOTSTRAP LOADER 
ASBUF DEF ASPBF     ADDRESS OF 9-WORD BUFFER IN BOOT
A#SCT DEF #SECT     DEFINE # SECTORS - 1 FOR SYS  $$
A#MSK DEF #MASK     INCREMENT TRACK # VALUE       $$
AREAD DEF READ
DEMOT DEF DEMTL     ADDRESS OF ROUTINE TO DEMOTE TYPE 6 TO TYPE 7 
ALRT6 DEF CLRT6     ADDRESS OF TYPE 6 CLEAR ROUTINE 
ATSTL DEF TSTEL     ADDRESS OF THE TSTEL ROUTINE
ASCHF DEF SCHF      ADDR OF SCHEDULE SEARCH ROUTINE 
      SKP 
* 
*                                   PROGRAM CONSTANT FACTORS
ZERO  OCT 0 
N1    DEC -1
N2    DEC -2
N3    DEC -3
N4    DEC -4
N5    DEC -5
N6    DEC -6
N8    DEC -8
N9    DEC -9
N10   DEC -10 
N11   DEC -11 
N24   DEC -24 
N27   DEC -27 
N60   DEC -60 
N64   DEC -64 
N100  DEC -100
P2    DEC 2 
P3    DEC 3 
P4    DEC 4 
P5    DEC 5 
P6    DEC 6 
P7    DEC 7 
P8    DEC 8 
P9    DEC 9 
P11   DEC 11
P12   DEC 12
P14   DEC 14
P15   DEC 15
P16   DEC 16
P17   DEC 17
P18   DEC 18
P22   DEC 22
P23   DEC 23
P24   DEC 24
P25   DEC 25
P28   DEC 28
P33   DEC 33
P38   DEC 38
P64   DEC 64
P99   DEC 99
L6    EQU N6
L10   EQU N8
L12   EQU N10 
L60   OCT -60 
L2000 OCT -2000 
M7    EQU P7
M22   EQU P18 
M4    EQU P4
M37   OCT 37
M60   OCT 60
M77   OCT 77
M120  OCT 120 
M177  OCT 177 
M377  OCT 377 
M0760 OCT 076000
M1740 OCT 174000
M1600 OCT 160000
M1777 OCT 1777
M2000 OCT 2000
M2002 OCT 2002
M2004 OCT 2004
M2006 OCT 2006
M1377 OCT 100377
M7400 OCT 177400
M7000 OCT 177000
M7600 OCT 177600
M7700 OCT 177700
M7777 OCT 77777 
      SKP 
DPWRS DEF *+1 
P0100 DEC 10000 
P1000 DEC 1000
P100  DEC 100 
P10   DEC 10
P1    DEC 1 
OPWRS DEF *+1 
M0100 OCT 10000 
M1000 OCT 1000
M100  OCT 100 
M10   OCT 10
      OCT 1 
* 
BLANK OCT 040       BLANK 
UBLNK OCT 20000     UPPER CHAR BLANK
MSIGN OCT 100000    NEGATIVE SIGN 
DSKAB OCT 3         ABSOLUTE DISK ADDRESS: 0,3
      SKP 
* 
*                                   CLEAR BUFFER WITH OCTAL ZEROES
* 
*  THE BUFCL SUBROUTINE CLEARS A 64-WORD BUFFER WITH ZEROES.
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = ADDRESS OF BUFFER
*    JSB BUFCL
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED. 
* 
BUFCL NOP 
      LDA N64 
      STA WDCNT     SET BUFFER LENGTH = 64
      CLA 
      STA B,I       CLEAR BUFFER WORD 
      INB 
      ISZ WDCNT     ALL WORDS CLEAR?
      JMP *-3       NO - CONTINUE CLEARING
      JMP BUFCL,I   RETURN
      SKP 
* 
*                                   NEW LINE (CR,LF) ON TTY 
* 
*  THE SPACE SUBROUTINE IS USED TO SPACE UP THE TELEPRINTER.
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB SPACE
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED. 
* 
SPACE NOP 
      CLA           SET CHARACTER COUNT = ZERO
      JSB DRKEY,I   OUTPUT CR, LF ON TTY
      JMP SPACE,I   RETURN
      SKP 
* 
*                                   PRINT: ERR XX 
* 
*  THE ERROR SUBROUTINE IS USED TO PRINT THE DIAGNOSTICS
*  FOR ALL ERROR MESSAGES.
* 
*  CALLING SEQUENCE:
*    A = 2-DIGIT ASCII ERROR CODE 
*    B = IGNORED
*    JSB ERROR
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED. 
* 
ERROR NOP           PRINT ERROR MESSAGES
      STA AMERR+3   SET ERROR CODE INTO MESSAGE 
      LDA P6
      LDB AMERR     AMERR = MESSAGE ADDRESS 
      JSB DRKEY,I   PRINT ERROR MESSAGE 
      JMP ERROR,I   RETURN
* 
*                                   IRRECOVERABLE ERROR EXIT
* 
IRERR NOP 
      JSB ERROR     PRINT ERROR MESSAGE 
HLT0  HLT 0B        WAIT - PROGRAM CAN NOT CONTINUE 
      JMP *-1       IRRECOVERABLE ERROR 
* 
AMERR DEF *+1 
      ASC 3,ERR     ERROR MESSAGE = ERR + CODE
      SPC 4 
ERR07 ASC 1,07      IDENT/LST OVERFLOW
ERR15 ASC 1,15      ILLEGAL CALL BY A TYPE 6 PROGRAM
ERR16 ASC 1,16      BP LINKAGE AREA OVERFLOW
ERR17 ASC 1,17      DISC OVERFLOW 
ERR18 ASC 1,18      MEMORY OVERFLOW 
ERR19 ASC 1,19      INVALID DBL ORDER/PROG OVERLAY
ERR22 ASC 1,22      DISC READ PARITY/DECODE ERROR 
ERR38 ASC 1,38      SYSTEM OVERFLOW INTO SCRATCH
      SKP 
*  THE INIDX AND IDX SUBROUTINES ARE USED TO SET THE CURRENT
*  ADDRESSES FOR THE ENTRY IN THE PROGRAM IDENTIFICATION
*  BLOCK TABLE (IDENT).  THE ADDRESS OF THE NEXT ENTRY
*  IN THE IDENT TABLE IS CONTAINED IN TIDNT.  ON RETURN FROM
*  IDX, TIDNT CONTAINS THE ADDRESS OF THE NEXT AVAILABLE
*  ENTRY IN IDENT.  THE ADDRESS OF THE FIRST ENTRY IS CONTAINED 
*  IN BIDNT AND THE ADDRESS OF THE END OF IDENT IS CONTAINED
*  IN PIDNT.
* 
*  IF THE NEXT IDENT ENTRY OVERFLOWS INTO THE LAST LST ENTRY, 
*  IDX PRINTS A DIAGNOSTIC AND EXITS TO THE IRRECOVERABLE ERROR 
*  SUBROUTINE.
* 
*                                   SET INITIAL IDENT ADDRESS 
* 
*  INIDX SETS THE ADDRESS OF THE FIRST ENTRY IN THE IDENT 
*  TABLE AS THE CURRENT ADDRESS.
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB INIDX
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED. 
* 
INIDX NOP 
      LDA BIDNT     BIDNT = INITIAL IDENT ADDRESS 
      STA TIDNT     SET CURRENT IDENT ADDRESS 
      JMP INIDX,I   RETURN
      SKP 
* 
*                                   SET IDENT ADDRESSES FROM TIDNT
* 
*  IDX SETS THE ADDRESSES OF THE CURRENT 10-WORD ENTRY IN THE 
*  IDENT TABLE FROM THE ADDRESS OF THE CURRENT ENTRY (TIDNT). 
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB IDX
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED. 
*  (N+1): CURRENT IDENT ADDRESSES ARE THE ADDRESSES 
*         OF THE NEXT AVAILABLE IDENT ENTRY, OR THE 
*         END OF THE IDENT TABLE HAS BEEN REACHED.
*  (N+2): CURRENT IDENT ENTRY ADDRESSES (NOT END OF IDENT)
* 
IDX   NOP 
      LDA TIDNT     TIDNT = CURRENT IDENT ADDRESS 
      CPA PIDNT     END OF IDENT LIST?
      RSS           YES - RETURN TO NEXT INSTRUCTION
      ISZ IDX       SET RETURN ADDRESS FOR N+2
      STA ID1       SET ADDRESS OF NAME 1,2 
      INA 
      STA ID2       SET ADDRESS OF NAME 3,4 
      INA 
      STA ID3       SET ADDRESS OF NAME 5, USE FLAG 
      INA 
      STA ID4       SET ADDRESS OF COM/PROG LENGTH
      INA 
      STA ID5       SET ADDRESS OF CURRENT DISK ADDR
      INA 
      STA ID6       SET ADDRESS OF M/S,PRIOR/DISK,TY
      INA 
      STA ID7       SET ADDRESS OF EXEC INTERV(1) 
      INA 
      STA ID8       SET ADDRESS OF EXEC INTERV(2) 
      INA 
      STA ID9       SET ADDRESS OF EXEC INTERV(3) 
      INA 
      STA ID10      SET MAIN IDENT ADDR FOR BS
      LDA TIDNT     TIDNT = CURRENT IDENT ADDR
      LDB A 
      CMA,INA 
      ADA PLST      PLST = CURRENT END LST ADDR 
      SSA,RSS       SKIP IF NO OVERLAP
      JMP LSERR     PRINT OVERFLOW MESSAGE
      ADB N10       SET FOR NEXT IDENT ADDRESS
      STB TIDNT     SET NEXT IDENT ADDRESS
      JMP IDX,I     RETURN
      SKP 
*  THE INLST AND LSTX SUBROUTINES ARE USED TO SET THE CURRENT 
*  LOADER SYMBOL TABLE (LST) ADDRESSES.  THE ADDR OF THE NEXT ENTRY 
*  IN LST IS CONTAINED IN TLST.  ON RETURN FROM IDX, TLST CONTAINS
*  THE ADDRESS OF THE NEXT AVAILABLE ENTRY IN LST, OR THE ADDRESS 
*  OF THE END OF LST.  THE ADDRESS OF THE FIRST ENTRY IN LST
*  IS AT BLST AND THE ADDRESS OF THE NEXT AVAILABLE ENTRY 
*  IS AT PLST.
* 
*  IF THE NEXT ENTRY IN LST OVERFLOWS INTO THE CURRENT
*  IDENT ENTRY, LSTX PRINTS A DIAGNOSTIC AND EXITS
*  TO THE IRRECOVERABLE ERROR SUBROUTINE. 
* 
*                                   SET INITIAL LST ADDRESS 
* 
*  INLST SETS THE ADDRESS OF THE FIRST ENTRY IN LST.
* 
INLST NOP 
      LDA BLST      BLST = FIRST LST ADDRESS
      STA TLST      SET CURRENT LST ADDRESS 
      JMP INLST,I   RETURN
      SKP 
* 
*                                   SET LST ADDRESSES FROM TLST 
* 
*  LSTX SETS THE CURRENT LST ADDRESSES FROM TLST. 
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB LSTX 
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED. 
*    (N+1): THE END OF LST IS REACHED AND THE CURRENT 
*           LST ADDRESSES ARE THE ADDRESSES OF THE NEXT AVAILABLE 
*           ENTRY IN LST. 
*    (N+2): CURRENT LST ADDRESSES ARE SET (NOT END OF LST). 
* 
LSTX  NOP 
      LDA TLST      GET CURRENT LST ADDRESS 
      CPA PLST      END OF LST TABLE? 
      RSS 
      ISZ LSTX      INCR RETURN ADDRESS 
      STA LST1      SET WORD 1  ADDR
      INA 
      STA LST2      SET WORD 2 ADDR 
      INA 
      STA LST3      SET WORD 3 ADDR 
      INA 
      STA LST4      SET WORD 4 ADDR 
      INA 
      STA LST5      SET WORD 5 ADDR 
      INA 
      STA TLST      SET NEXT LST ADDRESS
      CMA,INA 
      ADA PIDNT     PIDNT = ADDR CURRENT IDENT
      SSA,RSS       SKIP - INVALID LST ENTRY
      JMP LSTX,I    RETURN
* 
* 
LSERR LDA ERR07 
      JSB IRERR     IRRECOVERABLE ERROR EXIT
      SKP 
*                                  RELOCATION BASE TABLE
RBTAD DEF *+1 
      OCT 0         ABSOLUTE PROGRAM BASE 
TPREL OCT 0         CURRENT PROG BASE ADDRESS 
      OCT 0         BP RELOCATION ADDRESS 
COMAD OCT 0         CURRENT COMMON RELOCATION BASE
* 
ALBUF DEF LBUF
ADBUF DEF DBUF
AEBUF DEF EBUF,I
AIBUF DEF IBUF
AKBUF DEF KBUF
ATBUF DEF TBUF
PLAD  DEF PLIST 
AMLST DEF MLIST 
AMEM5 DEF MLIST+5 
AILST DEF ILIST 
* 
WDCNT OCT 0         TEMPORARY WORD COUNTER
* 
BLST  DEF LST       ADDR OF FIRST LST ENTRY 
TLST  BSS 1         CURRENT LST ADDR
PLST  BSS 1         ADDR OF NEXT AVAILABLE ENTRY
* 
BIDNT BSS 1         ADDR OF FIRST IDENT 
TIDNT BSS 1         CURRENT IDENT 
PIDNT BSS 1         NEXT AVAILABLE IDENT
* 
MAXC  BSS 1         MAX CHAR COUNT
TCHAR BSS 1         TEMPORARY CHAR SAVE AREA
OCTNO BSS 1         OCTAL DIGIT 
* 
DSKSY BSS 1         INITIAL ID SEGMENT DISK ADDRESS 
DSIZE BSS 1         DISK SIZE - NO. OF TRACKS 
DSKSC BSS 1         ADDRESS OF DISK SCRATCH AREA
PTRAK BSS 1         NUMBER OF DISK PROTECTED TRACKS 
DAUXN BSS 1         AUXILIARY DISK SIZE 
SDS#  BSS 1         # SECTORS/TRACK FOR SYSTEM DISC$
ADS#  OCT 0         # SECTORS/TRACK FOR AUX. DISC $$
PIOC  BSS 1         ADDR. OF PRIVILEGED I/O CARD  $$
IDSP  BSS 1         POSITION OF 1ST ID SEG. IN SECT$
TBCHN BSS 1         TIME BASE GENERATOR CHNL
SWAPF BSS 1         SWAPPING FLAG = 0/1 = NO/YES
LWASM BSS 1         LAST WORD SYS AVAIL MEM 
PARAD BSS 1         PARAMETER INPUT DRIVER ADDRESS
TTYCH BSS 1         SYSTEM TTY CHANNEL NO.
* 
DERCN BSS 1         DISK ERROR COUNTER
DSKAD BSS 1         CURRENT DISK ADDRESS
PLFLG BSS 1         PROGRAM LOAD. FLAG = -1/0 = L/NL
DSCNT BSS 1         DISK SEGMENT SECTOR COUNT 
* 
ID1   BSS 1         IDENT 1 ADDR: NAME 1,2
ID2   BSS 1         IDENT 2 ADDR: NAME 3,4
ID3   BSS 1         IDENT 3 ADDR: NAME 5, USAGE FLAG
ID4   BSS 1         IDENT 4 ADDR: COMMON LENGTH 
ID5   BSS 1         IDENT 5 ADDR: CURRENT DISK ADDR 
ID6   BSS 1         IDENT 6 ADDR: M/S,PRIORITY,TYPE 
ID7   BSS 1         IDENT 7 ADDR: EXEC INTERV (1) 
ID8   BSS 1         IDENT 8 ADDR: EXEC INTERV (2) 
ID9   BSS 1         IDENT 9 ADDR: EXEC INTERV (3) 
ID10  BSS 1         IDENT 10 ADDR: LIB LGTH/BS MAIN 
* 
LST1  BSS 1         WORD 1 ADDR (LST) 
LST2  BSS 1         WORD 2 ADDR (LST) 
LST3  BSS 1         WORD 3 ADDR (LST) 
LST4  BSS 1         WORD 4 ADDR (LST) 
LST5  BSS 1         WORD 5 ADDR (LST) 
* 
NXFLG BSS 1         ENT/EXT FLAG = -1/0 
EXCNT BSS 1         SYMBOL COUNTER
* 
CURAL BSS 1         CURRENT LBUF ADDRESS
LCNT  BSS 1         CURRENT LBUF COUNT
LBUF  BSS 64        LOAD BUFFER 
* 
CURAD BSS 1         CURRENT DBUF ADDRESS
DCNT  BSS 1         CURRENT DBUF COUNT
DBUF  BSS 64        RELOCATABLE DISK INPUT BUFFER 
* 
EBUF  BSS 64        DISK READ ERROR SCANOUT AREA
* 
CURAI BSS 1         CURRENT IBUF COUNT
ICNT  BSS 1         CURRENT IBUF COUNT
* 
LRBP  BSS 1         LOWER RESIDENT BP BOUND 
URBP  BSS 1         UPPER RESIDENT BP BOUND 
LBBP  BSS 1         LOWER BACKGROUND BP BOUND 
UBBP  BSS 1         UPPER BACKGROUND BP BOUND 
URBP1 BSS 1         LWA R/T DISC RES BP LINK AREA $$
BPMAX BSS 1 
      SPC 1 
TEMP1 NOP 
TEMP2 NOP 
LWH1  NOP 
LWH2  NOP 
L01   NOP 
L001  NOP 
      SPC 1 
RPARB ASC 1,) 
      SKP 
* 
* 
IBUF  BSS 64        ID SEGMENT BUFFER 
* 
CURAK BSS 1         CURRENT KBUF ADDRESS
KCNT  BSS 1         CURRENT KBUF COUNT
KBUF  BSS 64        KEYWORD BUFFER
* 
CURAT BSS 1         CURRENT TBUF ADDRESS
TCNT  BSS 1         CURRENT TBUF COUNT
TBUF  BSS 4         TEMPORARY BUFFER
* 
CURAP BSS 1         CURRENT PLIST ADDRESS 
* 
AMAD  BSS 1         CURRENT MLIST ADDRESS 
MLIST BSS 8         MEMORY MAP BUFFER 
* 
LICNT BSS 1         LONG ID SEGMENT COUNT 
SICNT BSS 1         SHORT ID SEGMENT COUNT
COMRT BSS 1         MAXIMUM RT COM LENGTH 
COMBG BSS 1         MAX BG COM LENGTH 
* 
DSKEY BSS 1         CURRENT KEYWORD DISK ADDRESS
DSKID BSS 1         DISK ID SEGMENT ADDRESS 
KEYCN BSS 1         TOTAL KEYWORD COUNT 
KEYCT BSS 1         CURRENT KEYWORD COUNT          $
* 
PTYPE BSS 1         PROGRAM TYPE
FSYBP BSS 1         FIRST WORD SYS BP LINKAGE 
SYSAD BSS 1         CURRENT ID SEGMENT ADDRESS
* 
TBREL BSS 1         CURRENT BP RELOC ADDR 
PBREL BSS 1         INITIAL BP RELOC ADDR 
PPREL BSS 1         INITIAL PROG RELOC ADDR 
* 
RELAD BSS 1         CURRENT CORE RELOCATION ADDRESS 
PLMAN BSS 1         CURRENT BG MAIN PLIST ADDRESS 
* 
BSBAD BSS 1         BG SEGMENT BP RELOC ADDR
BSPAD BSS 1         BG SEGMENT PROG RELOC ADDR
* 
LFLAG BSS 1         PROGRAMS-LOADED FLAG
IMAIN BSS 1         CURRENT MAIN IDENT ADDR 
HDFLG BSS 1         HEADING FORMAT FLAG 
CIDNT BSS 1         CURRENT MAIN IDENT ADDRESS
DSKRD BSS 1         DISK INPUT ADDRESS
* 
AEQT  BSS 1         ADDRESS OF EQUIPMENT TABLE
CEQT  BSS 1         NO. ENTRIES IN EQUIPMENT TABLE
* 
ASQT  BSS 1         ADDR OF DEVICE REFERENCE TABLE
CSQT  BSS 1         NO. ENTRIES IN DEV. REF. TABLE
* 
AINT  BSS 1         ADDRESS OF INTERRUPT TABLE
CINT  BSS 1         NO. ENTRIES IN INTERRUPT TABLE
* 
DSKIN BSS 1         DISK ADDR OF INT CODE RECORD
INTCN BSS 1         RECORD COUNT OF INT CODE
* 
CURIL BSS 1         CURRENT ILIST ADDRESS 
ILIST BSS 64        USER SYSTEM PROG IDENT ADDR LIST
* 
DSKRX BSS 1         CURRENT TRACK ADDR. FOR "DBIN"
EDCNT BSS 1         CURRENT DISK ERROR COUNT
DCMND BSS 1         DISK COMMAND/ADDRESS
MADDR BSS 1         MEMORY COMMAND/ADDRESS
TEMPP BSS 1         CURRENT ABSOLUTE WORD 
ABCNT BSS 1         CURRENT ABSOLUTE DISPLACEMENT 
DSKMN BSS 1         INITIAL MAIN DISK ADDRESS 
BSSDP BSS 1         INITIAL DISK RES MAIN BSS DISP
PRENT BSS 1         PRIMARY ENTRY POINT 
DBLAD BSS 1         CURRENT DBL ADDRESS 
REKEY BSS 1         INSTRUCTION TYPE BYTE 
INSCN BSS 1         INSTRUCTION TYPE COUNTER
EXORD BSS 1         EXT ORDINAL 
INSTR BSS 1         CURRENT INSTRUCTION 
PAGNO BSS 1         CURRENT PAGE NO.
OPRND BSS 1         CURRENT OPERAND 
PLGTH BSS 1         PROGRAM LENGTH
LOWER BSS 1         LOWER BP LST BOUND
UPPER BSS 1         UPPER BP LST BOUND
RANAD BSS 1         CURRENT POWER RANGE ADDRESS 
LIBFG BSS 1 
LDTYP BSS 1 
DSKA  NOP           ADDRESS OF HIGHEST DISK WRITE 
DRT2  BSS 1         CONTENTS OF DISK REF DRT ENTRY
DRT3  BSS 1         CONTENTS OF AUX DISK REF DRT
SCH1  BSS 1         ADDRESS OF IDENT OF PGM TO BE SCHEDULED 
SCH2  BSS 1         ADDR OF IDENT OF ABOVE PGM -1 IN LOAD SEQUENCE
SCH3  BSS 1         LENGTH OF SCHED PGMS ID SEGMENT 
SCH4  BSS 1         ID ADDRESS OF THE SCHEDULED PGM 
* 
ERR09 ASC 1,09      PARAMETER NAME ERROR
ERR10 ASC 1,10      PARAMETER TYPE ERROR
ERR11 ASC 1,11      PARAMETER PRIORITY ERROR
ERR12 ASC 1,12      PARAMETER INTERVAL ERROR
ERR21 ASC 1,21      $CIC NOT FOUND IN LST 
ERR24 ASC 1,24      INVALID CHANNEL NO. IN EQT REC
ERR25 ASC 1,25      INVALID DRIVER NAME 
ERR26 ASC 1,26      INVALID D,B, OR T OPERAND 
ERR27 ASC 1,27      INVALID DEVICE REF. NO. 
ERR28 ASC 1,28      INVALID INT REC CHANNEL NO. 
ERR29 ASC 1,29      INVALID INT CHANNEL NO. ORDER 
ERR30 ASC 1,30      INVALID INT REC MNEMONIC
ERR31 ASC 1,31      INVALID EQT NO. IN INT RECORD 
ERR32 ASC 1,32      INVALID PROGRAM NAME IN INT REC 
ERR33 ASC 1,33      INVALID ENTRY POINT IN INT RECORD 
ERR34 ASC 1,34      INVALID ABS VALUE IN INT REC
ERR35 ASC 1,35      BP INTERRUPT LOCATION OVERFLOW
ERR36 ASC 1,36      INVALID FINAL OPERAND IN INT REC
ERR37 ASC 1,37      INVALID COMMON IN SYS. LIB, OR UT PGM 
ERR39 ASC 1,39      ILLEGAL SYSTEM USE OF TYPE 6 PROGRAM
MS20  ASC 9,BG DISC RESIDENTS 
MS23  ASC 11,*SYSTEM STORED ON DISC 
MS02  ASC 8,BP LINKAGE XXXXX
MES42 DEF *+1 
      ASC 12,# OF BLANK ID SEGMENTS?
* 
MES22 DEF *+1 
      ASC 3,(NONE)
* 
MES25 DEF *+1 
      ASC 12,* EQUIPMENT TABLE ENTRY
* 
MES26 DEF *+1 
      ASC 12,* DEVICE REFERENCE TABLE 
* 
MES36 DEF *+1 
      ASC 11,CHANGE FWA SYS AV MEM? 
* 
MES41 DEF *+1 
      ASC 11,PRIV. INT. CARD ADDR?
* 
MES50 DEF *+1 
      ASC 7,START SCRATCH?
* 
MES40 DEF *+1 
      ASC 8,# SECTORS/TRACK?
      ORG * 
      HED ** SYSTEM BASE PAGE COMMUNICATION AREA ** 
*** SYSTEM BASE PAGE  COMMUNICATION  AREA *** 
* 
* 
* SYSTEM TABLE DEFINITION * 
* 
EQTA  EQU .+0      FWA  OF  EQUIPMENT TABLE 
EQT#  EQU .+1       # OF EQT ENTRIES
LUMAX EQU .+3       # OF LOGICAL UNITS (IN DRT) 
DRT   EQU .+2      FWA  OF  DEVICE REFERENCE TABLE
INTBA EQU .+4      FWA  OF  INTERRUPT TABLE 
INTLG EQU .+5       # OF INTERRUPT TABLE ENTRIES
TAT   EQU .+6      FWA  OF  TRACK ASSIGNMENT TABLE
KEYWD EQU .+7      FWA  OF  KEYWORD BLOCK 
* 
* I/O MODULE/DRIVER COMMUNICATION 
* 
EQT1  EQU .+8      ADDRESSES
EQT2  EQU .+9 
EQT3  EQU .+10      OF
EQT4  EQU .+11
EQT5  EQU .+12      CURRENT 
EQT6  EQU .+13
EQT7  EQU .+14      15-WORD 
EQT8  EQU .+15
EQT9  EQU .+16      EQT 
EQT10 EQU .+17
EQT11 EQU .+18      ENTRY 
EQT12 EQU .+81
EQT13 EQU .+82
EQT14 EQU .+83
EQT15 EQU .+84
* 
CHAN  EQU .+19     CURRENT DMA CHANNEL #
TBG   EQU .+20     I/O ADDRESS OF TIME-BASE CARD
SYSTY EQU .+21     EQT ENTRY ADDRESS OF SYSTEM TTY
* 
* SYSTEM REQUEST PROCESSOR /'EXEC' COMMUNICATION *
* 
RQCNT EQU .+22     # OF REQUEST PARAMETERS -1 
RQRTN EQU .+23      RETURN POINT ADDRESS
RQP1  EQU .+24      ADDRESSES 
RQP2  EQU .+25
RQP3  EQU .+26       OF REQUEST 
RQP4  EQU .+27
RQP5  EQU .+28       PARAMETERS 
RQP6  EQU .+29
RQP7  EQU .+30       (SET FOR MAXIMUM OF
RQP8  EQU .+31        8 PARAMETERS) 
* 
* DEFINITION OF SYSTEM LISTS (QUEUES) * 
* 
DORMT EQU .+32     ADDRESS OF 'DORMANT' LIST, 
SKEDD EQU .+33      'SCHEDULE' LIST,
SUSP3 EQU .+36      'AVAILABLE MEMORY' LIST,
SUSP4 EQU .+37      'DISC ALLOCATION'  LIST,
SUSP5 EQU .+38      'OPERATOR SUSPEND' LIST 
* 
* DEFINITION OF EXECUTING PROGRAM  ID SEGMENT' *
* 
XEQT  EQU .+39     ID SEGMENT ADDR. OF CURRENT PROG.
XLINK EQU .+40       'LINKAGE'
XTEMP EQU .+41       'TEMPORARY (5-WORDS) 
XPRIO EQU .+46       'PRIORITY' WORD
XPENT EQU .+47       'PRIMARY ENTRY POINT'
XSUSP EQU .+48       'POINT OF SUSPENSION'
XA    EQU .+49       'A REGISTER' AT SUSPENSION 
XB    EQU .+50       'B REGISTER' 
XEO   EQU .+51       'E AND OVERFLOW
* 
* SYSTEM MODULE COMMUNICATION FLAGS * 
* 
OPATN EQU .+52     OPERATOR/KEYBOARD ATTENTION FLAG 
OPFLG EQU .+53     OPERATOR COMMUNICATION FLAG
SWAP  EQU .+54     RT DISC RESIDENT SWAPPING FLAG 
DUMMY EQU .+55     I/O ADDRESS OF DUMMY INT. CARD 
IDSDA EQU .+56     DISC ADDR. OF FIRST ID SEGMENT 
IDSDP EQU .+57      -POSITION WITHIN SECTOR 
* 
* DEFINITION OF MEMORY ALLOCATION BASES * 
* 
BPA1  EQU .+58     FWA R/T DISC RES. BP LINK AREA 
BPA2  EQU .+59     LWA R/T DISC RES. BP LINK AREA 
BPA3  EQU .+60     FWA BKG DISC RES. BP LINK AREA 
LBORG EQU .+61     FWA OF RESIDENT LIBRARY AREA 
RTORG EQU .+62     FWA OF REAL-TIME AREA
RTCOM EQU .+63     LENGTH OF REAL TIME COMMON AREA
RTDRA EQU .+64     FWA OF R/T DISC RESIDENT AREA
AVMEM EQU .+65     FWA OF SYSTEM AVAILABLE MEMORY 
BKORG EQU .+66     FWA OF BACKGROUND AREA 
BKCOM EQU .+67     LENGTH OF BACKGROUND COMMON AREA 
BKDRA EQU .+68     FWA OF BKG DISC RESIDENT AREA
* 
* UTILITY PARAMETERS
* 
TATLG EQU .+69     LENGTH OF TRACK ASSIGNMENT TABLE 
TATSD EQU .+70      # OF TRACKS ON SYSTEM DISC
SECT2 EQU .+71      # SECTORS/TRACK ON LU 2 (SYSTEM)
SECT3 EQU .+72      # SECTORS/TRACK ON LU 3 (AUX.)
DSCLB EQU .+73     DISC ADDR OF RES LIB ENTRY PTS 
DSCLN EQU .+74      # OF RES LIB ENTRY POINTS 
DSCUT EQU .+75     DISC ADDR OF RELOC UTILITY PROGS 
DSCUN EQU .+76      # OF RELOC UTILITY PROGS
LGOTK EQU .+77     LOAD-N-GO: LU,STG TRACK,# OF TRKS
LGOC  EQU .+78      CURRENT LGO TRACK/SECTOR ADDRESS
SFCUN EQU .+79     SOURCE FILE LU AND DISC ADDRESS
MPTFL EQU .+80      MEMORY PROTECT ON/OFF FLAG (0/1)
FENCE EQU .+85      MEM PROTECT FENCE ADDRESS 
BKLWA EQU .+87     LWA OF MEMORY IN BACKGROUND
      HED ** RT EXECUTIVE SYSTEM GENERATOR ** 
      ORG 2000B 
* 
*  INITIAL TRANSFER IS MADE TO RTGEN BY SETTING 100(8)
*  IN THE SWITCH REGISTER AND PRESSING RUN. IF ANY ERRORS ARE 
*  DETECTED DURING THE INITIALIZATION PHASE, THE INITIALIZATION 
*  SECTION CAN BE REPEATED. 
* 
*  THE FOLLOWING MESSAGES ARE PRINTED DURING THE INITIALIZATION 
*  PHASE, WITH THE SPECIFICATIONS FOR EACH VALID RESONSE. 
* 
* 
*  MESSAGE         RESPONSE 
* 
*  FH DISC CHNL?      ENTER 2 OCTAL DIGITS
* 
*  SYS DISC SIZE?  ENTER 3 DECIMAL DIGITS 
* 
*  START SCRATCH?  ENTER 3 DECIMAL DIGITS 
* 
*  NO. PROTECTED?  ENTER 2 DECIMAL DIGITS 
* 
*  # SECTORS/TRACK?  ENTER 3 DECIMAL DIGITS       $$
* 
*  AUX DISC SIZE?  ENTER 3 DECIMAL DIGITS (OR ZERO) 
* 
*  # SECTORS/TRACK?  ENTER 3 DECIMAL DIGITS       $$
* 
*  TBG CHNL?       ENTER 2 OCTAL DIGITS 
* 
*  PRIV. INT. CARD ADDR?  ENTER 2 OCTAL DIGITS    $$
* 
*  SWAPPING?       ENTER YES OR NO
* 
*  LWA MEM?        ENTER 5 OCTAL DIGITS 
* 
*  PRGM INPT? 
*  LIBR INPT?      ENTER PT, MT, DF, OR TY        $$
*  PRAM INPT? 
* 
*  FOLLOWING SUCCESSFUL COMPLETION OF THIS SECTION, 
*  THE TRANSFER ADDRESS IS MOVED TO THE INITIALIZATION SECTION
*  OF THE LOADING PHASE.
* 
RTGEN CLC 0,C       TURN OFF ALL I/O,INTERRUPTS 
      JSB SPACE      NEW LINE 
      JSB SPACE      NEW LINE 
* 
*                                   SET DISK CHANNEL
CHNLD LDA P14 
      LDB MESS2     MESS2 = ADDR: FH DISK CHNL? 
      JSB REPLY     PRINT MESSAGE, GET REPLY
      LDA P2        SET FOR 2 OCTAL DIGITS INPUT
      JSB DOCON     GET DIGITS, RETURN OCTAL
      JMP CHNLD     REPEAT INPUT
      STA DCHNL     SET DISK CHANNEL NUMBER 
* 
*                                   GET SYSTEM DISK SIZE
      JSB SPACE     NEW LINE
SIZED LDA P14 
      LDB MESS1     MESS1 = ADDR: SYS DISK SIZE?
      JSB REPLY     PRINT MESSAGE, GET REPLY
      LDA N3        SET FOR 3 DECIMAL DIGITS INPUT
      JSB DOCON     GET DIGITS, RETURN OCTAL
      JMP SIZED     REPEAT INPUT
      STA DSIZE     SET SYSTEM DISK SIZE
* 
* 
      JSB SPACE     NEW LINE
STREL LDA P14 
      LDB MES50     MES50 = ADDR: START SCRATCH?
      JSB REPLY     PRINT MESSAGE, GET REPLY
      LDA N3        SET FOR 3 DECIMAL DIGITS INPUT
      JSB DOCON     GET DIGITS, RETURN OCTAL
      JMP STREL     REPEAT INPUT
      SZA,RSS       IF ZERO INPUT, USE DEFAULT VALUE
      JMP DFALT      (DISC MID-POINT) 
      LDB DSIZE     IF INPUT GREATER THAN DISC SIZE,
      CMB,INB        FORCE REPEAT INPUT 
      ADB A 
      RAL 
      SSB,RSS 
      JMP STREL 
      RSS 
DFALT LDA DSIZE 
      ALF,ALF       ROTATE LEFT FOR TRACK ADDRESS 
      RAR,RAR       DIVIDE BY 2                   $$
      AND M7600     ISOLATE TRACK ADDR.           $$
      STA DSKSC     SET INITIAL SCRATCH ADDRESS 
* 
*                                   SET NO. PROTECTED TRACKS
      JSB SPACE     NEW LINE
PROTD LDA P14 
      LDB MES21     MES21 = ADDR: NO. PROTECTED?
      JSB REPLY     PRINT MESSAGE, GET REPLY
      LDA N2        SET FOR 2 DECIMAL DIGITS INPUT
      JSB DOCON     GET DIGITS, RETURN OCTAL
      JMP PROTD     REPEAT INPUT
      STA PTRAK     SET NO. PROTECTED TRACKS
* 
*                                  GET # SECTORS FOR SYSTEM DISC
      JSB SPACE     NEW LINE                      $$
#SEC1 LDA P16                                     $$
      LDB MES40     MES40 = ADDR: # SECTORS/TRACK?$$
      JSB REPLY     PRINT MESSAGE, GET REPLY      $$
      LDA N3        SET FOR 3 DECIMAL DIGITS INPUT$$
      JSB DOCON     GET DIGITS, RETURN OCTAL      $$
      JMP #SEC1     REPEAT INPUT                  $$
      STA SDS#      SET # SECTORS FOR SYSTEM DISC $$
* 
*                                   GET AUXILIARY DISK SIZE 
      JSB SPACE     NEW LINE
AUXDS LDA P14 
      LDB MES33     MES33 = ADDR: AUX DISK SIZE?
      JSB REPLY     PRINT MESSAGE, GET REPLY
      LDA N3        SET FOR 3 DECIMAL DIGITS INPUT$$
      JSB DOCON     GET DIGITS, RETURN OCTAL
      JMP AUXDS     REPEAT INPUT
      STA DAUXN     SET AUXILIARY DISK SIZE 
      SZA,RSS       IF AUX. DISC NOT PRESENT,     $$
      JMP CHNLT-1    SKIP # OF SECTORS INPUT.     $$
* 
*                                  GET # SECTORS FOR AUX. DISC
      JSB SPACE     NEW LINE                      $$
#SEC2 LDA P16                                     $$
      LDB MES40     REPEAT                        $$
      JSB REPLY      # SECTORS                    $$
      LDA N3         MESSAGE AND                  $$
      JSB DOCON      INPUT.                       $$
      JMP #SEC2                                   $$
      STA ADS#      SET # SECTORS OF SYSTEM DISC  $$
* 
*                                   SET TIME BASE GENERATOR CHANNEL 
      JSB SPACE     NEW LINE
CHNLT LDA P9
      LDB MES30     MES30 = ADDR: TBG CHNL? 
      JSB REPLY     PRINT MESSAGE, GET REPLY
      LDA P2        SET FOR 2 OCTAL DIGITS INPUT
      JSB DOCON     GET DIGITS, RETURN OCTAL
      JMP CHNLT     REPEAT INPUT
      STA TBCHN     SET TBG CHANNEL NO. 
* 
*                                  GET PRIV. INT. CARD ADDR.
      JSB SPACE     NEW LINE                      $$
DUMY  LDA P22                                     $$
      LDB MES41     MES41 = ADDR: PRIV. INT. CARD?$$
      JSB REPLY     PRINT MESSAGE, GET REPLY      $$
      LDA P2        SET FOR 2 OCTAL DIGITS INPUT  $$
      JSB DOCON     GET DIGITS                    $$
      JMP DUMY      -ERROR, REPEAT INPUT.         $$
      STA PIOC      SET ADDR. OF DUMMY CARD.      $$
* 
*                                   SET SWAPPING FLAG 
      JSB SPACE     NEW LINE
FSWAP LDA P9
      LDB MES31     MES31 = ADDR: SWAPPING? 
      JSB REPLY     PRINT MESSAGE, GET REPLY
      LDA N3
      JSB AGETN,I   MOVE 3 CHARS TO TBUF
      JSB AGETA,I   GET NEXT CHAR FROM LBUF 
      CPA ZERO      END OF BUFFER?
      RSS           YES - CONTINUE
      JMP SWPER     INVALID TTY RESPONSE
      LDA TBUF      GET 2 TRANSFERRED CHARS 
      CPA YCHAR     CHARS = YE? 
      JMP SWAPY     YES - SET SWAP = 1
      CPA NCHAR     CHARS = NO? 
      JMP SWAPN     YES - SET SWAP=0
SWPER JSB INERR     INVALID TTY RESPONSE
      JMP FSWAP     REPEAT INPUT
SWAPY CLA,INA,RSS   SET A = 1, SKIP 
SWAPN CLA           SET A = 0 
      STA SWAPF     SET SWAPPING FLAG = 0/1 = NO/YES
* 
*                                   SET LAST WORD AVAIL MEMORY
      JSB SPACE     NEW LINE
SMLWA LDA P8
      LDB MESS3     MESS3 = ADDR: LWA MEM?
      JSB REPLY     PRINT MESSAGE, GET REPLY
      LDA P5        SET FOR 5 OCTAL DIGITS INPUT
      JSB DOCON     GET DIGITS, RETURN OCTAL
      JMP SMLWA     REPEAT INPUT
      STA LWASM     SET LWA MEM FOR SYSTEM
* 
*                                   SET PROGRAM INPUT UNIT
      JSB SPACE     NEW LINE
PGMIN LDA P10 
      LDB MESS4     MESS4 = ADDR: PRGM INPT?
      JSB REPLY     PRINT MESSAGE, GET REPLY
      JSB SINIT     GET CODE, ANALYSE 
      JMP PGMIN     REPEAT UNIT ENTRY 
      STA PGMAD     SET PROGRAM INPUT DRIVER ADDR 
* 
*                                   SET LIBRARY INPUT UNIT
      JSB SPACE     NEW LINE
LIBIN LDA P10 
      LDB MESS5     MESS5 = ADDR: LIBR INPT?
      JSB REPLY     PRINT MESSAGE, GET REPLY
      JSB SINIT     GET CODE, ANALYSE 
      JMP LIBIN     REPEAT ENTRY
      STA LIBAD     SET LIB INPUT DRIVER ADDRESS
* 
*                                   SET PARAMETER INPUT UNIT
      JSB SPACE     NEW LINE
PARIN LDA P10 
      LDB MESS6     MESS6 = ADDR: PRAM INPT?
      JSB REPLY     PRINT MESSAGE, GET REPLY
      JSB SINIT     GET CODE, ANALYSE 
      JMP PARIN     REPEAT PARAMETER INPUT
      STA PARAD     PARAD = PRAM INPUT DRIVER ADDR
      SKP 
* 
*                                   CONFIGURE DISK I/O INSTRUCTIONS 
* 
      LDA N5
      LDB HPDSK     GET HIGH PRIORITY ADDRESSES 
      JSB STDSK     SET HIGH PRIORITY CHANNEL NOS.
* 
      ISZ DCHNL     SET DISK CHNL NO. TO L.P. 
* 
      LDA N9
      JSB STDSK     SET LOW PRIORITY DISK ADDRESSES 
* 
      CLA 
DSK5  OTA 0         SET DISK ADDRESS = 0,0
DSK6  LIA 0         GET STATUS WORD 
      AND M4        ISOLATE PROTECT BIT 
      SZA           SKIP - TRACK IS PROTECTED 
      JMP *+7 
      JSB SPACE     NEW LINE
      LDA P33 
      LDB MES32     MES32 = ADDR: TURN OFF DISK ETC.
      JSB DRKEY,I   PRINT: TURN OFF DISK PROTECT
      HLT 32B       WAIT FOR OPERATOR 
      JMP DSK6       REPEAT CHECK 
      LDA ASBUF,I   GET ADDRESS OF BOOTSTRAP BUFFER 
      AND M1777     ISOLATE PAGE BITS 
      STA B 
      LDA LWASM     GET LWA SYSTEM MEMORY 
      AND M0760     ISOLATE PAGE NUMBER 
      STA TBUF      SAVE PAGE NO. OF BOOTSTRAP LDR
      IOR B         SET A = NEW BUFFER ADDRESS
      STA ASBUF,I   SET BUFFER ADDR IN BOOTSTRAP
      LDA SDS#      SET # OF SECTORS -1 FOR       $$
      ADA N1         SYSTEM DISC IN               $$
      STA A#SCT,I    BOOTSTRAP LOADER.            $$
      CMA,INA                                     $$
      AND M177      CONSTRUCT AND SET UPDATE TRACK$$
      STA A#MSK,I    # WITH SECTOR 0 VALUE.       $$
      CLA,INA       SET DISK ADDRESS = 0,1
      LDB ABOOT     GET ADDRESS OF BOOTSTRAP
      JSB ADOUT,I   OUTPUT BOOTSTRAP TO 0,1 
* 
      CLA           SET DISK ADDRESS = 0,0
      LDB ADBUF     GET ADDRESS OF DBUF 
      JSB ADIN,I    READ DISK 0,0 
      LDB ADBUF     GET ADDRESS OF DBUF 
      ADB P3        ADJUST FOR 4TH WORD IN 0,0
      LDA B,I       GET WORD 4 OF 0,0 (BASIC ENT PT)
      STA ABASC,I   SET BASIC ENTRY PT. IN NEW LDR
      LDA ABOOT     GET ADDRESS OF BOOTSTRAP LOADER 
      AND M1777     ISOLATE PAGE BITS 
      IOR TBUF      ADD PAGE NO.
      STA ARTEX,I   SET RT LOADER ENTRY PT. IN LDR
      CLA           SET DISK ADDRESS = 0,0
      LDB BLODR     GET ADDRESS OF 0,0 BOOTSTRAP
      JSB ADOUT,I   PUT OUT 0,0 
      LDA AINPT     GET ADDR OF INIT. PROG. CODE
      STA TRANS     SET CURRENT TRANSFER ADDRESS
      SKP 
* 
*                                   INITIALIZE LOADING
* 
INPUT CLA 
      STA DERCN     SET DISK ERROR COUNT TO ZERO
      JSB SPACE     NEW LINE
      JSB SPACE     NEW LINE
IMAGT JMP *+9        IF MAGTAPE NOT DEFINED, SKIP-
      JSB DRMAG,I    OTHERWISE, REWIND
      OCT 3           MT UNIT 
      CLA,INA         AND SPACE 
      CLB             TO FILE 
      JSB DRMAG,I     NUMBER
      OCT 4           TWO.
      HLT 1          ERROR
      HLT 1           HALTS 
      LDA LWAM      GET LAST WORD AVAIL MEMORY
      ADA N9        ADJUST FOR FIRST IDENT LENGTH 
      STA BIDNT     BIDNT = ADDR OF FIRST IDENT 
      STA PIDNT     PIDNT = ADDRESS OF NEXT IDENT 
      LDA BLST      BLST = ADDR OF FIRST LST ENTRY
      STA PLST      PLST = ADDRESS OF END OF LST
      LDA DSKSC     GET DISK ADDRESS OF SCRATCH AREA
      STA DSKAD     SET CURRENT DISK ADDRESS
      LDB ADBUF     GET ADDRESS OF DBUF 
      STB CURAD     INITIALIZE CURRENT DBUF ADDRESS 
      JSB BUFCL     CLEAR DBUF
      LDA N64 
      STA DCNT      INITIALIZE CURRENT DBUF COUNT 
      CCA           SET A = -1
      STA PLFLG     PLFLG = LOADING FLAG = -1 
* 
*                                   TEST FOR PROG, LIB, END OF LOAD 
*                                   SWR = 00 - LOAD NEXT SOURCE PROG
*                                   SWR = 01 - TERMINATE LOADING
*                                   SWR = 10 - LOAD LIBRARY PROGRAM 
* 
TSTIN HLT 77B       GET SWR, SET INPUT UNIT 
      LIA 1         GET SWR 
      SLA           SKIP IF MORE RECS TO READ 
      JMP LSTEX     PROCESS END OF LOAD CONDITION 
TSTN4 LDB PGMAD     GET PROG INPUT DRIVER ADDR
      ARS,SLA       SKIP - LOAD PROGRAM TAPE
      LDB LIBAD     GET LIBR INPUT DRIVER ADDR
      STB PINAD     SET INPUT UNIT DRIVER ADDR
      CCA 
      STA ETFLG     SET EOT FLAG = IGNORE 10 FF 
*                                   READ BINARY RECORD
LDRIN LDB ALBUF     ALBUF = ADDR OF LBUF
      JSB BUFCL     CLEAR LBUF
      LDA DRMAG 
      CPA PINAD 
      RSS 
      JMP PTDV. 
      LDA N64 
      LDB ALBUF 
      JSB PINAD,I 
      OCT 000000
      JMP MTEOT 
      JMP PAR.E 
      JMP TESTR 
PTDV. LDA N64 
      LDB ALBUF     ALBUF = ADDRESS OF LBUF 
      JSB PINAD,I   GET BINARY RECORD FROM INPT UNIT
      SZA           TEST FOR FEED FRAMES INPUT
      JMP TESTR     NO - PROCESS RECORD 
      LDA ETFLG     GET EOT FLAG
      SZA           SKIP IF MAX 10 FF PERMITTED 
      JMP LDRIN     IGNORE 10 FEED FRAMES 
MTEOT LDA P4
      LDB MESS7     MESS7 = ADDR: *EOT
      JSB DRKEY,I   PRINT: *EOT 
      JMP TSTIN     TEST SWR, SET INPUT UNUT
* 
*                                   PROCESS INPUT RECORD
TESTR CLA 
      STA ETFLG     SET EOT FLAG = MAX 10 FF
      LDA LBUF+1    GET RECORD IDENTIFIER 
      ALF,RAR       ROTATE RIC TO LOW A 
      AND M7        ISOLATE RIC 
      STA RIC       RIC = RECORD IDENT CODE 
      SZA           SKIP IF ABSOLUTE RECORD 
      ADA L6        ADD -6B 
      SSA,RSS       TEST FOR RIC = (1,5)
      JMP RCERR     INVALID RECORD TYPE 
* 
*                                   TEST CHECK SUM
      LDB LBUF      GET RECORD LENGTH 
      BLF,BLF       ROTATE TO LOW B 
      CMB,INB       SET TO NEG
      ADB P3        ADD 3 FOR WORD COUNT IN CHECKSUM
      SSB,RSS       TEST FOR SHORT (1,3) RECORD 
      JMP RCERR     SHORT (1-3) WORD RECORD 
      STB WDCNT     SET RECORD WORD COUNT 
      LDA LBUF+1    GET WORD 2 - INITIALIZE CHECKSUM
      LDB ALBUF     ALBUF = A(LBUF) 
      ADB P3        SET ADDR FOR WORD 4 OF LRUF 
      ADA B,I       ADD WORD TO CHECKSUM
      INB           INCR ADDR 
      ISZ WDCNT     SKIP IF END OF RECORD 
      JMP *-3       CONTINUE CHECKSUM TEST
      CPA LBUF+2    TEST WITH GIVEN CHECKSUM
      JMP LDRC      PROCESS VALID RECORD
* 
*                                   INVALID CHECKSUM
PAR.E LDA ERR02 
      JSB ERROR     PRINT ERROR MESSAGE 
      HLT 02B       WAIT FOR OPERATOR INTERVEBTION
      LDA DRMAG     IF ERROR ON 
      CPA PINAD     MASS STORAGE
      CLA,RSS       THEN SKIP 
      JMP LDRIN     ELSE REREAD THE RECORD
      CCB           MASS STORAGE  SO
      JSB DRMAG,I   BACKSPACE 
      OCT 4         ONE 
      HLT 1         RECORD
      HLT 1         AND 
      JMP LDRIN     REREAD RECORD 
* 
RCERR LDA ERR04 
      JSB ERROR     PRINT ERROR MESSAGE 
      HLT 04B       WAIT FOR OPERATOR INTERVENTION
      JMP LDRIN     REREAD RECORD 
* 
*                                   CLASSIFY RECORDS BY TYPE
LDRC  LDA RIC       GET REC IDENT CODE
      LDB PLFLG     PLFLG = PROGRAM LOADING FLAG
      CPA P1        RIC = 1? (NAM)
      JMP NAMR      PROCESS NAM REC 
      SZB           SKIP IF NOT LOADING 
      JMP NMERR     RECORD OUT OF SEQUENCE
      CPA P2        RIC = 2? (ENT)
      JMP ENTR      PROCESS ENT REC 
      CPA P3        RIC = 3? (DBL)
      JMP DBLR      PROCESS DBL REC 
      CPA P4        RIC = 4? (EXT)
      JMP EXTR      PROCESS EXT REC 
      SKP 
* 
*                                   PROCESS END RECORD
      CLA,INA       SET MASK = 1
      AND LBUF+1    ISOLATE M/S 
      RAR           MOVE M/S TO SIGN POSITION 
      IOR ID6,I     ADD TO PRIORITY,TYPE
      STA ID6,I     SET M/S, PRIORITY, TYPE 
      LDA DSKID     GET NEXT DBL ADDRESS
      LDB ALBUF     GET ADDRESS OF LBUF 
      JSB ADOUT,I   OUTPUT END RECORD 
      LDA TADBL     GET NEXT DBLST ADDRESS
      STA PADBL     SAVE END OF DBLST 
      CLA           GET MIN RELOCATION ADDR 
      STA TCHAR     SET CURRENT (MIN) VALUE 
SORT1 LDA M7777     GET MAX RELOCATION ADDR 
      STA MAXC      SAVE MAX VALUE
      LDA AXXB      GET ADDR OF DBL LIST. 
      STA TADBL     SET CURRENT DBLST ADDRESS 
SORT2 LDA TADBL     GET ADDRESS OF NEXT ENTRY 
      ISZ TADBL     INCR ADDR FOR NEXT ENTRY
      CPA PADBL     END OF LIST?
      JMP SORT5     YES - TEST FOR END OF SORT
      LDB A,I       GET CURRENT VALUE 
      CMB,INB 
      ADB TCHAR     ADD MIN VALUE 
      SZB,RSS       SKIP - NOT CURRENT VALUE
      JMP SORT3     OUTPUT CURRENT RECORD 
      SSB,RSS       SKIP - GREATER, EQUAL TO MIN
      JMP SORT2     IGNORE LESS THAN MIN
      LDB A,I       GET CURRENT VALUE 
      LDA B         SAVE VALUE IN A 
      CMB,INB 
      ADB MAXC      ADD MAX VALUE 
      CMB,SSB,INB,SZB  SKIP - NO NEW MAX
      STA MAXC      SET NEW MAX 
      JMP SORT2     GET NEXT VALUE
* 
SORT3 CMA           COMPLEMENT CURRENT DBLST ADDRESS
      ADA AXXB      ADD ADDR OF DBL LIST
      STA WDCNT     SET DBL LIST DISPLACEMENT 
      LDA P2        SET DISK ADDRESS = 0,2
      JSB INDAD,I   INCR DBL DISK ADDRESS 
      ISZ WDCNT     SKIP - END OF SEARCH FOR DBL REC
      JMP *-2       INCR DISK ADDRESS 
      LDB ALBUF     GET ADDRESS OF LBUF 
      JSB ADIN,I    GET RECORD FROM DISK
      JSB DWRIT     PACK,PUT OUT TO DISK
      LDA LBUF+1    COMPUTE 
      AND M77        LENGTH OF
      ADA LBUF+3     PROGRAM
      STA LWH2
      JMP SORT2     GET NEXT VALUE
* 
SORT5 LDA MAXC      GET PREVIOUS MAX
      STA TCHAR     SET NEW MIN 
      CPA M7777     END OF SORT?(NO NEW MAX SET)
      RSS 
      JMP SORT1     NO - PROCESS NEXT VALUE 
* 
      CCA 
      STA PLFLG     SET PROG LOAD FLAG = LOADING
      STA CNFLG     SET FLAG FOR LB, UT END COUNT 
      LDA DSKID     GET ADDRESS OF END RECORD 
      LDB ALBUF     GET ADDR OF LBUF
      JSB ADIN,I    GET END RECORD
      JSB DWRIT     PACK, PUT OUT TO DISK 
      LDA LWH1      COMPILED? 
      SZA,RSS        YES - SKIP 
      JMP LDRIN      NO - GET NEXT ONE
* 
      LDB ALBUF     INPUT NAM RECORD
      JSB ADIN,I
      LDA LWH2      STORE LENGTH
      IOR MSIGN      INTO IT
      STA LBUF+6
      LDA LWH1      OUTPUT NAM
      LDB ALBUF      RECORD AGAIN 
      JSB ADOUT,I 
      JMP LDRIN     NOW GO
* 
NMERR LDA ERR03 
      JSB ERROR     PRINT ERROR MESSAGE 
      HLT 03B       WAIT FOR OPERATOR INTERVENTION
      JMP LDRIN     REREAD RECORD 
      SKP 
* 
*                                   NAM RECORD PROCESSOR
NAM12 EQU LBUF+3
NAM34 EQU LBUF+4
NAM5  EQU LBUF+5
NPROG EQU LBUF+6
NBP   EQU LBUF+7
NCOM  EQU LBUF+8
NTYP  EQU LBUF+9
NPRIO EQU LBUF+10 
NINT1 EQU LBUF+11 
NINT2 EQU LBUF+12 
NINT3 EQU LBUF+13 
NINT4 EQU LBUF+14 
NINT5 EQU LBUF+15 
NINT6 EQU LBUF+16 
* 
NAMR  SZB,RSS       SKIP IF LOADING 
      JMP NMERR     RECORD OUT OF SEQUENCE
      LDA LBUF      GET RECORD LENGTH 
      ALF,ALF       ROTATE TO LOW A 
      CPA P17       TEST FOR NAM REC = 17 WORDS 
      JMP TSTYP     TEST NAM REC FOR RT-GENERATED 
      CPA P9        TEST FOR NAM REC = 9 WORDS
      RSS           YES - CONTINUE
      JMP RCERR     NO - INVALID RECORD TYPE
      LDA P17       GET NEW NAM REC LENGTH CODE 
      ALF,ALF       ROTATE TO HIGH A
      STA LBUF      SET NAM REC LENGTH IN WORD 1
TSTYP LDA NTYP      GET CURRENT PROGRAM TYPE
      SZA           SKIP - CURRENT TYPE = SYSTEM
      JMP NAMOK     DO NOT RESET NAM RECORD TYPE
      LDA DRMAG     IF INPUT FROM 
      CPA PINAD     MASS STORAGE
      CLA,RSS       IGNOR THE SR
      LIA 1         GET SWR FOrPROGRAM TYPE 
      RAR,RAR 
      RAR           ROTATE TO LOW A 
      AND P15        ISOLATE BITS 0-3 
      STA NTYP      SET PROGRAM TYPE IN NAM REC 
      SZA           IF SYSTEM SET PRIORITY TO ZERO
      LDA P99 
      STA NPRIO     SET PRIORITY
NAMOK LDB P3        SET DBL DISK ADDR = 0,3 
      STB DSKID     SET CURRENT DBL DISK ADDRESS
      CLB 
      STB DSCNT     CLEAR DISK SEGMENT COUNT
      STB CNFLG     CLEAR DISK SEGMENT COUNT FLAG 
      STB PLFLG     SET PLFLG = NOT LOADING 
      LDA AXXB      GET ADDR OF DBL LIST. 
      STA TADBL     SET CURRENT DBLST ADDRESS 
      JSB INIDX     INITIALIZE IDENT ADDRESSES
NEXTN JSB IDX       SET IDENT ADDRESSES 
      JMP ENTNA     YES - ENTER NAME
      LDA NAM12     GET NAME 1,2
      CPA ID1,I     EQUAL?
      RSS           YES - CONTINUE
      JMP NEXTN     NO - TRY NEXT IDENT 
      LDA NAM34     GET NAME 3, 4 
      CPA ID2,I     EQUAL?
      RSS           YES - CONTINUE
      JMP NEXTN     NO - TRY NEXT IDENT 
      LDA NAM5      GET NAME 5
      AND M7400     ISOLATE UPPER CHAR
      CPA ID3,I     EQUAL 
      RSS           YES - CONTINUE
      JMP NEXTN     NO - TRY NEXT IDENT 
* 
      LDA ERR08     GET ERROR CODE - DUPLICATE NAMES
      JSB ERROR     PRINT DIAGNOSTIC
      LDA P5
      LDB ID1       GET ADDRESS OF NAME IN IDENT
      JSB DRKEY,I   PRINT DUPLICATE PROG. NAME
      JMP REPNA     REPLACE REST OF IDENT 
* 
ENTNA LDA NAM12     GET NAME 1,2
      STA ID1,I     SET NAME 1,2 IN IDENT 
      LDA NAM34     GET NAME 3,4
      STA ID2,I     SET NAME 3,4 IN IDENT 
      LDA NAM5      GET NAME 5
      AND M7400     SAVE UPPER CHAR 
      STA ID3,I     SET NAME 5 IN IDENT 
      LDA TIDNT     GET ADDRESS OF NEXT IDENT 
      STA PIDNT     SAVE NEXT IDENT ADDRESS 
* 
REPNA LDA NTYP      GET PROGRAM TYPE
      AND M177      ISOLATE TYPE
      STA ID6,I     SET TYPE IN IDENT 
      LDB NCOM      GET COMMON LENGTH 
      STB ID4,I     SAVE COMMON LENGTH
      LDB NBP       GET BP LENGTH 
      SZB,RSS       SKIP IF BP LENGTH NON-ZERO
      JMP STPR      SET PRIORITY
      LDA ERR06     GET ERROR CODE
      JSB ERROR     PRINT DIAGNOSTIC
* 
STPR  LDA NPRIO     GET PRIORITY
      AND M177      ISOLATE PRIORITY
      ALF,ALF       ROTATE TO UPPER A 
      IOR ID6,I     ADD PRIORITY TO TYPE
      STA ID6,I     SET PRIORITY, TYPE IN IDENT 
      LDA DSKAD     DSKAD = CURRENT DISK ADDR 
      STA ID5,I     SET CURRENT DISK ADDR IN IDENT
      LDB NPROG     COMPILED? 
      SSB,RSS        IF YES, SKIP & SET SWITCH
      CLA            OTHERWISE, CLEAR SWITCH
      STA LWH1
      LDA NINT1     GET RESOLUTION CODE 
      ALF,ALF       ROTATE TO UPPER A 
      ALF,RAL       ROTATE TO UPPER 3 BITS
      IOR NINT2     ADD EXECUTION INTERVAL
      STA ID7,I     SET RESOLUTION CODE, EXEC MULT
      LDA NINT3     GET HOURS 
      ALF,ALF       ROTATE TO UPPER A 
      IOR NINT4     ADD MINUTES 
      STA ID8,I     SET HOURS, MINUTES
      LDA NINT5     GET SECONDS 
      ALF,ALF       ROTATE TO UPPER A 
      IOR NINT6     ADD 10'S MILLISECONDS 
      STA ID9,I     SET SECONDS, 10'S MILLISECONDS
      CLA 
      STA ID10,I    CLEAR BS IDENT MAIN ADDRESS 
      JSB DWRIT     PACK RECORD, OUTPUT TO DISK 
      JMP LDRIN     GET NEXT RECORD 
      SKP 
* 
*                                   DBL REC PROCESSOR 
DBLR  LDA LBUF+3    GET RELOCATION ADDRESS
      STA TADBL,I   SAVE ADDR IN DBLST
      ISZ TADBL     INCR DBLST ADDR FOR NEXT ENTRY
      LDA TADBL     GET NEXT DBLST ADDRESS
      CMA,INA 
      ADA ANDBL     ADD ADDRESS OF END OF DBL LIST
      SSA,RSS       SKIP - DBL OVERFLOW 
      JMP *+3       NO DBL OVERFLOW 
      LDA ERR20     GET ERROR CODE - DBL OVERFLOW 
      JSB ERROR     PRINT DIAGNOSTIC
      LDA DSKID     GET DBL DISK ADDRESS
      LDB ALBUF     GET ADDRESS OF LBUF 
      JSB ADOUT,I   OUTPUT DBL RECORD 
      LDA DSKID     GET DISK ADDRESS
      JSB INDAD,I   INCR ADDRESS
      STA DSKID     SET NEW DISK ADDRESS
      JMP LDRIN     GET NEXT RECORD 
      SKP 
* 
*                                   ENT/EXT RECORD PROCESSOR
ENTR  CCA,RSS       ENT PROCESSOR 
EXTR  CLA           EXT PROCESSOR 
      STA NXFLG     NXFLG = ENT/EXT FLAG
      LDA LBUF+1    SET NO. SYMBOLS 
      AND M37       ISOLATE NO. SYMBOLS 
      CMA,INA 
      STA EXCNT     SET SYMBOL COUNT
      LDA ALBUF     ALBUF = A(LBUF) 
      ADA P3        P3 = +3 
SETNX STA SYM12     SET STARTING SYMBOL ADDR
      INA 
      STA SYM34     SET CHARS 3,4 ADDR
      INA 
      STA SYM5      SET CHAR 5 ADDR 
      JSB INLST     INITIALIZE LST ADDRESSES
ENTX1 JSB LSTX      SET LST1 - LST5 
      JMP ENTX3     END OF LST
      LDA SYM12,I   GET CHARS 1,2 
      CPA LST1,I    EQUAL?
      RSS           YES - CONTINUE
      JMP ENTX1     TRY NEXT ENTRY
      LDA SYM34,I   GET CHARS 3,4 
      CPA LST2,I    EQUAL?
      RSS           YES - CONTINUE
      JMP ENTX1     TRY NEXT ENTRY
      LDA SYM5,I    GET CHAR 5
      AND M7400     ISOLATE UPPER CHAR
      CPA LST3,I    EQUAL?
      RSS           YES - CONTINUE
      JMP ENTX1     TRY NEXT ENTRY
* 
      LDA NXFLG     GET ENT/EXT FLAG
      SZA,RSS       SKIP IF ENT 
      JMP ENTX4     COMPLETE EXT PROCESSING 
* 
*                                   PROCESS ENT REC 
      LDA LST4,I    GET WORD 4 OF LST ENTRY 
      SZA,RSS       SKIP IF NON-ZERO (DEFINED)
      JMP ENTX2     MAKE ENTRY FOR UNDEFINED EXT
      SSA           SKIP IF ENTRY MADE
      JMP ENTX6     MAKE ENTRY FOR BS EXT 
      LDA ERR05     SET CODE - DUPLICATE ENTRY POINT
      JSB ERROR     PRINT ERROR MESSAGE 
      LDA P5
      LDB LST1      LST1 = ADDR OF SYMBOL 
      JSB DRKEY,I   PRINT DUPLICATE ENTRY SYMBOL
      JMP ENTX2     IGNORE DUPLICATE ENT'S
ENTX6 LDA ID6,I     GET CURRENT TYPE
      AND M177      ISOLATE TYPE
      CPA P3        TYPE = BG DISK RESIDENT?
      RSS           YES - CONTINUE (ERROR)
      JMP ENTX2     MAKE ENTRY FOR UNDEFINED EXT
      LDA ERR13     SET CODE = INVALID BG BS ORDER
      JSB IRERR     IRRECOVERABLE ERROR 
ENTX2 LDA ID1       GET MAIN IDENT ADDRESS
      STA LST4,I    ENTER IDENT ADDR IN WORD 4
      JMP ENTX5 
ENTX3 LDA SYM12,I   GET CHARS 1,2 
      STA LST1,I    SET CHARS 1,2 IN LST
      LDA SYM34,I   GET CHARS 3,4 
      STA LST2,I    SET CHARS 3,4 IN LST
      LDA SYM5,I    GET CHAR 5
      AND M7400     ISOLATE UPPER CHAR
      STA LST3,I    SET CHAR 5 IN LST 
      LDA LST5      GET WORD 5 ADDR 
      INA 
      STA PLST      PLST = NEXT LST ENTRY ADDRESS 
      CLB 
      STB LST5,I    CLEAR WORD 5 IN LST ENTRY (BOTH)
      LDA NXFLG     GET EXT/ENT FLAG
      SZA           SKIP IF EXT ENTRY 
      JMP ENTX2     SET WORD 4 OF ENT ENTRY 
      LDA ID6,I     GET TYPE
      AND M177      ISOLATE TYPE
      LDB ID1       GET MAIN IDENT ADDRESS
      CPA P5        TYPE = BS?
      CMB,RSS       YES - SET LST4 = BS REF, SKIP 
      CLB           NO - SET LST4 = UNDEFINED 
      STB LST4,I    YES - SET ADDRESS IN LST WORD 4 
ENTX4 LDA ID6,I     GET TYPE
      AND M177      ISOLATE TYPE
      CPA P5        TYPE = BG SEGMENT?
      RSS           YES - CONTINUE
      JMP ENTX5     NO - IGNORE BG SEG MAIN ADDR
      LDA ID1       GET CURRENT IDENT ADDRESS 
      STA IMAIN     SAVE IDENT ADDRESS
      LDA LST4,I    GET IDENT ADDRESS 
      SZA           SKIP IF UNDEFINED 
      SSA           SKIP IF IDENT ADDRESS 
      JMP ENTX5     IGNORE UNDEFINED EXT
      STA TIDNT     SET IDENT ADDRESS FOR IDX 
      JSB IDX       SET IDENT ADDRESSES 
      HLT 0         IDENT NOT FOUND 
      LDA ID6,I     GET TYPE
      SSA,RSS       SKIP IF MAIN
      JMP NTMAN     SET FLAG FOR IGNORING BS REF
      AND M177      ISOLATE TYPE
      CPA P3        TYPE = BG DISK RESIDENT?
      CCB,RSS       SET FLAG FOR BS REF, SKIP 
NTMAN CLB           SET FLAG FOR IGNORING BS REF
      STB TCHAR     SET FLAG = 0/-1 = IGNORE/BS REF 
      LDA IMAIN     GET CURRENT IDENT ADDRESS 
      STA TIDNT     SET FOR NEXT IDENT ADDRESSES
      JSB IDX       SET CURRENT IDENT ADDRESSES 
      HLT 0         ADDRESS INVALID 
      ISZ TCHAR     SKIP - SET IDENT ADDR FOR BS REF
      JMP ENTX5     IGNORE IF NOT MAIN BG DISK RES
      LDA LST4,I    GET BG MAIN ADDRESS 
      STA ID10,I    SET MAIN IDENT ADDR IN BS IDENT 
ENTX5 LDA SYM12     GET SYMBOL ADDR 
      ADA P3        ADJUST FOR BOTH ENT & EXT 
      LDB NXFLG     GET EXT/ENT FLAG
      SZB           SKIP IF EXT ENTRY 
      INA           ADJUST FOR ENT REC (4-WORD ENT) 
      ISZ EXCNT     TEST SYMBOL COUNTER 
      JMP SETNX     PROCESS NEXT SYMBOL 
      JSB DWRIT     PACK RECORD, OUTPUT TO DISK 
      JMP LDRIN     GET NEXT RECORD 
      SKP 
* 
*                                   WRITE RELOC REC ON DISK 
* 
*  DWRIT PACKS THE CURRENT CONTENTS OF LBUF INTO DBUF AND DUMPS 
*  DBUF WHEN IT CONTAINS 64 WORDS OF RELOCATABLE INPUT. 
*  IF THE END RECORD IS BEING PROCESSED, DWRIT TESTS FOR
*  PROCESSING LIBRARY PROGRAMS AND SETS THE NO. OF PACKED 
*  RELOCATABLE LIBRARY RECORDS IN WORD 10 OF IDENT FOR
*  USE IN MOVING THE RELOCATABLE LIBRARY TO THE PROTECTED 
*  AREA OF THE DISK AFTER THE LOADING PHASE IS COMPLETE.
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB DWRIT
* 
*  RETURN: CONTENTS OF A AND B DESTROYED
* 
DWRIT NOP 
      LDB ALBUF     GET ADDRESS OF LBUF 
      STB CURAL     SAVE CURRENT LBUF ADDRESS 
      LDA LBUF      GET RECORD LENGTH 
      ALF,ALF       ROTATE TO LOW A 
      CMA,INA 
      STA LCNT      SAVE RECORD LENGTH COUNT
LTOD  LDA CURAL,I   GET WORD FROM LBUF
      STA CURAD,I   SET WORD INTO DBUF
      ISZ DCNT      SKIP IF DBUF FULL 
      JMP GETL      TEST FOR END OF LBUF
      JSB DDOUT     OUTPUT DBUF TO DISK 
      RSS           OMIT CURRENT DBUF ADDR INCREMENT
GETL  ISZ CURAD     INCR CURRENT DBUF ADDRESS 
      ISZ CURAL     INCR CURRENT LBUF ADDRESS 
      ISZ LCNT      SKIP IF LBUF MOVED TO DBUF
      JMP LTOD      MOVE NEXT WORD TO DBUF
      LDA CNFLG     GET END FLAG
      SZA,RSS       SKIP IF END RECORD READ 
      JMP DWRIT,I   RETURN
* 
      LDA DCNT
      CPA N64       BUFFER EMPTY? 
      RSS 
      JSB DDOUT     OUTPUT TO DISK
* 
      LDA ID6,I     GET TYPE
      AND M177      ISOLATE TYPE
      CPA P5        TYPE = BG SEGMENT?
      JMP DWRIT,I   RETURN
      LDA DSCNT     GET TOTAL LIBR DISK SECTR COUNT 
      STA ID10,I    SET TOTAL SECTOR COUNT IN IDENT 
      JMP DWRIT,I   RETURN
      SKP 
* 
*                                   OUTPUT DBUF TO DISK 
* 
*  THE DDOUT SUBROUTINE WRITES THE CONTENTS OF DBUF IN THE
*  CURRENT DISK SECTOR.  FOLLOWING THIS DBUF IS CLEARED,
*  THE CURRENT ADDRESS AND COUNT FOR DBUF ARE SET,
*  AND THE NEXT DISK ADDRESS IS SET INTO DSKAD. 
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB DDOUT
* 
*   RETURN: CONTENTS OF A AND B ARE DESTROYED 
* 
DDOUT NOP 
      LDA DSKAD     GET CURRENT DISK ADDRESS
      LDB ADBUF     GET BUFFER ADDRESS
      JSB ADOUT,I   OUTPUT RECORD TO DISK 
      LDB ADBUF     GET ADDRESS OF DBUF 
      STB CURAD     INITIALIZE DBUF CURRENT ADDRESS 
      JSB BUFCL     CLEAR DBUF
      LDA N64 
      STA DCNT      INITIALIZE CURRENT DBUF COUNT 
      ISZ DSCNT     COUNT RECORD
      LDA DSKAD     GET CURRENT DISK ADDRESS
      JSB INDAD,I   INCR CURRENT DISK ADDRESS 
      STA DSKAD     SET NEW DISK ADDRESS
      JMP DDOUT,I   RETURN
      SKP 
* 
*                                   PRINT MESSAGE, GET REPLY
* 
*  THE SUBROUTINE REPLY CONTROLS THE PRINTING OF THE
*  MESSAGE, CLEARING OF THE INPUT BUFFER, TESTING FOR CHARACTERS
*  TRANSMITTED, AND INITIALIZATION OF THE BUFFER SCAN FOR 
*  ALL INITIALIZATION MESSAGES. 
* 
*  CALLING SEQUENCE:
*    A = NO CHARACTERS (POS.) IN MESSAGE
*    B = ADDRESS OF MESSAGE 
*    JSB REPLY
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED. 
* 
REPLY NOP 
      JSB DRKEY,I   PRINT MESSAGE 
      LDB ALBUF     GET ADDRESS OF LBUF 
      JSB BUFCL     CLEAR LBUF
      LDA P64 
      LDB ALBUF     SET BUFFER ADDRESS FOR INPUT
      JSB DRTTY,I   GET REPLY FROM TTY
      SZA,RSS       SKIP IF CHARACTERS TRANSMITTED
      JMP *-4       REPEAT INPUT
      JSB AGINI,I   INITIALIZE LBUF SCAN
      JMP REPLY,I   RETURN
      SKP 
* 
*                                   NUMERICAL INPUT CONTROL 
* 
*  THE DOCON SUBROUTINE ANALYZES THE INPUT FOR THE
*  CHANNEL NO., DISK SIZES, TBG CHANNEL NO. AND LAST
*  WORD OF AVAILABLE MEMORY.
* 
*  CALLING SEQUENCE:
*    A = MAX NO. OF CHARACTERS PERMITTED IN RESPONSE. 
*        THE SIGN OF A DETERMINES THE CONVERSION FROM 
*        ASCII TO OCTAL (POS.) OR DECIMAL (NEG.). 
*    B = IGNORED
*    JSB DOCON
* 
*  RETURN:
*    (N+1): CONTENTS OF A AND B ARE DESTROYED.  AN INVALID
*           CHARACTER HAS BEEN DETECTED IN THE RESPONSE, OR 
*           THE RESPONSE CONTAINS AN INVALID NO. CHARACTERS.
*           THE MESSAGE IS TO BE REPEATED ON RETURN.
*    (N+2): A = CONVERTED RESULT
* 
DOCON NOP 
      JSB AGETO,I   GET OCTAL/DECIMAL, RETURN OCTAL 
      JMP *+4       INVALID DIGIT 
      JSB AGETA,I   GET NEXT CHAR FROM LBUF 
      CPA ZERO      CHAR = ZERO? (END OF BUFFER)
      JMP *+3       YES - CONTINUE
      JSB INERR     INVALID DIGIT ENTRY 
      JMP DOCON,I   RETURN
      ISZ DOCON     INCR RETURN ADDRESS 
      LDA OCTNO     GET CONVERTED NUMBER
      JMP DOCON,I   RETURN
      SKP 
* 
*                                   INVALID TTY RESPONSE
* 
*  THE INERR SUBROUTINE PRINTS THE DIAGNOSTIC FOR INVALID 
*  RESPONSES DURING THE INITIALIZATION SECTION. 
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB INERR
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED. 
* 
INERR NOP 
      LDA ERR01     SET INVALID DEVICE ERROR CODE 
      JSB ERROR     PRINT ERROR MESSAGE 
      JMP INERR,I   RETURN
      SKP 
* 
*                                   ALPHABETIC INPUT CONTROL
* 
*  THE SINIT SUBROUTINE ANALYZES THE RESPONSE FOR THE PROGRAM,
*  LIBRARY, AND PARAMETER INPUT.
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB SINIT
* 
*  RETURN:
*    (N+1): AN INVALID SET OF CHARACTERS (NOT PT, MT, TY) 
*           OR NO. OF CHARACTERS HAS BEEN DETECTED. 
*           AFTER PRINTING THE DIAGNOSTIC, A RETURN IS MADE TO
*           PERMIT THE MESSAGE TO BE REPEATED.  THE CONTENTS
*           OF A AND B ARE DESTROYED. 
*    (N+2): A = ADDRESS OF DESIGNATED INPUT DRIVER
*           B = DESTROYED 
* 
SINIT NOP 
      LDA N2        SET MAX NO. DIGITS FOR GETNA
      JSB AGETN,I   MOVE LBUF TO TBUF 
      JSB AGETA,I   GET NEXT CHAR FROM LBUF 
      CPA ZERO      CHAR = ZERO? (END OF BUFFER)
      JMP *+3       YES - CONTINUE
CODIN JSB INERR     INVALID TTY RESPONSE
      JMP SINIT,I   RETURN - ERROR
      LDA TBUF      GET 2-CHARACTER CODE
      CPA TYTYP     TYPE = TTY? 
      JMP TYUN      YES - UNIT IS TELETYPE
      CPA PTTYP     TYPE = PT READER? 
      JMP PTUN      SET UNIT = PT READER
      CPA MTTYP     TYPE = MAG TAPE?
      JMP MTUN      SET UNIT = MAG TAPE 
      CPA DFTYP     TYPE = DISC FILE? 
      JMP MTUN      -PROCESS AS MAG TAPE. 
      JMP CODIN     INVALID PT, MT OR TY
TYUN  LDA DRTTY     DRTTY = TTY INPUT DRIVER ADDRESS
      RSS 
PTUN  LDA DRPTR     DRPTR = PT READER DRIVER ADDR 
      JMP PT.DV 
MTUN  CLA            MT OR DF 
      CPA DRMAG       DRIVER LOADED?
      JMP CODIN        NO - ERROR 
      STA IMAGT        YES: CLEAR REWIND PERMIT FLAG
      LDA DRMAG     DRMAG = MAG TAPE DRIVER ADDR
PT.DV ISZ SINIT     INCR RETURN ADDRESS 
      JMP SINIT,I   RETURN
      SKP 
* 
*                                   INSERT CHNL NO. IN INSTRUCTION
* 
*  THE STDSK SUBROUTINE SETS THE CURRENT DISK CHANNEL 
*  NOS. IN THE I/O INSTRUCTIONS.
* 
*  CALLING SEQUENCE:
*    A = NO. WORDS TO BE CONFIGURED (NEG.)
*    B = ADDRESS OF INSTRUCTION ADDR LIST 
*    JSB STDSK
* 
*  RETURN:
*    A = DESTROYED
*    B = NEXT INSTRUCTION ADDRESS 
* 
STDSK NOP 
      STA WDCNT     SAVE NO. OF INSTRUCTIONS
      LDA B,I       GET INSTRUCTION 
      AND M7700     ISOLATE INSTRUCTION CODE
      IOR DCHNL     INSERT CHANNEL NO.
      STA B,I       SET INSTRUCTION IN CODE 
      INB           INCR INSTRUCTION ADDRESS
      ISZ WDCNT     SKIP - ALL INSTRUCTIONS CONFIG. 
      JMP *-6       CONFIGURE NEXT INSTRUCTION
      JMP STDSK,I   RETURN
      SKP 
* 
*                                   LIST UNDEFINED EXTS 
* 
*  THE UNDEFINED EXTERNAL REFERENCES CAN BE LISTED AFTER
*  EACH END-OF-TAPE CONDITION IS DETECTED.
* 
*  FOLLOWING COMPLETION OF THE EXT LISTING, THE COMPUTER
*  HALTS TO PERMIT THE OPERATOR TO RETURN FOR ADDITIONAL
*  PROGRAM INPUT, OR CONTINUE WITH THE PROCESSING OF PARAMETERS.
* 
LSTEX JSB SPACE     NEW LINE
      JSB SPACE     NEW LINE
      CCA 
      STA NXCNT     SET SYMBOL COUNT = -1 
      JSB INLST     INITIALIZE LST ADDRESSES
OUTNX JSB LSTX      SET LST1 - LST5 
      JMP EXOUT     END OF LIST 
      LDA LST4,I    GET WORD 4 OF LST 
      CMA,SSA,INA,SZA  SKIP IF UNDEFINED OR BS REF
      JMP OUTNX     TRY NEXT LST SYMBOL 
      ISZ NXCNT     TEST FOR FIRST UNDEF EXT
      JMP OUTEX     NO - PUT OUT SYMBOL NAME
      LDA P10 
      LDB MESS8     MESS8 = ADDR: UNDEF EXTS
      JSB DRKEY,I   PRINT: UNDEF EXTS 
      JSB SPACE     NEW LINE
OUTEX LDA P5
      LDB LST1      LST1 = A(SYMBOL)
      JSB DRKEY,I   PRINT SYMBOL
      JMP OUTNX     TRY NEXT SYMBOL 
* 
EXOUT ISZ NXCNT     TEST FOR NO UNDEF EXTS
      JMP ENDEX     NO - OMIT MESSAGE 
      LDA P14 
      LDB MESS9     MESS9 = ADDR: NO UNDEF EXTS 
      JSB DRKEY,I   PRINT MESSAGE 
ENDEX JSB SPACE     NEW LINE
      HLT 77B       WAIT FOR OPERATOR INTERVENTION
      LIA 1         GET SWITCH REGISTER 
      SLA,RSS       SKIP IF SWITCH 0 UP 
      JMP TSTN4     TEST FOR PROGRAM OR LIBR LOAD 
* 
      CLA           SET DISC HIGH 
      STA DSKA      TO ZERO 
      STA SCH1      SET SCHEDULED  PGM FLAG TO ZERO 
      LDA IMAGT      IF MT OR DF USED 
      SZA             FOR INPUT, SKIP TO REWIND 
      JMP IPARM,I   NO, INITIATE PARAMETER INPUT. $$
      JSB DRMAG,I    REWIND/STANDBY 
      OCT 5          MT OR DF.                    $$
      JMP IPARM,I   INITIATE PARAMETER INPUT SECTION
      SKP 
* 
ERR01 ASC 1,01      INVALID TTY REPLY 
ERR02 ASC 1,02      CHECKSUM ERROR
ERR03 ASC 1,03      RECORD OUT OF SEQUENCE
ERR04 ASC 1,04      INVALID RECORD
ERR05 ASC 1,05      DUPLICATE ENTRY POINTS
ERR06 ASC 1,06      INVALID NAM REC - BP LENGTH 
ERR08 ASC 1,08      DUPLICATE PROGRAM NAMES 
ERR13 ASC 1,13      BG SEGMENT PRECEDES BG MAIN 
ERR20 ASC 1,20      DBL LIST OVERFLOW 
* 
TYTYP ASC 1,TY
PTTYP ASC 1,PT
MTTYP ASC 1,MT
DFTYP ASC 1,DF
* 
MESS1 DEF *+1 
      ASC 7,SYS DISC SIZE?
MESS2 DEF *+1 
      ASC 7,FH DISC CHNL? 
MESS3 DEF *+1 
      ASC 5,LWA MEM?
MESS4 DEF *+1 
      ASC 5,PRGM INPT?
MESS5 DEF *+1 
      ASC 5,LIBR INPT?
MESS6 DEF *+1 
      ASC 5,PRAM INPT?
MESS7 DEF *+1 
      ASC 2,*EOT
MESS8 DEF *+4 
MESS9 DEF *+1 
      ASC 7, NO UNDEF EXTS
MES21 DEF *+1 
      ASC 7,NO. PROTECTED?
MES30 DEF *+1 
      ASC 5,TBG CHNL? 
MES31 DEF *+1 
      ASC 5,SWAPPING? 
MES32 DEF *+1 
      ASC 17,TURN OFF DISC PROTECT - PRESS RUN
MES33 DEF *+1 
      ASC 7,AUX DISC SIZE?
* 
* 
HPDSK DEF *+1,I     HIGH PRIORITY CHANNEL NOS.
      DEF LINKG 
      DEF DMAC
      DEF DSK3
      DEF DSK8
      DEF DSKB
*                                   LOW PRIORITY CHANNEL NOS. 
      DEF DSK2
      DEF DSK4
      DEF DSK5
      DEF DSK6
      DEF DSK7
      DEF DSK9
      DEF DSKAG 
      DEF DSKC
YCHAR ASC 1,YE
NCHAR ASC 1,NO
DCHNL BSS 1         DISK I/O CHANNEL NO. (OCTAL)
PGMAD BSS 1         PROGRAM INPUT DRIVER ADDRESS
LIBAD BSS 1         LIB INPUT DRIVER ADDR 
PINAD BSS 1         INPUT DRIVER ADDRESS
ETFLG BSS 1         END TAPE FLAG = -1/0 = IGN/MAX
CNFLG BSS 1         LB, UT END FLAG 
RIC   BSS 1         RECORD IDENTIFICATION CODE
SYM12 BSS 1         CHAR 1,2 ADDR 
SYM34 BSS 1         CHAR 3,4 ADDR 
SYM5  BSS 1         CHAR 5 ADDR 
NXCNT BSS 1         UNDEFINED SYMBOL COUNT
* 
AXXB  DEF AXX       DEFINE ADDRESSES OF START AND END OF
ANDBL ABS 15776B     THE DBL LIST AREA. 
TADBL BSS 1         CURRENT DBLST ADDRESS 
PADBL BSS 1         ADDRESS OF END OF DBLST 
      ORG * 
      SKP 
      ORG 4000B 
* 
*                                   SET PARAMETERS INTO IDENTS
* 
*  THE PARAMETER INPUT SECTION PERMITS ALTERATION (OR INTRODUCTION) 
*  OF THE TYPE, PRIORITY, AND EXECUTION INTERVAL FOR EACH PROGRAM.
*  EACH PARAMETER RECORD HAS ONE OF THE FOLLOWING FORMATS:
* 
*    NAME,TYPE
*    NAME,TYPE,PRIORITY 
*    NAME,TYPE,PRIORITY,EXECUTION INTERVAL
* 
*  TYPE = 2 DECIMAL DIGITS (1-99) 
*  PRIORITY = 2 DECIMAL DIGITS (0-99) 
*  EXECUTION INTERVAL = 6 OPERANDS
*    1 - RESOLUTION CODE (2 DECIMAL DIGITS) 
*    2 - EXECUTION MULTIPLE (5 DECIMAL DIGITS)
*    3 - HOURS (2 DECIMAL DIGITS) 
*    4 - MINUTES (2 DECIMAL DIGITS) 
*    5 - SECONDS (2 DECIMAL DIGITS) 
*    6 - 10'S MILLISECONDS (2 DECIMAL DIGITS) 
* 
*  NOTE: TYPE OF BG DISK RESIDENTS HAVING BG SEGMENTS MAY NOT 
*        BE ALTERED WITHOUT DESTROYING RELATIONSHIP.
* 
PARAM JSB SPACE     NEW LINE
      LDA P10 
      LDB MES24     MES24 = ADDR: PARAMETERS
      JSB DRKEY,I   PRINT: PARAMETERS 
      JSB SPACE     NEW LINE
      LDB PARAD     GET PARAM INPUT DRIVER ADDRESS
      CPB DRTTY     INPUT UNIT = TTY? 
      RSS           YES - CONTINUE
      HLT 77B       WAIT FOR INSERTION OF PARAMETERS
* 
PARST LDB ALBUF     GET ADDRESS OF LBUF 
      JSB BUFCL     CLEAR LBUF
      LDA P64 
      LDB ALBUF     GET ADDRESS OF LBUF 
      JSB PARAD,I   GET ASCII PARAMETER RECORD
      SZA,RSS       SKIP IF CHARS INPUT 
      JMP *-4       REPEAT PARAMETER INPUT
      STA PARNO     SAVE PARAMETER RECORD LENGTH
      JSB GINIT     INITIALIZE BUFFER SCAN
      LDA N5
      JSB GETNA     MOVE CHARS FROM LBUF TO TBUF
      CPA PTERM     CHARS = /E? 
      JMP SETLB     YES - SET LIBRARY TYPE IN IDENT 
      JSB GETAL     GET NEXT CHAR FROM LBUF 
      CPA BLANK     CHAR = BLANK?(DELIMITER = COMMA)
      JMP *+3       YES - CONTINUE
* 
PANER LDA ERR09     PARAMETER NAME ERROR
      JMP PARER 
* 
      JSB INIDX     INITIALIZE IDENT ADDRESSES
NXTID JSB IDX       SET CURRENT IDENT ADDRESSES 
      JMP PANER     YES - INVALID NAME
      LDA ID1,I     GET NAME 1,2
      CPA TBUF      EQUAL?
      RSS           YES - CONTINUE
      JMP NXTID     NO - TRY NEXT IDENT 
      LDA ID2,I     GET NAME 3,4
      CPA TBUF+1    EQUAL?
      RSS           YES - CONTINUE
      JMP NXTID     NO - TRY NEXT IDENT 
      LDA ID3,I     GET NAME 5
      AND M7400     ISOLATE UPPER CHAR
      CPA TBUF+2    EQUAL?
      RSS           YES - CONTINUE
      JMP NXTID     NO - TRY NEXT NAME
* 
*                                   SET TYPE
      LDA N2
      JSB GETOC     CONVERT TO OCTAL
      JMP PATER     INVALID DIGIT 
      JSB GETAL     GET NEXT CHAR FROM LBUF 
      CPA ZERO      CHAR = ZERO? (END OF BUFFER)
      RSS           YES - CONTIMUE
      CPA BLANK     CHAR = BLANK?(DELIMITER = COMMA)
      JMP SETYP     SET PROGRAM TYPE IN IDENT 
PATER LDA ERR10     PARAMETER TYPE ERROR
      JMP PARER 
* 
SETYP CLB           IF THIS IS THE SCHEDULED PGM
      LDA ID1       AGAIN 
      CPA SCH1      THEN
      STB SCH1      CLEAR ITS FLAG
      LDB OCTNO     GET CONVERTED NUMBER
      LDA ID6,I     GET PREVIOUS TYPE 
      AND M7600     SET PREVIOUS TYPE = ZERO
      IOR B         INSERT NEW TYPE 
      STA ID6,I     SET NEW TYPE
      LDB ID1       PRESET B TO IDENT ADDRESS 
      AND M120      MASK 80 BITS
      CPA M120      SET?
      RSS           YES - SKIP
      JMP STY       NO - CONTINUE 
      XOR ID6,I     ZERO 80 BITS AND
      STA ID6,I     RESET IDENT 
      SSA,RSS       IF SUBROUTINE IGNORE
      JMP STY       IGNOR SUBROUTINE
      AND M177      GET TYPE TO A 
      SZA           IF ZERO OR
      ADA N5        MORE THAN 4 
      SSA           SKIP
      STB SCH1      ELSE SET PGM IDENT IN SCH FLAG
STY   JSB GETAL     GET NEXT CHAR FROM LBUF 
      CPA ZERO      CHAR = ZERO ? (END OF BUFFER) 
      JMP PARST     YES - GET NEXT PARAMETER RECORD 
* 
*                                   SET NEW PROGRAM PRIORITY
      LDA N2        SET COUNT FOR DECIMAL CONVERSION
      JSB GETOC     CONVERT TO OCTAL
      JMP PAPER     PRIORITY ERROR
      JSB GETAL     GET NEXT CHAR FROM LBUF 
      CPA ZERO      CHAR = ZERO ? (END OF BUFFER) 
      RSS           YES - CONTINUE
      CPA BLANK     CHAR = BLANK?(DELIMITER = COMMA)
      JMP SETNR     SET PRIORITY
PAPER LDA ERR11     PARAMETER PRIORITY ERROR
      JMP PARER 
* 
SETNR LDA ID6,I     GET TYPE
      AND M177      ISOLATE TYPE
      LDB OCTNO     GET PRIORITY
      SZB,RSS       SKIP - PRIORITY ENTERED 
      LDB P99       REPLACE ZERO PRIORITY WITH 99 
      SZA,RSS       SKIP - NOT SYSTEM PROGRAM 
      CLB           SET SYSTEM PRIORITY TO ZERO 
      BLF,BLF       ROTATE PRIORITY TO UPPER B
      LDA ID6,I     GET PREVIOUS PRIORITY 
      AND M1377     ISOLATE PRIORITY,SET TO ZERO
      IOR B         INSERT NEW PRIORITY 
      STA ID6,I     SET NEW PRIORITY
      JSB GETAL     GET NEXT CHAR FROM LBUF 
      CPA ZERO      CHAR = ZERO ? (END OF BUFFER) 
      JMP PARST     YES - GET NEXT PARAMETER RECORD 
* 
*                                   GET RESOLUTION CODE 
      LDA N2        SET FOR 2 DECIMAL DIGITS
      JSB EXINT     GET DIGITS FROM LBUF
      ALF,ALF       ROTATE TO UPPER A 
      ALF,RAL       ROTATE TO UPPER 3 BITS IN A 
      AND M1600     ISOLATE UPPER 3 BITS IN A 
      STA ID7,I     SET IN IDENT 7
* 
*                                   GET EXECUTION MULTIPLE
      LDA N5        SET COUNT FOR DECIMAL CONVERSION
      JSB EXINT     GET DIGITS FROM LBUF
      AND M1600     ISOLATE UPPER 3 BITS IN A 
      SZA           SKIP IF VALID MULTIPLE
      JMP PAIER     INVALID EXECUTION INTERV FORMAT 
      LDA OCTNO     GET CONVERTED NUMBER
      IOR ID7,I     ADD TO RESOLUTION CODE
      STA ID7,I     SET IN IDENT 7
* 
*                                   GET HOURS 
      LDA N2        SET FOR 2 DECIMAL DIGITS
      JSB EXINT     GET DIGITS FROM LBUF
      ALF,ALF       ROTATE TO UPPER A 
      STA ID8,I     SET IN IDENT 8
* 
*                                   GET MINUTES 
      LDA N2        SET FOR 2 DECIMAL DIGITS
      JSB EXINT     GET DIGITS FROM LBUF
      IOR ID8,I     ADD TO HOURS
      STA ID8,I     SET IN IDENT 8
* 
*                                   GET SECONDS 
      LDA N2        SET FOR 2 DECIMAL DIGITS
      JSB EXINT     GET DIGITS FROM LBUF
      ALF,ALF       ROTATE TO UPPER A 
      STA ID9,I     SET IN IDENT 9
* 
*                                   GET TENS OF MILLISECONDS
      LDA N2        SET FOR DECIMAL CONVERSION
      JSB GETOC     CONVERT TO OCTAL
      JMP PAIER     INVALID DIGIT 
      JSB GETAL     GET NEXT CHAR FROM LBUF 
      CPA ZERO      CHAR = 0? (END OF BUFFER) 
      RSS           YES - CONTINUE
      JMP PAIER     NO - INVALID DELIMITER
      LDA OCTNO     GET CONVERTED NUMBER
      IOR ID9,I     ADD TO SECS 
      STA ID9,I     SET IN IDENT 9
      JMP PARST     GET NEXT PARAMETER RECORD 
* 
*                                   EXECUTION INTERVAL INPUT CONTROL
EXINT NOP 
      JSB GETOC     CONVERT TO OCTAL
      JMP PAIER     INVALID DIGIT 
      JSB GETAL     GET NEXT CHAR FROM LBUF 
      CPA BLANK     CHAR = BLANK? (DELIMITER=COMMA) 
      RSS           YES - CONTINUE
      JMP PAIER     NO - INVALID DELIMITER
      LDA OCTNO     GET CONVERTED NUMBER
      JMP EXINT,I   RETURN WITH NUMBER IN A 
PAIER LDA ERR12     PARAMETER INTERVAL ERROR
* 
PARER STA TEMPE     SAVE ERROR CODE 
      JSB ERPNT     TEST FOR PRINTING LBUF
      LDA TEMPE     GET ERROR CODE
      JSB ERROR     PRINT ERROR MESSAGE 
      JSB SPACE     NEW LINE
      JMP PARST     REREAD PARAMETER RECORD 
* 
*                                   PRINT LBUF UNLESS FROM TTY
ERPNT NOP           PRINT CONTENTS OF LBUF
      LDB PARAD     GET ADDRESS OF PARAMETER UNIT 
      CPB DRTTY     DEVICE = TTY? 
      JMP *+4       YES - OMIT PRINTING ON TTY
      LDA PARNO     PARNO = PARAMETER RECORD LENGTH 
      LDB ALBUF     ALBUF = BUFFER ADDRESS
      JSB DRKEY,I   PRINT PARAMETER RECORD
      JMP ERPNT,I   RETURN
* 
SETLB JSB ERPNT     TEST FOR PRINTING /E
      JSB SPACE     NEW LINE
      SKP 
* 
*                                   SET LIBRARY, COM, TYPE TOTALS 
* 
*  THIS SECTION IS EXECUTED WHEN THE PARAMETERS HAVE
*  BEEN COMPLETELY READ IN.  IT COMPUTES THE MAXIMUM LENGTH OF
*  BOTH THE REAL TIME AND BACKGROUND COMMON AREAS.
*  IN ADDITION, IT DEMOTES THOSE LIBRARY PROGRAMS FROM LIBRARY (6)
*  TO UTILITY (7) IF THEY HAVE NOT BEEN CALLED BY RESIDENT PROGRAMS.
*  FINALLY, IT RESERVES A 22-WORD SECTION OF CODE FOR EACH USER 
*  PROGRAM (PLUS AN ADDITIONAL 6 WORDS IF DISK RESIDENT) TO 
*  GENERATE THE ID SEGMENTS.  FINALLY, IT RESEVES A KEYWORD TO
*  CONTAIN THE ADDRESS OF EACH ID SEGMENT.
*  IT ALSO SETS UP THE IDENT ADDRESS OF THE PROGRAM 
*  BE LOADED JUST PRIOR TO THE PROGRAM TO BE PUT IN THE 
*  SCHEDULED LIST, IF ANY.
* 
* 
      CLA 
      STA KEYCN     CLEAR TOTAL KEYWORD COUNT 
      STA SICNT     CLEAR SHORT ID SEG COUNT
      STA LICNT     CLEAR LONG ID SEG COUNT 
      STA COMRT     CLEAR RT COM LENGTH 
      STA COMBG     CLEAR BG COM LENGTH 
      JSB INIDX     INITIALIZE IDX
SETIX JSB IDX       SET IDENT ADDRESSES 
      JMP TRMCN     TERMINATE ID SEGMENT COUNT
      LDA ID6,I     GET TYPE
      AND M177      ISOLATE TYPE
      LDB ID4,I     GET COMMON LENGTH 
      CPA P1        TYPE = RT RESIDENT? 
      JMP SETRC     SET RT COMMON LENGTH
      CPA P2        TYPE = RT DISK RESIDENT?
      JMP SETRC     SET RT COMMON LENGTH
      CPA P3        TYPE = BG DISK RESIDENT?
      JMP SETBC     SET BG COMMON LENGTH
      CPA P4        TYPE = BG RESIDENT? 
      JMP SETBC     SET BG COMMON LENGTH
      CPA P5        TYPE = BG SEGMENT?
      JMP SETBC     SET BG COMMON LENGTH
      CPA ZERO      TYPE = SYSTEM?
      RSS           YES - CONTINUE
      CPA P6        TYPE = LIBRARY? 
      SZB,RSS       SKIP - HAS INVALID COMMON 
      JMP SETIX     PROCESS NEXT IDENT
      LDA ERR37     SET CODE = INVALID COMMON 
      JSB ERROR     PRINT DIAGNOSTIC
      LDA P5
      LDB ID1       GET IDENT ADDRESS 
      JSB DRKEY,I   PRINT PROG NAME FOR INVALID COM 
      JMP SETIX     PROCESS NEXT IDENT
* 
SETBC LDA COMBG     GET PREVIOUS MAX COMMON LENGTH
      CMA,INA 
      ADA B         SET A = PROG COM - PREVIOUS COM 
      SSA,RSS       SKIP IF PREVIOUS GREATER
      STB COMBG     SET NEW MAX BG COMMON LENGTH
      LDA ID6,I     GET M/S 
      SSA,RSS       SKIP IF MAIN
      JMP SETIX     PROCESS NEXT IDENT
      ISZ KEYCN     INCR TOTAL KEYWORD COUNT
      AND M177      ISOLATE TYPE
      CPA P4        TYPE = BG RESIDENT? 
      JMP INSIC     YES - COUNT SHORT ID SEGMENT
INLIC ISZ LICNT     INCR TOTAL LONG ID SEGMENT COUNT
      JMP SETIX     PROCESS NEXT IDENT
INSIC ISZ SICNT     INCR TOTAL SHORT ID SEG COUNT 
      JMP SETIX     PROCESS NEXT IDENT
SETRC LDA COMRT     GET PREVIOUS MAX COMMON LENGTH
      CMA,INA 
      ADA B         SET A = PROG COM - PREVIOUS COM 
      SSA,RSS       SKIP IF PREVIOUS GREATER
      STB COMRT     SET NEW MAX RT COM LENGTH 
      LDA ID6,I     GET M/S 
      SSA,RSS       SKIP IF MAIN
      JMP SETIX     PROCESS NEXT IDENT
      ISZ KEYCN     INCR TOTAL KEYWORD COUNT
      AND M177      ISOLATE TYPE
      CPA P1        TYPE = RT RESIDENT? 
      JMP INSIC     YES - COUNT SHORT ID SEGMENT
      JMP INLIC     NO - COUNT LONG ID SEGMENT
* 
* 
TRMCN JSB SPACE 
      LDA P23 
      LDB MES42    MES42 = ADDR: # OF BLANK ID'S  $$
      JSB AREAD,I    PRINT AND GET REPLY
      LDA N2        GET 2                         $$
      JSB GETOC      DECIMAL DIGITS, CONVERT      $$
      JMP TRM2      -INVALID INPUT.               $$
      SZA,RSS       IF ZERO, ADD 1                $$
      INA            FOR BKG. ON-LINE LOADING.    $$
      STA B         SAVE #.                       $$
      ADA LICNT     ADD TO LONG ID SEGMENT COUNT. $$
      STA LICNT                                   $$
      ADB KEYCN     ADD TO KEYWORD COUNT,         $$
      INB           ADD 1 FOR TERMINATOR.         $$
      STB KEYCN                                   $$
      JSB ASCHF,I   SET UP THE SCHEDULE PGM PARAMETERS
      LDA AFWAP     GET ADDRESS OF LOADING SECTION
      STA TRANS     RESET TRANSFER ADDRESS TO LOAD
      JMP AFWAP,I   LOAD ABSOLUTE SYSTEM
* 
TRM2  LDA TRM3      PRINT                         $$
      JSB ERROR      "ERR 01"                     $$
      JMP TRMCN+1 
TRM3  ASC 1,01                                    $$
      SKP 
* 
*                                   CLEAR UNDEFINED EXTS
* 
IPARS JSB INLST     INITIALIZE LSTX 
CLST3 JSB LSTX      SET LST ADDRESSES 
      JMP ENDLB     SET USAGE FLAGS 
      LDA LST4,I    GET IDENT ADDRESS 
      SSA,RSS       SKIP - UNDEFINED EXT
      JMP CLST3     IGNORE DEFINED ENTRY POINT
      CLA 
      STA LST4,I    CLEAR IDENT ADDRESS 
      JMP CLST3     TRY NEXT LST ENTRY
* 
*  THIS ROUTINE IS CALLED AFTER THE SYSTEM IS LOADED BUT BEFORE THE 
*  LIBRARY. 
      SPC 1 
*                                   CLEAR LOAD FLAGES FOR TYPE 6 PGMS 
* 
CLRT6 NOP 
      JSB INIDX     INITIALIZE IDX
SETLX JSB IDX       SET IDENT ADDRESSES 
      JMP CLRT6,I   END OF IDENTS 
      LDA ID6,I     GET TYPE
      AND M177      ISOLATE TYPE
      CPA P6        TYPE = LIBRARY? 
      RSS           YES - CONTINUE
      JMP SETLX     PROCESS NEXT IDENT
* 
      LDA ID3,I     TYPE = 6 - GET LOAD FLAG
      RAR,CLE,ELA   LOAD BIT TO E - AND CLEARED 
      STA ID3,I     RESET CLEARED FLAG
      SEZ,RSS       WAS IT LOADED?
      JMP SETLX     NO - CONTINUE 
      LDA ERR39     YES - ILLEGAL SYSTEM REFERENCE
      JSB ERROR     ERROR 39
      LDA P5        NOW SEND THE NAME 
      LDB ID1       OF THE CALLED PGM 
      JSB DRKEY,I 
      SPC 1 
      JSB INLST     INITIALIZE LSTX 
SETUX JSB LSTX      SET CURRENT LST ADDRESSES 
      JMP SETLX     END - CONTINUE ID SCAN
      LDA LST4,I    GET IDENT ADDRESS 
      CPA ID1       ENT BELONGS TO CURRENT PROG?
      CLA,RSS       YES - CONTINUE
      JMP SETUX     NO - TRY NEXT ENT 
      STA LST5,I    SET LINK TO ZERO. 
      JMP SETUX     CONTINUE SEARCH 
      SPC 2 
DEMTL NOP           DEMOTE UNCALLED TYPE 6 TO TYPE 7
      LDA BIDNT     SET UP THE SCAN 
      STA CIDNT     PARAMETERS
      LDA P6        FOR TYPE 6
      STA PTYPE     SCAN
DEMS  JSB AIDSN,I   GO SET ID ADDRESSES 
      JMP DEMTL,I   END - SO RETURN 
      LDB ID3,I     WAS PGM 
      SLB,RSS       LOADED? 
      ISZ ID6,I     NO; CHANGE TO TYPE 7. 
      JMP DEMS      YES/NO CONTINUE SCAN
* 
ENDLB LDA APARS     GET ADDR OF PARAMETER INPUT CODE
      STA TRANS     RESET INITIAL TRANSFER ADDRESS
      JMP PARAM     GET PARAMETERS
      SKP 
* 
*                                   GENERATE I/O TABLES 
* 
*  THIS SECTION OF CODE GENERATES THE I/O TABLES
*  FOR THE SYSTEM.  THESE INCLUDE THE EQUIPMENT TABLE (EQT),
*  STANDARD DEVICE REFERENCE TABLE (DRT), AND INTERRUPT TABLE.
* 
*  THE EQT RECORDS HAVE THE FOLLOWING FORMAT: 
* 
*    N1,DVRN2<,D><,B><,T> 
* 
*  N1 = CHANNEL NO. (2 OCTAL DIGITS)
*  N2 = DRIVER CLASS. CODE (2 OCTAL DIGITS) 
*  D = DMA FLAG (OPTIONAL)
*  B = BUFFERING FLAG (OPTIONAL)
*  T = TIME-OUT VALUE TO BE ENTERED 
* 
*    IF T IS ENTERED, A VALUE FOR THE DEVICE'S TIME-OUT 
*    CLOCK MUST BE NEXT ENTERED IN RESPONSE TO: 
*                  ' T = '
*    THE OPERATOR MUST ENTER A POSITIVE DECIMAL NUMBER
*    OF UP TO FIVE DIGITS.  THIS IS THEN THE NUMBER OF
*    TIME BASE GENERATOR INTERRUPTS (10 MSEC INTERVALS) 
*    BETWEEN THE TIME IO IS INITIATED ON THE DEVICE AND 
*    THE TIME AFTER WHICH THE DEVICE SHOULD HAVE INTERRUPTED. 
*    IF THE DEVICE HAS NOT INTERRUPTED BY THIS TIME, IT 
*    IS CONSIDERED TO HAVE TIMED-OUT. 
* 
* 
*  EACH DRT RECORD CONSISTS OF A 2-DIGIT NO. SPECIFYING THE 
*  CORRESPONDING ENTRY IN THE EQUIPMENT TABLE 
*  AND AN OPTIONAL 1-DIGIT NO. SPECIFYING A 
*  SUBCHANNEL WITHIN THAT ENTRY.  FOR EXAMPLE, IN 
*  RESPONSE TO THE MESSAGE:  5 = ?, THE RESPONSE 6 INDICATES THAT 
*  THE LOGICAL UNIT NO. 5 IS TO USE DEVICE 6 IN EQT.
*  WHEREAS THE RESPONSE 6,2 INDICATES THAT THE
*  LOGICAL UNIT NO. 5 IS TO USE SUBCHANNEL 2 OF 
*  DEVICE 6 IN EQT. 
* 
* 
*  THE INT RECORDS HAVE ONE OF THE FOLLOWING FORMATS: 
* 
*    N1,EQT,N2
*    N1,PRG,NAME
*    N1,ENT,ENTRY 
*    N1,ABS,N3
* 
*  N1 = CHANNEL NO. (2 OCTAL DIGITS - MUST BE IN INCREASING ORDER)
*        EXCEPTION:    IF N1 = 04 (POWER - FAIL), 
*        THIS ENTRY DOES NOT HAVE TO BE IN ORDER.  ALSO,
*        ONLY AN ENT OR AN ABS TYPE ENTRY IS ACCEPTED 
*        FOR N1 = 04. 
*  N2 = EQT NO. 
*  NAME = PROGRAM NAME TO BE SCHEDULED
*  ENTRY = ENTRY POINT TO WHICH TRANSFER IS TO BE MADE
*  N3 = ABSOLUTE VALUE (6 OCTAL DIGITS) 
* 
* 
*  ROUTINE TO INPUT TO BUFFER FROM TTY
* 
* 
READ  NOP 
      JSB DRKEY,I    SEND QUESTION
      LDB ALBUF 
      JSB BUFCL     CLEAR LBUF
      LDA P64 
      LDB ALBUF     GET ADDRESS OF LBUF 
      JSB DRTTY,I       ENTRY FROM TTY
      SZA,RSS       SKIP - DATA INPUT 
      JMP *-4       REPEAT INPUT
      JSB GINIT     INITIALIZE LBUF SCAN
      JMP READ,I    RETURN
* 
* 
* 
GENIO NOP 
* 
*                                   GENERATE EQUIPMENT TABLE (EQT)
* 
      LDA PPREL     GET CURRENT PROG RELOC ADDRESS
      STA AEQT      SAVE ADDRESS OF EQT 
      CLA 
      STA CEQT      CLEAR NO. OF EQT ENTRIES
      CCA           SET DRT2 AND
      STA DRT2      DRT3 TO IMPOSSIBLE
      STA DRT3      NUMBERS 
      LDA P23 
      LDB MES25     MES25 = ADDR: * EQT TABLE ENTRY 
      JSB DRKEY,I   PRINT: * EQUIPMENT TABLE ENTRY
* 
SEQT  CLA 
      JSB READ      GET EQT RECORD FROM TTY 
      LDA N2
      JSB GETNA     MOVE 2 CHARS TO TBUF
      CPA PTERM     CHARS = /E? 
      JMP SSQT      YES - SET DEVICE REF TABLE (SQT)
      JSB GINIT     RE-INITIALIZE LBUF SCAN 
      LDA P2
      JSB GETOC     GET 2 OCTAL DIGITS, CONVERT 
      JMP IOERR     INVALID DIGIT 
      JSB GETAL     GET NEXT CHAR FROM LBUF 
      CPA BLANK     CHAR = COMMA? 
      JMP CLDBU     YES - SET CHNL NO., CLEAR D,B,U 
IOERR LDA ERR24     SET CODE = INVALID CHNL IN EQT
      JSB ERROR     PRINT DIAGNOSTIC
      JMP SEQT      GET NEXT EQT RECORD 
* 
CLDBU LDB OCTNO     GET I/O CHANNEL NO. 
      STB IOADD     SET I/O ADDRESS 
      CLA 
      STA IODMA     CLEAR DMA FLAG
      STA IOBUF     CLEAR AUTOMATIC BUFFERING FLAG
      CCA 
      STA TFLAG     CLEAR TIME-OUT FLAG 
      CLA,INA 
      JSB GETNA     MOVE 1 CHAR TO RH TBUF POSITION 
      CPA CHARD     CHAR = D? 
      RSS           YES - CONTINUE
      JMP DVERR     INVALID DRIVER NAME 
      LDA N2
      JSB GETNA     MOVE 2 CHARS TO TBUF (CHARS 2,3)
      CPA CHAVR     CHARS = VR? 
      JMP STYPE     YES - GET DRIVER TYPE 
DVERR LDA ERR25     SET CODE = INVALID DRIVER NAME
      JSB ERROR     PRINT DIAGNOSTIC
      JMP SEQT      GET NEXT EQT RECORD 
STYPE LDA N2
      JSB GETNA     MOVE 2 CHARS TO TBUF
      STA ASTYP     SAVE 2 ASCII CHARS FOR I.XX,C.XX
      CCA 
      ADA CURAL     ADJUST CURRENT LBUF ADDR
      STA CURAL     RESET CURAL TO CONVERT TYPE 
      LDA P2
      JSB GETOC     GET 2 OCTAL CHARS, CONVERT
      JMP DVERR     INVALID DRIVER NAME 
      LDB OCTNO     GET DRIVER TYPE 
      BLF,BLF       ROTATE TO UPPER B 
      STB IOTYP     SET DRIVER TYPE 
      JSB GETAL     GET NEXT CHAR FROM LBUF 
      CPA ZERO      END OF BUFFER?
      JMP LISCN-1   SCAN FOR I.XX, C.XX 
      CPA BLANK     CHAR = COMMA? 
      RSS           YES - CONTINUE
      JMP DVERR     NO - INVALID DRIVER NAME
* 
      CCA 
      STA DFLAG     SET DMA-IN FLAG 
      STA BFLAG     SET BUFFERING-IN FLAG 
* 
INDBU CCA 
      STA CMFLG     SET COMMA FLAG = NO COMMA IN
      JSB GETAL     GET NEXT CHAR FROM LBUF 
      CPA CHARD     CHAR = D? 
      JMP SEDMA     YES - SET DMA CODE
      CPA CHARB     CHAR = B? 
      JMP SETBU     YES - SET BUFFERING CODE
      CPA CHART     CHAR = T? 
      JMP SETIM      YES - SET TIME-OUT FLAG
UNERR LDA ERR26     SET CODE = INVALID D,B,T
      JSB ERROR     PRINT DIAGNOSTIC
      JMP SEQT      GET NEXT EQT RECORD 
SETIM ISZ TFLAG     SKIP - FIRST T ENTERED
      JMP UNERR     DUPLICATE T'S ENTERED 
EQTST JSB GETAL     GET NEXT CHAR FROM LBUF 
      CPA ZERO      END OF BUFFER?
      JMP LISCN-1   SCAN FOR I.XX, C.XX 
      CPA BLANK     CHAR = COMMA? 
      JMP INDBU     YES - GET NEXT D,B,U, ENTRY 
      JMP UNERR     NO - INVALID D,B,U CHARACTER
* 
SEDMA ISZ DFLAG     SKIP - FIRST D ENTERED
      JMP UNERR     DUPLICATE D'S ENTERED 
      LDA MSIGN     SET BIT 15 = 1 FOR DMA FLAG 
      STA IODMA     SET DMA CODE
      JMP EQTST     TEST FOR NEXT OPERAND 
* 
SETBU ISZ BFLAG     SKIP - FIRST B ENTERED
      JMP UNERR     DUPLICATE B'S ENTERED 
      LDA BIT140    SET BIT14 = 1 
      STA IOBUF     SET AUTOMATIC BUFFERING CODE
      JMP EQTST     TEST FOR NEXT OPERAND 
* 
GENEQ JSB INLST     INITIALIZE LSTX 
LISCN JSB LSTX      SET LST ADDRESSES 
      JMP DVERR     I.XX NOT FOUND IN LST 
      LDA LST1,I    GET NAME 1,2 OF LST ENTRY 
      CPA IDEC      CHARS = I.? 
      RSS           YES - CONTINUE
      JMP LISCN     NO - TRY NEXT LST ENTRY 
      LDA LST2,I    GET NAME 3,4 OF LST ENTRY 
      CPA ASTYP     CHARS = XX IN DVRXX NAME? 
      RSS           YES - CONTINUE
      JMP LISCN     NO - TRY NEXT LST ENTRY 
      LDA LST3,I    GET NAME 5 OF LST NAME
      AND M7400     ISOLATE UPPER CHAR
      CPA UBLNK     CHAR = BLANK? 
      RSS           YES - CONTINUE
      JMP LISCN     NO - TRY NEXT LST ENTRY 
      LDA LST5,I    GET BP LINK ADDRESS 
      ADA M2000     ADJUST FOR BP ADDRESS 
      LDA A,I       GET ABSOLUTE ENTRY POINT ADDR 
      STA I.XX      SAVE DRIVER ENTRY POINT 
* 
      JSB INLST     INITIALIZE LSTX 
LCSCN JSB LSTX      SET LST ADDRESSES 
      JMP NOCXX     C.XX NOT FOUND IN LST 
      LDA LST1,I    GET NAME 1,2 OF LST ENTRY 
      CPA CDEC      CHARS = C.? 
      RSS           YES - CONTINUE
      JMP LCSCN     NO - TRY NEXT LST ENTRY 
      LDA LST2,I    GET NAME 3,4 OF LST ENTRY 
      CPA ASTYP     CHARS = XX IN DVRXX NAME? 
      RSS           YES - CONTINUE
      JMP LCSCN     NO - TRY NEXT LST ENTRY 
      LDA LST3,I    GET NAME 5 OF LST NAME
      AND M7400     ISOLATE UPPER CHAR
      CPA UBLNK     CHAR = BLANK? 
      RSS           YES - CONTINUE
      JMP LCSCN     NO - TRY NEXT LST ENTRY 
      LDA LST5,I    GET BP LINK ADDRESS 
      ADA M2000     ADJUST FOR BP ADDRESS 
      LDA A,I       GET ABSOLUTE COMP. POINT ADDR 
STCXX STA C.XX      SAVE DRIVER EXIT POINT
* 
      CLA 
      CLB,INB       SET COUNT = 1 
      JSB ALABD,I   PUT OUT I/O LIST POINTER
      LDA I.XX      GET DRIVER ENTRY POINT
      CLB,INB       SET COUNT =1
      JSB ALABD,I   OUTPUT ABSOLUTE DVRXX ENT ADDR
      LDA C.XX      GET DRIVER EXIT POINT 
      CLB,INB       SET COUNT = 1 
      JSB ALABD,I   OUTPUT ABSOLUTE DVRXX COMP. ADDR
      LDA IODMA     GET DMA CODE
      IOR IOBUF     ADD BUFFERING CODE
      IOR IOADD     ADD CHANNEL NO. 
      CLB,INB       SET COUNT = 1 
      JSB ALABD,I   OUTPUT D,B,U, CHANNEL 
* 
      LDA IOTYP     GET EQUIPMENT TYPE CODE 
      AND M7000     ISOLATE UPPER 7 BITS
      SZA           SKIP - TYPE = 0,I 
      CLA,RSS       SET STATUS = 0, SKIP
      LDA BLANK     SET STATUS = 40(8)
      IOR IOTYP     ADD EQUIPMENT TYPE CODE 
      CLB,INB       SET COUNT = 1 
      JSB ALABD,I   OUTPUT EQUIPMENT TYPE, STATUS 
* 
      LDA N8
      STA TCNT      SET TEMPORARY COUNT = -8
      CLA           SET EQT ENTRY WORD = ZERO 
      CLB,INB       SET COUNT = 1 
      JSB ALABD,I   OUTPUT ZERO TO EQT
      ISZ TCNT      SKIP - 8 ZEROES OUT 
      JMP *-4       CONTINUE ZERO OUTPUT
      LDA TFLAG     IF A TIME-OUT VALUE 
      SZA,RSS        IS TO BE ENTERED,
      JMP CLWD2      GO TO ENTER IT-
CLWD1 CLA 
      CLB,INB       FILL OUT
      JSB ALABD,I     REST OF EQT ENTRY 
      ISZ TFLAG 
      RSS 
      JMP CLWD1 
* 
      LDA PPREL     GET CURRENT EQT ADDRESS 
      ADA P15       ADD CURRENT ENTRY LENGTH
      STA PPREL     SET NEW RELOCATION ADDRESS
      ISZ CEQT      INCR EQT ENTRY COUNT
      JMP SEQT      PROCESS NEXT EQT RECORD 
* 
CLWD2 LDA P4
      LDB MES51     MES51 = ADDR:  T =
* 
      JSB READ
      LDA N5        GET T VALUE 
      JSB GETOC      AND CONVERT TO BINARY
      JMP CLWD2     INVALID ENTRY, REPEAT 
      SZA            IF ZERO, USE ZERO
      CMA           STORE -(T+1)
      CLB,INB        INTO EQT 
      JSB ALABD,I 
      JMP CLWD1     GO TO OUTPUT LAST EQT WORD
      SPC 1 
NOCXX LDA I.XX      C.XX NOT FOUND SO USE 
      JMP STCXX     I.XX ADDRESS
* 
*                                   SET DEVICE REFERENCE TABLE (SQT)
* 
SSQT  JSB SPACE     NEW LINE
      JSB SPACE     NEW LINE
      LDA PPREL     GET CURRENT RELOCATION ADDRESS
      STA ASQT      SAVE SQT ADDRESS
      CLA,INA 
      STA CSQT      SET SQT COUNT = 1 
      CCA 
      STA LFLAG     SET 1ST DEV REF INPUT FLAG = -1 
      LDA P24 
      LDB MES26     MES26 = ADDR: *DEV REF TABLE
      JSB DRKEY,I   PRINT: * DEVICE REFERENCE TABLE 
* 
DEVRE LDA CSQT      GET CURRENT DEV REF NO. 
      CMA,INA       SET TO NEG. FOR DECIMAL CONV
      LDB ATBUF     GET ADDRESS OF TBUF 
      JSB ACONV,I   CONVERT TO DECIMAL AT TBUF
      LDA TBUF+2    GET 2 LEAST SIGNIFICANT DIGITS
      AND M7400     ISOLATE UPPER CHAR
      CPA UASCZ     CHAR = ASCII ZERO?
      LDA UBLNK     YES - REPLACE WITH BLANK
      STA B         SAVE UPPER CHAR 
      LDA TBUF+2    GET 2-DIGIT DEV REF NO. 
      AND M177      ISOLATE LOWER CHAR
      IOR B         SET A = DEV REF CODE
      STA MES28,I   PUT DEV REF CODE IN MESSAGE 
      JSB SPACE     NEW LINE
      LDA P11 
      LDB MES28     MES28 = ADDR: XX = EQT #? 
      JSB READ      GET SQT RECORD FROM TTY 
      LDA N2
      JSB GETNA     MOVE 2 CHARS TO TBUF
      CPA PTERM     CHARS = /E? 
      JMP SINTT     YES - SET INTERRUPT TABLE 
      JSB GINIT     RE-INITIALIZE LBUF SCAN 
      LDA N3
      JSB GETOC     GET 2 DECIMAL DIGITS, CONVERT 
      JMP DRERR     INVALID DIGIT ENTERED 
      STA TEMPL     SAVE DEV. REF. NO.
      SZA,RSS       IF NO CHANNEL 
      JMP NOSUB     IGNOR SUBCHANNEL
      LDA CMFLG     COMMA ENCOUNTERED?
      SZA            YES - GO GET SUBCHANNEL
      JMP NOSUB      NO - DEFAULT IT TO ZERO
      INA 
      JSB GETOC     GET ONE OCTAL DIGIT 
      JMP DRERR 
      ALF,ALF       SET SUBCHANNEL NO.
      ALF,RAR        INTO BITS 13 - 11
      RSS 
NOSUB CLA           SET SUBCHANNEL = ZERO 
      STA TEMPH     SAVE SUBCHANNEL NO. 
      LDA TEMPL     GET DEV. REF. NO. 
      CMA,INA       COMPLEMENT
      ADA CEQT      ADD NO. EQT ENTRIES 
      SSA           SKIP IF VALID DEV. REF NO.
      JMP DRERR     INVALID DEV. REF. NO. (NO EQT)
      LDA TEMPL     GET DEV. REF NO.
      LDB CSQT      GET CURRENT SQT NO. 
      CPB P1        FIRST ENTRY?
      RSS           YES - CONTINUE
      CPB P2        SECOND ENTRY? 
      RSS           YES - CONTINUE
      JMP SESQT     PUT OUT DEV REF NO. TO SQT
      SZA,RSS       SKIP IF DEV REF IS NOT ZERO 
      JMP DRERR     INVALID DEV. REF. NO. 
      CPB P1        FIRST SQT ENTRY?
      RSS           YES - CONTINUE (SET TTY CHANNEL)
      JMP SESQT     PUT OUT DEV. REF. NO. TO SQT
      CMA,INA       COMPLEMENT CURRENT DEV. REF. NO.
      LDB AEQT      GET ADDRESS OF EQT
      INA,SZA,RSS   SKIP - DEV. REF. NOT 1
      JMP *+4       SET TTY CHANNEL NO. = FIRST EQT 
      ADB P15       ADJUST CURRENT EQT ADDRESS
      INA,SZA       SKIP - EQT FOUND
      JMP *-2       CONTINUE CURRENT EQT SEARCH 
      STB TTYCH     SET EQT ADDR IN TTY CHANNEL 
      LDA TEMPL     GET DEV. REF. NO. 
SESQT LDB CSQT      SET UP TO TEST LEGALITY OF
      CPA DRT2      DISK REFERENCES 
      JMP DRERR     ERROR - REFERENCE TO SYS DISK BY LU # 2 
      CPB P2        IF LU 2 SETUP 
      STA DRT2      SET FOR FUTURE TESTING
      CPB P2        IF LU 2 SET UP
      RSS           SKIP SUBCHANNEL 
      IOR TEMPH     ELSE - SET SUBCHANNEL 
      CPA DRT3      ILLEGAL REF TO AUX DISC?
      JMP DRERR     YES - TELL THE MAN
      SZA,RSS       IF ZERO ENTRY 
      JMP *+3       SKIP TEST 
      CPB P3        ELSE IF 3 
      STA DRT3      SET DRT3 FOR FUTURE TESTING 
      CLB,INB       SET COUNT = ONE 
      JSB ALABD,I   OUTPUT SQT ENTRY
      ISZ PPREL     INCR CURRENT RELOC ADDRESS
      ISZ CSQT      INCR CURRENT SQT COUNT
      JMP DEVRE     GET NEXT SQT ENTRY
DRERR LDA ERR27     SET CODE = INVALID DEV. REF. NO.
      JSB ERROR     PRINT DIAGNOSTIC
      JMP DEVRE     REPEAT INPUT
* 
TEMPL NOP 
TEMPH NOP 
      SKP 
SINTT JSB SPACE     NEW LINE
      JSB SPACE     NEW LINE
      CCA 
      ADA CSQT      SUBTRACT 1 FROM SQT COUNT 
      STA CSQT      SET SQT COUNT 
* 
*                                   SET INTERRUPT TABLE (INT) 
* 
      LDA PPREL     GET CURRENT RELOCATION ADDR 
      STA AINT      SAVE INTERRUPT TABLE ADDRESS
      LDA DSKAD     GET CURRENT ABS. CODE DISK ADDR 
      STA DSKIN     SAVE INT CODE DISK ADDR 
      LDA DCNT      GET CURRENT ABS. CODE DBUF COUNT
      STA INTCN     SAVE INT CODE DISK RECORD COUNT 
      LDA P17 
      LDB MES29     MES29 = ADDR. * INT TABLE 
      JSB DRKEY,I   PRINT: * INTERRUPT TABLE
      LDB AILST     GET ADDRESS OF ILIST
      STB CURIL     GET CURRENT ILIST ADDRESS 
      JSB BUFCL     CLEAR ILIST 
* 
      JSB INLST     INITIALIZE LSTX 
CISCN JSB LSTX      SET LST ADDRESSES 
      JMP NOCIC     CIC NOT FOUND IN LST
      LDA LST1,I    GET NAME 1,2 OF LST ENTRY 
      CPA CHR$C     CHARS = $C
      RSS           YES - CONTINUE
      JMP CISCN     NO - TRY NEXT LST ENTRY 
      LDA LST2,I    GET NAME 3,4 OF LST ENTRY 
      CPA CHRIC     CHARS = IC? 
      RSS           YES - CONTINUE
      JMP CISCN     NO - TRY NEXT LST ENTRY 
      LDA LST3,I    GET NAME 5 OF LST ENTRY 
      AND M7400     ISOLATE UPPER CHAR
      CPA UBLNK     CHAR = BLANK? 
      RSS           YES - CONTINUE
      JMP CISCN     NO - TRY NEXT LST ENTRY 
      LDA LST5,I    GET BP LINK ADDRESS 
CIC0  IOR IJSB      ADD JSB 0,I CODE
      STA JSCIC     SET JSB CIC,I CODE
      LDB FSYBP     GET FWA BP LINKAGE
      CMB,INB       COMPLEMENT
      STB TCNT      SET TEMPORARY COUNT 
      LDB M2000     ADJUST FOR FIRST BP ADDRESS 
      STA B,I       PUT JSB CIC,I IN BP LOCATION
      INB           INCR CURRENT BP ADDRESS 
      ISZ TCNT      SKIP - ALL INT LOCATIONS FILLED 
      JMP *-3       CONTINUE FILLING INT LOCATIONS
      LDB M2004     INITIALIZE TRAP CELL FOUR 
      LDA HLTB4      TO HALT(B) 4 
      STA B,I 
      LDB M2006     GET ADDR OF FIRST INT LOCATION
      STB TBREL     SET CURRENT BP ADDRESS
* 
SETIN CLA           NEW LINE
      JSB READ      GET INT RECORD FROM TTY 
      LDA N2
      JSB GETNA     MOVE 2 CHARS TO TBUF
      CPA PTERM     CHARS = /E? 
      JMP ENDIO     YES - I/O TABLES COMPLETE 
      JSB GINIT     RE-INITIALIZE LBUF SCAN 
      LDA P2
      JSB GETOC     GET 2 OCTAL DIGITS, CONVERT 
      JMP CHERR     INVALID INT CHANNEL NO. DIGIT 
      JSB GETAL     GET NEXT CHAR FROM LBUF 
      CPA BLANK     CHAR = COMMA? 
      JMP SETCH     SAVE INT CHANNEL NO.
CHERR LDA ERR28     SET CODE = INVALID INT CHNL NO. 
      JSB ERROR     PRINT DIAGNOSTIC
      JMP SETIN     REPEAT INT REC INPUT
* 
NOCIC LDA ERR21     SET CODE = $CIC NOT FOUND IN LST
      JSB IRERR     IRRECOVERABLE ERROR 
* 
SETCH LDA OCTNO     GET INT CHANNEL NO. 
      STA INTCH     SAVE CHANNEL NO.
* 
      LDA N2
      JSB GETNA     MOVE 2 CHARS TO TBUF
      CPA CHREQ     CHARS = EQ? 
      JMP INTEQ     YES - PROCESS INT EQT RECORD
      CPA CHRPR     CHARS = PR? 
      JMP INTPR     YES - PROCESS INT PRG RECORD
      CPA CHREN     CHARS = EN? 
      JMP INTEN     YES - PROCESS INT ENT RECORD
      CPA CHRAB     CHARS = AB? 
      JMP INTAB     YES - PROCESS INT ABS RECORD
IMNEM LDA ERR30     SET CODE = INVALID INT MNEMONIC 
      JSB ERROR     PRINT DIAGNOSTIC
      JMP SETIN     REPEAT INT REC INPUT
* 
INTEQ LDA N2
      JSB GETNA     MOVE NEXT 2 CHARS TO TBUF 
      CPA UTCHR     CHARS = T,BLANK?
      RSS           YES - CONTINUE
      JMP IMNEM     NO - INVALID INT MNEMONIC 
      LDA N2
      JSB GETOC     GET 2 DECIMAL DIGITS, CONVERT 
      JMP EQUER     INVALID EQT NO. IN INT REC
      LDB OCTNO     GET EQT TABLE ENTRY NO. 
      CMB,INB,SZB,RSS  SKIP - VALID LOWER LIMIT 
      JMP EQUER     INVALID EQT REFERENCE 
      STB TCHAR     SAVE EQT NO.
      ADB CEQT      ADD UPPER EQT REF. NO.
      SSB,RSS       SKIP - INVALID UPPER LIMIT
      JMP TSTIQ     TEST FOR FIRST EQT REFERENCE
EQUER LDA ERR31     SET CODE = INVALID EQT NO.
      JSB ERROR     PRINT DIAGNOSTIC
      JMP SETIN     REPEAT INT REC INPUT
* 
TSTIQ LDB TCHAR     GET EQT REF. NO.
      LDA AEQT      GET ADDR OF EQT 
      INB,SZB,RSS   SKIP - NOT FIRST EQT REFERENCE
      JMP SEQTI     SET EQT ADDR IN INT TABLE 
      ADA P15       ADJUST FOR NEXT EQT ENTRY ADDR
      INB,SZB       SKIP - EQT ADDRESS FOUND
      JMP *-2       CONTINUE EQT SEARCH 
SEQTI LDB JSCIC     GET JSB CIC CODE
      JMP COMIN     SET INTERRUPT TABLE, LOCATION 
* 
INTPR LDA N2
      JSB GETNA     MOVE 2 CHARS TO TBUF
      CPA UGCHR     CHARS = G,BLANK?
      RSS           YES - CONTINUE
      JMP IMNEM     NO - INVALID INT MNEMONIC 
      LDA N5
      JSB GETNA     MOVE 5 CHARS TO TBUF
* 
      JSB INIDX     INITIALIZE IDX
PRSCN JSB IDX       SET IDENT ADDRESSES 
      JMP PRERR     INVALID PROGRAM NAME
      LDA ID1,I     GET NAME 1,2 OF IDENT 
      CPA TBUF      CHARS EQUAL?
      RSS           YES - CONTINUE
      JMP PRSCN     TRY NEXT IDENT NAME 
      LDA ID2,I     GET NAME 3,4 OF IDENT 
      CPA TBUF+1    CHARS EQUAL?
      RSS           YES - CONTINUE
      JMP PRSCN     TRY NEXT IDENT NAME 
      LDA ID3,I     GET NAME 5 OF IDENT 
      AND M7400     ISOLATE UPPER CHAR
      CPA TBUF+2    CHARS EQUAL?
      RSS           YES - TEST FOR SYSTEM TYPE
      JMP PRSCN     TRY NEXT IDENT NAME 
      LDB JSCIC     GET JSB CIC CODE
      LDA ID1       GET CURRENT IDENT ADDRESS 
      STA CURIL,I   PUT IDENT ADDR IN ILIST 
      LDA CURIL     GET CURRENT ILIST ADDRESS.
      ISZ CURIL     INCR CURRENT ILIST ADDRESS
      JMP COMIN     SET INTERRUPT TABLE, LOCATION 
PRERR LDA ERR32     SET CODE = INVALID PROGRAM NAME 
      JSB ERROR     PRINT DIAGNOSTIC
      JMP SETIN     REPEAT INT REC INPUT
* 
* 
INTEN LDA N2
      JSB GETNA     MOVE 2 CHARS TO TBUF
      CPA UTCHR     CHARS = T, BLANK
      RSS           YES - CONTINUE
      JMP IMNEM     INVALID INT MNEMONIC
      LDA N5
      JSB GETNA     MOVE 5 CHARS TO TBUF
* 
      JSB INLST     INITIALIZE LSTX 
ENSCN JSB LSTX      SET LST ADDRESSES 
      JMP ENERR     INVALID ENTRY POINT 
      LDA LST1,I    GET NAME 1,2 OF LST ENTRY 
      CPA TBUF      CHARS EQUAL?
      RSS           YES - CONTINUE
      JMP ENSCN     NO - TRY NEXT LST ENTRY 
      LDA LST2,I    GET NAME 3,4 OF LST ENTRY 
      CPA TBUF+1    CHARS EQUAL?
      RSS           YES - CONTINUE
      JMP ENSCN     NO - TRY NEXT LST ENTRY 
      LDA LST3,I    GET NAME 5 OF LST ENTRY 
      AND M7400     ISOLATE UPPER CHAR
      CPA TBUF+2    CHARS EQUAL?
      RSS           YES - CONTINUE
      JMP ENSCN     NO - TRY NEXT LST ENTRY 
      LDA LST4,I    GET IDENT ADDR
      SZA,RSS       SKIP - ENT IS DEFINED 
      JMP ENERR     INVALID ENTRY POINT 
      STA TIDNT     SET IDENT ADDRESS OF PROGRAM
      JSB IDX       SET IDENT ADDRESSES 
      HLT 0B        END OF IDENT LIST 
      LDA ID6,I     GET PROGRAM TYPE
      AND M177      ISOLATE TYPE
      SZA,RSS       SKIP - NOT SYSTEM PROGRAM 
      JMP SETEN     SET ENTRY POINT ADDRESS 
ENERR LDA ERR33     SET CODE = INVALID ENTRY POINT
      JSB ERROR     PRINT DIAGNOSTIC
      JMP SETIN     REPEAT INT RECORD INPUT 
* 
SETEN LDA LST5,I    GET BP LINK ADDRESS 
      IOR IJSB      ADD JSB 0,I CODE
      STA B 
      CLA           SET INT ENTRY = ZERO
      JMP COMIN     SET INTERRUPT TABLE, LOCATION 
* 
INTAB LDA N2
      JSB GETNA     MOVE 2 CHARS TO TBUF
      CPA USCHR     CHARS = U,BLANK 
      RSS           YES - CONTINUE
      JMP IMNEM     NO - INVALID INT MNEMONIC 
      LDA P6
      JSB GETOC     GET 6 OCTAL DIGITS, CONVERT 
      JMP ABERR     INVALID ABS DIGIT 
      CLA 
      LDB OCTNO     GET ABSOLUTE VALUE
* 
COMIN STA TBUF      SAVE INT TABLE CODE 
      STB TBUF+1    SAVE INT LOCATION CODE
      JSB GETAL     GET NEXT CHAR FROM LBUF 
      CPA ZERO      END OF BUFFER?
      JMP *+4       YES - CONTINUE
      LDA ERR36     SET CODE = INVALID FINAL OPRND
      JSB ERROR     PRINT DIAGNOSTIC
      JMP SETIN     GET NEXT INT RECORD 
* 
      LDA INTCH     GET INT CHANNEL NO. 
      CPA P4        SPECIAL PROCESSING
      JMP PFINT      IF TRAP CELL FOUR
      CMA,INA 
      ADA L2000     ADJUST FOR BP LOCATION ADDR 
      ADA TBREL     ADD CURRENT BP ADDRESS
      SZA,RSS       SKIP - NOT NEXT LOCATION
      JMP STINT     SET INTERRUPT TABLES, LOCATION
      SSA           SKIP - INVALID CHANNEL NO. ORDER
      JMP FILLI     FILL IN SKIPPED VALUES
      LDA ERR29     SET CODE = INVALID INT CHNL ORDR
      JSB ERROR     PRINT DIAGNOSTIC
      JMP SETIN     GET NEXT INTERRUPT RECORD 
* 
PFINT LDA TBUF      IF TRAP CELL FOUR,
      SZA            ENTRY MUST BE AN 
      JMP CHERR      'ABS' OR AN 'ENT'
      LDA M2004 
      LDB TBUF+1    STORE INTO
      STB A,I        TRAP CELL FOUR 
      JMP SETIN     GET NEXT INTERRUPT RECORD 
* 
HLTB4 OCT 106004    TRAP CELL DEFAULT VALUE 
* 
FILLI STA TCNT      SET NO. OF FILL-INS REQUIRED
      CLA           SET INTERRUPT TABLE ENTRY = ZERO
      CLB,INB       SET COUNT = 1 
      JSB ALABD,I   OUTPUT ZERO TO INTERRUPT TABLE
      ISZ PPREL     INCR CURRENT INT TABLE ADDRESS
      LDA JSCIC     GET JSB CIC CODE
      STA TBREL,I   PUT JSB CIC IN INT LOCATION 
      ISZ TBREL     INCR CURRENT INT LOCATION ADDR
      ISZ TCNT      SKIP - ALL FILL-INS COMPLETE
      JMP FILLI+1   CONTINUE INT FILL-IN
* 
STINT LDB TBUF+1    GET INT LOCATION CODE 
      STB TBREL,I   PUT INT LOCATION CODE IN INT LOC
      ISZ TBREL     INCR CURRENT BP LOCATION ADDR 
      LDB TBREL     GET INT LOCATION ADDR 
      ADB L2000     ADJUST FOR BP ADDR
      CMB,INB 
      ADB FSYBP     ADD ADDR OF FIRST SYS LINK
      SSB,RSS       SKIP - INT LOCATION OVERFLOW
      JMP NOBPO     SET INT TABLE ENTRY 
      LDA ERR35     SET CODE = BP INT LOC OVERFLOW
      JSB ERROR     PRINT DIAGNOSTIC
      JSB SPACE     NEW LINE
      JMP AFWAP,I   GET FWA BP LINKAGE
* 
ABERR LDA ERR34     SET CODE = INVALID ABS DIGIT
      JSB ERROR     PRINT DIAGNOSTIC
      JMP SETIN     REPEAT INT REC INPUT
* 
NOBPO LDA TBUF      GET INT TABLE CODE
      CLB,INB       SET COUNT = 1 
      JSB ALABD,I   OUTPUT INT TABLE ENTRY
      ISZ PPREL     INCR CURRENT RELOCATION ADDR
      JMP SETIN     GET NEXT INT TABLE RECORD 
ENDIO LDA AINT      GET ADDRESS OF INT
      CMA,INA 
      ADA PPREL     ADD CURRENT RELOCATION ADDR 
      STA CINT      SAVE NO. INT ENTRIES
      JSB SPACE     NEW LINE
      JSB SPACE     NEW LINE
      JMP GENIO,I   RETURN - CONTINUE LOADING 
      SKP 
* 
*                                   GET CHAR FROM LBUF, RETURN IN A 
* 
*  THE FOLLOWING SUBROUTINE SUPPLIES THE CHARACTERS FOR 
*  GETNA AND GETOC. 
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB GETAL
* 
*  RETURN:
*    A = CURRENT CHARACTER
*    B = DESTROYED
* 
GETAL NOP 
      LDA CMFLG     CMFLG = COMMA-IN FLAG 
      SZA,RSS       SKIP IF NO COMMA IN 
      JMP BLRET     RETURN BLANK
      LDB BUFUL     GET U/L FLAG
IGNOR LDA CURAL,I   GET CHAR FROM LBUF
      SZB           SKIP IF LOWER CHAR
      ALF,ALF       ROTATE TO LOWER 
      AND M377      ISOLATE LOWER CHAR
      CPA ZERO      END OF BUFFER?
      JMP GETAL,I   YES - RETURN WITH ZERO
      CMB,SZB       RESET U/L, SKIP IF UPPER CHAR 
      ISZ CURAL     INCR LBUF ADDRESS 
      CPA BLANK     CHAR = BLANK? 
      JMP IGNOR     IGNORE BLANKS 
      STB BUFUL     SAVE U/L FLAG 
      CPA COMMA     CHAR = COMMA? 
      ISZ CMFLG     RESET FLAG TO SHOW COMMA IN 
      JMP GETAL,I   RETURN WITH NON-BLANK CHAR
BLRET LDA BLANK     REPLACE WITH BLANK CHAR 
      JMP GETAL,I   RETURN WITH BLANK 
      SKP 
* 
*                                   MOVE ALPHA FROM LBUF TO TBUF
* 
*  THE FOLLOWING SUBROUTINE MOVES THE CHARACTERS FROM LBUF
*  TO TBUF. 
* 
*  CALLING SEQUENCE:
*    A = MAX. NO. OF CHARACTERS TO BE MOVED.  THE SIGN OF A 
*        DESIGNATES THE POSITION OF THE FIRST CHARACTER.
*        IF THE SIGN OF A IS POSITIVE, THE FIRST CHAR IS TO 
*        BE MOVED TO THE LOW CHAR IN TBUF.  IF A IS NEGATIVE, THE 
*        FIRST CHARACTER IS TO BE MOVED TO THE UPPER CHAR IN TBUF.
*    B = IGNORED
*    JSB GETNA
* 
*  RETURN:
*    A = FIRST CHAR (IF ONLY 1 CHAR) OR FIRST 2 CHARS MOVED.
*    B = DESTROYED
* 
GETNA NOP 
      CCE,SSA,RSS   SET E = 1 (EVEN) POSITION 
      CMA,CLE,INA   SET E = 0 (ODD) POSITION - COMP 
      STA MAXC      MAXC = MAXIMUM NO. CHARS
      LDA ATBUF     ATBUF = ADDR OF TBUF
      STA CURAT     SET CURRENT TBUF ADDRESS
      CLB 
      STB TBUF      CLEAR WORD 1 OF TBUF
      CCA 
      STA CMFLG     SET COMMA-IN FLAG 
      SEZ,RSS       SKIP - ODD POSITION 
      JMP OCHAR     BEGIN WITH ODD CHARACTER
NEXTC JSB GETAL     GET CHAR FROM LBUF
      CPA ZERO      END OF BUFFER?
      LDA BLANK     YES - REPLACE CHAR WITH BLANK 
      ALF,ALF       ROTATE TO UPPER A 
      STA CURAT,I   SET CHARACTER IN TBUF 
      ISZ MAXC      CHECK FOR ALL CHARS IN
      JMP OCHAR     GET ODD CHAR FROM LBUF
      LDA TBUF      GET FIRST 2 TRANSFERRED CHARS 
      JMP GETNA,I   YES - RETURN
OCHAR JSB GETAL     GET CHAR FROM LBUF
      CPA ZERO      END OF BUFFER?
      LDA BLANK     REPLACE ZERO CHAR WITH BLANK
      IOR CURAT,I   ADD TO UPPER CHAR IN TBUF 
      STA CURAT,I   SET CHARS IN TBUF 
      ISZ CURAT     INCR TBUF ADDRESS 
      ISZ MAXC      CHECK FOR ALL CHARS IN
      JMP NEXTC     NO - TRY NEXT UPPER CHAR
      LDA TBUF      GET FIRST 2 TRANSFERRED CHARS 
      JMP GETNA,I   RETURN
      SKP 
* 
*                                   CONVERT OCT/DEC ASCII TO BINARY 
* 
*  THE GETOC SUBROUTINE CONVERTS THE NEXT CHARACTERS IN LBUF FROM 
*  ASCII (DECIMAL OR OCTAL) TO THEIR BINARY VALUE.
* 
*  CALLING SEQUENCE:
*    A = MAX. NO. OF CHARS IN CONVERSION REQUEST.  IF A IS
*        POSITIVE, THE REQUEST IS FOR OCTAL; IF A IS NEGATIVE,
*        THE REQUEST IS FOR DECIMAL.
*    B = IGNORED
*    JSB GETOC
* 
*  RETURN:
*    (N+1): INVALID DIGIT OR OVERFLOW IN CONVERSION 
*    (N+2): A = CONVERTED NO. 
*           B = DESTROYED 
* 
GETOC NOP 
      LDB L10       GET OCTAL RANGE 
      SSA           SKIP IF OCTAL REQUEST 
      LDB L12       GET DECIMAL RANGE 
      STB DRANG     SET DIGIT RANGE 
      SSA,RSS       SKIP IF DECIMAL REQUEST 
      CMA,INA       SET REQUEST COUNT TO NEGATIVE 
      STA MAXC      SET MAX NO. OF DIGITS 
      CCA 
      STA DIFLG     SET DATA-IN FLAG = NO DATA IN 
      STA CMFLG     SET COMMA-IN FLAG 
      CLA 
      STA OCTNO     OCTNO = OCTAL NUMBER
GETNX JSB GETAL     GET CHAR FROM LBUF
      CPA ZERO      CHAR = ZERO? (END OF BUFFER)
      JMP ENDOC     YES - RETURN
      CPA BLANK     CHAR = BLANK? (COMMA IN)
      JMP ENDOC     YES - RETURN
      ADA L60       SUBTRACT 60B FROM CHAR
      STA TCHAR     SAVE CHAR 
      SSA           SKIP IF VALID LOWER LIMIT 
      JMP DGERR     INVALID DIGIT 
      ADA DRANG     ADD DIGIT RANGE 
      CLE,SSA,RSS   CLEAR E - SKIP IF VALID DIGIT 
      JMP DGERR     INVALID DIGIT 
      ISZ DIFLG     INCR DATA-IN FLAG, SKIP 
      NOP 
      LDA OCTNO     GET PREVIOUS OCTAL NO.
      ADA A         SET A = OCTNO X 2 
      ADA A         SET A = OCTNO X 4 
      LDB DRANG     GET DIGIT RANGE 
      CPB L12       RANGE = DECIMAL?
      ADA OCTNO     SET A = OCTNO X 5 
      ADA A         SET A = OCTNO X 10/8
      ADA TCHAR     SET A = NEW OCTAL NO. 
      STA OCTNO     SAVE NEW OCTAL NO.
      SEZ           TEST FOR OVERFLOW 
      JMP DGERR     INVALID NO. 
      ISZ MAXC      SKIP IF ALL DIGITS PROCESSED
      JMP GETNX     GET NEXT DECIMAL DIGIT
      ISZ GETOC     INCR RETURN ADDRESS 
      LDA OCTNO     GET OCTAL EQUIVALENT
DGERR JMP GETOC,I   RETURN
ENDOC ISZ DIFLG     SKIP - NO DATA IN 
      JMP *-4       DATA IN - NORMAL RETURN 
      JMP GETOC,I   RETURN - ERROR
      SKP 
* 
*                                   INITIALIZE CHAR TRANSFER
* 
*  THE GINIT SUBROUTINE SETS THE CURRENT ADDRESS AND UPPER/LOWER
*  FLAG FOR SCANNING LBUF.
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB GINIT
* 
*  RETURN : CONTENTS OF A AND B ARE DESTROYED 
* 
GINIT NOP 
      LDA ALBUF     ALBUF = ADDR OF LBUF
      STA CURAL     SET CURRENT LBUF ADDRESS
      CCB 
      STB BUFUL     BUFUL = BUFFER U/L FLAG 
      JMP GINIT,I   RETURN
      SKP 
* 
* 
PTERM ASC 1,/E
* 
MES24 DEF MS24
MES51 DEF MS51
MES28 DEF MS28
MES29 DEF MS29
* 
COMMA OCT 054       COMMA 
IJSB  JSB 0,I       I-JSB CODE FOR INTERRUPT LOCS 
UASCZ OCT 30000     UPPER ASCII ZERO CHAR 
CHARD OCT 104       ASCII CHAR D
CHARB OCT 102       ASCII CHAR B
CHART OCT 124       ASCII CHAR T
BIT14 OCT 40000     BIT 14 = 1
IDEC  ASC 1,I.
CDEC  ASC 1,C.
CHR$C ASC 1,$C
CHRIC ASC 1,IC
CHAVR ASC 1,VR
CHREQ ASC 1,EQ
CHRPR ASC 1,PR
CHREN ASC 1,EN
CHRAB ASC 1,AB
UTCHR ASC 1,T 
UGCHR ASC 1,G 
USCHR ASC 1,S 
* 
TEMPE BSS 1         PARAMETER ERROR CODE
PARNO BSS 1         PARAMETER RECORD LENGTH 
* 
IOADD BSS 1         I/O ADDR (CHANNEL NO.) IN EQT 
IODMA BSS 1         I/O DMA FLAG IN EQT 
IOBUF BSS 1         I/O BUFFERING FLAG IN EQT 
IOTYP BSS 1         I/O DRIVER TYPE IN EQT (OCTAL)
ASTYP BSS 1         I/O DRIVER TYPE IN EQT (ASCII)
DFLAG BSS 1         DMA-IN FLAG FOR EQT 
BFLAG BSS 1         BUFFERING-IN FLAG FOR EQT 
TFLAG BSS 1         TIME-OUT ENTRY FLAG FOR EQT 
INTCH BSS 1         INT RECORD CHANNEL NO.
JSCIC BSS 1         JSB CIC,I CODE FOR INTERRUPT LOC
I.XX  BSS 1         DRIVER ENTRY POINT
C.XX  BSS 1         DRIVER EXIT POINT 
* 
DRANG BSS 1         DIGIT RANGE 
DIFLG BSS 1         DATA-IN FLAG = -1/0 = NOT IN/IN 
CMFLG BSS 1         COMMA FLAG = -1/0 = NOT IN/IN 
BUFUL BSS 1         BUFFER U/L FLAG 
MS24  ASC 5,PARAMETERS
MS51  ASC 2, T =
MS28  ASC 6,   =EQT #?
MS29  ASC 9,* INTERRUPT TABLE 
      SKP 
* 
*                                   LOAD ABSOLUTE SYSTEM
* 
*  THIS SECTION OF CODE CONTROLS THE GENERATION OF
*  THE ABSOLUTE CODE FOR THE SYSTEM.  EACH PROGRAM
*  IS LOADED BY TYPE AS FOLLOWS:
* 
*    (1) SYSTEM 
*    (2) RESIDENT LIBRARY 
*    (3) RT RESIDENTS 
*    (4) RT DISK RESIDENTS
*    (5) BG RESIDENTS 
*    (6) BG DISK RESIDENTS (AND BG SEGMENTS)
* 
*  EACH TYPE OF PROGRAM IS LOADED IN THE FOLLOWING MANNER:
* 
*  (1) THE IDENTIFICATION BLOCK FOR THE PROGRAM IS LOCATED
*  IN IDENT.  A CALL TO LOAD IS EXECUTED TO LOAD THIS PROGRAM AND 
*  ALL CALLED SUBROUTINES.  IF THE PROGRAM IS DISK RESIDENT,
*  THE BASE PAGE SECTION OF CODE IS WRITTEN ON THE DISK 
*  IMMEDIATELY AFTER THE MAIN SECTION OF CODE.  IF THE
*  PROGRAM IS RT DISK RESIDENT, THE BOUNDARIES OF THE LARGEST 
*  SECTION OF BASE PAGE AND PROGRAM ARE SAVED.  IF THE PROGRAM IS 
*  A USER PROGRAM (OTHER THAN SYSTEM USER PROGRAM) AN ID SEGMENT IS 
*  GENERATED.  FINALLY, THE BASE PAGE LINKAGE ADDRESSES ARE MADE
*  UNAVAILABLE TO SUBSEQUENT PROGRAMS IF THE PROGRAM IS DISK RESIDENT.
* 
*  THE ALLOCATION OF MEMORY TO THE SYSTEM IS GIVEN BELOW: 
* 
      SKP 
**************************************************
*                                                *
*                                                *
*            BG DISK RESIDENTS                   *
*                                                *
*                                                *
**************************************************
*                                                *
*                                                *
*                BG RESIDENTS                    *
*                                                *
*                                                *
**************************************************
*                 BG COMMON                      *
**************** BG BOUNDARY *********************
*                                                *
*                                                *
*          SYSTEM AVAILABLE MEMORY               *
*                                                *
*                                                *
**************************************************
*                                                *
*                                                *
*              RT DISK RESIDENTS                 *
*                                                *
*                                                *
**************************************************
*                                                *
*                                                *
*                 RT RESIDENTS                   *
*                                                *
*                                                *
**************************************************
*                  RT COMMON                     *
***************** RT BOUNDARY ********************
*                                                *
*              RESIDENT LIBRARY                  *
*                                                *
**************************************************
*                                                *
*             DISK ALLOCATION TABLE              *
*                  ID SEGMENTS                   *
*                   KEYWORDS                     *
*                 SYSTEM TABLES                  *
*                                                *
**************************************************
*                                                *
*                                                *
*                 RT EXECUTIVE                   *
*                                                *
*                                                *
********************* 2000 ***********************
*                                                *
*               BASE PAGE LINKAGES               *
*                                                *
**************************************************
      SKP 
*                                   SET FWA BP LINKAGE
FWENT JSB SPACE                                    $
      LDA P15                                      $
      LDB MES27     MES27 = ADDR: FWA BP LINKAGE? 
      JSB AREAD,I    PRINT AND GET REPLY
      LDA P4
      JSB AGETO,I   GET 4 OCTAL DIGITS, CONVERT 
      JMP LNKER     INVALID DIGIT ENTERED 
      JSB AGETA,I   GET NEXT CHAR FROM LBUF 
      CPA ZERO      END OF BUFFER?
      JMP SETFB     YES - SET FWA BP LINKAGE
LNKER LDA ERR23     GET ERROR CODE FOR INVALID REPLY
      JSB ERROR     PRINT DIAGNOSTIC
      JMP FWENT     REPEAT MESSAGE
SETFB LDB OCTNO     GET FWA BP
      SZB,RSS       SKIP - VALID (NON-ZERO) FWA BP
      JMP LNKER     REPEAT FWA BP LINKAGE INPUT 
      STB FSYBP     SET ADDR OF FIRST SYS LINK
      STB BPMAX     INITIALIZE NEXT AVAILABLE LINK POINTER
      JSB SPACE     NEW LINE
* 
*                                   CLEAR LST WORD 5
      JSB INLST     INITIALIZE LST ADDRESSES
CLLST JSB LSTX      SET LST ADDRESSES 
      JMP CLRID-1   CLEAR USAGE FLAGS 
      CLA 
      STA LST5,I    CLEAR LST WORD 5
      LDA LST3,I    GET WORD 3 OF LST ENTRY 
      AND M7400     ISOLATE UPPER CHARACTER 
      STA LST3,I    SET LST WORD 3 WITH NO ORDINAL
      JMP CLLST     CONTINUE CLEARING LST 
* 
*                                   CLEAR PROGRAM USAGE FLAGS 
      JSB INIDX     INITIALIZE IDENT ADDRESSES
CLRID JSB IDX       SET IDENT ADDRESSES 
      JMP IDCLR     ALL IDENT FLAGS CLEAR 
      LDA ID3,I     GET USAGE FLAG
      AND M7400     SET FLAG = ZERO 
      STA ID3,I     SET CLEARED USAGE FLAG
      JMP CLRID     CLEAR NEXT IDENT FLAG 
*                                   CLEAR PAGE 1 FOR INDIRECT LINKS 
IDCLR LDA L2000 
      STA WDCNT     SET WORD COUNT = 2000(8)
      CLA 
      LDB M2000     GET ADDRESS OF PAGE 1 
CLRBP STA B,I       CLEAR WORD IN BASE PAGE AREA
      INB           INCR PAGE ADDRESS 
      ISZ WDCNT     SKIP - AREA CLEARED 
      JMP CLRBP     CONTINUE CLEARING 
      SKP 
* 
*                                   LOAD INITIALIZATION 
      CLA 
      STA LIBFG     SET LIB FLAG TO SHOW NOT LIBRARY
      STA KEYCT                                    $
      STA RELAD     CLEAR RELOCATION ADDR FOR LABDO 
      STA COMAD     CLEAR COMMON RELOC BASE 
      STA PTYPE     SET PROGRAM TYPE = SYSTEM 
      STA URBP      CLEAR UPPER RESIDENR BP BOUND 
      STA LBBP      CLEAR LOW BACKGROUND BP BOUND 
      STA UBBP      CLEAR HIGH BACKGROUND BP BOUND
      LDA FSYBP     GET FIRST WORD AVAIL BP LINKAGE 
      STA LRBP      CLEAR LOW RESIDENT BP BOUND 
      STA PBREL     SET BP RELOC ADDR 
      LDA M2000 
      STA PPREL     SET PROGRAM RELOC ADDR
      STA LRMAN     SET LOWER RESIDENT MAIN ADDR
      LDA N64 
      STA DCNT      INITIALIZE ABSOLUTE OUTPUT COUNT
      LDB ADBUF     GET ADDRESS OF DBUF 
      STB CURAD     SET CURRENT DBUF ADDRESS
      LDA DSKAB     GET INITIAL ABSOLUTE DISK ADDR
      STA DSKAD     SET CURRENT ABSOLUTE DISK ADDR
      STA DSKBP     SET INITIAL BP ADDRESS
* 
      LDA M2000     GET UPPER ADDRESS OF BASE PAGE
      STA UBPSY     SAVE UPPER BP DISK ADDRESS
      LDB P2        GET LOWER ADDRESS OF BASE PAGE
      STB LBPSY     SAVE LOWER BP DISK ADDRESS
      JSB ABPOT,I   OUTPUT RESIDENT BP CODE 
      LDA DSKAD     GET CURRENT DISK ADDRESS
      STA DSKRR     SET MAIN RESIDENT DISK ADDRESS
      SKP 
* 
*                                   LOAD SYSTEM 
      JSB SPACE     NEW LINE
      LDA P6
      LDB MES12     MES12 = ADDR: SYSTEM
      JSB SETHD     PRINT HEADING, INITIALIZE IDX 
SYLD  JSB AIDSN,I   SCAN IDENTS 
      JMP SYEND     END OF IDENTS 
      LDB ID3,I     GET USAGE FLAG
      SLB,INB       SKIP IF UNUSED
      JMP SYLD      IGNORE USED PROGRAM 
      STB ID3,I     SET WORD 3 WITH USAGE FLAG
      JSB ALOAD,I   INITIATE AND LOAD MAIN PROGRAM
      JSB INCAD     UPDATE BP, PROG RELOC ADDR
      LDA TBREL     GET CURRENT BP ADDRESS
      STA URBP      SET UPPER RESIDENT BP BOUND 
      JMP SYLD      PROCESS NEXT SYSTEM PROGRAM 
* 
SYEND JSB ANOTS,I   TEST FOR PROGRAMS LOADED
      JSB SPACE     NEW LINE
      JSB AGNIO,I   SET I/O TABLES
* 
*                                   MOVE DBUF TO KBUF 
      LDA DSKAD     GET CURRENT ABSOLUTE DISK ADDR
      STA DSKEY     SAVE DISK ADDR FOR KEYWORDS 
      LDB AKBUF     GET ADDRESS OF KBUF 
      JSB AMOVE,I   MOVE DBUF TO KBUF FOR KEYWORDS
      STA KCNT      SET CURRENT KBUF COUNT
      ADA P64 
      ADA AKBUF     SET A = CURRENT KBUF ADDRESS
      STA CURAK     SET CURRENT KBUF ADDRESS
      LDB AKBUF     CLEAR 
      JSB BUFCL       KBUF
* 
*                                   OUTPUT SPACE FOR KEYWORDS 
      LDA PPREL     GET CURRENT PROGRAM RELOC ADDR
      STA KEYAD     SET CURRENT KEYWORD ADDRESS 
      ADA KEYCN     ADD TOTAL KEYWORD COUNT 
      STA PPREL     SET NEW RELOC ADDRESS FOR ID SEG
      STA SYSAD     SET INITIAL ID SEGMENT ADDRESS
      STA IDSAD     SET ADDR OF FIRST ID SEG
      CMA,INA 
      ADA KEYAD     SET A = TOTAL KEYWORD LENGTH
      STA TCNT      SET KEYWORD LENGTH
      CLA 
      CLB,INB       SET COUNT = 1 
      JSB ALABD,I   OUTPUT SPACE FOR KEYWORD TO DISK
      ISZ TCNT      SKIP - SPACE RESERVED FOR KEYS
      JMP *-4       CONTINUE RESERVING KEYWORD SPACE
* 
*                                   TRANSFER DBUF TO IBUF 
      LDA DSKAD     GET CURRENT DISK ADDRESS
      STA DSKID     SET DISK ID ADDRESS 
      STA DSKSY     SET INITIAL ID SEGMENT DISK ADDR
      LDB AIBUF     GET ADDRESS OF IBUF 
      JSB AMOVE,I   MOVE DBUF TO IBUF FOR ID SEGMENT
      STA ICNT      SET CURRENT IBUF COUNT
      ADA P64       SET A = NUMBER WORDS IN LBUF
      STA IDSP      SAVE ID SEGMENT POSITION      $$
      ADA AIBUF     ADD ADDRESS OF IBUF 
      STA CURAI     SET CURRENT IBUF ADDRESS
      LDB AIBUF     CLEAR 
      JSB BUFCL      IBUF 
* 
*                                   SAVE SPACE FOR ID SEGS,DISK DICT
      LDA SICNT     GET SHORT ID SEGMENT COUNT
      LDB PPREL     GET CURRENT RELOCATION ADDRESS
      CMA,INA,SZA,RSS  COMPLEMENT, SKIP IF NOT ZERO 
      JMP NOSID     NO SHORT ID SEGMENTS
      ADB P22       ADJUST FOR SHORT ID SEG LENGTH
      INA,SZA       SKIP - SET PPREL FOR LONG SEGS
      JMP *-2       CONTINUE COUNTING SHORT ID SEGS 
NOSID LDA LICNT     GET LONG ID SEGMENT COUNT 
      CMA,INA       SET TOTAL LONG ID SEG LENGTH
      ADB P28       ADJUST LENGTH FOR LONG ID SEG 
      INA,SZA       SKIP - RESERVE SPACE FOR ID SEGS
      JMP *-2       CONTINUE COUNTING LONG ID SEGS
      STB ADICT     SAVE ADDR OF DISK DICTIONARY
      ADB DSIZE    ADJUST FOR DISC DICT LENGTH
      ADB DAUXN         + AUX DISC LENGTH 
      STB PPREL     SAVE NEW MAIN RELOCATION ADDRESS
      STB LBCAD     SAVE LIBRARY CODE ADDRESS 
      CMB,INB       COMPLEMENT
      ADB SYSAD     ADD INITIAL ID SEGMENT ADDRESS
      STB TCNT      SAVE TOTAL KEYWORD, ID LENGTH 
      CLA 
      CLB,INB       SET COUNT FOR 1 WORD
      JSB ALABD,I   OUTPUT ZERO 
      ISZ TCNT      SKIP - ALL SPACE RESERVED 
      JMP *-4       REPEAT ZERO OUTPUT
* 
      CCA           SET LIB FLAG TO SHOW LIB LOADING
      STA LIBFG     SO ONLY TYPE  6 PROGRAMS WILL LOAD
      JSB ALRT6,I   GO CLEAR LOAD FLAGS FOR TYPE 6 PGMS 
      CLA,INA       SET TO GET TYPE 6 USED
      STA PTYPE     WITH RT-RESIDENTS 
      LDA DSKAD     GET CURRENT DISK ADDRESS
      STA DSKLC     SAVE DISK ADDR OF LIBRARY CODE
* 
      SKP 
*                                   LOAD LIBRARY
      LDA P7
      LDB MES13     MES13 = ADDR: LIBRARY 
      JSB SETHD     PRINT HEADING, INITIALIZE IDX 
LDLB  JSB AIDSN,I   SCAN IDENTS 
      JMP LBEND     END OF IDENTS 
      LDB ID3,I     GET USAGE FLAG
      SLB,INB       SKIP IF UNUSED LIBRARY ROUTINE
      JMP LDLB      IGNORE USED PROGRAM 
      JSB ALOAD,I   INITIATE AND LOAD MAIN PROGRAM
      JSB INCAD     UPDATE BP, PROG RELOC ADDR
      LDA TBREL     GET CURRENT BASE PAGE ADDRESS 
      STA URBP      SET UPPER RESIDENT BP BOUND 
      JMP LDLB      PROCESS MEXT LIBRARY PROGRAM
* 
LBEND LDA P4        WAS LIB LOAD FOR
      CPA PTYPE     BACKGROUND RES? 
      JMP COMTS     YES; DONE 
      STA PTYPE     NO; SET FOR BACKGROUND RES
      LDA BIDNT     RESET IDX 
      STA CIDNT     TO START OF LIST
      JMP LDLB      GO CHECK FOR BACK GROUND RES LIB
      SPC 1 
COMTS CLA           CLEAR LIB LOAD FLAG 
      STA LIBFG 
      JSB SPACE 
      JSB DEMOT,I   DEMOT UN CALLED TYPE 6 TO TYPE 7
      JSB ANOTS,I   TEST FOR PROGRAMS LOADED
      JSB SPACE     NEW LINE
      LDA PPREL     GET CURRENT PROG RELOCATION BASE
      STA RTCAD     SAVE RT LOAD ADDRESS
      LDB COMRT     GET RESIDENT COMMON LENGTH
      SZB,RSS       SKIP IF NON-ZERO
      JMP COMRZ     IGNORE ZERO COMMON
* 
*                                   PUT OUT HALTS FOR RT COMMON 
      LDA PPREL     GET CURRENT PROG RELOC ADDR 
      STA COMAD     SET RESIDENT COMMON BASE
      STA RELAD     SET CURRENT RELOCATION ADDRESS
      ADB A 
      STB PPREL     SET NEW PROG RELOC ADDR 
      LDB MES14+1   GET MESSAGE ADDRESS 
      JSB ACONV,I   CONVERT TO DECIMAL IN MESSAGE 
      LDA P16 
      LDB MES14     MES14 = ADDR: RT COM
      JSB DRKEY,I   PRINT LISTING 
      JSB SPACE     NEW LINE
      LDB COMRT     GET RT COM LENGTH 
      CMB,INB 
      STB TCNT      SET RT COM LENGTH 
      LDA HLT0      GET HALT CODE FOR RT COM
      CLB,INB       SET COUNT = 1 
      JSB ALABD,I   OUTPUT HALT CODE FOR COMMON 
      ISZ TCNT      SKIP - RT COM FILLED WITH HALTS 
      JMP *-4       CONTINUE FILLING RT COMMON
COMRZ CLA,INA 
      STA PTYPE     SET PROGRAM TYPE = RT RESIDENT
      SKP 
* 
*                                   LOAD RT RESIDENTS 
      LDA P12 
      LDB MES15     MES15 = ADDR: RT RESIDENTS
      JSB SETHD     PRINT HEADING, INITIALIZE IDX 
RRLD  JSB AIDSN,I   SCAN IDENTS 
      JMP RREND     END OF IDENTS 
      SEZ,RSS       SKIP IF MAIN
      JMP RRLD      IGNORE SUB
      LDB ID3,I     GET USAGE FLAG
      SLB,INB       SKIP - PROGRAM NOT LOADED 
      JMP RRLD      IGNORE LOADED PROGRAM 
      STB ID3,I     SET NEW USAGE FLAG
      JSB ALOAD,I   INITIATE AND LOAD MAIN PROGRAM
      CLA 
      JSB AGEND,I   GENERATE ID SEGMENT, KEYWORD
      JSB INCAD     UPDATE BP, PROG RELOC ADDR
      LDA TBREL     GET CURRENT BASE PAGE ADDRESS 
      STA URBP      SET UPPER RESIDENT BP BOUND 
      JMP RRLD      PROCESS NEXT RT RESIDENT
* 
RREND JSB ANOTS,I   TEST FOR PROGRAMS LOADED
      JSB SPACE     NEW LINE
      LDA PPREL     GET CURRENT PROG RELOCATION BASE
      STA URMAN     SET UPPER RESIDENT MAIN ADDR
      JSB AREMD,I   OUTPUT REMAINDER OF RECORD
* 
*                                   SCAN LST FOR INITIAL ENTRY POINT
      JSB INLST     INITIALIZE LSTX 
STSCN JSB LSTX      SET LST ADDRESSES 
      HLT 0B        START NOT FOUND IN LST
      LDA LST1,I    GET NAME 1,2
      CPA CHR$S     CHARS = $S? 
      RSS           YES - CONTINUE
      JMP STSCN     NO - TRY NEXT LST ENTRY 
      LDA LST2,I    GET NAME 3,4
      CPA CHRTR     CHARS = TR? 
      RSS           YES - CONTINUE
      JMP STSCN     NO - TRY NEXT LST ENTRY 
      LDA LST3,I    GET NAME 5
      AND M7400     ISOLATE UPPER CHAR
      CPA UCHRT     CHAR = T? 
      RSS           YES - START FOUND 
      JMP STSCN     NO - TRY NEXT LST ENTRY 
      LDB M2002     GET ADDR FOR JMP,I START
      LDA JMP3I     GET JMP 3,I CODE
      STA B,I       SET JMP 3,I IN BP LOCATION
      INB           INCR CURRENT BP ADDRESS 
      LDA LST5,I    GET BP ADDR FOR START 
      ADA M2000     ADJUST FOR BP ADDRESS 
      LDA A,I       GET ABSOLUTE ENTRY POINT ADDR 
      STA B,I       SET ADDR OF START IN BP LOCATION
      CLA 
      STA MAXRP     CLEAR MAX RT DISK RES PROG LGTH 
      STA MAXRB     CLEAR MAX RT DISK RES BP LENGTH 
      ISZ PTYPE     SET PROGRAM TYPE = RT DISK RES
      SKP 
* 
*                                   LOAD RT DISK RESIDENTS
      LDA P17 
      LDB MES16     MES16 = ADDR: RT DISK RESIDENTS 
      JSB SETHD     PRINT HEADINGS, INITIALIZE IDX
RDLD  JSB AIDSN,I   SCAN IDENTS 
      JMP RDEND     END OF IDENTS 
      SEZ,RSS       SKIP IF MAIN
      JMP RDLD      IGNORE SUBS 
      LDB ID3,I     GET USAGE FLAG
      SLB,INB       SKIP - PROGRAM NOT LOADED 
      JMP RDLD      IGNORE LOADED PROGRAM 
      STB ID3,I     SET NEW USAGE FLAG
      JSB ALOAD,I   INITIATE AND LOAD MAIN PROGRAM
      CCA 
      JSB AGEND,I   GENERATE ID SEGMENT, KEYWORD
      LDA PPREL     GET PROG RELOC ADDR 
      CMA,INA 
      ADA TPREL     SET A = PROG LENGTH 
      LDB MAXRP     GET PREVIOUS MAX PROG LENGTH
      CMB,INB 
      ADB A         SET B = PROG LENGTH - MAX LENGTH
      SSB,RSS       SKIP IF NO NEW MAXIMUM
      STA MAXRP     SET NEW MAX PROG LENGTH 
      LDA PBREL     GET BP RELOC ADDR 
      CMA,INA 
      ADA TBREL     SET A = BP LENGTH 
      LDB MAXRB     GET PREVIOUS MAX BP LENGTH
      CMB,INB 
      ADB A         SET B = BP LENGTH - MAX LENGTH
      SSB,RSS       SKIP IF NO NEW MAXIMUM
      STA MAXRB     SET NEW MAX BP LENGTH 
      JSB AREMD,I   OUTPUT REMAINING OF ABS REC 
      LDA TBREL     GET UPPER BP ADDRESS
      LDB PBREL     GET LOWER BP ADDRESS
      JSB ABPOT,I   OUTPUT BP SECTION 
      LDA PBREL     GET LOWER RT DISK RES BP ADDR 
      LDB TBREL     GET UPPER BOUND BP ADDRESS
      JSB ACLRT,I   CLEAR LOCAL BP LINKS
      JMP RDLD      PROCESS NEXT RT DISK RESIDENT 
* 
RDEND JSB ANOTS,I   TEST FOR PROGRAMS LOADED
      JSB SPACE     NEW LINE
* 
* 
BPCHA LDA P18       ASK:
      LDB MES2       CHANGE BP LINKAGE? 
      JSB AREAD,I    GET ANSWER 
      LDA P5        CONVERT FIVE DIGITS 
      JSB AGETO,I    OCTAL
      JMP CBPER     INPUT ERROR 
      JSB AGETA,I   NEXT CHARACTER
      SZA            ZERO?
      JMP CBPER     NO - ERROR
      LDA OCTNO     GET THE NMBER 
      SZA,RSS       IF RESPONSE IS ZERO,
      LDA BPMAX      USE THE CURRENT LIMIT
      STA SYBAD     SET ADDRESS OF BP LINKS 
      ADA N1        SUBTRACT 1 AND SAVE AS LAST WORD
      STA URBP1     RT DISC RESIDENT AREA IN BP.
      ADA P2        ADJUST FOR TEST 
      CMA,CLE,INA   SET NEGATIVE FOR TESTING
      ADA BPMAX     IF BELOW CURRENT
      LDA EOBP       BASE OR ABOVE
      ADA SYBAD      SYSTEM COMMON
      SEZ            THEN ERROR 
      JMP CBPER 
      LDA SYBAD     SET THE NEW BP-MAX
      STA BPMAX     INCASE NO BP IS USED IN BACKGROUND
      JSB SPACE     NEW LINE
* 
      LDA PPREL     GET PROG RELOC ADDR 
      ADA MAXRP     ADD MAX PROG LENGTH 
      STA SYMAD     SET SYSTEM AVAIL MEM ADDR 
* 
      LDB MES35     GET ADDR FOR CONVERSION IN MESS 
      JSB ACONV,I   CONVERT TO OCTAL
      LDA P16 
      LDB MES34     MES34 = ADDR: FWA SY MEM  XXXXX 
      JSB DRKEY,I   PRINT CURRENT SYS AV MEM BOUND
      JSB SPACE     NEW LINE
* 
GETAV LDA P22       PRINT:
      LDB MES36      "CHANGE FWA SYS AV MEM?" 
      JSB AREAD,I   PRINT AND GET REPLY 
      LDA P5        SET FOR 5 OCTAL DIGITS. 
      JSB AGETO,I    CONVERT TO OCTAL.
      JMP SYMER     -ERROR. 
      JSB AGETA,I   GET NEXT CHAR FROM LBUF.
      CPA ZERO      END OF BUFFER?
      JMP SETAV     YES, SET BOUNDARY.
* 
CBPER LDA ERR14     SEND ERROR MESSAGE
      JSB ERROR      TO OPERATOR
      JMP BPCHA     REPEAT
* 
SYMER LDA ERR14     USE ERROR 14 FOR INVALID
      JSB ERROR      # OR < ORIG. SYS AV MEM ADDR.
      JMP GETAV     -REPEAT REQUEST 
* 
SETAV LDA OCTNO     IF NUMBER 
      SZA,RSS       EQ 0, LEAVE FWA 
      JMP GETBG      SYS MEM AS IS. 
      LDB SYMAD     SUBTRACT ORIG.
      CMB,INB        FWA FROM 
      ADB A          NEW VALUE
      SSB           ERROR IF
      JMP SYMER      NEW < OLD. 
      STA SYMAD     SET NEW FWA IN SYMAD. 
      SKP 
* 
*                                   GET BG BOUNDARY 
* 
GETBG LDB ALBUF     GET ADDR OF LBUF
      JSB BUFCL     CLEAR LBUF
      JSB SPACE     NEW LINE
      LDA P12 
      LDB MES11     MES11 = ADDR: BG BOUNDARY?
      JSB AREAD,I   PRINT AND GET REPLY 
      LDA P5        SET FOR 5 OCTAL DIGITS
      JSB AGETO,I   CONVERT TO OCTAL
      JMP BGERR     BG BOUNDARY ERROR 
      JSB AGETA,I   GET NEXT CHAR FROM LBUF 
      CPA ZERO      END OF BUFFER?
      JMP SETBG     SET BG BOUNDARY 
* 
BGERR LDA ERR14     SET ERROR CODE - BG BOUNDARY
      JSB ERROR     PRINT ERROR MESSAGE 
      JMP GETBG     REPEAT BG INPUT REQUEST 
* 
SETBG LDA SYMAD     GET ADDR OF SYS AV MEM
      CMA,INA 
      ADA OCTNO     ADD BG BOUNDARY 
      SSA           SKIP - VALID BG BOUNDARY
      JMP BGERR     INVALID BG BOUNDARY 
      JSB SPACE     NEW LINE
* 
      LDA DSKAD     GET DISK ADDRESS
      STA DSKBG     SAVE ADDRESS OF BG CODE 
* 
      LDA OCTNO     GET BG BOUNDARY 
      STA BGBND     SAVE BG BOUNDARY
      STA COMAD     SET BACKGROUND COMMON BASE
      STA RELAD     SET CURRENT RELOCATION ADDRESS
      STA LBMAN     SAVE LOWER BG MAIN ADDR 
      STA PPREL     SET NEW MINIMUM PROG RELOC ADDR 
* 
      LDA SYBAD     GET CURRENT BG BP ADDRESS 
      STA PBREL     SET BP RELOCATION ADDRESS 
      STA LBBP      SET LOW BG BP ADDRESS 
      STA TBREL 
* 
      LDA PPREL     GET BACKGROUND BOUNDARY 
      LDB COMBG     GET BACKGROUND COMMON LENGTH
      SZB,RSS       SKIP IF BACKGROUND COMMON 
      JMP RICLR     IGNORE ZERO COMMON
      ADB A 
      STB PPREL     SET NEW BG RELOC ADDR 
* 
*                                   FILL BG COMMON WITH HALTS 
      LDB MES18+1   GET ADDRESS OF MESSAGE
      JSB ACONV,I   CONVERT TO OCTAL/DECIMAL
      LDA P16 
      LDB MES18     GET MESSAGE ADDRESS 
      JSB DRKEY,I   PRINT BACKGROUND COMMON LISTING 
      JSB SPACE     NEW LINE
      LDB COMBG     GET BG COM LENGTH 
      CMB,INB 
      STB TCNT      SET COMMON LENGTH 
      LDA HLT0      GET HALT CODE 
      CLB,INB       SET COUNT = 1 
      JSB ALABD,I   OUTPUT HALT CODE FOR COMMON 
      ISZ TCNT      SKIP - BG COM FILLED WITH HALTS 
      JMP *-4       CONTINUE FILLING BG COMMON
* 
RICLR LDA P4
      STA PTYPE     SET PROGRAM TYPE = BG RESIDENT
      SKP 
* 
*                                   LOAD BG RESIDENTS 
      LDA P12 
      LDB MES19     MES19 = ADDR: BG RESIDENTS
      JSB SETHD     PRINT HEADING, INITIALIZE IDX 
BRLD  JSB AIDSN,I   SCAN IDENTS 
      JMP BREND     END OF IDENTS 
      SEZ,RSS       SKIP IF MAIN
      JMP BRLD      IGNORE SUBS 
      LDB ID3,I     GET USAGE FLAG
      SLB,INB       SKIP - PROGRAM NOT LOADED 
      JMP BRLD      IGNORE LOADED PROGRAM 
      STB ID3,I     SET NEW USAGE FLAG
      JSB ALOAD,I   INITIATE AND LOAD MAIN PROGRAM
      JSB INCAD     INCR RELOCATION ADDRESSES 
      CLA 
      JSB AGEND,I   GENERATE ID SEGMENT, KEYWORD
      JMP BRLD      PROCESS NEXT BG RESIDENT
* 
BREND JSB ANOTS,I   TEST FOR PROGRAMS LOADED
      JSB SPACE     NEW LINE
      JSB AREMD,I   OUTPUT REMAINDER OF ABS REC 
      LDA PPREL     GET CURRENT PROGRAM RELOC BASE
      STA UBMAN     SAVE UPPER BG MAIN ADDRESS
      LDA TBREL     GET CURRENT BP ADDRESS
      STA UBBP      SET UPPER BACKGROUND BP BOUND 
      LDA P3
      STA PTYPE     SET PROG TYPE = BG DISK RESIDENT
      SKP 
* 
*                                   LOAD BG DISK RESIDENTS
      LDA P17 
      LDB MES20     MES20 = ADDR: BG DISK RESIDENTS 
      JSB SETHD     PRINT HEADING INITIALIZE IDX
BDLD  JSB AIDSN,I   SCAN IDENTS 
      JMP BDEND     END OF IDENTS 
      SEZ,RSS       SKIP IF MAIN
      JMP BDLD      IGNORE SUBS 
      LDB ID3,I     GET USAGE FLAG
      SLB,INB       SKIP - PROGRAM NOT LOADED 
      JMP BDLD      IGNORE LOADED PROGRAM 
      STB ID3,I     SET NEW USAGE FLAG
      LDA ID1       GET CURRENT MAIN IDENT ADDRESS
      STA IDMBS     SAVE MAIN IDENT ADDR FOR BS REF 
      JSB ALOAD,I   INITIATE AND LOAD MAIN PROGRAM
      CCA 
      JSB AGEND,I   GENERATE ID SEGMENT, KEYWORD
      JSB AREMD,I   OUTPUT REMAINDER OF RECORD
      LDA DSKAD     GET CURRENT DISK ADDRESS
      STA DSKBS     SAVE DISK ADDR OF BP SECTION
      LDA TBREL     GET UPPER BP ADDRESS
      LDB PBREL     GET LOWER BP ADDRESS
      JSB ABPOT,I   OUTPUT BP SECTION 
      LDA TPREL     GET CURRENT PROG RELOC ADDR 
      STA BSPAD     SAVE PROG RELOC ADDR FOR BS 
      LDA TBREL     GET CURRENT BP RELOC ADDR 
      STA BSBAD     SAVE BP RELOC ADDR FOR BS 
      LDA P5
      STA PTYPE     SET TYPE = BG SEGMENT 
      LDA PLAD      FIND END OF CURRENT 
      INA           PROGRAM LIST
      LDB A,I       GET ENTRY 
      SZB           ZERO - END
      JMP *-3       NO; TRY NEXT ENTRY
      STA PLMAN     SAVE CURRENT PROGRAM LIST ADDR
      JSB INIDX     INITIALIZE IDX
BSLD  JSB IDX       SET IDENT ADDRESSES 
      JMP BSEND     END OF IDENTS 
      LDA ID1       GET CURRENT MAIN IDENT ADDRESS
      STA IMAIN     SAVE MAIN BS IDENT ADDRESS
      LDA ID6,I     GET TYPE
      SSA,RSS       SKIP IF MAIN BG SEGMENT 
      JMP BSLD      IGNORE SUBS 
      AND M177      ISOLATE TYPE
      CPA P5        TYPE = BG SEGMENT?
      RSS           YES - CONTINUE
      JMP BSLD      NO - IGNORE IDENT 
      LDA ID10,I    GET BS MAIN IDENT ADDRESS 
      CPA IDMBS     BS CALLS THIS BG MAIN 
      RSS           YES - CONTINUE
      JMP BSLD      NO - IGNORE BACKGROUND SEGMENT
      LDA TIDNT     GET NEXT IDENT ADDRESS
      STA ABSID     SAVE ADDR FOR NEXT BG SEG SCAN
      CCB 
      STB HDFLG     SET HEADING FLAG FOR BG SEGMENT 
      JSB ALODS,I   LOAD BG SEGMENT 
      JSB SPACE     NEW LINE
      CCA 
      JSB AGEND,I   GENERATE ID SEGMENT, KEYWORD
      JSB AREMD,I   OUTPUT REMAINING OF ABS REC 
      LDA TBREL     GET UPPER BP ADDRESS
      LDB BSBAD     GET LOWER BS BP ADDRESS 
      JSB ABPOT,I   OUTPUT BP SECTION 
      LDA BSBAD     GET BS BP RELOC ADDR
      LDB TBREL     GET UPPER BOUND BP ADDRESS
      JSB ACLRT,I   CLEAR BP LINKAGES 
      LDA BSBAD     GET BS BP RELOC ADDRESS 
      STA TBREL     SET BP RELOC ADDR 
      LDA BSPAD     GET BS PROG RELOC ADDRESS 
      STA TPREL     SET PROG RELOC ADDR 
      LDA ABSID     GET NEXT BG SEG IDENT ADDR
      STA TIDNT     SET IDENT ADDRESS FOR IDX 
      JMP BSLD      LOAD NEXT BG SEGMENT
* 
BSEND LDA DSKAD     GET CURRENT DISK ADDRESS
      STA DSKBR     SAVE CURRENT DISK ADDR OF ABS 
      LDA DSKBS     GET DISK ADDR FOR MAIN BP CODE
      STA DSKAD     SET CURRENT BP CODE ADDRESS 
      LDA BSBAD     GET UPPER ADDR OF BP CODE 
      LDB PBREL     GET LOW ADDR FOR BP CODE
      JSB ABPOT,I   OUTPUT BP CODE FOR MAIN DISK RES
      LDA DSKBR     GET CURRENT DISK ADDRESS
      STA DSKAD     SET CURRENT ABS DISK ADDRESS
      LDA PBREL     GET LOW BP ADDRESS
      LDB BSBAD     GET UPPER BOUND BP CODE 
      JSB ACLRT,I   CLEAR BP LINKAGES 
* 
      LDA P3
      STA PTYPE     SET PROG TYPE = BG DISK RESIDENT
      JSB ACLID,I   CLEAR PROGS-LOADED FLAGS
      LDA IDMBS     GET MAIN IDENT ADDRESS
      STA TIDNT     SET CURRENT IDENT ADDRESS 
      JMP BDLD      LOAD NEXT BG DISK RESIDENT
* 
BDEND JSB ANOTS,I   TEST FOR PROGRAMS LOADED
      JSB SPACE     NEW LINE
      SKP 
* 
*                                   CLEAR SYSTEM COMMUNICATION AREA 
      LDA LWSBP     GET ADDR OF SYS COMM AREA 
      LDB M2000     GET ADDR OF END OF SYS COMM AREA
      CMB,INB 
      ADB A         SET B = COMM AREA LENGTH
      STB WDCNT     SET COUNT FOR CLEARING BP AREA
      CLB 
      STB A,I       CLEAR BP COMM AREA WORD 
      INA 
      ISZ WDCNT     SKIP - AREA CLEARED 
      JMP *-3       CONTINUE CLEARING BP AREA 
* 
*                                   MAKE LIBRARY ENTRY POINT LIST 
      CLA 
      STA LBCNT     CLEAR LIBRARY ENTRY POINT COUNT 
      STA RELAD     CLEAR RELOCATION ADDR FOR LABDO 
      LDA DSKAD     GET CURRENT ABSOLUTE DISK ADDR
      STA DSKLB     SAVE LIBR ENTRY POINT LIST ADDR 
      LDB ADBUF     GET ADDRESS OF DBUF 
      STB CURAD     SET CURRENT DBUF ADDRESS
      JSB BUFCL     CLEAR DBUF
      JSB INLST     INITIALIZE LST SCAN 
LBLST JSB LSTX      SET CURRENT LST ADDRESSES 
      JMP ENDRL     END OF LIST 
      LDB LIBRA     GET CURRENT LIBR ENT HEAD 
      STB TBUF      SAVE CURRENT LIBRARY ENT ADDRESS
      LDA N3
      STA TBUF+1    SET PREM. LIBR ENTRY PT COUNT 
TRYSY LDB TBUF,I    GET CURRENT LIBR ENT ADDRESS
      LDA LST1,I    GET NAME 1,2
      CPA B,I       CHARS EQUAL?
      INB,RSS       INCR LIBR ENT NAME ADDR - SKIP
      JMP TEST3     ALL 3 LIBR ENTS TESTED? 
      LDA LST2,I    GET NAME 3,4
      CPA B,I       CHARS EQUAL?
      INB,RSS       INCR LIBR ENT NAME ADDR - SKIP
      JMP TEST3     ALL 3 LIBR ENTS TESTED? 
      LDA B,I       GET NAME 5
      AND M7400     ISOLATE UPPER CHAR
      STA TBUF+2    SAVE UPPER CHAR OF NAME 
      LDA LST3,I    GET NAME 5 OF LST ENTRY 
      AND M7400     ISOLATE UPPER CHAR
      CPA TBUF+2    CHARS EQUAL?
      JMP LBOUT     YES - PUT OUT ENTRY POINT 
TEST3 ISZ TBUF      INCR CURRENT LIBR ENT HEAD ADDR 
      ISZ TBUF+1    SKIP - ALL 3 LIBR ENTS TESTED 
      JMP TRYSY     TRY NEXT LIBR ENT 
      LDA LST4,I    GET IDENT ADDR FOR ENTRY POINT
      SZA,RSS       SKIP - ENTRY POINT DEFINED
      JMP LBLST     IGNORE UNDEFINED ENTRY POINT
      STA TIDNT     SET IDENT ADDRESS FOR IDX 
      JSB IDX       SET IDENT ADDRESSES 
      HLT 0         INVALID IDENT ADDRESS 
      LDA ID6,I     GET PROGRAM TYPE
      AND M177      ISOLATE TYPE
      CPA P6        TYPE = LIBRARY? 
      RSS           YES - PROCESS LIBRARY ENTRY PT
      JMP LBLST     IGNORE NON-LIBRARY ENTRY POINT
LBOUT LDA LST1,I    GET ENTRY POINT 1,2 
      CLB,INB 
      JSB ALABD,I   OUTPUT NAME 1,2 
      LDA LST2,I    GET ENTRY POINT 3,4 
      CLB,INB 
      JSB ALABD,I   OUTPUT NAME 3,4 
      LDA LST3,I    GET ENTRY POINT 5 
      AND M7400     ISOLATE UPPER CHAR
      CLB,INB 
      JSB ALABD,I   OUTPUT NAME 5 
      LDA LST5,I    GET BP LOCATION ADDRESS 
      SZA,RSS       SKIP - HAS BP LOCATION
      HLT 0         UNDEFINED BP LOCATION 
      CLB,INB 
      JSB ALABD,I   OUTPUT BP ADDRESS OF ENTRY PT 
      ISZ LBCNT     INCR ENTRY POINT COUNT
      JMP LBLST     SCAN LST FOR NEXT ENTRY PT
ENDRL JSB AREMD,I   OUTPUT REMAINDER OF LIBR LIST 
* 
*                                   MOVE UTILITY PROGS TO LOW DISK
      CLA 
      STA UTCNT     CLEAR UTILITY PROGRAM COUNT 
      LDA DSKAD     GET CURRENT DISK ADDRESS
      STA DSKUT     SAVE DISK ADDR OF UTILITY PROGS 
      JSB INIDX     INITIALIZE IDENT SCAN 
GETLB JSB IDX       SET IDENT ADDRESSES 
      JMP ENDSX     ALL UTILITY PROGRAMS MOVED     $
      LDA ID6,I     GET TYPE
      AND M177      ISOLATE TYPE
      CPA P7        TYPE = UTILITY? 
      RSS           YES - MOVE
      JMP GETLB     IGNORE OTHER PROGRAMS 
      LDA ID10,I    GET DISK SECTOR COUNT 
      CMA,INA 
      STA DSCNT     SET SECTOR COUNT
      LDA ID5,I     GET INITIAL DISK ADDR 
      LDB DSKA      CHECK IF SYSTEM 
      CMB            HAS OVERLAYED
      ADB A          THIS RELOCATABLE 
      SSB,RSS        MODULE - 
      JMP MOVEL     IF NOT, CONTINUE
      LDA ERR38     IF SO, IRRECOVERABLE
      JSB IRERR 
MOVEL STA DSKRD     SET CURRENT UTILITY DISK ADDRESS
      LDB ADBUF     GET ADDRESS OF DBUF 
      JSB ADIN,I    READ UTILITY PROGRAM RECORD 
      LDA DSKAD     GET CURRENT ABSOLUTE DISK ADDR
      LDB ADBUF     GET ADDRESS OF DBUF 
      JSB ADOUT,I   WRITE UTILITY RECORD ON DISK
      LDA DSKAD     GET CURRENT ABSOLUTE DISK ADDR
      JSB INDAD,I   INCR DISK ADDRESS 
      STA DSKAD     SET NEW CURRENT DISK ADDRESS
      LDA DSKRD     GET CURRENT UTILITY DISK ADDR 
      JSB INDAD,I   INCR DISK ADDRESS 
      ISZ DSCNT     SKIP - UTILITY PROGRAM MOVED
      JMP MOVEL     MOVE NEXT UTILITY PROGRAM 
      ISZ UTCNT     INCR UTILITY PROGRAM COUNT
      JMP GETLB     SCAN IDENTS FOR NEXT UTILITY PRG
* 
*                    GENERATE BLANK ID SEGMENTS 
* 
ENDSX LDA KEYCT     IF NEXT KEYWORD IS             $
      INA            THE LAST (ZERO WORD),         $
      CPA  KEYCN     THEN TERMINATE                $
      JMP  ENDSZ     BLANK OUTPUT.                 $
      LDA  N2       A=-2 FOR BLANK ID SEGMENT FLAG.$
      JSB AGEND,I   GENERATE ID SEGMENT.           $
      JMP ENDSX     REPEAT TEST.                   $
* 
*                                   PUT OUT DISK DICTIONARY 
ENDSZ LDA DSKAD     GET CURRENT DISC ADDRESS.      $
      ALF,ALF       ROTATE DISK TRACK NO. TO LOW A
      RAL           ISOLATE                       $$
      AND M377       TRACK NUMBER.                $$
      INA           SET A = NUMBER OF USED TRACKS 
      LDB PTRAK     GET NO. OF PROTECTED TRACKS 
      CMB,INB 
      ADB A         SET B = NO. USED - NO. PROTECTED
      SSB           SKIP - NO. USED IS GREATER
      LDA PTRAK     SET NO. USED = NO. PROTECTED
      STA CURAT     SAVE NO. OF USED TRACKS 
      CMA,INA 
      STA TCNT      SET TRACK USAGE COUNT 
      LDA MSIGN     SET FLAG FOR SYSTEM-USED TRACK
      JSB AOUTD,I   OUTPUT TRACK-USED FLAG
      ISZ TCNT      SKIP - ALL USED TRACK FLAGS SET 
      JMP *-3       CONTINUE TO SET USED-TRACK FLAGS
      LDA CURAT     SET A = NO. OF USED TRACKS
      LDB DSIZE     SET B = SYSTEM DISK SIZE
      ADB DAUXN     AUXILIARY DISC SIZE 
      JSB ADSET,I   SET DISK TRACK TABLE
      LDA DSKID     GET CURRENT ID SEGMENT ADDR 
      CPA DSKLC     SAME DISK ADDRESSES?
      RSS           YES - 'OR' RECORDS
      JMP NIDOR     NO - PUT OUT LAST ID SEGMENTS 
      LDB ADBUF     GET ADDRESS OF DBUF 
      JSB ADIN,I    READ FIRST LIBRARY RECORD 
      LDB AIBUF     GET ADDRESS OF IBUF 
      JSB ARECO,I   'OR' RECORD WITH DBUF 
NIDOR LDA DSKID     GET CURRENT ID SEGMENT DISK ADDR
      LDB AIBUF     GET ADDR OF ID SEG BUFFER 
      JSB ADOUT,I   OUTPUT LAST ID SEGMENT SECTOR 
* 
*                                   PUT OUT LAST KEYWORD SECTOR 
      LDA DSKEY     GET CURRENT KEYWORD DISK ADDR 
      LDB ADBUF     GET ADDRESS OF DBUF 
      JSB ADIN,I    READ CURRENT KEYWORD SECTOR 
      LDB AKBUF     GET ADDRESS OF KBUF 
      JSB ARECO,I   'OR' DBUF AND LAST KBUF RECORD
NKYOR LDA DSKEY     GET CURRENT KEYWORD DISK ADDR 
      LDB AKBUF     GET ADDRESS OF KBUF 
      JSB ADOUT,I   OUTPUT LAST KEYWORD RECORD
* 
*                                   PUT OUT SYS COMM AREA VALUES
      LDB ADBUF     GET ADDRESS OF DBUF 
      STB CURAD     SET CURRENT DBUF ADDRESS
      JSB BUFCL     CLEAR DBUF
      LDA N64 
      STA DCNT      SET CURRENT DBUF COUNT
* 
      CLA 
      STA RELAD     CLEAR RELOCATION ADDR FOR LABDO 
      LDA LWSBP     GET LOW ADDR OF SYS COMM AREA 
      STA CURAT     SET CURRENT SYS BP ADDRESS
      LDB M2000     GET UPPER BP SYS COMM ADDR
      CMB,INB 
      ADB A         SET TOTAL BP COMM LENGTH
      STB TCNT      SAVE BP LENGTH
* 
      LDA AEQT      GET ADDRESS OF EQT
      STA EQTA      SET ADDRESS OF EQT
* 
      LDA CEQT      GET NO. OF EQT ENTRIES
      STA EQT#      SET NO. OF EQT ENTRIES
* 
      LDA ASQT      GET ADDR OF DEV REF TABLE 
      STA DRT       SET ADDR OF DEV REF TABLE 
* 
      LDA CSQT      GET NO. OF DEV REF TABLE ENTRIES
      STA LUMAX     SET NO. OF DEV REF TABLE ENTRIES
* 
      LDA AINT      GET ADDR OF INTERRUPT TABLE 
      STA INTBA     SET ADDR OF INTERRUPT TABLE 
* 
      LDA CINT      GET NO. OF INT ENTRIES
      STA INTLG     SET NO. OF INT ENTRIES
* 
      LDA ADICT     GET ADDR OF DISK TRACK TABLE
      STA TAT       SET ADDR OF DISK TRACK TABLE
* 
      LDA KEYAD     GET ADDR OF KEYWORD LIST
      STA KEYWD     SET ADDR OF KEYWORD LIST
* 
      LDA TBCHN     GET I/O ADDR FOR TBG
      STA TBG       SET I/O ADDR FOR TBG
* 
      LDA TTYCH     GET I/O ADDR FOR SYS TELETYPE 
      STA SYSTY     SET I/O ADDR FOR SYS TELETYPE 
* 
      LDB SCH4      SET ID ADDRESS OR ZERO
      STB SKEDD     IN SCHEDULED LIST 
* 
      LDA IDSAD     GET ADDR OF FIRST ID SEG
      CPA B         IF SAME AS HEAD OF SCHEDULE LIST
      LDA SCH3      USE NEXT ID ADDRESS 
      STA DORMT     SET DORMANT LIST HEAD 
* 
      LDA SWAPF     GET SWAPPING FLAG 
      STA SWAP      SET SWAPPING FLAG 
* 
      LDA LBCAD     GET ADDR OF LIBRARY 
      STA LBORG     SET ADDR OF LIBRARY 
* 
      LDA RTCAD     GET RT COM ADDRESS
      STA RTORG     SET RT COM ADDRESS
* 
      LDA COMRT     GET RT COM LENGTH 
      STA RTCOM     SET RT COM LENGTH 
* 
      LDA URMAN     SET FWA OF R/T                $$
      STA RTDRA      DISC RESIDENT AREA.          $$
* 
      LDA SYMAD     GET ADDRESS OF SYS AV MEM 
      STA AVMEM     SET ADDR OF SYS AV MEM
* 
      LDA LBMAN     SET BG BOUNDARY 
      STA BKORG     SET BG BOUNDARY 
* 
      LDA COMBG     SET BACKGROUND                $$
      STA BKCOM      COMMON LENGTH.               $$
* 
      LDA UBMAN     GET BG DISK RESIDENT ORIGIN 
      STA BKDRA     SET BG DISK RESIDENT ORIGIN 
* 
      LDA LWASM     GET LAST AVAIL ADDR FOR SYSTEM
      STA BKLWA     SET LAST AVAIL ADDR FOR SYSTEM
* 
      LDA URBP      SET FWA OF R/T DISC RESIDENT  $$
      STA BPA1       LINK AREA IN BASE PAGE.      $$
* 
      LDA URBP1     SET LWA FOR R/T               $$
      STA BPA2       BASE PAGE LINK.              $$
* 
      LDA UBBP      SET FWA OF BKG DISC RESIDENT  $$
      STA BPA3       LINK AREA IN BASE PAGE.      $$
* 
      LDA PIOC      SET ADDRESS OF                $$
      STA DUMMY      PRIVILEGED I/O CARD.         $$
* 
      LDA SDS#      SET # SECTORS/TRACK FOR       $$
      STA SECT2      SYSTEM DISC (LU #2).         $$
* 
      LDA ADS#      SET # SECTORS/TRACK FOR       $$
      STA SECT3      AUXILIARY DISC (LU #3).      $$
* 
      LDA DSKSY     SET DISC ADDR. OF             $$
      STA IDSDA      FIRST ID SEGMENT.            $$
* 
      LDA IDSP      SET POSITION OF 1ST ID SEGMENT$$
      STA IDSDP      IN SECTOR.                   $$
* 
      CLA           CLEAR                         $$
      STA LGOTK      OTHER                        $$
      STA LGOC       STORAGE.                     $$
      STA SFCUN                                   $$
* 
      LDA DSKLB     GET DISK ADDR OF LIB ENTRY PTS
      STA DSCLB     SET DISK ADDR OF LIB ENTRY PTS
* 
      LDA LBCNT     GET NO. OF LIB ENTRY PTS
      STA DSCLN     SET NO. OF LIB ENTRY PTS
* 
      LDA DSKUT     GET DISK ADDR OF UTILITY PROGS
      STA DSCUT     SET DISK ADDR OF UTILITY PROGS
* 
      LDA UTCNT     GET NO. OF UTILITY PROGS
      STA DSCUN     SET NO. OF UTILITY PROGS
      LDA DSIZE     SYSTEM DISC SIZE
      STA TATSD 
* 
      LDA DSIZE     TOTAL DISC TABLE LENGTH 
      ADA DAUXN 
      CMA,INA 
      STA TATLG     SET TOTAL DISK TABLE LENGTH 
* 
*                                   PUT OUT BASE PAGE 
* 
      LDB LWSBP     GET ADDRESS OF SYS COMM AREA
      ADB M2000     ADJUST FOR BP LOCATION
      LDA CURAT,I   GET WORD OF SYS COMM AREA 
      STA B,I       MOVE WORD TO BP LOCATION
      INB           INCR CURRENT BP LOCATION WORD 
      ISZ CURAT     INCR CURRENT BP ADDRESS 
      ISZ TCNT      SKIP - SYS COMM AREA MOVED
      JMP *-5       CONTINUE MOVING BASE PAGE 
      LDA DSKAD     GET CURRENT ABS DISK ADDRESS
      STA DSKAV     SAVE NEXT AVAILABLE DISK ADDR 
      LDA DSKAB     GET INITIAL ABSOLUTE DISK ADDR
      STA DSKAD     SET CURRENT DISK ADDRESS
      LDA M2000     GET UPPER SYSTEM BP ADDRESS 
      LDB P2        GET LOWER SYSTEM BP ADDRESS 
      JSB ABPOT,I   OUTPUT RESIDENT BP SECTION
* 
*                                   SET BOOTSTRAP LOADER BUFFER 
      CLA,INA       SET DISK ADDRESS = 0,1
      LDB ADBUF     GET ADDRESS OF DBUF 
      JSB ADIN,I    READ RT EXEC BOOTSTRAP LOADER 
      LDA N9
      STA WDCNT     SET BUFFER LENGTH = 9 
      LDB ABOOT     GET ADDR OF BOOTSTRAP LOADER
      CMB,INB 
      ADB ASBUF     ADD ADDRESS OF BOOTSTRAP BUFFER 
      INB           SET B = BOOTSTRAP DISPLACEMENT
      ADB ADBUF     GET ADDRESS OF BOOTSTRAP BUFFER 
      STB CURAD     SET CURRENT DBUF ADDRESS
      LDB ASECT     GET ADDRESS OF BOOTSTRAP VALUES 
      LDA B,I       GET WORD FOR BOOTSTRAP BUFFER 
      STA CURAD,I   SET WORD INTO DBUF
      INB           INCR CURRENT ASECT ADDRESS
      ISZ CURAD     INCR CURRENT DBUF ADDRESS 
      ISZ WDCNT     SKIP - BOOTSTRAP BUFFER SET 
      JMP *-5       CONTINUE SETTING VALUES IN BOOT 
      CLA,INA       SET DISK ADDRESS = 0,1
      LDB ADBUF     GET ADDRESS OF DBUF 
      JSB ADOUT,I   WRITE BOOTSTRAP LOADER IN 0,1 
* 
      LDA P22 
      LDB MES23     MES23 = ADDR: *SYSTEM STORED ETC
      JSB DRKEY,I   PRINT: SYSTEM STORED ON DISK
* 
      LDA DSKAV     CONVERT 
      ALF,ALF        LAST 
      RAL             USED
      AND M377        DISC
      CMA,INA         TRACK # 
      LDB AKBUF       TO DECIMAL
      JSB ACONV,I     AND 
      LDA KBUF+2      STORE 
      STA MES38+13    IN MESSAGE. 
      LDA DSKAV     CONVERT 
      AND M177        SECTOR
      CMA,INA         # TO
      LDB AKBUF       DECIMAL 
      JSB ACONV,I     AND 
      LDA KBUF+2      STORE 
      STA MES38+17    IN
      LDA KBUF+1      MESSAGE 
      AND M377      ISOLATE 3RD DIGIT,
      IOR UBLNK      ADD UPPER BLANK. 
      STA MES38+16
      LDA P38       PRINT MESSAGE:
      LDB MES38     "LAST SYS DISC ADDR:
      JSB DRKEY,I      TRK XX SEC XXX(10)"
      JSB SPACE 
* 
      LDA DSKAV     GET NEXT AVAILABLE DISK ADDR
      LDB DERCN     GET DISK ERROR COUNT
      HLT 77B 
      JMP *-1       END OF JOB
* 
*                                   (TURN ON DISK PROTECT)
* 
      SKP 
* 
*                                   PRINT HEADING, INITIALIZE IDX 
* 
*  THE SETHD SUBROUTINE PRINTS THE HEADINGS FOR THE DIFFERENT 
*  TYPES OF PROGRAMS LOADED, SETS THE NO-PROGRAMS-LOADED-YET
*  FLAG, AND ORIGINS THE SCAN OF IDENT. 
* 
*  CALLING SEQUENCE:
*    A = NO. CHARS. (POS.) IN MESSAGE 
*    B = ADDRESS OF MESSAGE 
*    JSB SETHD
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED
* 
SETHD NOP 
      JSB DRKEY,I   PRINT HEADING 
      JSB SPACE     NEW LINE
      CCA 
      STA LFLAG     SET PROGRAMS-LOADED FLAG = -1 
      LDA BIDNT     GET FIRST IDENT ADDRESS 
      STA CIDNT     SET IDENT ADDRESS FOR ID SCAN 
      JMP SETHD,I   RETURN
      SKP 
* 
*                                   UPDATE RESIDENT MEMORY BOUNDS 
* 
*  THE INCAD SUBROUTINE UPDATES THE MAIN AND BP MEMORY BOUNDS 
*  FROM THAT USED IN THE PREVIOUS LOADING CALL. 
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB INCAD
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED
* 
INCAD NOP 
      LDA TPREL     GET CURRENT RELOCATION ADDRESS
      STA PPREL     SET NEW PROGRAM RELOC ADDRESS 
      LDA TBREL     GET CURRENT BP RELOC ADDRESS
      STA PBREL     SET NEW BP RELOCATION ADDRESS 
      JMP INCAD,I   RETURN
      SKP 
* 
ERR14 ASC 1,14      BG BOUNDARY ERROR 
ERR23 ASC 1,23      INVALID FWA BP LINKAGE ADDRESS
* 
MES2  DEF MS2 
MES11 DEF *+1 
      ASC 6,BG BOUNDARY?
MES12 DEF *+1 
      ASC 3,SYSTEM
MES13 DEF *+1 
      ASC 4,LIBRARY 
MES14 DEF *+2 
      DEF *+6 
      ASC 8,RT COM
MES15 DEF *+1 
      ASC 6,RT RESIDENTS
MES16 DEF *+1 
      ASC 9,RT DISC RESIDENTS 
MES18 DEF *+2 
      DEF *+6 
      ASC 8,BG COM
MES19 DEF *+1 
      ASC 6,BG RESIDENTS
MES20 DEF MS20
MES23 DEF MS23
MES27 DEF *+1 
      ASC 8,FWA BP LINKAGE? 
MES34 DEF SYMES 
MES35 DEF SYMES+5 
SYMES ASC 8,FWA SY MEM
* 
MES38 DEF *+1 
      ASC 12,LAST SYS DISC ADDR: TRK
      NOP           (TRACK #) 
      ASC 2, SEC
      OCT 20000     (BLANK , HI DIGIT FOR SECTOR) 
      NOP           (LOWER 2 DIGITS FOR SECTOR) 
      ASC 2,(10)
* 
ASECT DEF SECTR 
JMP3I JMP 3,I       INITIAL JMP INSTRUCTION 
UCHRT OCT 52000     UPPER ASCII CHAR T
* 
LIBRA DEF *+1 
      DEF EXEC
      DEF $LIBR 
      DEF $LIBX 
* 
EXEC  ASC 3,EXEC
$LIBR ASC 3,$LIBR 
$LIBX ASC 3,$LIBX 
CHR$S ASC 1,$S
CHRTR ASC 1,TR
* 
      SKP 
* 
SECTR BSS 0         BOOTSTRAP BUFFER FORMAT 
* 
LBPSY BSS 1         LOWER SYSTEM BP ADDRESS 
UBPSY BSS 1         UPPER SYSTEM BP ADDRESS 
DSKBP BSS 1         SYS BP DISK ADDRESS 
* 
LRMAN BSS 1         MAIN RESIDENT LOWER ADDRESS 
URMAN BSS 1         MAIN RESIDENT UPPER ADDRESS 
DSKRR BSS 1         MAIN RESIDENT DISK ADDRESS
* 
LBMAN BSS 1         MAIN BG LOWER ADDRESS 
UBMAN BSS 1         MAIN BG UPPER ADDRESS 
DSKBG BSS 1         MAIN BACKGROUND DISK ADDRESS
* 
SYMAD BSS 1         AVAIL SYS MEM ADDR
BGBND BSS 1         BACKGROUND BOUNDARY 
* 
DSKAV BSS 1         NEXT AVAILABLE DISK ADDRESS 
DSKLC BSS 1         DISK ADDRESS OF LIBRARY CODE
DSKLB BSS 1         DISK ADDR OF LIBRARY ENTRY PTS
DSKUT BSS 1         UTILITY PROG DISK ADDRESS 
DSKBS BSS 1         DISK ADDR OF MAIN BG DISK RES BP
DSKBR BSS 1         CURRENT MAIN BG DISK RES DISK AD
ADICT BSS 1         ADDR OF DISK DICTIONARY 
LBCNT BSS 1         RESIDENT LIBR ENTRY PT COUNT
UTCNT BSS 1         UTILITY LIBRARY COUNT 
KEYAD BSS 1         CURRENT KEYWORD ADDRESS 
RTCAD BSS 1         RT COM CORE ADDRESS 
LBCAD BSS 1         LIBRARY CODE ADDRESS
SYBAD BSS 1         ADDR OF FIRST BP LINK FOR BG
IDSAD BSS 1         ADDR OF FIRST ID SEGMENT
ABSID BSS 1         IDENT ADDR FOR NEXT BG SEG SCAN 
MAXRP BSS 1         MAXIMUM RT DISK RESIDENT PROG 
MAXRB BSS 1         MAXIMUM RT DISK RESIDENT BP 
IDMBS BSS 1         BG MAIN ADDRESS FOR BS REF
      ORG * 
      SKP 
      ORG 10000B
* 
*                                   INCREMENT DISK ADDRESS
* 
*  THE DISKA SUBROUTINE INCREMENTS THE CURRENT DISK ADDRESS 
*  TO PROVIDE THE ADDRESS OF THE SUCCEEDING SECTOR, 
*  WHETHER THAT SECTOR IS ON THE SAME TRACK OR THE FOLLOWING
*  TRACK.  IN ADDITION, THE DISKA SUBROUTINE CHECKS THAT
*  THE NEXT DISK ADDRESS IS VALID.
* 
*  CALLING SEQUENCE:
*    A = CURRENT DISK ADDRESS 
*    B = IGNORED
*    JSB DISKA
* 
*  RETURN:
*    A = NEXT DISK ADDRESS
*    B = DESTROYED
* 
DISKA NOP 
      STA B         SAVE CURRENT ADDRESS
      AND M177      ISOLATE SECTOR NUMBER 
      INA           ADD 1.                        $$
      CPA SDS#      IF = TO MAX NO. ON SYS. DISC, $$
      CLA            SET # = 0,                   $$
      STA DISKT      AND SAVE NEW SECTOR #.       $$
      LDA B         ISOLATE                       $$
      ALF,ALF        TRACK                        $$
      RAL            ADDRESS                      $$
      AND M377       IN LOW A.                    $$
      CLB           IF NEW                        $$
      CPB DISKT      SECTOR # = 0,                $$
      INA            ADD 1 TO TRACK #.            $$
      CPA DSIZE     CHECK FOR OVERFLOW.           $$
      JMP DKERR      -YES.                        $$
      ALF,RAL       RESTORE TRACK # TO 14-07,     $$
      RAL,RAL        AND                          $$
      IOR DISKT      INSERT SECTOR #.             $$
      JMP DISKA,I   -RETURN.                      $$
* 
DKERR LDA ERR17     SET CODE FOR INSUFFICIENT DISK
      JSB IRERR     IRRECOVERABLE ERROR EXIT
* 
DISKT NOP           -TEMPORARY STORAGE            $$
      SKP 
* 
*                                   DISK INPUT DRIVER 
* 
*  THE DISKI SUBROUTINE CONTROLS THE INPUT FROM THE DISK. 
*  IT ADDS THE DIRECTION BIT TO THE CORE ADDRESS, AND 
*  CONTAINS THE ERROR RECOVERY PROCEDURE IF READ PARITY 
*  OR DECODE ERRORS ARE DETECTED ON READ.  FOLLOWING DETECTION
*  OF SUCH AN ERROR, 9 ADDITIONAL ATTEMPTS TO READ THE
*  SPECIFIED SECTOR WILL BE MADE.  IF THESE FAIL, THE DISK ADDRESS
*  AND THE CORE ADDRESS ARE DISPLAYED IN THE A AND B REGISTERS
*  AND THE COMPUTER HALTS.  BY PRESSING RUN, 10 ADDITIONAL
*  ATTEMPTS TO READ THE SECTOR WILL BE MADE.
* 
*  CALLING SEQUENCE:
*    A = DISK ADDRESS 
*    B = CORE ADDRESS 
*    JSB DISKI
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED. 
* 
DISKI NOP 
      ADB MSIGN     SET SIGN = 1
      STA DCMND     SAVE DISK ADDRESS 
      STB MADDR     SAVE MEMORY ADDRESS 
REPR1 LDA N10       SET DISK READ ERROR COUNT 
      STA EDCNT     SET ERROR COUNTER 
REPR2 LDA DCMND     GET DISK ADDRESS
      LDB MADDR     GET CORE ADDRESS
      JSB DISKD     READ 64-WORD RECORD 
      JMP DISKI,I   RETURN
      ISZ EDCNT     SKIP - 10 READ ATTEMPTS FAILED
      JMP REPR2     TRY AGAIN 
      LDA ERR22     GET DISK READ ERROR CODE
      JSB ERROR     PRINT ERROR MESSAGE 
      LDA DCMND     GET DISK ADDRESS
      LDB MADDR     GET CORE ADDRESS
      HLT 22B       WAIT FOR OPERATOR INTERVENTION
      JMP REPR1     TRY 10 MORE TIMES 
      SKP 
* 
*                                   DISK OUTPUT DRIVER
* 
*  THE DISKO SUBROUTINE CONTROLS ALL OUTPUT TO THE
*  DISK.  IT ADDS THE DIRECTION BIT TO THE CORE ADDRESS, AND CONTAINS 
*  THE ERROR RECOVERY PROCEDURE IF DISK ERRORS ARE DETECTED.
*  FOLLOWING EXECUTION OF THE DISK WRITE, THE SECTOR IS 
*  IMMEDIATELY READ BACK TO TEST FOR ERRORS.  IF ERRORS ARE DETECTED, 
*  THIS PROCEDURE IS REPEATED (SEE RECOVERY FOR DISKI). 
* 
*  CALLING SEQUENCE:
*    A = DISK ADDRESS 
*    B = CORE ADDRESS 
*    JSB DISKO
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED. 
* 
DISKO NOP 
      STB MADDR     SAVE MEMORY ADDRESS 
      LDB DSKA      GET CURRENT HIGH
      CMB,INB       AND SUBTRACT
      ADB A         FROM CURRENT ADDRESS
      SSB,RSS       IF NEW HIGH 
      STA DSKA      SET NEW HIGH
      IOR MSIGN     SET SIGN OF DISK ADDR = WRITE 
      STA DCMND     SAVE DISK ADDRESS 
REPW1 LDA N10       SET DISK READ ERROR COUNT 
      STA EDCNT     SET ERROR COUNTER 
REPW2 LDA DCMND     GET DISK ADDRESS
      LDB MADDR     GET CORE ADDRESS
      JSB DISKD     WRITE 64-WORD RECORD
      LDA DCMND     GET DISK ADDRESS
      RAL,CLE,ERA   CLEAR WRITE BIT 
      LDB AEBUF     GET ADDRESS OF SCANOUT AREA 
      JSB DISKD     READ RECORD FROM DISK 
      JMP DISKO,I   RETURN
      ISZ EDCNT     SKIP - 10 READ ATTEMPTS FAILED
      JMP REPW2     TRY AGAIN 
      LDA ERR22     GET DISK READ ERROR CODE
      JSB ERROR     PRINT ERROR MESSAGE 
      LDA DCMND     GET DISK ADDRESS
      LDB MADDR     GET CORE ADDRESS
      HLT 22B       WAIT FOR OPERATOR INTERVENTION
      JMP REPW1     TRY 10 MORE TIMES 
      SKP 
* 
*                                   COMMON I/O DISK DRIVER
* 
*  THE DISKD SUBROUTINE IS THE MAIN DISK INPUT/OUTPUT 
*  DRIVER.  IT SETS UP THE MEMORY ADDRESS REGISTER, THE 
*  WORD COUNT REGISTER, AND THE DISK ADDRESS.  FOLLOWING THESE, 
*  IT INITIATES THE TRANSFER, AND WAITS UNTIL THE TRANSFER
*  IS COMPLETE (BY TESTING THE DISK STATUS WORD).  IN THE CASE OF 
*  A DISK READ, IT TESTS FOR READ PARITY AND DECODE ERRORS. 
* 
*  CALLING SEQUENCE:
*    A = DISK ADDRESS (WITH DIRECTION BIT)
*    B = CORE ADDRESS (WITH DIRECTION BIT)
*    JSB DISKD
* 
*  RETURN: CONTENTS OF A AND B ARE DESTOYED.
*    (N+1): READ - A READ PARITY OR DECODE ERROR IS DETECTED
*           WRITE - ALL 
*    (N+2): NORMAL READ 
* 
DISKD NOP 
      CCE,SSA,RSS   SET E = 1 (DISK WRITE)
      CLE           SET E FOR DISK READ 
      CLC 2         PREPARE TO SET MEM ADDR REGISTER
      OTB 2         SET MEM ADDR IN MAR 
      LDB DMAC      ASSIGN THE DMA
      OTB 6         TO THE DISK 
* 
      STC 2         PREPARE TO SET WORD COUNT REG 
      LDB N64       SET WORD COUNT = 64 
      OTB 2         SET WORD COUNT IN WCR 
* 
DSK2  OTA 0         SET DISK ADDR IN COMMAND CHNL 
* 
      STC 6,C       INITIATE DMA 1
DSK3  STC 0         INITIATE DATA TRANSFER
DSK4  LIA 0         GET STATUS WORD 
      SLA           SKIP IF TRANSFER COMPLETE 
      JMP *-2       WAIT
      SEZ           SKIP - DISK READ
      JMP DISKD,I   WRITE RETURN
      AND M22       ISOLATE BITS 1,4
      SZA,RSS       SKIP - READ PARITY OR DECODE ERR
      JMP DISKD,I   NORMAL READ RETURN
      ISZ DERCN     INCR TOTAL DISK ERROR COUNT 
      ISZ DISKD     INCR RETURN ADDRESS (ERROR) 
      JMP DISKD,I   DISK READ ERROR RETURN
* 
DMAC  OCT 20000 
      SKP 
* 
*                                   SCAN IDENTS FOR PROGRAM TYPE
* 
*  THE IDSCN SUBROUTINE SCANS IDENT FOR A PROGRAM OF THE
*  CURRENT TYPE (SET IN PTYPE). 
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB IDSCN
* 
*  RETURN: CONTENTS OF A AND B ARE DESTOYED.
*    E = M/S FLAG FOR CURRENT PROGRAM.
* 
IDSCN NOP 
      LDA CIDNT     GET NEXT IDENT IN SCAN
      STA TIDNT     SET IDENT ADDRESS FOR IDX 
      JSB IDX       SET IDENT ADDRESSES 
      JMP IDSCN,I   RETURN - END OF IDENTS
      LDA ID1       GET CURRENT MAIN IDENT ADDRESS
      STA IMAIN     SAVE CURRENT MAIN IDENT ADDRESS 
      LDA TIDNT     GET NEXT IDENT ADDRESS
      STA CIDNT     SAVE ADDR FOR NEXT IDENT SCAN 
      LDA ID6,I     GET TYPE
      RAL,CLE,ERA   SET E = M/S 
      AND M177      ISOLATE PROGRAM TYPE
      CPA PTYPE     CURRENT TYPE? 
      RSS           YES - CONTINUE
      JMP IDSCN+3   IGNORE IDENT - TRY NEXT IDENT 
      ISZ IDSCN     INCR RETURN ADDRESS 
      JMP IDSCN,I   RETURN
      SKP 
* 
*                                   TEST FOR SOME PROGRAMS LOADED 
* 
*  THE NOTST SUBROUTINE CHECKS FOR PROGRAMS OF THE CURRENT
*  TYPE LOADED.  IT IS EXECUTED FOLLOWING COMPLETION OF THE 
*  LOADING SEQUENCE FOR EACH PROGRAM TYPE.  IF NO PROGRAMS OF 
*  THIS TYPE HAVE BEEN LOADED, IT PRINTS THE MESSAGE
*  (NONE) ON THE TELEPRINTER. 
*  OTHERWISE IT REPORTS THE CURRENT BASE PAGE LINKAGE ADDRESS.
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB NOTST
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED. 
* 
NOTST NOP 
      LDA BPMAX     GET CURRENT NEXT LINK 
      LDB MES03      AND MESSAGE ADDRESS
      JSB CONVD     CONVERT TO ASCII
      LDA P16       SEND MESSAGE: 
      LDB MES02      BP LINKAGE XXXXX 
      ISZ LFLAG     IF NO PROGRAMS LOADED,
      JMP *+3        SEND:  (NONE)
      LDA P6
      LDB MES22     MES22 = ADDR: (NONE)
      JSB DRKEY,I   PRINT: (NONE) 
      JMP NOTST,I   RETURN
      SPC 2 
MES02 DEF MS02
MES03 DEF MS02+5
      SKP 
* 
*                                   OUTPUT ABSOLUTE BASE PAGE CODE
* 
*  BPOUT OUTPUTS THE BASE PAGE SECTION OF CODE FOLLOWING LOADING OF 
*  EACH DISK RESIDENT PROGRAM, BEGINNING WITH THE DISK
*  ADDRESS SPECIFIED IN DSKAD.
* 
*  CALLING SEQUENCE:
*    A = UPPER BP ADDRESS 
*    B = LOWER BP ADDRESS 
*    JSB BPOUT
* 
*  RETURN: CONTENTS OF A AND B ARE DESTOYED.
* 
BPOUT NOP 
      CMA,INA       COMPLEMENT UPPER ADDRESS
      ADA B         ADD LOWER ADDRESS 
      STA TCNT      SAVE BP LENGTH
      ADB M2000     ADJUST FOR BP ADDRESS 
      STB CURAT     SAVE CURRENT LOWER CORE ADDR
      SSA,RSS       SKIP - SOME CODE IN BP
      JMP BPOUT,I   RETURN - ALL CODE OUT 
      LDA DSKAD     GET CURRENT DISK ADDRESS
BPSYO JSB ADOUT,I   OUTPUT CURRENT BP SECTOR
      LDA DSKAD     GET CURRENT DISK ADDRESS
      JSB INDAD,I   INCR DISK ADDRESS 
      STA DSKAD     SAVE NEXT DISK ADDRESS
      LDB TCNT      GET CURRENT LENGTH
      ADB P64 
      STB TCNT      SAVE COUNT FOR NEXT PASS
      SSB,RSS       SKIP - MORE CODE TO PUT OUT 
      JMP BPOUT,I   RETURN - ALL CODE OUT 
      LDB CURAT     GET CURRENT LOW CORE ADDRESS
      ADB P64 
      STB CURAT     SET NEXT CORE ADDRESS 
      JMP BPSYO     OUTPUT NEXT SECTOR TO DISK
      SKP 
* 
*                                   CONVERT A TO ASCII AT B 
* 
*  THE CONVD SUBROUTINE CONVERTS THE CONTENTS OF A
*  INTO ASCII (DECIMAL OR OCTAL) AT THE LOCATION SPECIFIED
*  BY B.  THE CONVERTED RESULT REQUIRES 3 WORDS, AND IS 
*  IN THE FORMAT:  XXXXX, WITH A SPACE IN THE FIRST POSITION. 
* 
*  CALLING SEQUENCE:
*    A = NO. TO BE CONVERTED.  IF THE SIGN OF A IS POS.,
*        THE CONVERSION IS TO BE IN OCTAL;  IF NEGATIVE,
*        IN DECIMAL.
*    B = ADDRESS OF CORE LOCATION FOR CONVERTED RESULT
*    JSB CONVD
* 
*  RETURN: CONTENTS OF A AND B ARE DESTOYED.
* 
CONVD NOP 
      STB CURAT     SET MESSAGE ADDRESS 
      LDB OPWRS     GET ADDR OF OCTAL POWERS
      SSA           SKIP IF OCTAL CONV REQUIRED 
      LDB DPWRS     GET ADDRESS OF DECIMAL POWERS 
      STB RANAD     SET POWER RANGE ADDRESS 
      SSA,RSS       SKIP IF NEGATIVE (DECIMAL)
      CMA,INA       CONVERT NUMBER TO NEGATIVE
      STA B         PUT NUMBER IN B (REMAINDER) 
      LDA N2
      STA TCNT      SET CONVERSION COUNTER
      JSB GETD      GET FIRST DIGIT 
      IOR UBLNK     ADD BLANK TO FIRST CHAR 
      STA CURAT,I   SAVE FIRST BLANK, CHARACTER 
      ISZ CURAT     INCR MESSAGE ADDRESS
NEXTD JSB GETD      GET NEXT DIGIT
      ALF,ALF       ROTATE TO UPPER 
      STA CURAT,I   SAVE UPPER CHARACTER
      JSB GETD      GET NEXT DIGIT
      IOR CURAT,I   ADD UPPER CHAR
      STA CURAT,I   SAVE NEXT 2 CHARACTERS
      ISZ CURAT     INCR MESSAGE ADDRESS
      ISZ TCNT      SKIP - 5 DIGITS IN
      JMP NEXTD     NO - CONTINUE WITH NEXT DIGIT 
      JMP CONVD,I   YES - RETURN
      SKP 
* 
*                                   GET DIGIT FOR CONVD 
* 
*  GETD PROVIDES THE ASCII CHARACTERS FOR CONVD.
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = REMAINDER
*    JSB GETD 
* 
*  RETURN:
*    A = ASCII DIGIT
*    B = IGNORED
* 
GETD  NOP 
      CLA 
INCRA ADB RANAD,I   ADD POWER 
      CMB,SSB,INB,SZB   SKIP - TRY NEXT HIGHER DIGIT
      JMP *+4       DIGIT FOUND 
      INA           INCR DIGIT
 `    CMB,INB       RESTORE REMAINDER TO NEGATIVE 
      JMP INCRA     TRY HIGHER DIGIT
      ADB RANAD,I   ADD POWER 
      CMB,INB       RESTORE REMAINDER 
      ISZ RANAD     INCR POWER LIST ADDRESS 
      IOR M60       CONVERT TO ASCII
      JMP GETD,I    RETURN WITH DIGIT IN A
      SKP 
* 
*                                   CLEAR MEMORY MAP BUFFER 
* 
*  CLIST CLEARS THE MEMORY MAP BUFFER WITH BLANKS.
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB CLIST
* 
*  RETURN: CONTENTS OF A AND B ARE DESTOYED.
* 
CLIST NOP 
      LDB AMLST     AMLST = ADDR OF MLIST 
      LDA N8
      STA AMAD      SET BUFFER LENGTH 
      LDA BLNKS     GET 2 BLANK CHARACTERS
      STA B,I       CLEAR BUFFER WORD 
      INB 
      ISZ AMAD      ALL WORDS CLEAR?
      JMP *-3       NO - CONTINUE CLEARING
      JMP CLIST,I   RETURN
      SPC 1 
LINKA DEF ALINK     ADDRESS OF CURRENT
LINKB DEF BLINK       LINKAGE ROUTINES
LINKD DEF DLINK 
BLN3 DEF BLIN3
CROSA DEF CROSS 
BLNKS ASC 1,        BLANKS
BLAST ASC 1, *      BLANK,ASTERISK
LPAR  OCT 50        LEFT PAREN
LWH3  NOP 
LWH4  NOP 
      SKP 
* 
*                                   INITIATE MAIN PROGRAM LOADING 
* 
*  LOAD IS THE SUBROUTINE FOR ENTRY TO LOADS FOR THOSE
*  PROGRAMS WHICH REQUIRE USE OF A NEW BP AND PROGRAM BASE. 
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB LOAD 
* 
*  RETURN: CONTENTS OF A AND B ARE DESTOYED.
* 
LOAD  NOP 
      CCB 
      STB HDFLG     SET HEADING FLAG
      LDA PPREL     GET PROGRAM RELOCATION ADDRESS
      STA TPREL     SET CURRENT PROG RELOC ADDRESS
      LDA PBREL     GET BP RELOCATION ADDRESS 
      STA TBREL     SET CURRENT BP RELOC ADDRESS
      JSB LOADS     LOAD PROGRAM
      LDA LIBFG     IF NOT LIB LOAD 
      SZA,RSS       THEN
      JSB SPACE     NEW LINE
      JMP LOAD,I    RETURN
      SKP 
* 
*                                   LOAD, LINK MAIN PROG & SUBS.
* 
*  LOADS IS THE MAIN LOADING SUBROUTINE FOR GENERATING THE ABSOLUTE 
*  CODE AND LINKING ALL CALLED SUBROUTINES.  IT IS USED BY EACH 
*  PROGRAM TYPE FOR LOADING.  IT READS THE RELOCATABLE RECORDS FROM 
*  THE SCRATCH PORTION OF THE DISK, AND WRITES THE ABSOLUTE CODE
*  ON THE LOWER (PROTECTED) PORTION OF THE DISK.
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB LOADS
* 
*  RETURN: CONTENTS OF A AND B ARE DESTOYED.
* 
LOADS NOP 
      CCA 
      STA PLFLG     SET FLAG = NO DBL RECS IN 
LOADN CLA 
      STA L001
      CCA 
      STA LWH1      PRESET
      LDB L001
      SZB 
      JMP *+5 
      LDA TPREL     SAVE FOR RESET
      STA LWH4       FOR NEXT PASS
      LDA TBREL 
      STA LWH3
      LDA RSS 
      STA BLN3,I
      CLA 
LOADX STA L01 
      LDA L001
      SZA,RSS 
      JMP LH16      CLEAR 
      LDA LWH3       BP LINK
      LDB TBREL       ADDRESSES 
      JSB ACLRT,I 
LH16  LDA LWH4      RESTORE TPREL 
      LDB L01        OR IS THIS FINAL PASS? 
      SZB,RSS       SKIP IF FINAL 
      STA TPREL     RESTORE IT
      LDA LWH3
      STA TBREL     RESTORE TBREL 
      JSB CLIST     BLANK MEMORY MAP BUFFER 
      LDA AMLST     AMLST = ADDR OF MEM MAP BUFFER
      STA AMAD      SET CURRENT MEMORY MAP ADDRESS
      LDA HDFLG     GET HEADING FORMAT FLAG 
      STA TEMP2 
      SSA,RSS       SKIP IF NEGATIVE (MAIN) 
      ISZ AMAD      INCR CURRENT MEM MAP ADDR 
      LDA ID1,I     GET NAME 1,2
      STA AMAD,I    SET NAME 1,2 IN MEMORY MAP
      ISZ AMAD      INCR CURRENT MEMORY MAP ADDRESS 
      LDA ID2,I     GET NAME 3 4
      STA AMAD,I    SET NAME 3,4 IN MEMORY MAP
      ISZ AMAD      INCR CURRENT MEMORY MAP ADDRESS 
      LDA ID3,I     GET NAME 5
      AND M7400     ISOLATE UPPER CHAR
      IOR BLANK     ADD BLANK (OCT 40)
      STA AMAD,I    SET NAME 5 IN MEMORY MAP
      JSB ZLOAD     LOADING?
      JMP LH7        NO 
      LDA L01 
      SZA           1ST PASS? 
      JMP LH7        YES
      ISZ TEMP2      NO - TEST TEMPORARY HDFLG
      JMP SUBHD 
      JMP *+3 
LH7   ISZ HDFLG     TEST REAL THING 
      JMP SUBHD     SKIP PRIORITY OUTPUT FOR SUB
* 
      LDA DSKAD     GET CURRENT DISK ADDRESS
      LDB L01 
      SZB,RSS       IF 1ST PASS,
      STA DSKMN     SAVE INITIAL MAIN DISK ADDRESS
      LDB PLMAN     GET LIST ADDRESS FOR SEGMENTS 
      LDA PTYPE     GET PROGRAM TYPE
      CPA P5        TYPE = BG SEGMENT?
      JMP CLPLT     BACK GROUND SEGMENT SO JUMP 
      LDB PLAD      GET ADDRESS OF PROGRAM LIST 
      LDA ID1       GET IDENT ADDRESS OF MAIN 
      STA B,I       SET ADDRESS IN PLIST
      INB           INCR CURRENT PLIST ADDRESS
CLPLT CLA 
      STA B,I       CLEAR PLIST WORD
* 
SETMP LDA LPAR      GET LEFT PAREN (OCT 50) 
      IOR AMAD,I    CHANGE NAME 5, BLANK TO NAME 5,(
      STA AMAD,I    SET NAME 5, LEFT PAREN IN MAP 
      LDA ID6,I     GET PRIORITY
      ALF,ALF       ROTATE TO LOW A 
      AND M177      ISOLATE PRIORITY
      CMA,INA       SET TO NEGATIVE FOR DECIMAL CONV
      LDB ATBUF     GET MESSAGE ADDRESS 
      JSB CONVD     CONVERT TO DECIMAL/OCTAL
      LDA TBUF+2    GET 2 LEAST SIGNIFICANT DIGITS
      STA MLIST+3   SET PRIORITY IN MEMORY MAP
      LDA RPARB     GET RIGHT PAREN,BLANK 
      STA MLIST+4   SET RIGHT PAREN IN MEMORY MAP 
SUBHD LDA TPREL     GET CURRENT PROG RELOC ADDR 
      LDB AMEM5     SET B = ADDR OF MEMORY MAP + 5
      JSB CONVD     CONVERT TO DECIMAL/OCTAL
      LDA ID6,I     GET TYPE
      AND M177      MASK
      STA LDTYP     SET TYPE OF CURRENT PGM 
      JSB ZLOAD     LOADING THIS ONE? 
      JMP LH1       NO; SKIP MAP
      LDA L01 
      SZA,RSS       ALSO SKIP MAP 
      JMP LH1        ON FIRST PASS
      ISZ LFLAG     YES; STEP LOADED PGMS FLAG
      NOP 
      LDA P16 
      LDB AMLST     AMLST = ADDR OF MEM MAP BUFFER
      JSB DRKEY,I   PRINT HEADING 
LH1   LDA ID5,I     GET DISK ADDRESS
      STA DSKRD     SAVE CURRENT DISK INPUT ADDRESS 
* 
*                                   READ NAM RECORD FROM DISK 
      JSB DBIN      GET RECORD FROM DISK
DBINT LDA LBUF+1    GET RIC 
      ALF,RAR       ROTATE TO LOW A 
      AND M7        ISOLATE RIC 
      CPA P1        NAM RECORD? 
      RSS           YES - CONTINUE
      HLT 0B        INVALID DISK RECORD 
      LDA LBUF+6    GET PROGRAM LENGTH
      STA PLGTH     SAVE PROGRAM LENGTH 
      JSB ZLOAD     LOADING?
RSS   RSS           NO - SKIP 
      JSB LINKA,I   SET UP LOW CURRENT PG LINK BUFF 
      LDB TPREL     GET PROGRAM RELOCATION BASE 
      STB RELAD     SET CURRENT RELOCATION ADDRESS
      LDA CURAL     GET CURRENT LBUF ADDRESS
      ADA P17       ADJUST FOR END OF NAM RECORD
      STA CURAL     SET FOR END OF NAM RECORD 
      LDA LCNT      GET CURRENT LBUF COUNT
      ADA P17       ADJUST FOR END OF NAM RECORD
      STA LCNT      SET NEW CURRENT COUNT 
* 
*                                   CLASSIFY ENT, EXT, DBL, END RECS
CLSRC JSB DBSET     GET ADDR OF NEXT WORD IN LBUF 
      LDA CURAL,I   GET SECOND WORD IN RECORD 
      LDB A         SAVE WORD IN B
      ALF,RAR       ROTATE RIC TO LOW A 
      AND M7        ISOLATE RIC 
      CPA P2        ENT RECORD? 
      JMP DENTR     PROCESS ENT RECORD
      CPA P3        DBL RECORD? 
      JMP DDBLR     PROCESS DBL RECORD
      CPA P4        EXT RECORD? 
      JMP DEXTR     PROCESS EXT RECORD
      CPA P5        END RECORD? 
      RSS           YES - PROCESS END RECORD
      HLT 0B        INVALID DISK RECORD 
* 
      JSB ZLOAD     LOADING?
      JMP CLST-1     NO 
      LDA L01       IF FIRST OF 
      SZA            TWO PASSES,
      JMP *+3        GO TO WRITE
      STA LWH1       LOW CURRENT PAGE 
      JMP CROSA,I    LINK BUFFER
*                                   PROCESS END RECORD
      JSB DBSET     GET ADDR OF NEXT WORD IN LBUF 
      JSB DBSET     GET ADDR OF NEXT WORD IN LBUF 
      LDA TPREL     GET CURRENT PROG RELOCATION BASE
      ADA CURAL,I   ADD RELOCATION ADDRESS
      LDB HDFLG     GET HEADING FLAG
      SZB,RSS       SKIP UNLESS MAIN
      STA PRENT     SAVE PRIMARY ENTRY POINT FOR ID 
      JSB INLST     INITIATE LSTX 
CLST  JSB LSTX      SET LST ADDRESSES 
      JMP LSTCR     END OF LST
      LDA LST3,I    GET WORD 3 OF LST (ORDINAL) 
      AND M7400     ISOLATE UPPER CHAR - CLEAR ORD
      STA LST3,I    SET NAME 5 IN LST 
      JMP CLST      CONTINUE CLEARING ORDINALS
LSTCR JSB ZLOAD     WAS CURRENT PGM LOADED? 
      JMP PLSCN-1   NO SKIP ADDRESS UP DATE 
      LDA PLGTH     GET PROGRAM LENGTH
      RAL,CLE,ERA   SET E = SIGN
      ADA TPREL     ADD PROGRAM RELOCATION BASE 
      SEZ           SKIP IF ASSEMBLER PRODUCED
      LDA RELAD     GET CURRENT RELOCATION ADDRESS
      STA TPREL     SET NEW RELOCATION BASE 
      STA B         SAVE NEW PROG RELOC BASE IN B 
      LDA RELAD     GET LAST WORD ADDRESS 
      CMA,INA 
      ADB A         ADD RELOC BASE
      SZB,RSS       SKIP - FILL SPACE WITH HALTS
      JMP *+3       NO HALTS REQUIRED AT END OF PROG
      CLA 
      JSB ALABD,I   FILL IN LAST BSS WITH ZEROS 
      LDA L01       IF 2ND PASS, GO TO WRITE HIGH 
      SSA,RSS       CURRENT PAGE LINK BUFFER
      JSB LINKB,I   SEND HIGH CURRENT PG LINK BUFF
      LDB PLAD      PLAD = ADDR OF PROGRAM LIST 
PLSCN LDA B,I       GET PROG LIST ENTRY 
      SZA,RSS       SKIP - ENTRY IN PLIST 
      JMP CLFLG     CLEAR FLAGS FOR PROGRAMS
      SSA           SKIP IF POSITIVE (PROG LOADED)
      JMP ENTID     GET NEXT PROGRAM IDENT ADDRESS
EPLST INB           INCR PROGRAM LIST ADDRESS 
      JMP PLSCN     NO - CONTINUE PROG LIST SEARCH
CLFLG LDA PTYPE     GET CURRENT PROGRAM TYPE
      CPA P3        TYPE = BG DISK RESIDENT?
      JMP LOADS,I   YES - DO NOT CLEAR LOADED FLAGS 
      JSB CLID3     CLEAR PROG-LOADED FLAGS 
      JMP LOADS,I   RETURN - ALL FLAGS CLEARED
* 
ENTID RAL,CLE,ERA   CLEAR SIGN (PROG TO BE LOADED)
      STA TIDNT     SET IDENT ADDRESS FOR IDX 
      STA B,I       SET ENTRY IN PROGRAM LIST 
      JSB IDX       SET IDENT ADDRESSES 
      HLT 0B        INVALID RETURN - NON-EXISTENT ID
      LDA ID3,I     GET PROGRAM USAGE FLAG
      SLA,INA       SKIP - PROGRAM NOT YET LOADED 
      JMP EPLST     TEST FOR END OF PLIST 
      STA ID3,I     SET PROGRAM USAGE FLAG = LOADED 
      JMP LOADN     LOAD NEXT PROGRAM 
* 
*                                   PROCESS ENT/EXT RECORDS 
DENTR CCA,RSS       SET ENT FLAG AND SKIP 
DEXTR CLA           SET EXT FLAG
      STA NXFLG     SAVE ENT/EXT FLAG 
      LDA B         GET NO. ENTRIES IN EXT/ENT
      AND M37       ISOLATE SYMBOL COUNT
      CMA,INA 
      STA EXCNT     SET SYMBOL COUNTER
      JSB DBSET     GET ADDR OF NEXT WORD IN LBUF 
      JSB DBSET     GET ADDR OF NEXT WORD IN LBUF 
NXSYM LDA CURAL,I   GET NAME 1,2
      STA TBUF      SAVE NAME 1,2 IN TEMP BUFF
      JSB DBSET     GET ADDR OF NEXT WORD IN LBUF 
      LDA CURAL,I   GET NAME 3,4
      STA TBUF+1    SAVE NAME IN TEMP BUFF
      JSB DBSET     GET ADDR OF NEXT WORD IN LBUF 
      LDA CURAL,I   GET NAME 5
      STA TBUF+2    SAVE NAME IN TEMP BUFF
      JSB DBSET     GET ADDR OF NEXT WORD IN LBUF 
      JSB INLST     INITIATE LSTX 
ENEX1 JSB LSTX      SET LST ADDRESSES 
      HLT 0B        ENT/EXT NOT FOUND IN LST
      LDA TBUF      GET NAME 1,2
      CPA LST1,I    EQUAL?
      RSS           YES - CONTINUE
      JMP ENEX1     NO - TRY NEXT LST ENTRY 
      LDA TBUF+1    GET NAME 3,4
      CPA LST2,I    EQUAL?
      RSS           YES - CONTINUE
      JMP ENEX1     NO - TRY NEXT LST ENTRY 
      LDA TBUF+2    GET NAME 5
      AND M7400     ISOLATE UPPER CHAR
      STA B 
      LDA LST3,I
      AND M7400 
      CPA B         EQUAL?
      RSS           YES - CONTINUE
      JMP ENEX1     NO - TRY NEXT LST ENTRY 
* 
      LDA NXFLG     GET ENT/EXT FLAG
      SZA,RSS       SKIP IF ENTRY 
      JMP EXT1      PROCESS EXT 
      JSB ZLOAD     IF NOT LOADING CURRENT PGM
      JMP NLENT     SKIP LINK AND MAP 
      LDB TPREL     GET CURRENT PROG RELOC BASE 
      ADB CURAL,I   ADD CURRENT RELOCATION VALUE
      STB OPRND     SAVE ABS ENTRY PT. ADDRESS
      LDA LST5,I    GET BP LINK ADDRESS 
      SZA,RSS       SKIP - BP LINK ADDR SET 
      JSB BPSCN     SET BP LINK ADDR, BP LINK 
      STA LST5,I    SET BP LINK ADDRESS IN LST
      JSB SETOP     SET OPERAND IN BASE PAGE
      LDA L01       IF 1ST OF TWO 
      SZA,RSS        PASSES, SKIP 
      JMP NLENT      ENT LIST 
      LIA 1         GET SWITCH REGISTER 
      SSA,RSS       SKIP - SWITCH 15 UP (LIST ENTS) 
      JMP NLENT     SUPPRESS PRINTING OF MAP
      JSB CLIST     CLEAR MEMORY MAP BUFFER 
      LDA BLAST     GET BLANK, ASTERISK 
      STA MLIST+1   SET IN MAP
      LDA LST1,I    GET NAME 1,2
      STA MLIST+2   SET IN MEMORY MAP 
      LDA LST2,I    GET NAME 3,4
      STA MLIST+3   SET IN MEMORY MAP BUFFER
      LDA LST3,I    GET NAME 5
      AND M7400     ISOLATE UPPER CHAR
      IOR BLANK     SET LOWER CHARACTER = BLANK 
      STA MLIST+4   SET NAME 5 IN MEM MAP 
      LDA OPRND     GET ABSOLUTE ENTRY PT. ADDRESS
      LDB AMEM5     GET ADDRESS OF MESSAGE
      JSB CONVD     CONVERT TO DECIMAL/OCTAL
      LDA P16 
      LDB AMLST     GET ADDRESS OF MEM MAP BUFFER 
      JSB DRKEY,I   PRINT ENTRY POINT 
NLENT JSB DBSET     GET ADDR OF NEXT WORD IN LBUF 
      JMP EXEND     PROCESS NEXT SYMBOL 
* 
EXT1  LDA TBUF+2    GET ORDINAL 
      STA LST3,I    SET ORDINAL IN LST
      JSB ZLOAD     IF NOT LOADING CURRENT PGM
      JMP *+5       SKIP LINK ALLOCATION
      LDA LST5,I    GET BP LINK ADDRESS 
      SZA,RSS       SKIP - BP LINK ADDRESS SET
      JSB ALLOC     ALLOCATE NEW BP LOCATION
      STA LST5,I    SET NEW BP LINK ADDRESS 
      LDA LST4,I    GET IDENT ADDRESS 
      SZA,RSS       SKIP - EXT DEFINED
      JMP EXEND     IGNORE UNDEFINED PROGRAM CALL 
      STA TIDNT     SET ID ADDR FOR IDX 
      LDA ID1       GET CURRENT IDENT ADDRESS 
      STA TBUF      SAVE CURRENT IDENT ADDRESS
      JSB IDX       SET IDENT ADDRESSES 
      HLT 0B        IDENT NOT FOUND IN LIST 
      LDA ID6,I     GET M/S, TYPE 
      STA TBUF+1    SAVE M/S, TYPE
      LDA ID3,I     GET PROGRAM USAGE FLAG
      STA TBUF+2    SAVE USAGE FLAG 
      LDA TBUF      GET CURRENT IDENT ADDRESS 
      STA TIDNT     SET CURRENT IDENT ADDR
      JSB IDX       SET IDENT ADDRESSES 
      HLT 0B        CURRENT IDENT NOT FOUND IN LIST 
      LDA TBUF+1    GET M/S, TYPE FOR EXT 
      RAL,CLE,ERA   SET E = M/S 
      AND M177      ISOLATE TYPE
      CPA P6        TYPE = LIBRARY? 
      JMP LIBUT     YES - TEST FOR LOADING
      SZA,RSS       IF SYSTEM REFERENCE 
      JMP *+4       CONTINUE
      LDB P6        ELSE IF CURRENT TYPE
      CPB LDTYP     IS 6 THEN 
      JMP CALER     ERROR - TYPE 6 MAY  ONLY CALL TYPES 0/6 
      CPA P7        TYPE = UTILITY? 
      JMP LIBUT     YES - TEST FOR LOADING
      SEZ           SKIP - NOT MAIN PROGRAM 
      JMP EXEND     IGNORE PROGRAM CALL 
LIBUT LDB PLAD      GET PROGRAM LIST ADDRESS
PLEXT LDA B,I       GET PROG LIST ENTRY 
      SZA,RSS       SKIP IF IDENT ADDRESS 
      JMP SEXT      MAKE ENTRY IN PROGRAM LIST
      RAL,CLE,ERA   CLEAR SIGN
      CPA LST4,I    PROGRAM PREVIOUSLY CALLED?
      JMP EXEND     YES - IGNORE EXT SYMBOL 
      INB           INCR PROG LIST ADDR 
      JMP PLEXT      CONTINUE PROGRAM LIST SCAN 
CALER LDA ERR15     SET ERROR CODE - ILLEGAL CALL 
      JSB ERROR     PRINT DIAGNOSTIC
      JMP EXEND     TEST FOR ALL EXTS PROCESSED 
SEXT  LDA TBUF+2    GET PROGRAM USAGE FLAG
      SLA           SKIP - PROGRAM NOT LOADED 
      JMP EXEND     OMIT PROGRAM LIST ENTRY 
      LDA LST4,I    GET CALLED PROGRAM IDENT ADDRESS
      IOR MSIGN     SET SIGN TO SHOW PROG NOT LOADED
      STA B,I       SET IN PROGRAM LIST 
      INB           STEP TO NEXT LIST ENTRY 
      CLA           AND 
      STA B,I       SET TO ZERO TO INDICATE END 
EXEND ISZ EXCNT     SKIP - ALL SYMBOLS PROCESSED
      JMP NXSYM     NO - PROCESS NEXT SYMBOL
      JMP CLSRC     NO - CLASSIFY NEXT RECORD 
* 
*                                   PROCESS DBL RECORDS 
DDBLR JSB ZLOAD     IF NOT LOADING
      JMP CLST-1    SKIP TO END 
      LDA B         GET COUNT 
      AND M77       ISOLATE COUNT 
      CMA,INA 
      STA EXCNT     SET INSTRUCTION COUNT 
      JSB DBSET     GET ADDR OF NEXT WORD IN LBUF 
      JSB DBSET     GET ADDR OF NEXT WORD IN LBUF 
* 
      LDB CURAL,I   GET RELOCATION ADDRESS
      STB DBLAD     SAVE RELOCATION ADDRESS 
      ISZ PLFLG     SKIP - FIRST DBL RECORD 
      JMP DBL0      IGNORE SUBSEQUENT RECORDS 
      LDA L01 
      SZA 
      LDA ID6,I     GET TYPE
      AND M177      ISOLATE TYPE
      CPA P2        TYPE = RT DISK RESIDENT?
      JMP HABSS     SET NEW MEMORY BOUND
      CPA P3        TYPE = BG DISK RESIDENT?
      JMP HABSS     SET NEW MEMORY BOUND
      CPA P5        TYPE = BG SEGMENT?
      RSS 
      CLB           SET PGMAD = 0 FOR RESIDENTS 
HABSS STB BSSDP     SAVE INITIAL PROG DISPLACEMENT
      ADB RELAD     ADD RELOCATION ADDRESS
      STB RELAD     SET NEW RELOCATION ADDRESS
DBL0  JSB DBSET     GET ADDR OF NEXT WORD IN LBUF 
DBL1  LDB CURAL,I   GET RELOCATION BYTES
      STB REKEY     SAVE FOR RELOCATION TYPE
      LDA N5
      STA INSCN     SET RELOCATION BYTE COUNT 
      JSB DBSET     GET ADDR OF NEXT WORD IN LBUF 
* 
DBL2  LDA REKEY     GET RELOCATION BYTES
      ALF,RAR       ROTATE TO LOW A 
      STA REKEY     SAVE FOR NEXT INSTRUCTION WORD
      AND M7        ISOLATE CURRENT BYTE
      CPA P4        EXTERNAL REFERENCE? 
      JMP DBL4      YES - GET LINK ADDRESS
      CPA P5        MEMORY REFERENCE? 
      JMP DBL6      YES - CHECK FOR INDIRECT LINK 
      ADA RBTAD     ADD RELOCATION BASE TABLE ADDR
      LDA A,I       GET RELOCATION BASE 
      ADA CURAL,I   ADD CURRENT INSTRUCTION WORD
* 
DBL3  LDB RELAD     GET PREVIOUS RELOCATION ADDRESS 
      CMB,INB       SET TO NEGATIVE 
      ADB DBLAD     ADD CURRENT RELOCATION ADDRESS
      ADB TPREL     ADD CURRENT PROG RELOCATION BASE
      INB           INCR FOR NEXT LOCATION
      STA TEMP2     IF 1ST OF 2 PASSES, 
      LDA L01        DO NOT OUTPUT
      SZA,RSS        TO DISC
      JMP *+3 
      LDA TEMP2 
      JSB ALABD,I   OUTPUT ABSOLUTE WORD
      JSB DBSET     GET ADDR OF NEXT WORD IN LBUF 
      ISZ EXCNT     SKIP - LAST INSTRUCTION OUT 
      RSS           NO - CONTINUE 
      JMP CLSRC     YES - CLASSIFY NEXT RECORD
      ISZ DBLAD     INCR DBL RELOCATION ADDRESS 
      ISZ INSCN     SKIP IF NEW RELOCATION BYTE 
      JMP DBL2      NO - PROCESS NEXT INSTRUCTION 
      JMP DBL1      YES - GET NEXT RELOCATION BYTE
* 
DBL4  LDA CURAL,I   GET CURRENT DBL WORD
      AND M377      ISOLATE ORDINAL 
      STA EXORD     SAVE ORDINAL
      JSB INLST     INITIALIZE LSTX 
DBL5  JSB LSTX      SET LST ADDRESSES 
      HLT 0B        ORDINAL NOT FOUND 
      LDA LST3,I    GET WORD 3 OF LST ENTRY 
      AND M377      ISOLATE ORDINAL 
      CPA EXORD     SAME ORDINALS?
      RSS           YES - CONTINUE
      JMP DBL5      NO - CONTINUE LST SEARCH
      LDB LST5,I    GET BP LINK ADDRESS 
      LDA CURAL,I   GET CURRENT DBL WORD
      AND M1740     ISOLATE INSTRUCTION CODE
      IOR MSIGN     SET SIGN = 1 (INDIRECT) 
      IOR B         SET ADDRESS = BP LINK ADDRESS 
      JMP DBL3      OUTPUT INSTRUCIION
* 
DBL6  LDA CURAL,I   GET CURRENT DBL WORD
      STA INSTR     SAVE INSTRUCTION CODE 
      JSB DBSET     GET ADDR OF NEXT WORD IN LBUF 
      LDA INSTR     GET INSTRUCTION CODE
      LDB TPREL     GET CURRENT PROG RELOC ADDR 
      RAR,SLA,RAL   SKIP IF PROGRAM REFERENCE 
      LDB COMAD     REPLACE PROG WITH COMMON BASE 
      ADB CURAL,I   ADD CURRENT INSTR ADDRESS 
      AND M1740     ISOLATE INSTRUCTION CODE
      SSA           SKIP IF DIRECT REFERENCE
      ADB MSIGN     SET SIGN = 1
      STA INSTR     SAVE INSTRUCTION CODE 
      LDA DBLAD     GET CURRENT RELOCATION ADDRESS
      ADA TPREL     ADD CURRENT RELOCATION BASE 
      AND M0760     ISOLATE PAGE NUMBER 
      STA PAGNO     SAVE CURRENT PAGE NUMBER
      LDA B         GET INSTRUCTION ADDRESS 
      AND M0760     ISOLATE PAGE NUMBER 
      CPA PAGNO     SAME PAGE?
      JMP DBL7      YES - NO INDIRECT ADDRESS NEEDED
      STB OPRND     SAVE INSTRUCTION ADDRESS
      JSB BPSCN     SCAN BP FOR SAME OPERAND
LINKC JSB SETOP     SET OPERAND IN BP LOCATION
      STA B         SAVE LINK ADDRESS 
      AND M1777     GET PAGE OFFSET 
      CPA B         CURRENT PAGE? 
      RSS           NO SKIP 
      IOR M2000     YES-- SET CURRENT PAGE BIT
      IOR MSIGN     SET INDIRECT BIT
      JMP DBL8      GO ADD INSTRUCTION AND STORE THE WORD 
* 
DBL7  LDA B         GET OPERAND ADDRESS 
      AND M1777     ISOLATE PAGE LOCATION 
      IOR M2000     SET Z/C = 1 (CURRENT) 
DBL8  IOR INSTR     ADD INSTRUCTION CODE
      JMP DBL3      OUTPUT INSTRUCTION WORD 
      SPC 2 
ZLOAD NOP           TEST FOR LOADING CURRENT PGM
      LDA LIBFG     LIB LOADING?
      SZA,RSS 
      JMP *+3       NO; THEN LOADING - GO STEP ADDRESS
      LDA P6        YES; CURRENT PGM TYPE=6?
      CPA LDTYP 
      ISZ ZLOAD     LIB AND SIX OR NOT LIB STEP ADDRESS 
      JMP ZLOAD,I   RETURN
      SKP 
*                                   CLEAR PROGRAMS-LOADED FLAGS 
* 
*  CLID3 CLEARS THE USAGE FLAGS TO ENSURE THAT PROGRAMS WILL BE 
*  RE-LOADED AGAIN IF CALLED MORE THAN ONCE.  THIS IS ESSENTIAL 
*  FOR ALL UTILITY PROGRAMS AND USER SUBROUTINES, BUT MUST NOT
*  BE DONE FOR SYSTEM PROGRAMS, LIBRARY PROGRAMS, OR MAIN USER
*  PROGRAMS.  BOTH THE USAGE FLAG IN THE IDENT ENTRY AND THE
*  BP LINK ADDRESS FOR ALL ENTRY POINTS IN THE PROGRAM ARE CLEARED. 
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB CLID3
*  RETURN: CONTENTS OF A AND B ARE DESTROYED. 
* 
CLID3 NOP 
      LDA P5
      LDB PLAD      GET ADDRESS OF PROGRAM LIST 
      CPA PTYPE     PROG = BG SEGMENT?
      LDB PLMAN     YES - GET MAIN PROG LIST ADDRESS
      STB CURAP     SET CURRENT PROG LIST ADDRESS 
TRID3 LDA CURAP,I   GET CURRENT PROG LIST ENTRY 
      SZA,RSS       SKIP - NOT ENT OF PROG LIST 
      JMP CLID3,I   RETURN (ALL FLAGS CLEARED)
      ISZ CURAP     INCR CURRENT PROG LIST ADDRESS
      STA TIDNT     SET CURRENT IDENT ADDRESS 
      JSB IDX       SET CURRENT IDENT ADDRESSES 
      HLT 0B        IDENT NOT FOUND 
      LDA ID6,I     GET M/S,TYPE
      SSA           SKIP IF SUB 
      JMP TRID3     IGNORE MAIN 
      AND M177      ISOLATE TYPE
      CPA P6        TYPE = LIBRARY? 
      JMP TRID3     YES - DO NOT CHANGE FLAG
      CPA ZERO      TYPE = SYSTEM?
      JMP TRID3     YES - DO NOT CHANGE FLAG
      LDA ID3,I     GET USAGE FLAG
      AND M7400     ISOLATE NAME 5
      STA ID3,I     SET NAME 5 IN IDENT 
      JSB INLST     INITIALIZE LSTX 
CLSUT JSB LSTX      SET CURRENT LST ADDRESSES 
      JMP TRID3     TRY NEXT IDENT
      LDA LST4,I    GET IDENT ADDRESS 
      CPA ID1       ENT/EXT BELONGS TO CURRENT PROG?
      CLB,RSS       YES - CONTINUE
      JMP CLSUT     TRY NEXT LST ENTRY
      STB LST5,I    CLEAR BP LINK ADDRESS 
      JMP CLSUT     CONTINUE CLEARING BP LINK ADDR. 
     SKP
* 
*                                   GET BP LINK ADDR, SET BP VALUE
* 
*  BPSCN SCANS THE RESIDENT AND CURRENT SECTIONS OF BASE PAGE 
*  FOR A VALUE EQUAL TO THE CURRENT OPERAND.  IF SUCH A VALUE 
*  IS FOUND, THE ADDRESS OF THE OPERAND IS RETURNED 
*  IN THE A-REGISTER.  OTHERWISE, A NEW BP LINK WORD IS 
*  RESERVED AND THE ADDRESS OF THIS WORD RETURNED IN A. 
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB BPSCN
* 
*  RETURN:
*    A = BP LINK ADDRESS FOR CURRENT OPERAND
*    B = DESTOYED 
* 
BPSCN NOP           SCAN BP AREA FOR SAME OPERAND 
* 
      LDA LRBP      GET LOW RESIDENT BOUND
      LDB URBP      GET HIGH RESIDENT BOUND 
      JSB SCNBP     SCAN AREA FOR SAME OPERAND
* 
      LDA LBBP      GET LOW BACKGROUND BOUND
      LDB UBBP      GET HIGH BACKGROUND BOUND 
      JSB SCNBP     SCAN AREA FOR SAME OPERAND
* 
      LDA PBREL     GET LOW CURRENT BOUND 
      LDB TBREL     GET HIGH CURRENT BOUND
      JSB SCNBP     SCAN AREA FOR SAME OPERAND
* 
      JSB LINKD,I   GO CHECK FOR CURRENT PAGE LINK
* 
      JSB ALLOC     ALLOCATE NEW BP LINK ADDRESS
      JMP BPSCN,I   RETURN - A = BP LINK ADDRESS
      SKP 
* 
*                                   SCAN BP AREA FOR SAME OPERAND 
* 
*  THE SCNBP SUBROUTINES CONTROLS THE SCAN FOR A GIVEN OPERAND
*  IN THE CURRENT BP SECTION. 
* 
*  CALLING SEQUENCE:
*    A = LOWER BP ADDRESS 
*    B = UPPER BP ADDRESS 
*    JSB SCNBP
* 
*  RETURN:
*    (1): TO BPSCN - OPERAND NOT FOUND
*    (2): TO MAIN PROGRAM - OPERAND FOUND (A = BP ADDR OF OPERAND)
* 
SCNBP NOP 
      CMB,INB       SET LOW BOUND TO NEGATIVE 
      STB UPPER     SAVE NEGATIVE UPPER BOUND 
      STA LOWER     SAVE LOWER BOUND
BPSRC LDA LOWER     GET CURRENT LOW BP BOUND
      ADA UPPER     TEST FOR END OF AREA
      SSA,RSS       SKIP - AREA NOT EXHAUSTED 
      JMP SCNBP,I   RETURN - SAME OPERAND NOT FOUND 
      LDB OPRND     GET OPERAND 
      LDA LOWER     SET A = LOWER BOUND 
      ADA M2000     ADJUST FOR FIRST PAGE ADDRESS 
      ISZ LOWER     INCR LOWER BOUND
      CPB A,I       OPERANDS EQUAL? 
      RSS           YES - GET BP ADDRESS
      JMP BPSRC     NO - CONTINUE BP SCAN 
      ADA L2000     ADJUST FOR BP ADDRESS 
      JMP BPSCN,I   RETURN - A = BP LINK ADDR FOR OP
      SKP 
* 
*                                   SET OPERAND IN BP LOCATION
* 
*  SETOP SETS THE CURRENT OPERAND IN THE BP LOCATION
*  SPECIFIED BY THE ADDRESS IN A. 
* 
*  CALLING SEQUENCE:
*    A = CURRENT BP LINK ADDRESS
*    B = IGNORED
*    JSB SETOP
* 
*  RETURN:
*    A = BP LINK ADDRESS
*    B = DESTROYED
* 
SETOP NOP 
      ADA M2000     ADJUST BP LINK ADDRESS
      LDB OPRND     GET OPERAND 
      STB A,I       SET BP VALUE IN BP LOCATION 
      ADA L2000     ADJUST FOR BP ADDRESS 
      JMP SETOP,I   RETURN - A = BP LINK ADDRESS
      SKP 
* 
*                                   ALLOCATE NEW BP LINK WORD 
* 
*  THE ALLOC SUBROUTINE ESTABLISHES ALL THE BP LINKAGE ADDRESSES. 
*  IF THE ALLOCATED LINK WORD FALLS IN THE SYSTEM COMMUNICATION AREA, 
*  A DISGNOSTIC IS PRINTED. 
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB ALLOC
* 
*  RETURN:
*    A = ALLOCATED BP LINK ADDRESS
*    B = DESTROYED
* 
ALLOC NOP 
      LDA TBREL     GET NEXT BP ADDRESS 
      ADA M2000     ADJUST FOR BP ADDRESS 
      CLB 
      STB A,I       CLEAR ALLOCATED BP LOCATION 
      ADA L2000     ADJUST FOR BP ADDRESS 
      ISZ TBREL     INCR BP RELOCATION ADDR 
      STA TCHAR     SAVE THE LOCATION 
      LDA TBREL     GET THE NEXT LOCATION 
      STA B         TO B
      CMB,INB       SUBTRACT
      ADB BPMAX     FROM CURRENT MAX
      SSB           IF GREATER THAN MAX 
      STA BPMAX     SET NEW MAX 
      CMA,CLE,INA   SET NEXT LINKAGE ADDRESS NEG
      ADA LWSBP     ADD ORGIN OS SYS COMM AREA
      LDA ERR16     GET ERROR CODE: BP OVERFLOW 
      SEZ,RSS       SKIP IF NO OVERFLOW - 
      JSB ERROR     PRINT ERROR MESSAGE 
      LDA TCHAR     GET BP LINK ADDRESS 
      JMP ALLOC,I   RETURN
      SKP 
* 
*                                   READ RELOCATABLE RECORD CONTROL 
* 
*  DBSET ESTABLISHES THE ADDRESS OF THE NEXT WORD OF THE RELOCATABLE
*  RECORD IN LBUF.  IF LBUF HAS BEEN PROCESSED, IT ISSUES A CALL TO 
*  DBIN TO READ ANOTHER PACKED RELOCATABLE RECORD.
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB DBSET
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED
* 
DBSET NOP 
      ISZ CURAL     INCR CURRENT LBUF ADDRESS 
      ISZ LCNT      SKIP - END OF LBUF
      JMP DBSET,I   RETURN
      JSB DBIN      READ NEXT RELOCATABLE REC 
      JMP DBSET,I   RETURN
      SKP 
* 
*                                   READ PACKED RELOCATABLE RECS
* 
*  THE DBIN SUBROUTINE READS THE PACKED RELOCATABLE RECORDS FROM
*  THE DISK AS SPECIFIED BY THE DISK ADDRESS AT DSKRD.
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB DBIN 
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED. 
* 
DBIN  NOP 
      LDA DSKRD     GET CURRENT DISK ADDRESS
      LDB DBIN      GET RETURN ADDRESS
      CPB DBINS     IF NAM RECORD READ, CHECK 
      RSS            FOR WRITE (ABSOLUTE) ADDRESS 
      JMP DBIN1      GREATER THAN READ (RELOC) ADDRESS -
      LDB DSKA      GET CURRENT HIGH WRITE ADDRESS
      CMB           IF EQUAL OR GREATER THAN
      ADB A          THIS READ ADDRESS, 
      SSB,RSS        ABSOLUTE HAS EXTENDED
      JMP DBIN1      OVER RELOCATABLE:
      LDA ERR38       IRRECOVERABLE 
      JSB IRERR       ERROR 
DBIN1 LDB ALBUF     GET ADDRESS OF LBUF 
      STB CURAL     SET CURRENT LBUF ADDRESS
      JSB DISKI     READ RECORD FROM DISK 
      LDA DSKRD     GET DISK ADDRESS
      STA DSKRX     -SAVE CURRENT ADDRESS.
      JSB DISKA     INCR DISK ADDRESS 
      STA DSKRD     SET NEXT DISK ADDRESS 
      LDA N64 
      STA LCNT      SET CURRENT LBUF COUNT
      JMP DBIN,I    RETURN
      SPC 1 
DBINS DEF DBINT     ADDRESS OF NAM RECORD READ RETURN 
      SKP 
* 
*                                   MOVE DBUF TO SPECIFIED BUFFER 
* 
*  THE MOVER SUBROUTINE MOVES THE CURRENT CONTENTS OF DBUF
*  TO THE BUFFER SPECIFIED IN B.
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = ADDR OF BUFFER TO WHICH DBUF IS MOVED
*    JSB MOVER
* 
*  RETURN:
*    A = CURRENT DBUF COUNT 
*    B = DESTROYED
* 
MOVER NOP 
      LDA ADBUF     GET ADDRESS OF DBUF 
      STA CURAT     SET CURRENT DBUF ADDRESS
      LDA N64 
      STA TCNT      SET CURRENT COUNT 
MOVED LDA CURAT,I   GET WORD FROM DBUF
      STA B,I       PUT WORD INTO CURRENT BUFFER
      ISZ CURAT     INCR CURRENT DBUF ADDRESS 
      INB           INCR CURRENT BUFFER ADDRESS 
      ISZ TCNT      SKIP - DBUF MOVED TO CURRENT
      JMP MOVED     CONTINUE MOVING FROM DBUF 
      LDA DCNT      GET CURRENT DBUF COUNT
      JMP MOVER,I   RETURN
      SKP 
* 
*                                   'OR' CURRENT RECORD WITH DBUF 
* 
*  THE RECOR SUBROUTINE OR'S DBUF AND THE SPECIFIED RECORD
*  AND PLACES THE RESULT IN THE OTHER BUFFER. 
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = ADDRESS OF BUFFER TO BE OR-ED
*    JSB RECOR
* 
*  RETURN:  CONTENTS OF A AND B ARE DESTOYED. 
* 
RECOR NOP 
      LDA ADBUF     GET ADDRESS OF DBUF 
      STA CURAD     SET CURRENT DBUF ADDRESS
      LDA N64 
      STA WDCNT     SET RECORD LENGTH 
ORREC LDA B,I       GET CURRENT BUFFER WORD 
      IOR CURAD,I   ADD CURRENT DBUF WORD 
      STA B,I       SET NEW BUFFER WORD 
      INB           INCR CURRENT BUFFER ADDRESS 
      ISZ CURAD     INCR CURRENT DBUF ADDRESS 
      ISZ WDCNT     SKIP - ALL WORDS OR-ED
      JMP ORREC     OR NEXT BUFFER WORD 
      JMP RECOR,I   RETURN
      SKP 
* 
*                                   GENERATE INT ENTRY,KEYWD,ID SEG 
* 
*  GENID GENERATES THE CURRENT ID SEGMENT AND KEYWORD 
*  FOR THE PROGRAM LOADED.  IN ADDITION, IT GENERATES THE 
*  LINKAGE REQUIRED IN THE INTERRUPT TABLE FOR THOSE PROGRAMS 
*  WHICH ARE TO BE SCHEDULED UPON RECEIPT OF AN INTERRUPT.
* 
*  CALLING SEQUENCE:
*    A = 0 (GENERATE SHORT ID SEGMENT)
*       -1 (GENERATE LONG ID SEGMENT) 
*        -2 (GENERATE BLANK ID SEGMENT)            $
*    B = IGNORED
*    JSB GENID
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED
* 
GENID NOP 
      STA PLFLG     SAVE ID SEGMENT LENGTH FLAG 
      CPA  N2       IF = 2, SKIP INT CODE          $
      JMP  STKEY     CHECK, GENERATE KEYWORD.      $
*                                   GENERATE INT ENTRY FOR USER SYS 
      LDA DSKIN     GET DISK ADDR OF INT CODE 
      STA DSKRD     SET DISK ADDR FOR DBIN
      JSB DBIN      READ RECORD TO LBUF 
      LDA INTCN     GET INT DISK RECORD COUNT 
      STA LCNT      SET CURRENT LBUF COUNT
      ADA P64 
      ADA ALBUF     SET A = CURRENT LBUF ADDRESS
      STA CURAL     SET CURRENT LBUF ADDRESS
      LDA CINT      GET NO. OF INT ENTRIES
      CMA,INA,SZA,RSS  SKIP - INT NOT EMPTY 
      JMP STKEY     GENERATE KEYWORD, ID SEGMENT
      STA TCNT      SAVE TOTAL INT COUNT
GETIT LDA CURAL,I   GET CURRENT WORD IN INT 
      SZA           IGNORE ZERO ENTRIES IN INT
      SSA           TEST POSITIVE ENTRIES FOR ILIST 
      JMP NOTPN     IGNORE NEG(ID SEG), ZERO IN INT 
      ADA L2000     TEST FOR VALUE NOT IN SYS PROG
      SSA,RSS       SKIP - INT ENTRY POINTS TO ILIST
      JMP NOTPN     IGNORE NORMAL INT ENTRY 
      LDA CURAL,I   GET CURRENT WORD IN INT 
      LDA A,I       GET ENTRY IN ILIST
      CPA IMAIN     EQUAL TO MAIN IDENT ADDR? 
      RSS           YES - CONTINUE
      JMP NOTPN     IGNORE REF IF NOT CURRENT MAIN
      LDA SYSAD     GET ID SEG ADDRESS
      CMA,INA       GET 2'S COMPLEMENT FOR INT ENTRY
      STA CURAL,I   PUT ID SEG ADDR IN INT
      LDA DSKRX     GET CURRENT INT DISK ADDRESS
      LDB ALBUF     GET ADDRESS OF LBUF 
      JSB DISKO     REWRITE INT RECORD ON DISK
NOTPN JSB DBSET     GET ADDR OF NEXT WORD IN LBUF 
      ISZ TCNT      SKIP - INT EXHAUSTED
      JMP GETIT     ANALYZE NEXT INT ENTRY
* 
*                                   GENERATE KEYWORD
STKEY LDA IMAIN     GET MAIN IDENT ADDRESS
      STA TIDNT     SET ADDRESS FOR IDX 
      JSB IDX       SET IDENT ADDRESSES 
      HLT 0         NO IDENT FOUND
      LDA ID1       GET IDENT ADDRESS 
      LDB SYSAD     GET CURRENT ID SEGMENT ADDRESS
      CPA SCH1      SCHEDUL PGM?
      STB SCH4      YES  SAVE ITS ID ADDRESS
      LDA PLFLG     GET THE ID SEGMENT LENGTH FLAG
      STB CURAK,I   PUT ID SEGMENT ADDR IN KBUF 
      ADB P22       ADJUST FOR NEXT ID SEGMENT ADDR 
      SZA           SKIP - SHORT ID SEGMENT 
      ADB P6        ADJUST FOR LONG ID SEGMENT
      STB SYSAD     SET NEXT ID SEGMENT ADDRESS 
      LDA ID1       IF THIS IS THE PGM TO BE SCHEDULED
      CPA SCH1      THEN
      STB SCH3      SAVE ADDRESS OF NEXT ID 
      ISZ KEYCT     ADD 1 TO CURRENT KEYWORD COUNT.$
      ISZ CURAK     INCR CURRENT KBUF ADDRESS 
      ISZ KCNT      SKIP - KBUF FULL
      JMP KYOUT     NO - PROCESS ID SEGMENT 
      LDA DSKEY     GET CURRENT KEYWORD DISK ADDRESS
      STA DSKRD      SET TO READ IN TARGET SECTOR 
      JSB DBIN       FROM DISC INTO LBUF. 
      LDB AKBUF     -OR- INT RECORD WITH KBUF 
      JSB AREDO,I 
      LDA  DSKEY     -RESTORE A-REGISTER           $
      LDB AKBUF     GET ADDRESS OF KBUF 
      STB CURAK     SET NEW CURRENT KBUF ADDRESS
      JSB DISKO     OUTPUT KEYWORD RECORD TO DISK 
      LDB AKBUF     GET ADDRESS OF KBUF 
      JSB BUFCL     CLEAR KEYWORD BUFFER
      LDA DSKEY     GET CURRENT KEYWORD DISK ADDRESS
      JSB DISKA     INCREMENT DISK ADDRESS
      STA DSKEY     SET NEW KEYWORD DISK ADDRESS
      LDA N64 
      STA KCNT      SET NEW KBUF COUNT
* 
*                                   GENERATE ID SEGMENT 
KYOUT LDA PLFLG     IF FLAG = -2 FOR               $
      CPA N2         BLANK OUTPUT,                 $
      JMP BLOUT      TRANSFER                      $
      LDA SYSAD     GET CURRENT ID SEGMENT ADDRESS
      LDB ID1       IF THIS IS THE SCHEDULED PGM
      CPB SCH1      THEN
      CLA           SET ZERO - END OF LIST
      CPB SCH2      IF NEXT IS SCHEDULED PGM
      ADA SCH3      ADD LENGTH OF ITS ID TO SKIP IT IN DORM LIST
      JSB OUTID     OUTPUT WORD TO ID SEGMENT BUFFER
      LDB N5
      JSB ZOUT      OUTPUT ZEROES TO ID SEGMENT 
      LDA ID6,I     GET PRIORITY
      ALF,ALF       ROTATE TO LOW A 
      AND M177      ISOLATE PRIORITY
      JSB OUTID     OUTPUT WORD TO ID SEGMENT BUFFER
      LDA PRENT     GET PRIMARY ENTRY POINT 
      JSB OUTID     OUTPUT WORD TO ID SEGMENT BUFFER
      LDB N2
      JSB ZOUT      OUTPUT ZEROES TO ID SEGMENT 
      LDA SCH4      GET THE ID SEGMENT ADDR OF SCHED PGM
      INA           STEP TO PRAM LIST 
      LDB ID1       IS CURRENT PGM
      CPB SCH1      THE SCHED PGM?
      RSS           YES - SKIP  A IS THE B REG FOR THE ID SEGMENT 
      CLA           NO SET TO SEND A ZERO TO THE ID SEGMENT 
      JSB OUTID     OUTPUT B REG TO ID SEGMENT
      CLA           SEND E/O REGS TO
      JSB OUTID     THE ID SEGMENT
      LDA ID1,I     GET NAME 1,2
      JSB OUTID     OUTPUT WORD TO ID SEGMENT BUFFER
      LDA ID2,I     GET NAME 3,4
      JSB OUTID     OUTPUT WORD TO ID SEGMENT BUFFER
      LDA ID6,I     GET TYPE
      AND M177      ISOLATE TYPE
      STA B         SAVE TYPE IN B
      LDA ID3,I     GET NAME 5
      AND M7400     ISOLATE NAME 5
      IOR B         ADD TYPE TO NAME 5
      JSB OUTID     OUTPUT WORD TO ID SEGMENT BUFFER
      CLA           PRESET FOR DORMANT
      LDB ID1       IF THIS PGM TO BE 
      CPB SCH1      SCHEDULED 
      CLA,INA       SET SCHEDULED FLAG
      JSB OUTID     SET WORD IN ID
      CLA           SET TIME LINK 
      JSB OUTID     TO ZERO AND OUTPUT
      LDA ID7,I     GET RESOLUTION CODE, EXEC MULT
      JSB OUTID     OUTPUT WORD TO ID SEGMENT BUFFER
      LDA ID9,I     GET 10'S MILLISECONDS 
      AND M377      ISOLATE LOWER CHAR
      ADA N100      GET COMPLEMENTED VALUE
      JSB OUTID     OUTPUT WORD TO ID SEGMENT BUFFER
      LDA ID9,I     GET SECONDS 
      ALF,ALF       ROTATE TO LOW A 
      AND M377      ISOLATE LOWER CHAR
      ADA N60       GET COMPLEMENTED VALUE
      JSB OUTID     OUTPUT WORD TO ID SEGMENT BUFFER
      LDA ID8,I     GET MINUTES 
      AND M377      ISOLATE LOWER CHAR
      ADA N60       GET COMPLEMENTED VALUE
      JSB OUTID     OUTPUT WORD TO ID SEGMENT BUFFER
      LDA ID8,I     GET HOURS 
      ALF,ALF       ROTATE TO LOW A 
      AND M377      ISOLATE LOWER CHAR
      ADA N24       GET COMPLEMENTED VALUE
      JSB OUTID     OUTPUT WORD TO ID SEGMENT BUFFER
      ISZ PLFLG     SKIP - PUTOUT LONG ID SEGMENT 
      JMP GENID,I   RETURN - SHORT ID SEGMENT 
      LDA PPREL     GET CURRENT PROG RELOC ADDRESS
      LDB PTYPE     GET CURRENT PROG TYPE 
      CPB P5        TYPE = BG SEGMENT?
      LDA BSPAD     YES - GET BS RELOC ADDRESS
      ADA BSSDP     ADD INITIAL PROG DISPLACEMENT 
      JSB OUTID     OUTPUT WORD TO ID SEGMENT BUFFER
      LDA TPREL     GET CURRENT RELOCATION ADDRESS
      JSB OUTID     OUTPUT WORD TO ID SEGMENT BUFFER
      LDA PBREL     GET LOW BP RELOCATION ADDR
      LDB PTYPE     GET PROGRAM TYPE
      CPB P5        TYPE = BG SEGMENT?
      LDA BSBAD     YES - GET BS BP ADDRESS 
      JSB OUTID     PUTPUT WORD TO ID SEGMENT BUFFER
      LDA TBREL     GET HIGH BP RELOCATION ADDR 
      JSB OUTID     OUTPUT WORD TO ID SEGMENT BUFFER
      LDA DSKMN     GET INITIAL MAIN DISK ADDRESS 
      JSB OUTID     OUTPUT WORD TO ID SEGMENT BUFFER
      CLA 
      JSB OUTID     OUTPUT WORD TO ID SEGMENT BUFFER
      JMP GENID,I   RETURN - ID SEGMENT OUT 
* 
BLOUT LDB KEYCT     CHECK CURRENT ID POSITION.     $
      INB            IF NOT LAST ID SEGMENT,
      LDA SYSAD      SET NON-ZERO LINK WORD.       $
      CPB KEYCN     OTHERWISE, SET LAST LINK       $
      CLA            WORD = 0 TO TERMINATE DORMANT $
      JSB OUTID      LAST, OUTPUT LINK WORD.       $
* 
      LDB N27       OUTPUT 27 ZEROS TO             $
      JSB ZOUT       COMPLETE ID SEGMENT,          $
      JMP GENID,I   RETURN                         $
      SKP 
* 
*                                   OUTPUT ZERO TO IDBUF
* 
*  ZOUT PUTS OUT ZEROES TO THE ID SEGMENT BUFFER. 
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = NO. OF ZEROES TO GO OUT (NEG.).
*    JSB ZOUT 
* 
*  RETURN: CONTENTS OF A AND B ARE DESTOYED.
* 
ZOUT  NOP 
      STB TCNT      SAVE NO. OF ZEROES TO GO OUT
      CLA 
      JSB OUTID     OUTPUT ZERO TO IDBUF
      ISZ TCNT      SKIP - ALL ZEROES OUT 
      JMP *-3       CONTINUE ZERO OUTPUT TO IBUF
      JMP ZOUT,I    RETURN
      SKP 
* 
*                                   OUTPUT ID SEGMENT WORD TO IBUF
* 
*  OUTID PACKS THE WORDS FOR THE ID SEGMENTS IN THE ID SEGMENT
*  BUFFER AND WRITES THE BUFFER ON THE DISK WHEN IT CONTAINS
*  64 WORDS.
* 
*  CALLING SEQUENCE:
*    A = CURRENT ID SEGMENT WORD
*    B = IGNORED
*    JSB OUTID
* 
*   RETURN: CONTENTS OF A AND B ARE DESTROYED 
* 
OUTID NOP 
      STA CURAI,I   PUT WORD INTO ID BUFFER 
      ISZ CURAI     INCR CURRENT ID BUFFER ADDRESS
      ISZ ICNT      SKIP - IBUF FULL
      JMP OUTID,I   RETURN
      LDA DSKID     GET CURRENT ID SEGMENT DISK ADDR
      CPA DSKSY     IF CURRENT IBUF ADDRESS 
      RSS           EQ INITIAL ID SEG DISC ADDR,
      JMP OUTD1      SKIP, OTHERWISE GO TO WRITE. 
      STA DSKRD      SET TO READ IN TARGET SECTOR 
      JSB DBIN       FROM DISC INTO LBUF. 
      LDB AIBUF     -OR- INT RECORD IN LBUF 
      JSB AREDO,I    WITH CURRENT IBUF. 
      LDA DSKID     -RESTORE  A-REGISTER
OUTD1 LDB AIBUF     GET ID BUFFER ADDRESS.
      JSB DISKO     WRITE ID SEGMENT REC ON DISK
      LDB AIBUF     GET BUFFER ADDRESS
      STB CURAI     SET NEW CURRENT IBUF ADDRESS
      JSB BUFCL     CLEAR ID BUFFER 
      LDA DSKID     GET CURRENT ID SEGMENT DISK ADDR
      JSB DISKA     INCREMENT DISK ADDRESS
      STA DSKID     SAVE NEXT DISK ID ADDRESS 
      LDA N64 
      STA ICNT      SET CURRENT IBUF COUNT
      JMP OUTID,I   RETURN
      SKP 
* 
*                                   SET DISK TRACK TABLE
* 
*  DTSET SETS UP THE DISK TRACK TABLE FOR BOTH THE SYSTEM 
*  AND AUXILIARY DISK.  IT USES THE ID SEGMENT BUFFER FOR 
*  PUTTING OUT THE TRACK TABLES.
* 
*  CALLING SEQUENCE:
*    A = NO. USED TRACKS
*    B = DISK SIZE
*    JSB DTSET
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED. 
* 
DTSET NOP 
      CMB,INB 
      ADB A 
      JSB AZOUT,I 
      JMP DTSET,I 
      SKP 
* 
*                                   OUTPUT ABSOLUTE PROGRAM WORD
* 
*  LABDO PUTS OUT THE CURRENT ABSOLUTE CODE WORD FOR THE PROGRAM
*  BEING LOADED. IT FILLS THE GAPS WITH ZERO CODES IF THE 
*  CURRENT WORD DOES NOT FALL IN THE NEXT POSITION.  IN 
*  ADDITION, IT CHECKS FOR PROGRAM OVERLAY AND PPRINTS A DIAGNOSTIC 
*  IF THE CURRENT PROGRAM WORD OVERLAYS A PREFIOUSLY-GENERATED
*  SECTION OF CODE.  THE CURRENT PROG RELOCATION ADDRESS
*  IS PRINTED WITH THE DIAGNOSTIC, BUT THE ORIGINALLY-
*  GENERATED CODE IS NOT MODIFIED.
* 
*  CALLING SEQUENCE:
*    A = CURRENT ABSOLUTE CODE WORD 
*    B = CURRENT DISPLACEMENT FROM PREVIOUS WORD
*    JSB LABDO
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED
* 
LABDO NOP 
      STA TEMPP     SAVE PROGRAM WORD 
      CMB,SSB,INB,SZB  SKIP - OVERLAY 
      JMP TSTAB-1 
      LDA ERR19     SET ERROR CODE - PROGRAM OVERLAY
      JSB ERROR     PRINT DIAGNOSTIC
      LDA DBLAD     GET CURRENT PROG RELOC ADDRESS
      LDB ATBUF     GET ADDRESS OF TBUF 
      JSB ACONV,I    CONVERT TO DECIMAL/OCTAL IN TBUF 
      LDA ULPAR     GET UPPER CHAR LEFT PAREN 
      IOR TBUF      ADD LEFT PAREN TO FIRST DIGIT 
      STA TBUF      SET LEFT PAREN, FIRST DIGIT 
      LDA RPARB     GET RIGHT PAREN, BLANK
      STA TBUF+3    SET RIGHT PAREN IN BUFFER 
      LDA P7
      LDB ATBUF     GET ADDRESS OF TBUF 
      JSB DRKEY,I   PRINT RELOC ADDR OF OVERLAY 
      JMP LABDO,I   RETURN - NO OUTPUT
* 
      STB ABCNT     SAVE ABSOLUTE COUNT 
TSTAB ISZ ABCNT     SKIP - PUT OUT LAST WORD
      JMP CLOUT     SET ZEROS INTO BSS AREA 
      LDA TEMPP     GET LAST WORD 
      STA CURAD,I   SET INTO LOAD BUFFER
      JSB ATSTL,I   TEST FOR BUFFER FULL
      JMP LABDO,I   RETURN
* 
CLOUT CLA           REPLACE SKIPPED AREA WITH ZEROS.
      STA CURAD,I   SET INTO LOAD BUFFER
      JSB ATSTL,I   TEST FOR BUFFER FULL
      JMP TSTAB     OUTPUT NEXT WORD
      SPC 1 
ULPAR OCT 24000 
      SKP 
* 
*                                   TEST FOR ABSOLUTE BUFFER FULL 
* 
*  TSTEL PUTS OUT THE CURRENT ABSOLUTE BUFFER WHEN IT 
*  CONTAINS 64 WORDS OF CODE.  IN ADDITION, IT CHECKS FOR 
*  POSSIBLE PROGRAM OVERFLOW AND PRINTS A DIAGNOSTIC. 
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB TSTEL
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED
* 
TSTEL NOP 
      LDA RELAD     GET ABSOLUTE ADDRESS
      ISZ RELAD     INCR ABSOLUTE ADDRESS 
      CMA,INA       COMPLEMENT CURRENT RELOC ADDR 
      ADA LWASM     ADD LAST WORD AVAIL SYSTEM MEM
      SSA,RSS       SKIP - INVALID RELOCATION ADDR
      JMP NOVER     NO MEMORY OVERFLOW
      LDA ERR18     SET ERROR CODE - MEMORY OVERFLOW
      JSB ERROR     REPORT ERROR AND CONTINUE 
NOVER ISZ CURAD     INCR CURRENT DBUF ADDRESS 
      ISZ DCNT      SKIP - DBUF FULL
      JMP TSTEL,I   RETURN - LBUF NOT FULL
      JSB DBOUT     WRITE DBUF ON DISK
      JMP TSTEL,I   RETURN
      SKP 
* 
*                                   OUTPUT REST (IF ANY) OF ABS. REC
* 
*  REMDO PUTS OUT THE CURRENT SECTOR IF IT CONTAINS ANY WORDS OF
*  ABSOLUTE CODE.  THIS IS NORMALLY DONE WHEN THE CODE FOR THE
*  MAIN PROGRAM SECTION HAS BEEN GENERATED. 
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB REMDO
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED. 
* 
REMDO NOP 
      LDA DCNT      GET CURRENT DBUF COUNT
      CPA N64       BUFFER EMPTY? 
      JMP REMDO,I   YES - RETURN
      JSB DBOUT     WRITE DBUF ON DISK
      JMP REMDO,I   RETURN
      SKP 
* 
*                                   DUMP DBUF TO DISK 
* 
*  DBOUT WRITES THE CONTENTS OF THE ABSOLUTE BUFFER ON THE DISK 
*  AT THE DISK ADDRESS SPECIFIED BY DSKAD.
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = IGNORED
*    JSB DBOUT
* 
*  RETURN: CONTENTS OF A AND B ARE DESTOYED.
* 
DBOUT NOP 
      LDA DSKAD     GET CURRENT DISK ADDRESS
      LDB ADBUF     GET ADDRESS OF DBUF 
      JSB ADOUT,I   WRITE RECORD ON DISK
      LDB ADBUF     GET ADDRESS OF DBUF 
      STB CURAD     SET CURRENT DBUF ADDRESS
      JSB BUFCL     CLEAR LBUF
      LDA DSKAD     GET CURRENT DISK ADDRESS
      JSB INDAD,I   UPDATE DISK ADDRESS 
      STA DSKAD     SET NEXT DISK ADDRESS 
      LDA N64 
      STA DCNT      SET CURRENT DBUF COUNT
      JMP DBOUT,I   RETURN
      SKP 
* 
*        'OR' CURRENT RECORD WITH LBUF
* 
*  THE "REDOR" SUBROUTINE OR'S LBUF AND THE SPECIFIED 
* RECORD (BUFFER) AND PLACES THE RESULT IN THE
* OTHER BUFFER. 
* 
*  CALLING SEQUENCE:
*    A = IGNORED
*    B = ADDRESS OF BUFFER TO BE OR-ED
*    JSB REDOR
*   -RETURN: CONTENTS OF A AND B DESTROYED
* 
REDOR NOP 
      LDA ALBUF     GET ADDRESS OF LBUF 
      STA REDR2     SET CURRENT LBUF ADDRESS. 
      LDA N64 
      STA REDR3     SET RECORD LENGTH 
REDR1 LDA B,I       GET CURRENT BUFFER WORD 
      IOR REDR2,I   ADD CURRENT LBUF WORD 
      STA B,I       SET NEW BUFFER WORD 
      INB           INCR CURRENT BUFFER ADDRESS 
      ISZ REDR2     INCR CURRENT LBUF ADDRESS 
      ISZ REDR3     SKIP - ALL WORDS OR-ED. 
      JMP REDR1     -OR- NEXT BUFFER WORD.
      JMP REDOR,I   RETURN. 
* 
REDR2 NOP 
REDR3 NOP 
      SKP 
* 
*  FIND IDENT OF PROGRAM TO BE LOADED JUST
*  PRIOR TO PROGRAM TO BE SCHEDULED.
* 
*  THIS ROUTINE SCANS THE IDENTS IN THE 
*  SAME ORDER AS THEY ARE TO BE LOADED
*  AND SAVES THE IDENT ADDRESS OF THE 
*  PROGRAM JUST BEFORE THE SCHEDULED
*  PROGRAM, OR ZERO IF THERE IS NO SCHEDULED
*  PROGRAM OR IT IS THE FIRST TO BE LOADED. 
* 
*  CALLING SEQUENCE:
* 
*  SET SCH1 TO IDENT OF PROGRAM TO BE SCHEDULED 
* 
*  JSB ASCHF,I
* 
*  RETURN:  SCH2  IDENT OF PROGRAM -1 IN LOAD ORDER 
*           SCH3  LENGTH OF ID FOR SCH1 PGM 
*           SCH4  0 
      SPC 3 
SCHF  NOP 
      CLA           CLEAR THE 
      STA SCH2      SCH PRAMETERS 
      STA SCH3      FOR 
      STA SCH4      DEFAULT 
      LDA SCH1      IS A PGM TO BE
      SZA,RSS       SCHEDULED?
      JMP SCHF,I    NO, EXIT
      CLA,INA       YES;  SET TO SCAN 
SCHF3 STA PTYPE     THE IDENTS
      LDA BIDNT     SET POINTER 
      STA CIDNT     FOR SCAN ROUTINE
SCHF1 JSB AIDSN,I   GO SCAN 
      JMP SCHF8     END OF CURRENT TYPE  GO SET FOR NEXT
      SEZ,RSS       IGNOR 
      JMP SCHF1     SUBS
SCHF2 LDB P22       SET ID LENGTH 
      LDA PTYPE     IF
      CPA P2        DISC
      ADB P6        RESIDENT
      CPA P3        I.E. 1 OR 3 
      ADB P6        THEN
      STB SCH3      SAVE ID LENGTH
      LDB ID1       GET IDENT ADDRESS 
      CPB SCH1      THIS THE SCHEDULED PGM? 
      JMP SCHF,I    YES - DONE - RETURN 
      STB SCH2      NO - UPDATE LAST ONE POINTER
      CPA P5        IF SEGMENT GO 
      JMP SCHF5     SCAN NEXT SEGMENT 
      CPA P3        IF BACKGROUND DISC RESIDENT 
      RSS           SKIP
      JMP SCHF1     ELSE GET NEXT PGM 
      LDA ID1       BACKGROUND DISK RES SO
      STA TBUF      SET UP TO SCANN FOR 
      LDA BIDNT     SEGMENTS
      STA CIDNT 
      LDA P5        SET TYPE TO SEGMENTS
      STA PTYPE     AND 
SCHF5 JSB AIDSN,I   START SCAN
      JMP SCHF4     END OF SEGMENTS - GO RESET
      SEZ,RSS       IGNOR 
      JMP SCHF5     SUBROUTINES 
      LDA ID10,I    DOES THIS SEGMENT BELONG TO 
      CPA TBUF      CURRENT PGM?
      JMP SCHF2     YES - GO UPDATE 
      JMP SCHF5     NO - TRY NEXT ONE 
      SPC 1 
SCHF4 LDA P3        END OF SEGMENTS SO
      STA PTYPE     RESET FOR NEXT
      LDA TBUF      BACKGROUND
      ADA N10       STEP TO NEXT IDENT
      JMP SCHF1-1   PGM AND CONTINUE SCAN 
      SPC 1 
SCHF8 CLB           END OF CURRENT TYPE 
      ISZ PTYPE     STEP TYPE 
      LDA PTYPE     IS LAST TYPE
      CPA P3        RT DISC RES?
      INB           YES - SET FOR BACKGROUND RES
      CPA P5        BACKGROUND RES? 
      LDB N2        YES SET FOR BACK GROUND DISC RES
      CPA P4        BACKGROUND DISC RES???? 
      HLT 33B       YES - ERROR END OF IDENTS AND NO PGM
      ADA B         SET NEXT TYPE IN A
      JMP SCHF3     AND CONTINUE SCAN 
      SKP 
* 
*                                   CLEAR LOCAL LST ENTRIES 
* 
*  CLRLT CLEARS THE CURRENT BP LINKAGE ADDRESSES IN THE LOADER
*  SYMBOL TABLE TO MAKE THEM UNAVAILABLE TO THE SUCCEEDING
*  PROGRAMS.  THIS CONSISTS OF CLEARING WORD 5 OF THE LST 
*  ENTRY, AND THE CORRESPONDING BP LINK VALUE IN BASE PAGE. 
* 
*  CALLING SEQUENCE:
*    A = CURRENT LOW BP ADDRESS 
*    B = CURRENT HIGH BP ADDRESS
*    JSB CLRLT
* 
*  RETURN: CONTENTS OF A AND B ARE DESTROYED. 
* 
CLRLT NOP 
      CMA,INA       SET NEGATIVE
      STA LOWER     SAVE LOWER BOUND
      CMB,INB       SET NEGATIVE
      STB UPPER     SAVE UPPER BOUND
      JSB INLST     INITIALIZE LSTX 
CLRNX JSB LSTX      SET LST ADDRESSES 
      JMP CLBPS     CLEAR BP SECTION
      LDA LST5,I    GET WORD 5 OF LST ENTRY 
      ADA LOWER     ADD NEG LOWER BOUND 
      SSA           SKIP IF GREATER, EQUAL TO LOWER 
      JMP CLRNX     TRY NEXT ENTRY
      LDA LST5,I    GET WORD 5 OF LST ENTRY 
      ADA UPPER     ADD NEG UPPER BOUND 
      SSA,RSS       SKIP IF LESS THAN UPPER 
      JMP CLRNX     TRY NEXT ENTRY
      CLB 
      STB LST5,I    CLEAR BP LINK ADDRESS 
      JMP CLRNX     TRY NEXT ENTRY
CLBPS LDB LOWER     GET LOWER BP BOUND
      CMB,INB       SET TO POSITIVE 
      LDA UPPER     GET UPPER BOUND (NEG.)
      ADA B         SET A = TOTAL WORD COUNT
      SSA,RSS       SKIP - SOME BP SECTION TO CLEAR 
      JMP CLRLT,I   RETURN - NO BP SECTION
      STA WDCNT     SET COUNT FOR CLEARING
      ADB M2000     ADJUST FOR BP ADDRESS 
      CLA 
      STA B,I       CLEAR BO WORD 
      INB 
      ISZ WDCNT     SKIP - ALL BP CLEAR 
      JMP *-3 
      JMP CLRLT,I   END OF CLEARING 
      SPC 3 
AXX   BSS 0         DBL RECORD LIST AREA
PLIST BSS 0         PLIST - SHARES DBL LIST AREA
* 
      HED ** TRACK 0, SECTOR 0 BOOTSTRAP ** 
* 
*  THE FOLLOWING IS THE FORMAT FOR THE PORTION OF THE 
*  BOOTSTRAP LOADER TO BE SET IN 0,0.  THIS SECTION OF THE
*  BOOTSTRAP IS LOADED INTO 2 TO 77B BY THE PROTECTED BINARY
*  LOADER.  WHEN IT IS READ COMPLETELY INTO CORE IT CHECKS FOR
*  READ PARITY ERRORS DURING ITS INPUT.  FOLLOWING THIS A HALT
*  INSTRUCTION PERMITS THE OPERATOR TO PROTECT THE BASIC
*  BINARY LOADER AND SET SWITCH 0 OF THE SWITCH REGISTER
*  TO 0 (EITHER REAL TIME EXECUTIVE OR TIME-SHARED BASIC) 
*  OR 1 (DISC MONITOR SYSTEM).  PRESSING 'RUN' READS THE
*  SELECTED SYSTEM LOADER FROM 0,1 OR 0,2 RESPECTIVELY.  THIS 
*  PORTION OF THE BOOTSTRAP OPERATION WILL THEN LOAD INTO 
*  CORE THE SELECTED SYSTEM AND TRANSFER CONTROL TO IT. 
* 
BSBSO EQU 14000B
      ORG BSBSO 
* 
RLOAD OCT 0,0       DON'T USE (A) AND (B) 
RT/TS OCT 0         REAL TIME EXEC/TIME-SHARED BASIC
DMS   OCT 0 
      HLT 4,C       IN CASE OF POWER FAIL 
* 
BSLD0 STA BSLD2-BSBSO+1  CHANGE IRRECOVERABLE HLT 0 
      ISZ BSLD2-BSBSO      INTO RECOVERABLE HLT 1 
      HLT 77B       PROTECT BBL, SET SWR FOR SYSTEM 
      LDA LINKG-BSBSO    SET UP DISC/DMA
      OTA 6                LINKAGE
* 
BSLD1 LIA 1         SELECT SYSTEM LOADER
      CLB,INB         FROM SWITCH REGISTER: 
      SLA               SWR = 0 IMPLIES SECTOR 1
      INB               SWR = 1 IMPLIES SECTOR 2
DSK7  OTB 0         OUTPUT DISC ADDRESS 
      CCE,INB       SAVE
      LDA 1,I         CHOSEN LOADER'S 
      STA CORAD-BSBSO   ENTRY POINT 
      RAL,ERA       OUTPUT 'READ' FORM
      CLC 2           OF LOADER'S 
      OTA 2             CORE ADDRESS
      LDA .N64-BSBSO     OUTPUT 
      STC 2                TRANSFER 
      OTA 2                  LENGTH 
      STC 6,C       START DMA 
DSK8  STC 0         START DISC TRANSFER 
      JSB TSTAT-BSBSO    VALIDATE READ
      JMP CORAD-BSBSO,I  TRANSFER TO SYSTEM LOADER
* 
TSTAT DEF BSLD0-BSBSO    (INITIAL EXIT) 
DSK9  LIA 0         WAIT FOR
      SLA             TRANSFER
      JMP *-BSBSO-2     COMPLETION
      AND BSB32-BSBSO    TRANSFER 
      SZA,RSS              OK?
      JMP TSTAT-BSBSO,I  YES
BSLD2 HLT 0              NO (HLT 1, NOP AFTER CHECK 
      JMP *-BSBSO-1 
      JMP BSLD1-BSBSO    RETRY LOAD 
* 
CORAD OCT 0         SYSTEM LOADER ENTRY ADDRESS 
LINKG OCT 20000     DISC/DMA LINKAGE TEMPLATE 
BSB32 OCT 32        TRANSFER VALIDATION MASK
.N64  DEC -64 
* 
      ORG BSBSO+77B 
      JMP DSK9-BSBSO     TEST BOOTSTRAP LOAD
      ORG * 
      HED ** RT MONITOR BOOT STRAP LOADER **
      ORG 15600B
* 
*  THE FOLLOWING LOADER PERMITS LOADING OF THE RESIDENT PORTIONS
*  OF THE REAL TIME MONITOR.  THE LOADER IS LOCATED ON SECTOR 1,
*  TRACK 0 OF THE SYSTEM DISC.  IT IS GENERATED BY THE SYSTEM 
*  GENERATOR AND CONSISTS OF: 
* 
*  (1) THE INSTRUCTIONS REQUIRED FOR LOADING THE SYSTEM 
*  (2) THE DISK AND CORE ADDRESSES SPECIFYING LOADING 
* 
* 
*  THE ADDRESSES REQUIRED FOR LOADING ARE THE FOLLOWING:
* 
*  (A) BASE PAGE LINKAGES 
*     (1) LOW CORE ADDRESS
*     (2) HIGH CORE ADDRESS 
*     (3) DISK ADDRESS OF ABSOLUTE CODE 
* 
*  (B) SYSTEM, RT RESIDENT MAIN 
*     (1) LOW CORE ADDRESS
*     (2) HIGH CORE ADDRESS 
*     (3) DISK ADDRESS OF ABSOLUTE CODE 
* 
*  (C) BG RESIDENT MAIN 
*     (1) LOW CORE ADDRESS
*     (2) HIGH CORE ADDRESS 
*     (3) DISK ADDRESS OF ABSOLUTE CODE 
* 
*  THE PROGRAM IS ASSUMED TO BE LOADED IN THE 64 WORDS PRECEDING
*  THE PROTECTED LOADER.
* 
START LDB ASPBF     GET ADDR OF DISK SPEC. BUFFER 
      STB SPCAD     SET CURRENT SPBUF ADDRESS 
      JSB PLOAD     LOAD MAIN SYSTEM, RT RESIDENTS
      JSB PLOAD     LOAD MAIN BG RESIDENTS
      JSB PLOAD     LOAD BP LINKAGES
      JMP 3B,I      TRANSFER TO RT MONITOR ENTRY PT.
* 
PLOAD NOP 
      LDB SPCAD,I   GET LOW CORE ADDRESS
      ISZ SPCAD     INCR CURRENT SPBUF ADDRESS
      LDA SPCAD,I   GET HIGH CORE ADDRESS 
      ISZ SPCAD     INCR CURRENT SPBUF ADDRESS
      CMA,CCE,INA   COMPLEMENT, SET DIRECTION BIT 
      ADA B         SET A = TOTAL WORD COUNT
      RBL,ERB       SET DIRECTION BIT IN CORE ADDR
      CLC 2 
      OTB 2         SET MEMORY ADDRESS REGISTER 
      LDB SPCAD,I   GET DISK ADDRESS OF ABSOLUTE CODE 
      ISZ SPCAD     INCR CURRENT SPBUF ADDRESS
* 
SLOAD SSA,RSS       SKIP - MORE SECTORS TO LOAD 
      JMP PLOAD,I   RETURN - THIS SECTION LOADED
      ADA P.64      ADJUST FOR NEXT COUNT 
      STA RECNT     SET REMAINING COUNT 
      SSA           SKIP - LESS THAN 64 WORDS 
      CLA 
      ADA N.64      SET A = CURRENT SECTOR COUNT
      STC 2 
      OTA 2         SET WORD COUNT REGISTER 
DSKAG OTB 0         OUTPUT CURRENT DISK ADDRESS 
      STC 6,C       INITIATE DMA
DSKB  STC 0         INITIATE DATA TRANSFER
DSKC  LIA 0         GET STATUS WORD 
      SLA           SKIP - TRANSFER COMPLETE
      JMP *-2       WAIT FOR COMPLETION 
      RAR,SLA,RAL   SKIP - NO READ PARITY ERROR 
      HLT 0B        WAIT FOR OPERATOR - READ PARITY 
      LDA B         GET CURRENT DISK ADDRESS
      AND M.177     ISOLATE SECTOR NO.
      CPA #SECT     LAST SECTOR READ?             $$
      RSS           YES - CONTINUE ON NEXT TRACK
      CLA,INA,RSS   NO - SET COUNT FOR NEXT SECTOR
      LDA #MASK     SET COUNT FOR NEXT TRACK      $$
      ADB A         SET B = NEXT DISK ADDRESS 
      LDA RECNT     GET REMAINING COUNT 
      JMP SLOAD     LOAD NEXT SECTOR
* 
*                                   DATA AREA 
M.177 OCT 177 
#SECT NOP           # SECTORS - 1 FOR SYSTEM DISC $$
#MASK NOP           INCREMENT TRACK # VALUE       $$
N.64  DEC -64 
P.64  DEC 64
RECNT OCT 0         CURRENT REMAINING COUNT 
SPCAD OCT 0         CURRENT DISK SPEC. BUFFER ADDR
ASPBF DEF *+1 
      BSS 9         SYSTEM LOADING SPECIFICATIONS 
      HED   CURRENT PAGE LINKAGE ROUTINES 
      ORG 16000B
      SPC 3 
*     THE FOLLOWING ROUTINES LINK A PROGRAM THROUGH CURRENT PAGE
*     LINKS WHEN POSSIBLE.  THIS IS POSSIBLE WHEN THE LENGTH
*     OF THE PROGRAM IS KNOWN AND WHEN THE PROGRAM IS NOT AN
*     ASSEMBLED TYPE 3 OR 5 PROGRAM.
      SPC 3 
ALINK NOP 
      LDA L01       1ST OF 2 PASSES?
      SSA 
      JMP ALINK,I    NO - 1 PASS ONLY 
      SZA            YES - SKIP 
      JMP LH3        NO - 2ND PASS
      SPC 1 
      LDA L001      1ST PASS ESTIMATE OR
      SZA            1ST PASS CURR PG LINK LOAD?
      JMP LH10      LINK LOAD 
      SPC 1 
      LIB 1         DOES OPERATOR WANT CURRENT PAGE 
      RBL            LINKS IF POSSIBLE? 
      SSB,RSS        IF YES - SKIP
      SPC 1 
LH2   CCA,RSS       NO - SW REG BIT 14=0
      RSS 
      JMP LOADA,I   RESTART 
      SPC 1 
      LDA PLGTH 
      SSA,RSS       NO CURRENT PAGE LINKS 
      LDA PTYPE      IF ASSEMBLED TYPE 3 OR 5 
      CPA P3
      RSS 
      CPA P5
      JMP LH2 
      SPC 1 
      LDA TPREL     GET ADDR
      STA B          OF LAST WD 
      IOR M1777      OF PAGE
      SPC 1 
      CMB,INB       COMPUTE # WDS 
      INB            REMAINING
      ADB A          ON PAGE
      STB TEMP2 
      SPC 1 
      LDA PLGTH     COMPUTE # WDS 
      RAL,CLE,ERA    OF PROGRAM 
      CMB,INB        THAT FALL
      ADB A          BEYOND THIS
      STB TEMP1      PAGE 
      SPC 1 
      SSB           PROGRAM FIT ON
      RSS            THIS PAGE? 
      SZB,RSS       NO - SKIP 
      JMP LH2       YES 
      SPC 1 
      LDA TEMP2     COMPUTE MINIMUM OF: 
      ARS            HALF # WDS OF PROG 
      CMB,INB         ON CURRENT PAGE-OR- 
      ADB A          # WDS OF PROG ON 
      SSB,RSS         NEXT PAGE 
      SPC 1 
      LDA TEMP1     DIVIDE THIS 
      CLB            MINIMUM BY 
      DIV P4         FOUR 
      SZA,RSS       IF NON-ZERO, USE AS SIZE
      JMP LH2        OF LOW CURRENT PG LINK BUFF
      RSS 
      SPC 1 
LH10  LDA LWH2
      LDB TPREL     SET NEW 
      STB TEMP1      LOAD ADDRESS 
      ADB A          AND UPPER LIMIT
      STB TPREL      OF LINK BUFFER 
      STB CPMAX 
      CMA,INA       SAVE # FOR
      STA LWH2       OUTPUT TO DISC 
      SPC 1 
LH3   LDA TEMP1     SET UP
      STA CPLOC      PARAMETERS FOR 
      STA CPBAS      CURRENT PAGE 
      AND M0760      LINK ALLOCATOR 
      STA CPADD 
      JMP ALINK,I   RETURN
      SPC 3 
*     DLINK         DLINK IS CALLED AFTER A SCN OF CURRENT
*     BASE PAGE HAS NOT FOUND THE CURRENT REQUIRED LINK.
*     IT RETURNS TO P+1 IF NO CURRENT PAGE LINK IS POSSIBLE.
      SPC 2 
DLINK NOP 
      LDA BPSCM,I   GET THE CALLIN ADDRESS
      CPA CLINK     IF DBL CALL 
      RSS           SKIP
      JMP DLINK,I   ELSE - EXIT USE BASE PAGE 
      LDA L01       SINGLE PASS ONLY? 
      SSA            NO - SKIP
      JMP DLINK,I    YES
LH4   LDA CPADD     GET LINK PAGE 
      CPA PAGNO     SAME AS INSTR PAGE? 
      RSS           YES SKIP
      JMP CROSS 
      LDA CPLSA     GET LIST BASE 
      STA BLINK     SET FOR SCAN
      LDB CPBAS     GET THE NO OF CP LINKS SO FAR 
      CMB,INB       SO FAR
      ADB CPLOC     TO B
      CMB,INB,SZB,RSS     IF ZERO 
      JMP DLIN1     JUMP TO ALOCATE 
      LDA BLINK,I   GET LINK CONTENTS 
      CPA OPRND     SAME AS REQUIRED? 
      JMP DLIN1     YES GO RETURN THE ADDRESS 
      ISZ BLINK     STEP THE ADDRESS
      INB,SZB       STEP COUNT IF END THEN CONTINUE 
      JMP *-5       CONTINUE SCAN 
DLIN1 LDA CPLOC     GET THE NEXT LOCATION 
      ADA B         ADD THE OFFSET  IN CASE NOT A NEW LINK
      CPA CPMAX     ANY LEFT
      JMP DLINK,I   NO EXIT 
      SZB,RSS       IF A NEW LINK THEN
      ISZ CPLOC     STEP THE LOCATION COUNTER 
      LDB OPRND     GET THE LINK WORD AND 
      STB BLINK,I   SET IN THE LINK LIST
      LDB BPSCM,I   GET THE RETURN ADDRESS
      INB           SKIP THE BP SET ROUTINE 
      JMP B,I       RETURN
      SPC 2 
CROSS LDA L01       1ST PASS? 
      SZA            YES - SKIP 
      JMP BLIN3      NO - 2ND 
      SPC 1 
      LDA L001      LINK LOAD ON 1ST PASS?
      SZA,RSS        SKIP IF YES
      JMP LH11       NO - ESTIMATING
      LDA LWH2      GET # TO OUTPUT 
      SZA 
      JSB BLIN0 
BLIN2 CLA,INA       START 
      JMP LOADA,I    PASS 2 
      SPC 1 
BLIN3 RSS 
      JMP DLINK,I 
      LDA PLGTH     SET UP
      RAL,CLE,ERA    HIGH 
      ADA TPREL      CURRENT PAGE 
      STA CPLOC      LINK BUFFER
      STA CPBAS 
      AND M0760 
      STA CPADD 
      ADA M2000 
      STA CPMAX 
      CLA           CLEAR BLIN3 SO DONE 
      STA BLIN3      ONCE ONLY
      JMP LH4 
      SPC 1 
LH11  LDA TEMP1 
      CMA,INA 
      ADA CPLOC 
      STA LWH2
      CLA,INA 
      JMP LOADY,I 
      SPC 3 
*     BLINK         BLINK SENDS THE LINKAGE AREA TO THE DISC
*     IT IS CALLED JUST AFTER THE END RECORD IS READ
      SPC 1 
BLINK NOP 
      ISZ LWH1      RETURN IF NO HIGH 
      JMP BLINK,I    LINK BUFFER
      LDA CPLOC     GET CP LINKAGE LOCATION 
      CMA,INA 
      ADA TPREL     ADD CURRENT LOAD LOC
      STA LWH2      SET NEG. # WDS TO OUTPUT
      SZA,RSS       IF ZERO 
      JMP BLINK,I   EXIT
      JSB BLIN0     OUTPUT BUFFER TO DISC 
      LDA CPLOC     DONE - UPDATE THE 
      STA TPREL     CURRENT RELOCATION ADDRESS
      JMP BLINK,I   AND RETURN
      SPC 3 
BLIN0 NOP 
      LDA CPLSA     GET THE LINK LIST ADDRESS 
      STA ALINK     AND SET WORKING POINTER 
      SPC 1 
BLIN1 LDA ALINK,I   GET THE LINK WORD 
      CLB,INB       AND SEND
      JSB ALABD,I   TO THE DISC 
      ISZ ALINK     STEP ADDRESS
      ISZ LWH2       AND COUNT
      JMP BLIN1     MORE - SO GO GET THEM 
      JMP BLIN0,I 
      SPC 3 
CLINK DEF LINKC 
LOADA DEF LOADX 
LOADY DEF LOADN+1 
BPSCM DEF BPSCN 
CPLSA ABS 15000B
CPLOC NOP           CURRENT PAGE LINKAGE ADDRESS
CPBAS NOP           CURRENT PAGE LINKAGE BASE 
CPADD NOP           PAGE ADDRESS OF CURRENT PAGE LINK AREA
CPMAX NOP           LAST WORD PLUS ONE OF CURRENT PAGE LINK AREA
      SPC 1 
LST   BSS 5 
      SPC 2 
END   EQU * 
      SPC 2 
      END RTGEN 
