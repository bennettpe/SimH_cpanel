ASMB,R,L,B,C   ** RT EXEC CENTRAL CONTROL MODULE ** 
      HED ** REAL-TIME EXECUTIVE  CENTRAL CONTROL MODULE ** 
      NAM EXEC
* 
***** AMD-DAS ***** FEB,72 ***** REV.LWH *****
* 
      ENT EXEC,$ABRT,$ERMG,$ALC,$RTN,$RQST,$OTRL
      ENT $LIBR,$LIBX,$DREQ,$DREL,$SDRL,$SDSK 
* 
      EXT $CVT3,$SYMG,$LIST,$TREM,$XEQ
      EXT $IRT,$CVEQ
      SUP 
* 
*****  < EXEC >   PROGRAM  DESCRIPTION  ***** 
* 
*  THE PRIMARY FUNCTION OF THIS PROGRAM IS
* TO PROVIDE GENERAL CHECKING AND EXAMINATION 
* OF SYSTEM SERVICE REQUESTS AND TO CALL THE
* APPROPRIATE PROCESSING ROUTINE IN OTHER 
* SECTIONS OF THE REAL-TIME EXECUTIVE.
* 
*  THIS PROGRAM IS CALLED DIRECTLY FROM THE 
* CENTRAL INTERRUPT CONTROL <CIC> SECTION 
* WHEN A MEMORY PROTECT VIOLATION IS ACKNOWLEDGED.
* ALL SYSTEM REQUESTS BY A USER PROGRAM CAUSE A 
* PROTECT VIOLATION.
* 
*   SYSTEM REQUEST FORMAT:
*   ----------------------
* 
*     THE GENERAL FORMAT OF A SYSTEM REQUEST IS 
*    A BLOCK CONTAINING AN EXECUTABLE INSTRUCTION 
*    TO GAIN ENTRY TO THE EXECUTIVE AND AN ADDRESS
*    LIST OF PARAMETERS. THE FIRST PARAMETER IS 
*    A NUMERIC CODE IDENTIFYING THE REQUEST TYPE. 
*    THE LENGTH OF THE PARAMETER LIST VARIES
*    ACCORDING TO THE AMOUNT OF INFORMATION RE- 
*    QUIRED FOR EACH REQUEST (OR VARIATIONS WITHIN
*    A SINGLE REQUEST). THIS FORMAT ALLOWS SYSTEM 
*    REQUESTS TO BE SPECIFIED IN A FORTRAN CALL 
*    STATEMENT IN ADDITION TO ASSEMBLY LANGUAGE FORMAT. 
* 
*        CALL  EXEC  (P1,P2,...PN)
* 
*     OR
* 
*        EXT   EXEC 
*        JSB   EXEC   (CAUSES MEMORY PROTECT VIOLATION) 
*        DEF   *+1+N  DEFINE EXIT POINT, N= # PARAMETERS
*        DEF   RCODE  DEFINE REQUEST CODE 
*        DEF   P1     DEFINE PARAMETER LIST, 1 TO N 
*        .
*        .            (PARAMETERS MAY BE INDIRECTLY 
*        .             REFERENCED, E.G. DEF P3,I) 
*        DEF   PN 
*       - EXIT POINT -
* 
*     RCODE  DEC  N 
*     P1     DEC/OCT/DEF,ETC  TO DEFINE A VLAUE 
* 
* 
*   RE-ENTRANT LIBRARY REQUEST
*   --------------------------
* 
*     THE SYSTEM LIBRARY (RESIDENT) CONTAINS
*    PROGRAMS STRUCTURED IN 'RE-ENTRANT' FORMAT 
*    OR IN 'PRIVILEGED' EXECUTION FORMAT. 
* 
*     - RE-ENTRANT FORMAT ALLOWS A LIBRARY
*    PROGRAM TO BE RE-ENTERED BY A CALL FROM
*    A HIGHER-PRIORITY PROGRAM DURING THE 
*    PROCESSING OF A CALL FROM A LOWER-PRIORITY 
*    PROGRAM. 
* 
*     - PRIVILEGED EXECUTION FORMAT ALLOWS A
*    SHORT-RUNNING LIBRARY PROGRAM TO BE EXECUTED 
*    WITH THE INTERRUPT SYSTEM DISABLED.
* 
* 
* 
*  MEMORY PROTECT ERROR:
*  ---------------------
* 
*    IF THE INSTRUCTION CAUSING THE PROTECT VIOLATION 
*   IS NOT A JSB EXEC OR A JSB TO LIBRARY 
*   PROGRAM, THEN A USER PROGRAM ERROR IS 
*   ASSUMED. A DIAGNOSTIC IS OUTPUT TO THE SYSTEM 
*   TELETYPE LISTING THE PROGRAM NAME AND ADDRESS 
*   OF VIOLATING INSTRUCTION AND THE PROGRAM IS 
*   SET DORMANT IN THE PROGRAM ABORT PROCEDURE. 
* 
      SKP 
* 
EXEC  NOP 
* 
      HLT 0        PROTECTION AGAINST DIRECT CALL.
* 
RTRQP LIA 5        GET ADDRESS OF VIOLATION.
      STA VADR     SAVE VIOLATION ADDRESS.
      STA XSUSP,I  SET AS POINT OF SUSPENSION.
      STA TEMP1    SAVE (P+1) OF
      ISZ TEMP1     CALL. 
      LDA A,I      GET WORD.
      AND MASK1    ISOLATE INSTR. CODE. 
      CPA JSBI     IF INSTRUCTION IS JSB  ,I
      RSS           CHECK OPERAND ADDRESS.
      JMP MPERR     -MEMORY PROTECT ERROR-
      LDA VADR     CHECK
      LDA A,I       FOR EFFECTIVE 
      AND MASK2     OPERAND ADDRESS 
      LDA A,I       SAME AS 
      CPA EXECA     -EXEC-. 
      JMP R0        YES, REQUEST TO BE ANALYSED.
      CPA LIBRA    -LIBRARY ROUTINE CALLING FOR 
      JMP LIBRC     RE-ENTRANT OR PRIVILEGED RUN. 
      CPA LIBXA    -LIBRARY ROUTINE RETURNING 
      JMP LIBXC     TO CALLER.
* 
* CHECK FOR USER CALL TO LIBRARY PROGRAM
* 
      STA B        SAVE OPERAND ADDRESS.
      LDA LBORG    SUBTRACT LIBRARY 
      CMA,INA       AREA ORIGIN FROM
      ADA B          OPERAND ADDRESS. 
      SSA          MEMORY PROTECT ERROR IF
      JMP MPERR     OPERAND LT LIBRARY ORIGIN.
      LDA RTORG    SUBTRACT REAL-TIME 
      CMA,INA       AREA ORIGIN FROM
      ADA B          OPERAND ADDRESS. 
      SSA,RSS      IF NOT CALL TO LIBRARY RESIDENT, 
      JMP MPERR     THEN VALID MEMORY PROTECT ERROR.
      LDA TEMP1    -CALL TO LIBRARY.
      STA B,I       SET (P+1) ADDRESS IN ENTRY POINT
      ADB .2        SET (P+1) OF
      STB LIBR       JSB  LIBR  IN -LIBR-.
      JMP LB1      - TRANSFER TO LIBR SECTION.
      SPC 1 
JSBI  JSB 0,I 
MASK1 OCT 176000
MASK2 OCT 1777
EXECA DEF EXEC
RQP2A DEF RQP2
VADR  NOP 
N9    DEC -9
* 
* ANALYZE SYSTEM REQUEST
* 
R0    LDB TEMP1     (B) = P+1 OF  JSB EXEC. 
      LDA B,I      GET EXIT ADDRESS,
      SSA          ERROR IF RETURN POINT ADDRESS
      JMP RQERR     IS 'INDIRECT'.
      SZA,RSS      ERROR
      JMP RQERR     IF RETURN 
      CPA .1        ADDRESS = 
      JMP RQERR      0 OR 1 (A OR B REGISTERS)
      STA RQRTN     SAVE IN BASE PAGE 
      STB TEMP1    SAVE REQUEST WORD 2 ADDRESS. 
      CMB,INB      SUBTRACT WORD 2 ADDRESS FROM 
      ADA B         EXIT ADDRESS. 
      SZA,RSS      IF ZERO, THEN NO REQUEST CODE
      JMP RQERR     AND IS ILLEGAL. 
      ADA N1       SUBTRACT 1.
      SZA,RSS      IF ZERO, THEN WORD 3 (REQUEST
      JMP RQERR     CODE) IS NOT SUPPLIED, ERROR. 
      ADA N1       SUBTRACT 1 AGAIN TO DETERMINE
      STA RQCNT     AND SAVE # OF ACTUAL PARAMETERS.
      STA B 
* 
      SSA          ERROR IF # 
      JMP RQERR     IS NEGATIVE OR
      ADA N9        IS GREATER
      SSA,RSS       THAN
      JMP RQERR     8.
* 
      CLA          - ZERO 
      STA RQP2
      STA RQP3       PARAMETER
      STA RQP4
      STA RQP5       ADDRESS
      STA RQP6
      STA RQP7       AREA 
      STA RQP8
* 
      CMB,INB      SET PARAMETER # NEG. FOR INDEX 
      ISZ TEMP1    (TEMP1) = ADDR. OF WORD 3
      JSB EFFAD    GET EFFECTIVE OPERAND ADDR. IN A.
      STA RQP1     SET ADDR. OF REQUEST CODE WORD.
      SZB,RSS      IF NO ACTUAL PARAMETERS SUPPLIED,
      JMP R2        SKIP NEXT SECTION.
* 
      LDA RQP2A    SET (TEMP2) =
      STA TEMP2     ADDRESS OF RQP2 IN BASE PAGE. 
      ISZ TEMP1    SET (TEMP1) = ADDR. OF WORD 4. 
R1    JSB EFFAD    GET EFFECTIVE OPERAND ADDRESS. 
      STA TEMP2,I  SET IN BASE PAGE.
      ISZ TEMP2    INDEX
      ISZ TEMP1     ADDRESSES AND 
      INB,SZB       PARAMETER COUNT.
      JMP R1       - CONTINUE - 
      SKP 
* 
* CHECK LEGALITY OF REQUEST CODE
* 
R2    LDA RQP1,I   GET REQUEST CODE 
      SZA,RSS       ERROR IF
      JMP RQERR      ZERO OR NEGATIVE 
      CMA,INA 
      SSA,RSS 
      JMP RQERR      SUBTRACT FROM #
      ADA CODE#     OF REQUEST TYPES. 
      SSA          -ERROR IF LARGER 
      JMP RQERR     THAN # DEFINED. 
* 
      LDA RQP1,I   ADD REQUEST CODE 
      ADA RQTBL     TO FWA-1 OF REQUEST TABLE.
      LDA A,I      GET LINK ADDR. OF PROCESSOR. 
      SSA,RSS      JUMP IF PROCESSOR IS 
      JMP *+3       IN 'EXEC'.
      RAL,CLE,ERA  REMOVE I-BIT 
      LDA A,I       AND GET EFFECTIVE ADDRESS.
* 
* TRANSFER TO REQUEST PROCESSOR 
* 
      JMP A,I      ACTIVATE PROCESSOR - NO RETURN.
* 
* SUBROUTINE  <EFFAD>,  COMPUTE EFFECTIVE ADDRESS 
* 
EFFAD NOP 
      LDA TEMP1,I       GET ADDRESS 
      SZA,RSS      ERROR IF 
      JMP RQERR     ADDRESS = 
      CPA .1         0 OR 1 
      JMP RQERR       (A OR B REGISTERS)
      RAL,CLE,SLA,ERA   TEST I-BIT AND CLEAR
      RSS               -INDIRECT-
      JMP EFFAD,I       RETURN WITH (A) = ADDRESS.
      LDA A,I      GET NEXT ADDRESS IN INDIRECT 
      JMP EFFAD+2   CHAIN AND PROCESS.
      SPC 1 
.1    DEC 1 
.2    DEC 2 
N1    DEC -1
      HED ** SUPERVISORY CONTROL OF LIBRARY PROGRAM EXECUTION **
* 
* SUPERVISORY CONTROL OF PROGRAM LIBRARY EXECUTION
* 
*  ALL LIBRARY PROGRAMS REFERENCED BY USER PROGRAMS 
* IN THE SYSTEM ARE COMBINED IN A BLOCK OF MEMORY 
* WHICH IS PROTECTED FROM THE REAL-TIME AREA. THE 
* LIBRARY AREA IS IMMEDIATELY BELOW THE RT AREA 
* AND JUST ABOVE THE SYSTEM AREA. 
* 
*  A USER LIBRARY CALL CAUSES A PROTECT VIOLATION.
* THIS SECTION FACILITATES ENTRY INTO THE LIBRARY 
* PROGRAM BY PERFORMING THE NECESSARY PROCESSING
* FOR RE-ENTRANCY OR OPERATING THE PROGRAM WITH 
* THE INTERRUPT SYSTEM TURNED OFF FOR A 'PRIVILEGED'
* EXECUTION PROGRAM.
* 
*  RE-ENTRANT OR PRIVILEGED PROGRAM FORMAT: 
*  ---------------------------------------- 
* 
*   ENTRY   NOP 
*           JSB  LIBR 
*           DEF  TDB  (OR 'NOP' IF PRIVILEGED)
*          - FIRST INSTRUCTION FOR FUNCTION - 
*            -    CODE
*            -     TO 
*            -     PERFORM
*            -     PROGRAM FUNCTION 
*    EXIT   JSB  LIBX 
*           DEF  TDB  (OR  DEF ENTRY IF PRIVILEGED) 
*           DEC  N   RETURN ADJUSTMENT FOR RE-ENTRANT 
*            -
*   TDB     NOP    HOLDS LINKAGE TO PREVIOUS BLOCK
*           DEC N  LENGTH OF TEMPORARY DATA BLOCK 
*           NOP    RETURN ADDRESS OF CALL.
*         - BLOCK USED FOR
*             HOLDING TEMPORARY 
*              VALUES GENERATED 
*               BY THE ROUTINE. 
* 
* 
*  < LIBR > IS ENTERED WHEN A LIBRARY 
* PROGRAM IS CALLED.  IF THE CALLED 
* PROGRAM IS 'RE-ENTRANT' AND IS CALLED 
* DURING THE PROCESSING OF A PREVIOUS 
* CALL, THE TEMPORARY-DATA-BLOCK IS 
* MOVED INTO A BLOCK IN AVAILABLE MEMORY
* BEFORE THE ROUTINE IS ENTERED.
* 
* 
LIBRA DEF LIBR
* 
LIBRC LDA TEMP1    SET (P+1) OF 
      STA LIBR      JSB LIBR IN -LIBR-. 
      JMP LB1       SKIP SAVING REGISTERS.
* 
LIBR  NOP         -NON INTERRUPT ENTRY--
      JSB SAVER     ( SAVE REGISTERS IN ID SEGMENT) 
* 
LB1   LDB LIBR,I   GET (P+2) OF -LIBR- CALL.
      SZB,RSS      IF (P+2) = 0, THEN CALLED PROGRAM
      JMP PVEXC     IS IN 'PRIVILEGED' FORMAT.
* 
      STB TEMP1    SAVE -TDB- ADDRESS.
      LDA B,I      GET WORD 1 OF DATA BLOCK.
      INA          IF -LINK- WORD = 0, THEN NEED NOT
      CPA .1        MOVE BLOCK BUT -LINK- WORD IS 
      JMP LB4        SET TO = 1 AS FLAG.
* 
      INB          GET  -TDB- 
      LDA B,I       WORD LENGTH.
      STA LB2      SAVE FOR MEMORY ALLOCATION 
      CMA,INA       AND AS INDEX
      STA MVCNT     FOR BLOCK MOVE. 
* 
      JSB .ALC.    ALLOCATE TEMPORARY BLOCK IN
LB2   NOP           AVAILABLE MEMORY. 
* 
      SZA,RSS      IF NO MEMORY AVAILABLE,
      JMP LB5       REJECT ORIGINAL CALLER. 
* 
      STB TEMP3    SAVE NEW BLOCK LENGTH
      STA TEMP2    SAVE NEW BLOCK LOCATION. 
      STA MVADR 
      LDB TEMP1    (B) = TDB ADDRESS. 
LB3   LDA B,I      MOVE  TDB
      STA MVADR,I   FROM
      ISZ MVADR     LIBRARY RE-ENTRANT PROGRAM
      INB           TO BLOCK
      ISZ MVCNT     IN AVAILABLE
      JMP LB3       MEMORY. 
      LDB TEMP3    CHECK NEW BLOCK
      CPB LB2       LENGTH AGAINST REQ. LENGTH. 
      JMP LB4-1     = 
      LDA TEMP2    NOT =, NEW BLOCK IS
      INA           1 WORD LONGER.
      LDB A,I      SET BLOCK LENGTH WORD IN 
      CMB,INB       WORD 2 NEGATIVE TO
      STB A,I       INDICATED CONDITION.
      LDA TEMP2    (A) = NEW BLOCK ADDRESS. 
* 
LB4   STA TEMP1,I  SET 1 OR NEW ADDR. IN TDB(1).
      LDB TEMP1    (B) = ADDR. OF TDB.
      ADB .2       SET
      LDA LIBR      (P+1) 
      ADA N2        OF ORIGINAL 
      LDA A,I       CALL IN 
      STA B,I       WORD 3 OF TDB IN PROGRAM. 
      ISZ LIBR     SET TO FIRST INSTR IN LIB. PROG. 
* 
      LDA LBORG    SET MEMORY PROTECT BOUNDARY
      STA FENCE 
      OTA 5         TO LIBRARY ORIGIN.
* 
      JSB $IRT      RESET INTERRUPT CONDITIONS
      JSB RSTR     RESTORE REGISTERS. 
* 
      STF 0        TURN ON INTERRUPT SYSTEM 
      STC 5        TURN ON MEMORY PROTECT 
* 
      JMP LIBR,I   TRANSFER TO LIBRARY PROGRAM. 
      SPC 1 
MVADR NOP 
MVCNT NOP 
PVCNT NOP 
* 
* REJECT SECTION CAUSED BY NO MEMORY
*  AVAILABLE FOR -TDB-. CALLING USER PROGRAM
*  IS SUSPENDED BACK TO POINT OF CALL AND 
*  LINKED INTO MEMORY SUSPENSION LIST.
* 
LB5   LDA XEQT     SET ID SEGMENT ADDRESS 
      STA LB6       IN CALL TO LIST 
* 
      JSB LIST     SUSPEND
      OCT 104       PROGRAM 
LB6   NOP 
      JMP XEQ      TRANSFER TO EXECUTE SECTION. 
* 
* 
* INITIATE PRIVILEGED EXECUTION OF USER PROGRAM 
* 
PVEXC JSB RSTR     RESTORE REGISTERS. 
      ISZ LIBR     INDEX TO (P+2) OF CALL.
      ISZ PVCNT    ADD 1 TO PRIV. EXECUTION COUNT.
      JMP LIBR,I   TRANSFER TO PROGRAM. 
* 
      SKP 
*  < LIBX > IS ENTERED WHEN A LIBRARY 
* PROGRAM TERMINATES ITS EXECUTION. A 
* TEMPORARY DATA BLOCK IS MOVED BACK
* INTO THE LIBRARY PROGRAM, IF REQUIRED,
* BEFORE RETURN TO THE ORIGINAL CALLER. 
* 
* 
LIBXA DEF LIBX
* 
LIBXC LDA TEMP1     SET (P+1) OF
      STA LIBX       JSB LIBX 
      JMP LB10      IN LIBX.
* 
LIBX  NOP           - NON-INTERRUPT ENTRY - 
      JSB SAVER      SAVE REGISTERS.
* 
LB10  LDA PVCNT    IF PVCNT IS ZERO, THEN 
      SZA,RSS       RETURNING PROGRAM 
      JMP LB13      IS RE-ENTRANT.
* 
      ADA N1       -PRIVILEGED- PROGRAM.
      STA PVCNT    SUBTRACT 1 FROM PVCNT. 
      LDB LIBX,I   GET (P+1): LOCATION OF ENTRY 
      LDB B,I       POINT.  GET AND 
      STB LIBX      SET  RETURN ADDRESS.
      SZA,RSS      IF PVCNT NOW = 0, THEN RETURNING 
      JMP LB11      TO USER OR RE-ENTRANT PROGRAM.
* 
      JSB RSTR     RETURNING TO 
      JMP LIBX,I    'PRIVILEGED' PROGRAM. 
* 
LB11  LDA LIBX     IF RETURN
      CMA,INA       POINT IS TO 
      ADA RTORG     USER, 
      SSA           GO TO SET 
      JMP LB16      MEMORY PROTECT FENCE. 
* 
LB12  JSB $IRT      RESET INTERRUPT CONDITIONS
      JSB RSTR      -RETURN TO RE-ENTRANT OR USER.
      STF 0        TURN INTERRUPT SYSTEM ON.
      STC 5        TURN MEMORY PROTECT ON.
      JMP LIBX,I    -RETURN-
* 
* RE-ENTRANT PROGRAM RETURNING TO USER CALL.
* 
LB13  LDB LIBX,I   SET  -TDB- ADDRESS.
      STB TEMP1     IN TEMP1. 
      ISZ LIBX      SET TO (P+2) OF CALL TO -LIBX-. 
      INB          GET TDB
      LDA B,I       LENGTH -
      CMA,INA      SET AS INDEX 
      STA MVCNT     FOR PREVIOUS TDB MOVE.
      INB          GET
      LDA B,I       RETURN POINT ADJUSTMENT.
      ADA LIBX,I    ADD TO (P+1) OF LIBRARY CALL
      STA LIBX      AND SET FOR RETURN TO USER. 
* 
      LDB TEMP1,I  GET PREVIOUS -TDB- LOCATION. 
      CLA          IF NO
      CPB .1        PREVIOUS BLOCK, THEN GO 
      JMP LB17       TO SET WORD 1 OF TDB = 0.
      STB MVADR    SAVE PREVIOUS
      STB LB15      TDB ADDRESS.
      LDB TEMP1    (B) = ADDR. OF TDB AREA IN PROG. 
LB14  LDA MVADR,I  MOVE 
      STA B,I       PREVIOUS
      ISZ MVADR     -TDB- 
      INB           BACK
      ISZ MVCNT     INTO RE-ENTRANT 
      JMP LB14      LIBRARY PROGRAM.
      LDB TEMP1    CHECK
      INB           FOR NEED TO 
      LDA B,I       RELEASE 1 MORE THAN TDB LENGTH. 
      SSA,RSS      IF LENGTH WORD +,
      JMP *+4       THEN USE STATED LENGTH. 
      CMA,INA      SET POSITIVE AND 
      STA B,I       RESTORE IN PROGRAM TDB. 
      INA          ADD 1 FOR RELEASE CALL.
      STA LB15+1
* 
      JSB .RTN.    RELEASE PREVIOUS -TDB- AREA. 
LB15  NOP           - FWA BLOCK AREA -
      NOP           - LENGTH IN WORDS-
      JMP LB11     GO TO CHECK RETURN ADDRESS 
* 
* SET MEMORY PROTECT FENCE FOR RETURN TO USER 
* 
LB16  LDA LIBX     SUBTRACT 
      CMA,INA       RETURN POINT
      ADA BKORG     FROM BACKGROUND ORIGIN. 
      LDB RTORG    (B) = REAL-TIME ORIGIN 
      SSA           IF RETURN IS TO BACKGROUND, 
      LDB BKORG     SET (B) = BACKGROUND ORIGIN 
      STB FENCE 
      OTB 5        SET MEMORY PROTECT FENCE REGISTER
* 
      JMP LB12      GO TO RETURN TO USER. 
* 
* 
LB17  STA TEMP1,I  FOR NO MOVE, SET WORD 1 OF PROG. 
      JMP LB11      TDB = 0, GO TO CHECK RETURN.
* 
      SKP 
* SUBROUTINES: <SAVER> AND <RSTR> USED FOR
*              SAVING AND RESTORING REGISTERS 
*              IN LIBRARY PROGRAM PROCESSING. 
* 
SAVER NOP 
      STA XA,I
      STB XB,I
      ERA,ALS 
      SOC 
      INA 
      STA XEO,I 
      JMP SAVER,I 
* 
RSTR  NOP 
      LDA XEO,I 
      CLO 
      SLA,ELA 
      STF 1 
      LDA XA,I
      LDB XB,I
      JMP RSTR,I
      HED * DYNAMIC MEMORY ALLOCATION ROUTINE 
* 
* DYNAMIC MEMORY ALLOCATION ROUTINE 
* 
*  THIS ROUTINE PROVIDES FOR THE DYNAMIC
* ALLOCATION AND RELEASE OF BLOCKS IN THE 
* SYSTEM AVAILABLE MEMORY AREA WHICH IS 
* POSITIONED BETWEEN THE REAL-TIME
* AND BACKGROUND AREAS. 
* 
*  .ALC.  :  ALLOCATE BLOCK 
*  .RTN.  :  RELEASE  BLOCK 
* 
* CALLING SEQUENCES:
* 
*    1.  .ALC.
*        .      REGISTERS MEANINGLESS 
*       (P)      JSB  .ALC. 
*       (P+1)    (# WORDS NEEDED) 
*       (P+2)    - RETURN - 
* 
*             ON RETURN:
*           (A) = FWA NEW BLOCK OR (A) = 0
*           (B) = # WORDS ALLOCATED ( MAY BE 1
*                   GREATER THAN REQUESTED) 
*         (A) = 0 IF NO MEMORY AVAILABLE
* 
*    2. (P)      JSB  .RTN. 
*       (P+1)    (FWA OF BUFFER)
*       (P+2)    (# WORDS RETURNED) 
*       (P+3)    - RETURN - REGISTERS MEANINGLESS 
* 
* 
* 
.ALC. NOP 
      LDA PNTR     CHECK FOR FIRST
      SZA           CALL. 
      JMP MEM1      NO. 
* 
      LDA AVMEM    YES, INITIALIZE MEMORY BLOCK.
      CMA,INA      SET WORD1 = # AVAILABLE. 
      ADA BKORG     ( BKORG - FWA AVAILABLE MEMORY )
      STA AVMEM,I 
      LDB AVMEM    INITIALIZE 
      STB PNTR       -PNTR- TO FWA BLOCK. 
      INB          SET WORD2 = 77777
      LDA MASK4      TO MEAN ONLY 
      STA B,I        1 LARGE BLOCK. 
      LDA PNTR
* 
MEM1  CPA MASK4    PNTR = 77777 MEANS NO MEMORY 
      JMP MEM7      IS NOW AVAILABLE, REJECT. 
      STA AAD      OTHERWISE, BEGIN SEARCH. 
* 
MEM2  LDB .ALC.,I  (B) = LENGTH REQUESTED : (X).
      STB SAVB     SET BUFFER LENGTH. 
      CMB,INB        - X
      ADB A,I      LENGTH CURRENT (I) - LENGTH (X)
      SSB,RSS        >=0? 
      JMP MEM3     YES, ALLOCATE THIS BLOCK.
      INA 
      LDB A,I       (B) = FORWARD ADDRESS (FWD) OF I
      CPB MASK4    IF FWD(I)=77777 THEN DONE, 
      JMP MEM7      NO BLOCK WAS FOUND, REJECT. 
      LDB AAD      MOVE THIS BLOCK POINTER
      STB BAD       TO LAST BLOCK POINTER,
      LDA A,I       AND NEXT BLOCK TO 
      STA AAD       THIS BLOCK. 
      JMP MEM2     REPEAT LOOP. 
* 
MEM3  ADB N2       IS BLOCK AT LEAST 2 WORDS
      SSB           LARGER THAN REQUEST?
      JMP MEM4     -NO, ALLOCATE ENTIRE BLOCK.
      ADB .2       (B) = LENGTH(I) - LENGTH(X)
      STB AAD,I    SET NEW L(I).
      ADB AAD 
      STB SAVA     SAVA = NEW BLOCK ADDRESS.
      JMP MEM6      -EXIT-. 
* 
MEM4  LDB AAD,I    SET BUFFER TO LENGTH(I) TO ALLO- 
      STB SAVB      CATE LENGTH (X) + 1.
      STA SAVA     AAD IS BUFFER ADDRESS. 
      CPA PNTR     IS THIS FIRST BLOCK? 
      JMP MEM5     YES, MOVE PNTR TO FWD(I) 
      INA          NO - 
      LDB A,I      FWD(I) TO
      LDA BAD 
      INA 
      STB A,I       FWD(I-1)
      JMP MEM6
* 
MEM5  INA          SET
      LDB A,I       PNTR TO NEW 
      STB PNTR       FIRST BLOCK. 
* 
MEM6  ISZ .ALC.    ADJUST RETURN TO (P+2).
      LDA SAVA      (A) FWA OF NEW BLOCK
      LDB SAVB      (B) LENGTH OF BLOCK 
      JMP .ALC.,I    - EXIT - 
* 
MEM7  CLA          -REJECT, SET (A) = 0.
      ISZ .ALC.     ADJUST RETURN TO (P+2)
      JMP .ALC.,I    AND  -EXIT-
      SKP 
.RTN. NOP 
      LDA .RTN.,I  (A) = FWA RETURN BUFFER
      STA ADX         TO (ADX). 
      ISZ .RTN. 
      LDA .RTN.,I   # WORDS RETURNED (X)
      ADA N2
      SSA           < 2 ? 
      JMP MEM18     BUFFER TOO SMALL-IGNORE.
* 
      CLA 
      STA BAD 
      LDB PNTR
* 
MEM10 STB AAD      PNTR TO AAD
      CMB,INB 
      ADB ADX 
      SSB          ADX - AAD >= 0?
      JMP MEM11 
      LDA AAD      YES, 
      STA BAD       AAD TO BAD
      INA 
      LDB A,I      NEXT BUFFER ADDRESS TO AAD 
      JMP MEM10     - CONTINUE SCAN.
* 
MEM11 ADB .RTN.,I  X + ADX >= AAD?
      SSB 
      JMP MEM12     NO
      LDA AAD 
      LDB ADX 
      CMB,INB 
      ADB AAD 
      ADB AAD,I 
      STB ADX,I    L(X) = L(A) + AAD - ADX
      INA 
      LDB A,I       (B) = FWD(A)
      LDA ADX 
      INA 
      STB A,I      FWD(A) TO FWD (X)
      JMP MEM13 
* 
MEM12 LDA .RTN.,I  X NOT CONTIGUOUS WITH A
      STA ADX,I 
      LDA ADX 
      INA 
      LDB AAD 
      STB A,I      FWD(X) = AAD 
* 
MEM13 LDB BAD 
      SZB,RSS      ANY LOWER BLOCKS?
      JMP MEM14     NO, DONE
      INB 
      LDA ADX 
      CPA BAD      SAME BLOCK?
      RSS          YES, DO NOT SET FWD(B).
      STA B,I      ADX TO FWD(B)
      LDA BAD 
      ADA BAD,I 
      LDB ADX 
      CMB,INB 
      ADB A 
      SSB          BAD + L(B) >= ADX? 
      JMP MEM15    NO, DONE.
      LDA ADX      YES, B AND X OVERLAP 
      INA 
      LDB A,I 
      LDA BAD 
      INA 
      STB A,I      FWD(X) TO FWD(B) 
      CMA,INA 
      INA 
      ADA ADX 
      ADA ADX,I 
      STA BAD,I    L(B) = L(X) + ADX - BAD
      JMP MEM15 
* 
MEM14 LDA ADX      X IS NOW 
      STA PNTR      FIRST BLOCK 
* 
* A BLOCK HAS BEEN RETURNED - ALL PROGRAMS
*  WAITING FOR AVAILABLE MEMORY ARE LINKED
*  BACK INTO THE SCHEDULE LIST FROM THE 
*  MEMORY SUSPENSION LIST.
* 
MEM15 LDA SUSP3    GET SUSPENSION LIST POINTER
      SZA,RSS      IF EMPTY LIST, 
      JMP MEM18     GO TO EXIT. 
* 
MEM16 STA MEM17     SAVE ID SEGMENT ADDRESS.
      LDA A,I      GET NEXT LINK ADDRESS
      STA SAVA      AND SAVE. 
* 
      JSB LIST     CALL *SCHEDULER* TO
      OCT 101       LINK INTO -SCHEDULE- LIST.
MEM17 NOP           - ID SEGMENT ADDRESS -
* 
      LDA SAVA     IF END OF LIST,
      SZA           EXIT ROUTINE
      JMP MEM16     -SCHEDULE NEXT PROGRAM IN LIST- 
* 
MEM18 ISZ .RTN. 
      JMP .RTN.,I 
* 
* 
PNTR  NOP 
AAD   NOP 
BAD   NOP 
ADX   NOP 
* 
SAVA  NOP 
SAVB  NOP 
* 
      HED ** SYSTEM DISC ALLOCATION/RELEASE PROCESSOR **
*  SYSTEM DISC ALLOCATION/RELEASE REQUESTS
* 
*  THESE REQUESTS CONFORM TO THE GENERAL
* SYSTEM REQUEST FORMAT.
* 
*  A.  DISC TRACK ALLOCATION
* 
*      THE ALLOCATION REQUEST  INCLUDES THE 
*     NUMBER OF CONTIGUOUS TRACKS DESIRED, A
*     PARAMETER TO INDICATE SUSPENSION OR 
*     NO SUSPENSION IF THE REQUESTED SPACE IS 
*     NOT AVAILABLE AND VARIABLE STORAGE FOR
*     RETURNING THE STARTING TRACK NUMBER, THE
*     DISC LOGICAL UNIT NUMBER AND THE NUMBER 
*     OF SECTORS PER TRACK FOR THE ASSIGNED 
*     DISC. 
* 
*      (P)    JSB EXEC
*      (P+1)  DEF *+6     (DEFINE RETURN) 
*      (P+2)  DEF RCODE   ( " REQUEST CODE) 
*      (P+3)  DEF #TRAK   ( " # TRACKS DESIRED) 
*      (P+4)  DEF STRAK   ( " WORD FOR TRACK #) 
*      (P+5)  DEF DISC    ( "  "   FOR DISC LU #) 
*      (P+6)  DEF SECT#   ( "  "   FOR # SECTORS) 
*      (P+7)  - RETURN -
* 
*      RCODE  DEC M 
*      #TRAK  DEC N 
*      STRAK  NOP 
*      DISC   NOP 
*      SECT#  NOP 
* 
*     M =  4 ALLOCATE TRACK TO PROGRAM
*       = 15 ALLOCATE TRACK GLOBALLY
* 
*     #TRAK (BIT 15):= 0 TO MEAN SUSPENSION IF
*                        TRACKS NOT AVAILABLE 
*                    = 1 TO MEAN NO SUSPENSION AND
*                        SET (STRAK) = -1 IF NO 
*                        TRACKS AVAILABLE.
* 
*     STRAK : THE STARTING TRACK NUMBER OF THE
*             CONTIGUOUS GROUP ALLOCATED IS 
*             STORED IN THIS WORD  ( OR = -1 AS 
*             DESCRIBED FOR 'NO SUSPENSION' ABOVE). 
* 
*     DISC : THE LOGICAL UNIT NUMBER OF THE DISC
*            ON WHICH THE TRACK(S) WERE ALLOCATED 
*            IS STORED IN THIS WORD.
* 
*     SECT#: THE NUMBER OF SECTORS PER TRACK FOR
*            THIS DISC ALLOCATION IS STORED IN
*            THIS WORD. 
      SKP 
* 
*  B.  DISC TRACK RELEASE 
* 
*      THE RELEASE  REQUEST PROVIDES FOR RELEASING
*     A SINGLE TRACK, A CONTIGUOUS GROUP OF TRACKS
*     OR ALL TRACKS ASSIGNED.  THE TRACKS TO BE 
*     RELEASED MUST BE EITHER ASSIGNED TO THE 
*     REQUESTING PROGRAM (REQUEST CODE 5) OR
*     ASSIGNED GLOBALLY (REQUEST CODE 16).
* 
*      (P)    JSB EXEC
*      (P+1)  DEF *+5     (DEFINE RETURN) 
*      (P+2)  DEF RCODE   ( "  REQUEST CODE)
*      (P+3)  DEF #TRAK   ( " # TRACKS TO RELEASE)
*      (P+4)  DEF STRAK   ( " STARTING TRACK #) 
*      (P+5)  DEF DISC    ( " DISC LU # ) 
*      (P+6)  - RETURN -
* 
*      RCODE  DEC M 
*      #TRAK  DEC N 
*      STRAK  NOP 
*      DISC   NOP 
* 
*     M =  5 RELEASE PROGRAM TRACK
*       = 16 RELEASE GLOBAL TRACK 
* 
*     #TRAK: = N, TO INDICATE THE NUMBER OF CONTIG- 
*                 UOUS TRACKS TO RELEASE BEGINNING
*                 AT THE TRACK NUMBER IN 'STRAK'. 
* 
*            = -1, TO MEAN RELEASE ALL TRACKS ASSIGNED
*                   TO THE USER PROGRAM - 
*                   VALID ONLY FOR PROGRAM ASSIGNED TRACKS
*                  IN THIS CASE, THE 'STRAK' AND
*                  'DISC' PARAMETERS NEED NOT 
*                  BE INCLUDED. 
* 
*     STRAK:  THE STARTING TRACK OF THE GROUP TO
*             BE RELEASED IS STORED IN THIS WORD. 
* 
*     DISC:   THE LOGICAL UNIT NUMBER OF THE DISC 
*             CONTAINING THE TRACKS IS STORED 
*             IN THIS WORD. 
      SKP 
* 
*  **  TRACK  ASSIGNMENT  TABLE  ** 
* 
*   THE *TAT* IS A VARIABLE LENGTH TABLE DESCRIBING 
*  THE AVAILABILITY OF EACH DISC TRACK ON THE 
*  SYSTEM DISC AND, IF INCLUDED, THE AUXILIARY DISC.
*   THE *TAT* IS CONSTRUCTED BY <RTGEN> BASED ON
*  USER PARAMETERS DECLARING THE SIZE OF THE SYSTEM 
*  DISC AND THE AVAILABILITY AND SIZE OF AN AUXILIARY 
*  DISC. EACH TRACK IS REPRESENTED BY A 1-WORD ENTRY. 
*  THE FIRST WORDS OF THE TABLE CORRESPOND TO THE 
*  N TRACKS OF THE SYSTEM DISC, USUALLY 32, 64 OR 
*  128. THE WORD "TATSD" IN THE BASE PAGE COMMUNI-
*  CATION AREA CONTAINS THE SIZE OF THE SYSTEM DISC 
*  AS A POSITIVE INTEGER. IF AN AUXILIARLY DISC IS
*  INCLUDED, THE REST OF THE *TAT* CONTAINS 1-WORD
*  ENTRIES TO DESCRIBE THE TRACKS ON THAT DISC. 
*   RTGEN INITIALIZES THE PROTECTED TRACKS OF THE 
*  SYSTEM DISC TO BE ASSIGNED TO THE SYSTEM (PERM-
*  ANENTLY UNAVAILABLE).
*   THE CONTENTS OF A TRACK ASSIGNMENT ENTRY WORD 
*  MAY BE ONE OF THE FOUR VALUES: 
* 
*       0   - AVAILABLE FOR ASSIGNMENT
*    100000 - ASSIGNED TO THE SYSTEM (OR PROTECTED) 
*    077777 - ASSIGNED GLOBALLY 
*     NNNNN - USER PROGRAM ASSIGNMENT. NNNNN IS THE 
*              ID SEGMENT ADDRESS OF THE PROGRAM. 
* 
*  THE WORD "TATLG" IN THE BP COMMUNICATION AREA
*  CONTAINS THE NEGATIVE LENGTH OF THE TAT. 
*  THE WORD "TAT" CONTAINS THE FWA OF THE TABLE.
* 
* 
** VARIABLE NUMBER OF SECTORS PER TRACK ON FIXED-HEAD SYSTEMS **
* 
*    ONE RTE CAN ACCOMODATE TWO FIXED-HEAD
*   DISC UNITS TERMED THE SYSTEM DISC (LU #2) 
*   AND THE AUXILIARY DISC (LU#3). THESE DISCS
*   MAY BE DIFFERENT MODELS OF A FIXED-HEAD 
*   DISC AND WITH DIFFERING NUMBER OF SECTORS 
*   PER TRACK. FOR THIS REASON THE WORDS
*    'SECT2' AND 'SECT3' IN THE BASE PAGE 
*   COMMUNICATION AREA CONTAIN THE NUMBER OF
*   SECTORS PER TRACK FOR LOGICAL UNITS 2 AND 3.
* 
* 
      SKP 
* TRACK  ALLOCATION  (USER CALL)
* 
DISC1 CLA,RSS       SET 
DISCA CLA,INA        ENTRY
      STA TEMP7      SWITCH 
      LDA RQCNT     INSURE
      ADA N4        THAT
      SZA            4 PARAMETERS ARE SUPPLIED. 
      JMP DERR1     -NO, ERROR 'DR01' 
* 
      LDA RQP2,I    GET '#TRAK' PARAMETER TO CHECK
      AND MASK4      'N'. REMOVE BIT 15,
      SZA,RSS       -ERROR IF 
      JMP DERR2      #TRAK = 0. 
* 
      LDB TEMP7     (A)=# TRACKS
      SZB           (B)=ID SEGMENT ADDRESS
      CCB,RSS           OR GLOBAL FLAG
      LDB XEQT
      ELB,CLE,ERB 
      JSB DREQ      CALL FOR CONTIGUOUS ALLOCATION
* 
      SZB           IF TRACKS ALLOCATED,
      JMP DSC3       CONTINUE.
* 
* NO TRACKS ARE AVAILABLE 
* 
      CCA           CHECK SUSPENSION
      LDB RQP2,I     PARAMETER. 
      SSB           IF BIT 15 = 1, GO TO SET STRAK
      JMP DSC4       = -1 AND RETURN TO CALLER. 
* 
* SUSPEND PROGRAM - LINK INTO DISC SUSPENSION LIST
* 
      LDA XEQT     SET ID SEGMENT ADDRESS OF PROGRAM
      STA DSC2      IN CALL TO <LIST>.
* 
      JSB LIST     SUSPEND
      OCT 105       PROGRAM 
DSC2  NOP           - DISC SUSPENSION LIST -
      JMP XEQ       - EXIT -
* 
* AVAILABLE TRACK FOUND 
* 
DSC3  STA TEMP1     SAVE STARTING TRACK #.
      LDA SECT2     SET TO STORE
      CPB .3         # SECTORS PER TRACK IN 
      LDA SECT3      'SECT#' DEPENDING ON LU # IN B.
      STA RQP5,I    SET # SECTORS.
* 
      STB RQP4,I    SET DISC LOGICAL UNIT #.
      LDA TEMP1     (A)= STARTING TRACK #.
* 
DSC4  STA RQP3,I    SET TRACK # OR -1.
      LDA RQRTN    SET *XSUSP* TO 
      STA XSUSP,I   BE EXIT ADDRESS 
      JMP XEQ        - EXIT -.
* 
.3    DEC 3 
N2    DEC -2
N4    DEC -4
MASK4 OCT 77777 
* 
* 
* TRACK RELEASE  (USER CALL)
* 
DISC2 CLA,CLE,RSS    SET
DISCB CLA,CCE,INA     ENTRY 
      STA TEMP7      SWITCH 
      LDA RQCNT     INSURE
      SZA,RSS       THAT AT LEAST 1 PARAMETER GIVEN.
      JMP DERR1     - NO, ERROR 
      LDA XEQT      (A)= ID SEGMENT ADDRESS 
      LDB RQP2,I    GET PARAMETER:
      CPB N1         IF = -1, 
      JMP DSC7        GO TO RELEASE ALL FOR THIS PROG 
* 
      LDA RQCNT     INSURE THAT THE 
      CPA .3         STRAK AND DISC PARAMETERS
      RSS            ARE PROVIDED.
      JMP DERR1     -NO, ERROR
* 
      LDA RQP4,I    GET DISC LU #.
      CPA .2        CHECK VALIDITY. 
      RSS           -ERROR 'DR02' IF
      CPA .3         NOT
      RSS            2 OR 
      JMP DERR2      3
* 
      LDB TAT       SET (B) = FWA OF TAT FOR
      CPA .3         SYSTEM DISC OR FOR 
      ADB TATSD      AUXILIARY DISC 
      ADB RQP3,I    ADD STRAK FROM USER CALL. 
* 
      LDA RQP2,I    GET #TRAK.
      CMA,INA       SET NEGATIVE FOR
      SSA,RSS        COUNTER. ERROR IF 0 OR 
      JMP DERR2      ORIGINALLY NEGATIVE. 
      STA TEMP1     SET COUNTER.
      STA TEMP6 
* 
      LDA TEMP7     RELEASE 
      SZA            NON-GLOBAL 
      JMP DSC8       GLOBAL 
* 
DSC5  LDA B,I       GET CURRENT TRACK ASSIGNMENT
      CPA XEQT      COMPARE TO PROGRAM ID SEG ADDRESS 
      CLA,RSS 
      JMP DERR3      OTHERWISE, REQUEST ERROR.
      STA B,I        = 0 TO BE AVAILABLE. 
      INB           ADD 1 TO TAT ADDRESS. 
      ISZ TEMP1     -INDEX COUNTER. 
      JMP DSC5       -MORE
* 
DSC6  JSB DSKED     FINISHED-SCHEDULE DISC SUSP PROGS 
* 
      LDA RQRTN    SET RETURN ADDRESS 
      STA XSUSP,I   AS POINT OF SUSPENSION
      JMP XEQ        - EXIT - 
* 
DSC7  SEZ 
      JMP DERR1     CANNOT RELEASE ALL GLOBAL 
      JSB SDSCR     RELEASE ALL 
      JMP DSC6      SPC 1 
DSC8  STB TEMP4     SAVE ADDR OF
      STB TEMP7      ENTRY IN TAT 
      LDA RQP3,I    SAVE TRACK
      STA TEMP8      NUMBER 
      SPC 1 
      CCA 
      ADA RQP4,I    SET DISC QUEUE
      ADA DRT        ADDRESS
      LDA A,I        INTO 
      AND MASK3      EQT1 
      JSB $CVEQ 
      SPC 1 
DSC9  LDA TEMP7,I   GLOBAL
      CPA MASK4      TRACK? 
      RSS           YES-GO SEE IF IN USE
      JMP DSC15     NO-RETURN TO PROG WITH A=-2 
      LDB EQT1,I    GET REQUESTS QUEUED ON DISC 
DSC10 STB TEMP9     DISC QUEUE EXHAUSTED? 
      SZB,RSS 
      JMP DSC12      YES-GO TO NEXT TRACK 
      INB            NO-SEE IF REQUEST
      LDA B,I        IS FOR THIS TRACK
      ALF,ALF 
      AND .3
      CPA RQP4,I    SAME LU? I.E. DISC? 
      RSS            YES-CHECK IF SAME TRACK
      JMP DSC11      NO 
      ADB .3
      LDA B,I 
      CPA TEMP8     SAME TRACK? 
      JMP DSC15+2    YES-RETURN WITH A=-1 
      SPC 1 
DSC11 LDB TEMP9,I   GO TO NEXT REQUEST
      JMP DSC10      IN QUEUE 
      SPC 1 
DSC12 ISZ TEMP1     ALL TRACKS CHECKED
      RSS            FOR GLOBAL & NOT IN USE? 
      JMP DSC13     YES-RELEASE THEM
      ISZ TEMP7     NO- 
      ISZ TEMP8      CHECK NEXT TRACK 
      JMP DSC9
      SPC 1 
DSC13 STB TEMP4,I   CLEAR ALL 
      ISZ TEMP4      TRACKS 
      ISZ TEMP6 
      JMP DSC13     SETUP TO RETURN 
      STB XA,I      TO PROGRAM
      JMP DSC6       WITH A=0 
      SPC 1 
DSC15 CLA,INA       STORE A REGISTER
      CMA,RSS        TO INDICATE WHY
      CCA            NO TRACKS RELEASED 
      STA XA,I
      JMP DSC6+1
* 
* DISC REQUEST ERROR SECTION
* 
DERR1 LDB DA01     -ILLEGAL DISC REQUEST - DR01 - 
      JMP DERR
DERR2 LDB DA02     -ILLEGAL TRACK #      - DR02 - 
      JMP DERR
DERR3 LDB DA03     -TRACK NOT ASSIGNED TO PROG- DR03
DERR  LDA DRA      (A) = DR  IN ASCII.
      JSB ERMSG    PRINT ERROR DIAG. AND ABORT PROG 
      LDA XEQT
      JSB ABORT 
      JMP XEQ       -EXIT-
* 
DA01  ASC 1,01
DA02  ASC 1,02
DA03  ASC 1,03
DRA   ASC 1,DR
* 
* 
* SUBROUTINE:  <ODSCR>
* 
*  PURPOSE:  THIS SUBROUTINE SCANS THE TAT
*           (TRACK ASSIGNMENT TABLE) AND
*           RELEASES ANY TRACKS ASSIGNED
*           TO THE PROGRAM WHOSE ID SEGMENT 
*           ADDRESS IS IN THE A REGISTER. 
* 
* 
*  CALL: (A) = ID SEGMENT ADDRESS OF PROGRAM
*              WHOSE TRACKS ARE TO BE RELEASED
*        (P)      JSB ODSCR  (OR $OTRL) 
*        (P+1)     -RETURN- 
* 
* 
ODSCR NOP 
      STA TEMP3      SAVE ID SEGMENT ADDRESS
      LDA *-2         AND RETURN ADDRESS FOR
      STA SDSCR       SDSCR ROUTINE AND JUMP
      JMP SDSC1       TO IT 
      SKP 
* 
* SUBROUTINE:  < SDSCR >
* 
*  PURPOSE:  THIS ROUTINE SCANS THE  TAT
*           (TRACK ASSIGNMENT TABLE) AND
*           RELEASES ANY TRACKS ASSIGNED
*           TO THE PROGRAM WHOSE ID SEGMENT 
*           IS DEFINED IN *XEQT* OR ANY TRACKS ASSIGNED 
*           GLOBALLY DEPENDING ON A REG CONTENTS ON ENTRY.
* 
* 
*  EXCEPTION: IF THE NAME OF THE SUBJECT PROGRAM IS 
*             "EDIT", AN IMMEDIATE EXIT IS MADE TO
*             AVOID RELEASING SAVED SOURCE FILES AND
*             TRACKS IN THE NAME OF THE EDITOR PROGRAM. 
* 
*  CALL: (A) = ID SEGMENT ADDRESS OF PROGRAM
*              OR 077777B (GLOBAL FLAG) 
*        (P)     JSB SDSCR  (OR $SDRL)
*        (P+1)    -RETURN-
* 
* 
SDSCR NOP 
      STA TEMP3 
      STA B 
      ADB .12 
      LDA B,I        CHECK
      CPA SDSC2      NAME 
      INB,RSS        FOR
      JMP SDSC1       "EDIT " 
      LDA B,I 
      CPA SDSC2+1 
      INB,RSS 
      JMP SDSC1 
      LDA B,I 
      AND MASK5 
      IOR .40 
      CPA SDSC2+2 
      JMP SDSCR,I    YES,  RETURN.
* 
SDSC1 LDA TAT      SET  *TAT* 
      STA TEMP1     ADDRESS 
      LDA TATLG     AND TAT LENGTH
      STA TEMP2     AS INDEX. 
      CLB          (B) = 0 FOR RELEASE
* 
      LDA TEMP1,I  GET CURRENT TRACK ASSIGNMENT.
      CPA TEMP3     IF ASSIGNED TO THIS PROGRAM,
      STB TEMP1,I   RELEASE IT. 
      ISZ TEMP1    SET
      ISZ TEMP2     FOR 
      JMP *-5       NEXT TRACK. 
      JMP SDSCR,I    -FINISHED- 
* 
SDSC2 ASC 3,EDIT
      SPC 1 
MSIGN OCT 100000
      SKP 
* 
* SYSTEM SUBROUTINE:  < DREQ >
* 
*  PURPOSE:  THIS SUBROUTINE PROVIDES FOR THE 
*           ALLOCATION OF 'N' CONTIGUOUS TRACKS 
*            FOR BOTH SYSTEM ROUTINES AND NORMAL
*            USER PROGRAMS. THE 'N' CONTIGUOUS
*            TRACKS ALLOCATED WILL BE ON THE SAME 
*            DISC UNIT, NO SPANNING OF DISCS WITH 
*            ONE ALLOCATION IS ALLOWED. 
* 
*  CALL:    (A)  = NUMBER OF CONTIGUOUS TRACKS
*            (B)  = : 0 FOR CALL FROM SYSTEM ROUTINE
*                   : (XEQT) FOR AN ACTUAL USER 
*                     REQUEST. THE ID SEGMENT 
*                     ADDRESS (XEQT) IS STORED IN 
*                     THE ASSIGNED TRACK WORDS IN 
*                     THE -TAT-.
*                   : (077777B) FOR A GLOBAL ASSIGNMENT REQUEST.
*                     THIS OCTAL NUMBER IS STORED IN THE
*                     ASSIGNED TRACK WORDS IN THE -TAT-.
* 
*      (P)      JSB  DREQ 
*      (P+1)    -RETURN-
* 
*           ON RETURN: 1) B = 0 IF N TRACKS WERE
*                          NOT AVAILABLE
* 
*                      2) A =  STARTING TRACK ADDRESS 
*                              OF N TRACKS. 
*                         B = LOGICAL UNIT # OF DISC
* 
* 
DREQ  NOP 
      STA TEMP1    SAVE  'N'
* 
      SZB,RSS       IF B=0, SET (B) = 100000 FOR
      LDB MSIGN      SYSTEM ASSIGNMENT. 
      STB TEMP6     SAVE ASSIGNMENT VALUE.
* 
      LDA TAT      SET  *TAT* 
      STA TEMP3     ADDRESS 
      ADA TATSD 
      STA TEMP7 
      LDA TATLG     AND TAT LENGTH
      STA TEMP4     AS  INDEX.
      CLA          INITIALIZE 
      STA TEMP5     TRACK COUNTER.
* 
DREQ1 LDA TEMP3,I  GET CURRENT TRACK ASSIGNMENT.
      SZA,RSS      IF NOT ASSIGNED, 
      JMP DREQ3     CHECK FOR N CONTIGUOUS. 
      ISZ TEMP3    SET
DREQ5 ISZ TEMP5     FOR 
      ISZ TEMP4      NEXT 
      JMP DREQ1       TRACK.
* 
DREQ2 CLB          NOT AVAILABLE, EXIT
      JMP DREQ,I    WITH  (B) = 0.
* 
* AVAILABLE TRACK FOUND - CHECK NEXT 'N-1' TRACKS 
* 
DREQ3 LDB TEMP5    (B) = FIRST TRACK ADDRESS. 
      LDA TEMP1    SET
      CMA,INA       'N' 
      STA TEMP2      AS INDEX.
DREQ4 LDA TEMP3,I  CHECK CURRENT
      SZA           TRACK ASSIGNMENT. 
      JMP DREQ1     -ASSIGNED, CONTINUE OTHER SCAN. 
      ISZ TEMP3    INDEX CURRENT *TAT* ADDRESS. 
      ISZ TEMP2    INDEX  -'N'
      RSS           NOT ZERO, CHECK NEXT TRACK. 
      JMP DREQ6      - FOUND N TRACKS - 
      LDA TEMP3     END OF SYSTEM 
      CPA TEMP7      DISC (LU 2)? 
      JMP DREQ5     YES - DO NOT SPAN 
      ISZ TEMP5    INDEX TRACK COUNTER
      ISZ TEMP4     AND TRACK INDEX.
      JMP DREQ4      -NOT FINISHED WITH TAT SIZE. 
      JMP DREQ2     NOT N AVAILABLE.
* 
* N CONTIGUOUS TRACKS FOUND 
* 
DREQ6 STB TEMP3    SAVE FIRST TRACK #.
      ADB TAT      SET STARTING TRACK 
      STB TEMP4     *TAT* ADDRESS.
      LDA TEMP1    SET
      CMA,INA       'N' 
      STA TEMP2      AS INDEX.
      LDA TEMP6     SET TRACK WORD
      STA TEMP4,I    = 100000 FOR SYSTEM USE
      ISZ TEMP4      OR TO THE ID SEGMENT ADDRESS 
      ISZ TEMP2      OF THE USER PROGRAM OR TO
      JMP *-3        077777B FOR GLOBAL ASSIGNMENT. 
      LDA TATSD    SUBTRACT SYS DISC
      CMA,INA       SIZE FROM STARTING
      ADA TEMP3      TRACK #. 
      LDB .2       (B) = 2 FOR SYSTEM DISC. 
      SSA,RSS      IF TRACK # GT SYS DISC SIZE, 
      INB           SET (B)=3 FOR AUX. DISC 
      CPB .2       (A) = STARTING 
      LDA TEMP3     TRACK # IN APPROPRIATE DISC 
      JMP DREQ,I    -EXIT-. 
      SPC 1 
TEMP1 NOP 
TEMP2 NOP 
TEMP3 NOP 
TEMP4 NOP 
TEMP5 NOP 
TEMP6 NOP 
TEMP7 NOP 
TEMP8 NOP 
TEMP9 NOP 
      SKP 
* 
* SYSTEM SUBROUTINE:  < DREL >
* 
*  PURPOSE:  THIS ROUTINE RELEASES 'N' CONTIGUOUS 
*           TRACKS (ASSIGNED TO THE SYSTEM) 
*           BEGINNING AT TRACK 'M'. 
* 
*  CALL:    (A) = 'M' - STARTING TRACK # (+ SIZE OF 
*                        SYSTEM DISC IF LU #3)
*           (B) = 'N' - # OF CONTIGUOUS TRACKS
*      (P) )   JSB  DREL
*      (P+1)   -RETURN- 
* 
* 
DREL  NOP 
      ADA TAT      COMPUTE  *TAT* ADDRESS 
      STA TEMP1     OF STARTING ADDRESS.
      LDA A,I      GLOBAL TRACKS
      SSA,RSS       ARE NOT TO
      JMP DREL,I    BE RELEASED.
      CMB,INB      SET 'N' AS INDEX.
      CLA          SET CURRENT
      STA TEMP1,I   TRACK 
      ISZ TEMP1      RELEASED 
      INB,SZB 
      JMP *-3 
      JSB DSKED    SCHEDULE ANY SUSPENDED PROGRAMS. 
      JMP DREL,I    -EXIT-
* 
* SUBROUTINE:  < DSKED >
* 
*  PRUPOSE: THIS ROUTINE CALLS FOR THE
*          SCHEDULING OF ALL USER PROGRAMS
*          SUSPENDED BECAUSE OF DISC TRACK
*          AVAILABILITY.
* 
*  CALL:  (P)     JSB  DSKED
*         (P+1)   - RETURN -
* 
* 
DSKED NOP 
      LDA SUSP4    GET DISC SUSPENSION LIST POINTER.
DSKD1 SZA,RSS      IF EMPTY LIST, 
      JMP DSKED,I   EXIT. 
* 
      STA DSKD2    SAVE ID SEGMENT ADDRESS. 
      LDA A,I      GET NEXT LINK ADDRESS
      STA TEMP1     AND SAVE. 
* 
      JSB LIST     CALL *SCHEDULER* TO
      OCT 101       LINK INTO SCHEDULE LIST.
DSKD2 NOP           -ID SEGMENT ADDRESS-
* 
      LDA TEMP1    IF END OF LIST 
      JMP DSKD1     EXIT - ELSE, SCHEDULE NEXT PROGRAM
      HED * EXEC  - ERROR MESSAGE AND ABORT SECTION * 
* 
*  ERROR SECTION
* 
*  THE FOLLOWING DIAGNOSTICS ARE OUTPUT ON THE
* SYSTEM TELETYPEWRITER ON DETECTION OF:
* 
*   1) VALID MEMORY PROTECT VIOLATION (I.E THE
*       INSTRUCTION CAUSING THE VIOLATION IS
*       NOT  JSB EXEC.
* 
*        MP  -PNAME-  -PADDR- 
* 
*   2) REQUEST CODE UNDEFINED OR ILLEGAL
*       NUMBER OF PARAMETERS
* 
*        RQ   -PNAME- -PADDR- 
* 
*  THE ROUTINE -ERMSG- IS USED TO FORMAT
* THE DIAGNOSTIC AND CALL FOR ITS OUTPUT. 
* 
* 
MPERR LDA MP       (A) =  'MP'
      RSS 
* 
RQERR LDA RQ1      (A)  'RQ'
      LDB BLANK    (B) = BLANKS 
      JSB ERMSG 
      LDA XEQT     ABORT
      JSB ABORT     PROGRAM.
      JMP XEQ 
* 
MP    ASC 1,MP
BLANK ASC 1,
RQ1   ASC 1,RQ
* 
* SUBROUTINE:  <ERMSG>
* 
*  PURPOSE:  THIS ROUTINE FORMATS A DIAGNOSTIC
*           MESSAGE WHICH CONTAINS A FOUR 
*           CHARACTER MNEMONIC DESCRIBING THE 
*           ERROR WITH THE PROGRAM NAME AND 
*           LOCATION OF THE ERROR. IT THEN
*           CALLS THE ROUTINE  <SYSMG> TO 
*           OUTPUT THE MESSAGE. 
* 
*  CALL:    (A),(B) CONTAIN A 4 ASCII CHARACTER 
*           MNEMONIC OR CODE DESCRIBING THE ERROR 
* 
*     (P)   JSB  ERMSG
*     (P+1) - RETURN - (REGISTERS MEANINGLESS)
      SKP 
* 
ERMSG NOP 
* 
      STA MSG+1    SET ERROR MNEMONIC IN
      STB MSG+2     FIRST 4 CHARACTERS OF MESSAGE.
* 
      LDB XEQT     SET (B) = ADDRESS OF 3-WORD
      ADB .12       PROGRAM NAME IN ID SEGMENT
      LDA B,I      SET
      STA MSG+4     PROGRAM 
      INB           NAME
      LDA B,I       IN
      STA MSG+5     MESSAGE.
      CLE,INB      (E=0 FOR ASCII CONVERSION) 
      LDA B,I 
      AND MASK5 
      IOR .40 
      STA MSG+6 
* 
      LDA XSUSP,I  GET LOCATION OF ERROR
      JSB CVT3     CONVERT TO OCTAL/ASCII FORMAT
      STA B        (B) = ADDR. OF 3-WORD BLOCK
      LDA B,I      MAKE 
      AND MASK3     LEADING 
      IOR UBLNK     ZERO A BLANK FOR
      STA MSG+7     5-DIGIT MEMORY ADDRESS. 
      INB          SET
      LDA B,I       ADDRESS 
      STA MSG+8     IN
      INB           MESSAGE.
      LDA B,I 
      STA MSG+9 
* 
      LDA MSGA     CALL <SYSTEM MESSAGE> TO 
      JSB SYSMG     OUTPUT DIAGNOSTIC.
* 
      JMP ERMSG,I 
* 
MASK3 OCT 377 
MASK5 OCT 177400
UBLNK OCT 20000 
* 
MSGA  DEF *+1 
* 
MSG   DEC -18 
      ASC 9,
* 
      SKP 
* ROUTINE:    < ABORT > 
* 
*  PURPOSE:  THIS ROUTINE PROVIDES FOR REMOVING 
*           A USER PROGRAM FROM EXECUTION USUALLY 
*           AFTER AN ERROR CONDITION IS DETECTED
*           WHICH PROHIBITS CONTINUED EXECUTION.
*           THE PROGRAM IS SET TO THE DORMANT 
*           STATE, TIME INTERVAL REMOVED AND ANY
*           DISC TRACKS ASSIGNED TO THE PROGRAM 
*           RELEASED. 
* 
*            THE PROGRAM NAME IS SET IN THE MESSAGE 
*           "XXXXX ABORTED" WHICH IS PRINTED
*           ON THE SYSTEM TELETYPE. 
* 
*  CALL:    (A) = ID SEGMENT ADDRESS
*         (P)   JSB ABORT 
*         (P+1) -RETURN- (REGISTERS MEANINGLESS)
* 
ABORT NOP          SET ID SEGMENT ADDRESS 
      STA *+3       IN CALL TO <LIST>.
      JSB LIST     CALL TO SET
      OCT 100       PROGRAM IN DORMANT LIST.
AB1   NOP          -HOLDS PROGRAM ID SEGMENT ADDR.
      LDA AB1      (A) = ID SEGMENT ADDRESS 
      JSB SDSCR    RELEASE ANY DISC TRACKS
      JSB DSKED    SCHEDULE ANY DISC SUSP. PROGRAMS.
      LDB AB1      (B) = ADDR. OF -TLINK- IN
      ADB .16        ID SEGMENT.
      JSB TREMP    REMOVE TIME SELECTION
      LDB AB1      SET (B) = ADDRESS OF 3-WORD
      ADB .12       PROGRAM NAME IN ID SEGMENT. 
      LDA B,I      SET
      STA ABM       PROGRAM 
      INB           NAME
      LDA B,I       IN
      STA ABM+1     MESSAGE 
      INB 
      LDA B,I 
      AND MASK5 
      IOR .40 
      STA ABM+2 
      LDA ABMA     PRINT MESSAGE: 
      JSB SYSMG     "XXXXX ABORTED" 
      JMP ABORT,I  -EXIT- 
* 
ABMA  DEF *+1 
      DEC -13 
ABM   ASC 7,XXXXX ABORTED 
      SPC 1 
.16   DEC 16
.12   DEC 12
.40   OCT 40
      HED  *  EXEC -- EQU TABLE 
* 
* ENTRY POINTS OF THE MODULES OF THE REAL-TIME
* EXECUTIVE BEGIN WITH '$' TO AVOID DUPLICATE 
* ENTRY POINT NAMES WITH USER PROGRAMS. 
* 
$ABRT EQU ABORT 
$ERMG EQU ERMSG 
$ALC  EQU .ALC. 
$RTN  EQU .RTN. 
$RQST EQU RTRQP 
$LIBR EQU LIBR
$LIBX EQU LIBX
$DREQ EQU DREQ
$DREL EQU DREL
$SDRL EQU SDSCR 
$OTRL EQU ODSCR 
$SDSK EQU DSKED 
CVT3  EQU  $CVT3
SYSMG EQU $SYMG 
LIST  EQU $LIST 
TREMP EQU $TREM 
XEQ   EQU $XEQ
      SPC 1 
A     EQU 0 
B     EQU 1 
      HED  *  EXEC -- REQUEST CODE TABLE
*  ***  REQUEST CODE TABLE  *** 
* 
*  THIS DEFINES THE RELATION FOR SYSTEM 
* REQUEST CODES AND CORRESPONDING PROCESSORS. 
* THE TABLE CONSISTS OF ONE-WORD ENTRIES IN 
* NUMERIC ORDER CORRESPONDING TO THE DEFINED
* SYSTEM REQUEST CODES. THE CONTENTS OF EACH
* ENTRY IS THE BASE PAGE LINKAGE ADDRESS OF 
* THE WORD CONTAINING THE ENTRY POINT ADDRESS 
* OF THE PROCESSOR. AN  -EXT- MUST BE USED
* WITH THE -DEF- IN DEFINING THE TABLE. 
* 
*  THE  WORD LABELLED -CODE#- CONTAINS THE
* TOTAL # OF REQUEST CODE.
* 
RQTBL DEF *        DEFINE FWA-1 OF TABLE
* 
      EXT $IORQ 
IOREQ EQU $IORQ 
      DEF IOREQ    CODE 1   I/O READ
      DEF IOREQ    CODE 2   I/O WRITE 
      DEF IOREQ    CODE 3   I/O CONTROL 
* 
      DEF DISC1    CODE 4   DISC TRACK ALLOCATION 
      DEF DISC2    CODE 5   DISC TRACK RELEASE
* 
      EXT $MPT1 
MEMP1 EQU $MPT1 
      DEF MEMP1    CODE 6   PROGRAM COMPLETION
* 
      EXT $MPT2 
MEMP2 EQU $MPT2 
      DEF MEMP2    CODE 7   OPERATOR SUSPENSION 
* 
      EXT $MPT3 
MEMP3 EQU $MPT3 
      DEF MEMP3    CODE 8   LOAD PROGRAM SEGMENT
* 
      EXT $MPT4 
MEMP4 EQU $MPT4 
      DEF MEMP4    CODE 9   SCHEDULE WITH WAIT
* 
      EXT $MPT5 
MEMP5 EQU $MPT5 
      DEF MEMP5    CODE 10  SCHEDULE PROGRAM
* 
      EXT $MPT6 
MEMP6 EQU $MPT6 
      DEF MEMP6    CODE 11  REAL TIME/DATE
* 
      EXT $MPT7 
MEMP7 EQU $MPT7 
      DEF MEMP7    CODE 12  TIME SELECTION
* 
      DEF IOREQ    CODE 13  I/O DEVICE STATUS 
* 
      DEF RQERR    CODE 14  NOT VALID 
* 
      DEF DISCA    CODE 15 GLOBAL TRACK ASSIGNMENT
      DEF DISCB    CODE 16 GLOBAL TRACK RELEASE 
* 
* 
* 
* DEFINE END OF TABLE AND # ENTRIES IN TABLE. 
*  -CODE# MUST FOLLOW TABLE ENTRIES.
*  -ADDITIONAL REQUESTS MAY BE INSERTED 
*    AT THIS POINT. 
* 
CODE# ABS *-1-RQTBL 
* 
      HED ** SYSTEM BASE PAGE COMMUNICATION AREA ** 
* 
*** SYSTEM BASE PAGE  COMMUNICATION  AREA *** 
* 
.     EQU 1650B     ESTABLISH ORIGIN OF AREA
* 
* SYSTEM TABLE DEFINITION * 
* 
EQTA  EQU .+0      FWA  OF  EQUIPMENT TABLE 
EQT#  EQU .+1       # OF EQT ENTRIES
DRT   EQU .+2      FWA  OF  DEVICE REFERENCE TABLE
LUMAX EQU .+3       # OF LOGICAL UNITS (IN DRT) 
INTBA EQU .+4      FWA  OF  INTERRUPT TABLE 
INTLG EQU .+5       # OF INTERRUPT TABLE ENTRIES
TAT   EQU .+6      FWA  OF  TRACK ASSIGNMENT TABLE
KEYWD EQU .+7      FWA  OF  KEYWORD BLOCK 
* 
* I/O MODULE/DRIVER COMMUNICATION 
* 
EQT1  EQU .+8      ADDRESSES
EQT2  EQU .+9 
EQT3  EQU .+10      OF
EQT4  EQU .+11
EQT5  EQU .+12      CURRENT 
EQT6  EQU .+13
EQT7  EQU .+14     15 - WORD
EQT8  EQU .+15
EQT9  EQU .+16      EQT 
EQT10 EQU .+17
EQT11 EQU .+18      ENTRY 
EQT12 EQU .+81
EQT13 EQU .+82
EQT14 EQU .+83
EQT15 EQU .+84
* 
CHAN  EQU .+19     CURRENT DMA CHANNEL #
TBG   EQU .+20     I/O ADDRESS OF TIME-BASE CARD
SYSTY EQU .+21     EQT ENTRY ADDRESS OF SYSTEM TTY
* 
* SYSTEM REQUEST PROCESSOR /'EXEC' COMMUNICATION *
* 
RQCNT EQU .+22     # OF REQUEST PARAMETERS -1 
RQRTN EQU .+23      RETURN POINT ADDRESS
RQP1  EQU .+24      ADDRESSES 
RQP2  EQU .+25
RQP3  EQU .+26       OF REQUEST 
RQP4  EQU .+27
RQP5  EQU .+28       PARAMETERS 
RQP6  EQU .+29
RQP7  EQU .+30       (SET FOR MAXIMUM OF
RQP8  EQU .+31        8 PARAMETERS) 
* 
* DEFINITION OF SYSTEM LISTS (QUEUES) * 
* 
DORMT EQU .+32     ADDRESS OF 'DORMANT' LIST, 
SKEDD EQU .+33      'SCHEDULE' LIST,
SUSP3 EQU .+36      'AVAILABLE MEMORY' LIST,
SUSP4 EQU .+37      'DISC ALLOCATION'  LIST,
SUSP5 EQU .+38      'OPERATOR SUSPEND' LIST 
* 
* DEFINITION OF EXECUTING PROGRAM  ID SEGMENT' *
* 
XEQT  EQU .+39     ID SEGMENT ADDR. OF CURRENT PROG.
XLINK EQU .+40       'LINKAGE'
XTEMP EQU .+41       'TEMPORARY (5-WORDS) 
XPRIO EQU .+46       'PRIORITY' WORD
XPENT EQU .+47       'PRIMARY ENTRY POINT'
XSUSP EQU .+48       'POINT OF SUSPENSION'
XA    EQU .+49       'A REGISTER' AT SUSPENSION 
XB    EQU .+50       'B REGISTER' 
XEO   EQU .+51       'E AND OVERFLOW
* 
* SYSTEM MODULE COMMUNICATION FLAGS * 
* 
OPATN EQU .+52     OPERATOR/KEYBOARD ATTENTION FLAG 
OPFLG EQU .+53     OPERATOR COMMUNICATION FLAG
SWAP  EQU .+54     RT DISC RESIDENT SWAPPING FLAG 
DUMMY EQU .+55     I/O ADDRESS OF DUMMY INT. CARD 
IDSDA EQU .+56     DISC ADDR. OF FIRST ID SEGMENT 
IDSDP EQU .+57      -POSITION WITHIN SECTOR 
* 
* DEFINITION OF MEMORY ALLOCATION BASES * 
* 
BPA1  EQU .+58     FWA R/T DISC RES. BP LINK AREA 
BPA2  EQU .+59     LWA R/T DISC RES. BP LINK AREA 
BPA3  EQU .+60     FWA BKG DISC RES. BP LINK AREA 
LBORG EQU .+61     FWA OF RESIDENT LIBRARY AREA 
RTORG EQU .+62     FWA OF REAL-TIME AREA
RTCOM EQU .+63     LENGTH OF REAL TIME COMMON AREA
RTDRA EQU .+64     FWA OF R/T DISC RESIDENT AREA
AVMEM EQU .+65     FWA OF SYSTEM AVAILABLE MEMORY 
BKORG EQU .+66     FWA OF BACKGROUND AREA 
BKCOM EQU .+67     LENGTH OF BABKGSMUND COMMON AREA 
BKDRA EQU .+68     FWA OF BKG DISC RESIDENT AREA
* 
* UTILITY PARAMETERS
* 
TATLG EQU .+69     LENGTH OF TRACK ASSIGNMENT TABLE 
TATSD EQU .+70      # OF TRACKS ON SYSTEM DISC
SECT2 EQU .+71      # SECTORS/TRACK ON LU 2 (SYSTEM)
SECT3 EQU .+72      # SECTORS/TRACK ON LU 3 (AUX.)
DSCLB EQU .+73     DISC ADDR OF RES LIB ENTRY PTS 
DSCLN EQU .+74      # OF RES LIB ENTRY POINTS 
DSCUT EQU .+75     DISC ADDR OF RELOC UTILITY PROGS 
DSCUN EQU .+76      # OF RELOC UTILITY PROGS
LGOTK EQU .+77     LOAD-N-GO: LU,STG TRACK,# OF TRKS
LGOC  EQU .+78      CURRENT LGO TRACK/SECTOR ADDRESS
SFCUN EQU .+79     SOURCE FILE LU AND DISC ADDRESS
MPTFL EQU .+80      MEMORY PROTECT ON/OFF FLAG (0/1)
FENCE EQU .+85      MEM PROTECT FENCE ADDRESS 
BKLWA EQU .+87     LWA OF MEMORY IN BACKGROUND
* 
      END EXEC
