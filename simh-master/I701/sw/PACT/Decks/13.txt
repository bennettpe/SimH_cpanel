        DEC
        NNNN OP ADDR COMMENTS
          90+ 9  979 SRCHREG  + ADD       TWO          SEARCH REGION IN TREGIONS. TR TO ERROR IF NOT FOUND 
          91+13   98          + STORE A   SRCHREX      RETURN IN ACC THE ENTRY IN TREGIONS FOUND
          92+10   92          + R ADD     *
          93+ 1   67          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
          94+ 0  376          + STOP      TREGIONS     ... TREGIONS TABLE
          95+ 0  375          + STOP      NREGIONS     ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NREGIONS 
          96+ 0  355          + STOP      FACT         ... THE VALUE TO FIND 
          97+ 4   99          + TR 0      SREGNFER
          98+ 1    0 SRCHREX  + TR        /   /
          99+10   99 SREGNFER + R ADD     *            
         100+ 1  316          + TR        ERROR
         101+ 0  991          + STOP      ERRREGNF     ERROR: REGION DO NOT EXISTS
         102+ 9  979 LOADCC   + ADD       TWO          LOAD PACTSCR INTO CARD IMAGE SO 
         103+13  122          + STORE A   CPCCEX       CURRENT PACT SOURCE CODE CAN BE PRINTED
         104+10  976          + R ADD     ZERO         COPY TO LEFT SIDE OF SOURCE CODE CARD IMAGE
         105+13  109          + STORE A   CPCC1        AT 0..46 FROM PACTSCR
         106+10  125          + R ADD     CPCC2
         107+13  108          + STORE A   CPCC 
         108-10    0 CPCC     - R ADD     /   /
         109-12    0 CPCC1    - STORE     /   /
         110+10  109          + R ADD     CPCC1
         111+ 5  979          + SUB       TWO
         112+13  114          + STORE A   CPCC1B
         113+10  976          + R ADD     ZERO
         114-12    0 CPCC1B   - STORE     /   /
         115+10  108          + R ADD     CPCC
         116+ 5  979          + SUB       TWO
         117+13  108          + STORE A   CPCC
         118+10  109          + R ADD     CPCC1
         119+ 5  980          + SUB       D4
         120+13  109          + STORE A   CPCC1
         121+ 5  124          + SUB       CPCCE
         122+ 4    0 CPCCEX   + TR 0      /   /        RETURN TO CALLER
         123+ 1  108          + TR        CPCC
         124-12   48 CPCCE    - STORE     0048         LAST LOCATION TO COPY FROM 
         125+ 8  328 CPCC2    + NOOP      PACTSRC      PACTSRC = FIRST LOCATION TO COPY FROM
         126+10  126 INIT     + R ADD     *            
         127+ 1   53          + TR        PRTNLINE     
         128+ 0  101          + STOP      0101         STRINGZ AT COL 1
         129+ 0 1006          + STOP      MSGSTART     "COMPUTE FINAL REGION LENGTH"
         130+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         131+10  131          + R ADD     *
         132+ 1   63          + TR        RWDRUM       READ TREGIONS ARRAY FROM DRUM
         133+24  128          + READ      0128         DRUM INSTR
         134+ 0    0          + STOP      0000         DRUM ADDR 
         135+ 0  374          + STOP      MAXNREGS     ADDR OF START OF TABLES
         136+ 0  402          + STOP      0402         MAXNREGS (1 HALF-WORD) + NREGIONS (1 HW) + TREGIONS (100 HW)
         137+10  137          + R ADD     *            CLEAR TABLE
         138+ 1   65          + TR        CLMEM        TREXSIZE, TREXTMP
         139+ 0  776          + STOP      TREXSIZE
         140+ 0  982          + STOP      D200         = MAXNREGS * 2
         141+10  976          + R ADD     ZERO         CLEAR CC RECORD
         142+12  352          + STORE     REGION     
         143+12  353          + STORE     STEP       
         144+12  354          + STORE     OP         
         145+12  355          + STORE     FACT       
         146+12  356          + STORE     S1         
         147+12  357          + STORE     S2         
         148+12  358          + STORE     QR         
         149+12  359          + STORE     QF         
         150-12  360          - STORE     NUM        
         151+12  362          + STORE     CLUE       
         152+12  363          + STORE     STEPN      
         153+12  364          + STORE     FACTN      
         154+12  365          + STORE     FACTREG    
         155+12  366          + STORE     S1N        
         156+12  367          + STORE     S2N        
         157+12  368          + STORE     D1N        
         158+12  369          + STORE     D2N        
         159+12  370          + STORE     NINST      
         160+12  371          + STORE     NINCR 
         161+10  372          + R ADD     CCLEN        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         162+10  476          + R ADD     TRISDUP      NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         163+10  976          + R ADD     ZERO
         164+12  987          + STORE     PASS         INIT PASS COUNT
         165+12  988          + STORE     DUPLOOP      INIT DUP LOOP ERROR FLAG (=0 -> NO LOOP)
         166+10  987 READPASS + R ADD     PASS         INCR PASS NUMBER
         167+ 9  978          + ADD       ONE
         168+12  987          + STORE     PASS
         169+10  976          + R ADD     ZERO
         170+12  989          + STORE     NPENDING     NUMBER OF PENDING TO COMPUTE REGIONS=0
         171+12  990          + STORE     NCOMP        NUMBER OF COMPUTED REGIONS=0
         172+12  983          + STORE     IREG         REGION NUMBER BEING PROCESSED
         173+28  257          + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE)
         174+10  976 READREG  + R ADD     ZERO         INIT READ REGION
         175+12  985          + STORE     STEPCNT      STEP COUNT FOR REGION
         176+12  986          + STORE     EQTMPCNT     TEMP VARS NEEDED FOR RESULT OF STEP IN THIS REGION 
         177+10  983          + R ADD     IREG         SELECT NEXT REGION
         178+ 9  978          + ADD       ONE
         179+12  983          + STORE     IREG
         180+10  180 READSTEP + R ADD     *            READ PACT USER PROGRAM SOURCE CODE FROM TAPE IN
         181+ 1   61          + TR        RDTAPE
         182+ 0  257          + STOP      TAPEIN
         183+ 0  328          + STOP      CCODE        BUF TO READ IN FROM TAPE
         184+ 2  285          + TR OV     EOF          TR IF END OF FILE
         185+10  354          + R ADD     OP
         186+ 4  243          + TR 0      EOR          TR IF END OF REGION
         187+10  187          + R ADD     *            LOAD PACTSCR INTO CARD IMAGE SO 
         188+ 1  102          + TR        LOADCC       CURRENT PACT SOURCE CODE CAN BE PRINTED
         189+10  354          + R ADD     OP
         190+ 5  981          + SUB       OPDUP
         191+ 4  199          + TR 0      CHKDUP       OP="DUP REGION" -> TR TO CHECK REGION EXISTS, MARK REGION AS DUPLICATED
         192+ 8    0 NEXT     + NOOP      0000         CONTINUE WITH NEXT STEP RECORD
         193+30   74          + SENSE     0074         SENSE SWITCH 6
         194+ 1  197          + TR        ENDLOG1      TR IF NO LOG SELECTED
         195+10  195          + R ADD     *            PRINT STEP JUST PROCESSED
         196+ 1   59          + TR        PRINTCRD
         197+ 8    0 ENDLOG1  + NOOP      0000 
         198+ 1  180          + TR        READSTEP
         199+10  985 CHKDUP   + R ADD     STEPCNT
         200+ 3  210          + TR +      CHKDUP1      STEP COUNT IS VALID, TR TO PROCEED
         201+ 1  192          + TR        NEXT         THE STEP COUNT OF THIS REGION IS NO VALID, TR TO NEXT TO SKIP STEPS 
         202+10  988 CHKDUNOK + R ADD     DUPLOOP      CHECK FLAG INDICATING INVALID REGION ARE IN FACT UNRESOLVABLE DUP LOOPS.
         203+ 4  207          + TR 0      CHKNOK2      NO DUP LOOP, JUST THE STEP COUNT OF THIS REGION IS NO VALID YET, TR TO INVALIDATE 
         204+10  204          + R ADD     *            THE DUPLICATED REGION IS UNRESOLVABLE BECAUSE IT FORMS A DUP-LOOP. SIGNAL THE ERROR
         205+ 1  316          + TR        ERROR        TE DUP INSTR WILL BE IGNORED, SO NO NEED TO INVALIDATE STEPCNT
         206+ 0  998          + STOP      ERRDUPLO     ERROR: LOOP IN DUP REGIONS 
         207+ 6  978 CHKNOK2  + R SUB     ONE          INVALIDATE SIZE OF THIS REGION BY SETTING STEPCNT=-1
         208+12  985          + STORE     STEPCNT
         209+ 1  192          + TR        NEXT         THE STEP COUNT OF THIS REGION IS NO VALID, TR TO NEXT TO SKIP STEPS 
         210+10  210 CHKDUP1  + R ADD     *            SEARCH REGION STATED IN FACTOR VAR = THE DUPLICATED REGION NAME
         211+ 1   90          + TR        SRCHREG      ERROR IF REGION DO NOT EXISTS IN TREGS TABLE
         212+13  984          + STORE A   IREGDUP      STORE THE DUPLICATED REGION INDEX NUMBER
         213+10  213          + R ADD     *            
         214+ 1   71          + TR        READTBL
         215+ 0  776          + STOP      TREXSIZE     ... VAL=TREXSIZE[IREGDUP] GET CURRENT EXTENDED SIZE FOR DUPLICATED REGION
         216+ 0  984          + STOP      IREGDUP
         217+ 0  373          + STOP      VAL
         218+30   74          + SENSE     0074         SENSE SWITCH 6
         219+ 1  229          + TR        ENDLOG1A     TR IF NO LOG SELECTED
         220+10  220          + R ADD     *
         221+ 1   55          + TR        PRTSTR
         222+ 0 1021          + STOP      MSGSTP       "STEPS" = NUMBER OF STEPS OF DUPLICATED REGION   
         223+ 0   40          + STOP      0040         COL 40
         224+15  373          + LOAD MQ   VAL
         225+10  225          + R ADD     *
         226+ 1   57          + TR        PRTINT
         227+ 0    4          + STOP      0004         4-DIGITS NUM
         228+ 0   45          + STOP      0045         COL 45
         229+ 8    0 ENDLOG1A + NOOP      0000
         230+10  373          + R ADD     VAL
         231+ 4  202          + TR 0      CHKDUNOK     THE FINAL (EXPANDED) SIZE OF REGION TO BE DUPLICATED HERE IS NOT KNOW YET -> TR TO INVALIDATE THE COUNT ON THIS REGION
         232+ 9  985          + ADD       STEPCNT      THE FINAL (EXPANDED) SIZE OF REGION TO BE DUPLICATED HERE IS FULLY KNOW. ADD IT
         233+ 5  978          + SUB       ONE          TO THE SIZE OF CURRENT REGION. MUST SUBSTRACT ONE BECAUSE THE DUP INSTR IS REPLACED
         234+12  985          + STORE     STEPCNT      WITH FIRST INSTR OF DUPLICATED REGION
         235+10  235          + R ADD     *            
         236+ 1   71          + TR        READTBL
         237+ 0  876          + STOP      TREXTMP      ... VAL=TREXTMP[IREGDUP] GET CURRENT NUM OF TEMP VARS FOR DUPLICATED REGION
         238+ 0  984          + STOP      IREGDUP
         239+ 0  373          + STOP      VAL
         240+ 9  986          + ADD       EQTMPCNT     ADD THE NUMBER OF TEMP VARS NEEDED BY DUPLICATED REGION TO THE TOTAL FOR CURRENT REGION
         241+12  986          + STORE     EQTMPCNT
         242+ 1  192          + TR        NEXT         TR TO NEXT TO CONTINUE PROCESSING STEPS 
         243+ 8    0 EOR      + NOOP      0000         END OF REGION  
         244+10  985          + R ADD     STEPCNT
         245+ 3  250          + TR +      EOR1         TR IF STEP COUNT FOR THIS REGION IS VALID
         246+10  989          + R ADD     NPENDING     STEP COUNT NOT VALID YET -> INCR THE NUMBER
         247+ 9  978          + ADD       ONE          OF PENDING REGIONS. WILL NEED ANOTHER PASS TO RESOLVE THIS REGION
         248+12  989          + STORE     NPENDING
         249+ 1  174          + TR        READREG      PROCEED WITH NEXT REGION
         250+10  250 EOR1     + R ADD     *            STEP COUNT IS VALID. CHECK IF MUST UPDATE TABLE
         251+ 1   71          + TR        READTBL
         252+ 0  776          + STOP      TREXSIZE     ... VAL=TREXSIZE[IREG] GET EXTENDED SIZE FOR CURRENT REGION
         253+ 0  983          + STOP      IREG
         254+ 0  373          + STOP      VAL
         255+ 4  257          + TR 0      EOR2         SIZE OF THIS REGION NOT VALID YET -> PROCEED TO UPATE THE REGION WITH STEPCOUNT
         256+ 1  174          + TR        READREG      THIS REGION ALREADY COMPUTED -> PROCEED WITH NEXT REGION
         257+10  257 EOR2     + R ADD     *            
         258+ 1   71          + TR        READTBL
         259+ 0  576          + STOP      TRSIZE       ... VAL=TRSIZE[IREG] GET SIZE FOR CURRENT REGION
         260+ 0  983          + STOP      IREG
         261+ 0  373          + STOP      VAL
         262+ 9  985          + ADD       STEPCNT      VAL=STEPCOUNT+VAL    ADD STEP COUNT OF INCLUDED REGIONS
         263+12  373          + STORE     VAL
         264+10  264          + R ADD     *            SAVE STEP COUNT FOR REGION
         265+ 1   69          + TR        EQTBL
         266+ 0  776          + STOP      TREXSIZE     ... TREXSIZE[IREG]=VAL -> TREXSIZE[IREG]=TRSIZE[IREG] + STEPCNT
         267+ 0  983          + STOP      IREG         
         268+ 0  373          + STOP      VAL
         269+10  269          + R ADD     *            
         270+ 1   71          + TR        READTBL
         271+ 0  676          + STOP      TREQTMP      ... VAL=TREQTMP[IREG] GET NUMBER OF TEMP VARS NEEDE IN CURRENT REGION
         272+ 0  983          + STOP      IREG
         273+ 0  373          + STOP      VAL
         274+ 9  986          + ADD       EQTMPCNT     VAL=EQ TEMP COUNT+VAL
         275+12  373          + STORE     VAL
         276+10  276          + R ADD     *            SAVE COUNT FOR REGION
         277+ 1   69          + TR        EQTBL
         278+ 0  876          + STOP      TREXTMP      ... TREXTMP[IREG]=VAL -> TREXTMP[IREG]=TREQTMP[IREG] + EQTMPCNT
         279+ 0  983          + STOP      IREG         
         280+ 0  373          + STOP      VAL
         281+10  990          + R ADD     NCOMP        INCR THE NUMBER OF COMPUTED REGIONS
         282+ 9  978          + ADD       ONE
         283+12  990          + STORE     NCOMP
         284+ 1  174          + TR        READREG      PROCEED WITH NEXT REGION
         285+ 8    0 EOF      + NOOP      0000         END OF FILE
         286+30   74          + SENSE     0074         SENSE SWITCH 6
         287+ 1  295          + TR        ENDLOG1B     TR IF NO LOG SELECTED
         288+10  288          + R ADD     *
         289+ 1   53          + TR        PRTNLINE     
         290+ 0  101          + STOP      0101         STRINGZ AT COL 1
         291+ 0 1016          + STOP      MSGDONE      "END OF PASS"
         292+ 0  210          + STOP      0210         INT AT COL 10
         293+ 0  987          + STOP      PASS         CURRENT NUMBER OF PASS 
         294+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         295+ 8    0 ENDLOG1B + NOOP      0000
         296+10  989          + R ADD     NPENDING     GET NUMBER OF REGIONS PENDING TO BE RESOLVED
         297+ 4  304          + TR 0      EOPROC       IF NONE, TR TO END OF PROCESSING
         298+10  990          + R ADD     NCOMP        GET NUMBER OF REGIONS COMPUTED IN THIS PASS
         299+ 5  978          + SUB       ONE          IF SOME COMPUTED, TR TO START A NEW PASS TO APPLY 
         300+ 3  166          + TR +      READPASS     THE NEW COMPUTED REGIONS TO UNRESOLVED YET REGIONS
         301+10  978          + R ADD     ONE          HERE, THE PASS JUST DONE WAS NOT ABLE TO COMPUTE THE PENDING REGIONS
         302+12  988          + STORE     DUPLOOP      THIS IS BECAUSE THERE IS AN UNRESOLVABLE LOOP IN THE DUP'ES REGIONS
         303+ 3  166          + TR +      READPASS     SET DUPLOOP=1 AND DO A LAST PASS SIGNALING THE OFFENING DUP TO USER
         304+ 8    0 EOPROC   + NOOP      0000         END OF PROCESSING. SAVE FINAL SIZE OF REGIONS TO DRUM
         305+10  305          + R ADD     *
         306+ 1   63          + TR        RWDRUM       SAVE NREGIONS, TREGIONS, TRISDUP, TRSIZE AND TREQTMP TO DRUM
         307+26  128          + WRITE     0128         DRUM INSTR
         308+ 0    0          + STOP      0000         DRUM ADDR 
         309+ 0  374          + STOP      MAXNREGS     ADDR OF START OF TABLES
         310+ 0  602          + STOP      0602         MAXNREGS (1 HALF-WORD) + NREGIONS (1 HW) + TREGIONS (100 HW)
         311+28  257          + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE)
         312+10  312          + R ADD     *
         313+ 1   51          + TR        CHAIN        IF SW2 IS ON, A +STOP 4095 IS EXECUTED 
         314+ 0  256          + STOP      PACTCOMP     CHAIN TO NEXT STAGE IN PACT COMPILER TAPE
         315+ 0 4095          + STOP      4095
         316+ 9  979 ERROR    + ADD       TWO
         317+13  318          + STORE A   ERRP1
         318+10    0 ERRP1    + R ADD     /   /
         319+13  325          + STORE A   ERRSTRZ      SAVE ADDR OF ERROR TXT MESSAGE
         320+10  320          + R ADD     *            PRINT USER PROGRAM SOURCE CODE CARD JUST PROCESSED
         321+ 1   59          + TR        PRINTCRD
         322+10  322          + R ADD     *
         323+ 1   53          + TR        PRTNLINE     
         324+ 0  101          + STOP      0101         STRINGZ AT COL 1
         325+ 0    0 ERRSTRZ  + STOP      /   /        ERROR MESSAGE
         326+ 0    0          + STOP      0000         END OF LINE
         327+ 0  180          + STOP      READSTEP     IF USER PRESS STARTS, PROGRAM RESUMES PROCESSING NEXT SOURCE CODE STEP 
         328+     0  PACTSRC    RES       24           CARD IMAGE OF PACT SOURCE CODE CARD (12 FULL WORDS)
         352+     0  REGION     DEF       0
         353+     0  STEP       DEF       0            REGION = ALFA (<0)
         354+     0  OP         DEF       0            STEP   = INT (>0)
         355+     0  FACT       DEF       0            OP     = 0..43    =0 MEANS END OF REGION
         356+     0  S1         DEF       0            FACT   < 0 -> FACTOR IS AN ALFA SYMBOL (VAR, REGION, ...) 
         357+     0  S2         DEF       0            FACT = 0 -> BLANK FACTOR
         358+     0  QR         DEF       0            FACT = 0..9999 -> DESTINATION STEP FOR TRANSFER/RESULT OF STEP
         359+     0  QF         DEF       0            CLUE = -, R OR N
         360+     0  NUM        DEF       0            
         361+     0             DEF       0            S1/S2 = 0 -> BLANK, >0 -> INTEGER, <0 -> ALFA 
         362+     0  CLUE       DEF       0
         363+     0  STEPN      DEF       0            QR = +/- INTEGER OR BLANK. 
         364+     0  FACTN      DEF       0            QF = SET IF THERE IS AN INTEGER FACTOR/NUMBER IN CARD
         365+     0  FACTREG    DEF       0
         366+     0  S1N        DEF       0
         367+     0  S2N        DEF       0
         368+     0  D1N        DEF       0
         369+     0  D2N        DEF       0
         370+     0  NINST      DEF       0
         371+     0  NINCR      DEF       0
         372+    44  CCLEN      DEF       0044         LENGTH OF COMPACT CODE RECORD 
         373+     0  VAL        DEF       0            TEMP VAR (HERE TO MAKE TABLES START AT EVEN LOCATION)
         374+   100  MAXNREGS   DEF       100          MAX 100 REGIONS CAN DE DEFINED IN ONE PROGRAM 
         375+     0  NREGIONS   DEF       0            NUMBER OF REGIONS DEFINED
         376+     0  TREGIONS   RES       100          EACH ENTRY IN TABLE IS 1 HALF-WORD. HAS THE NAME (ALFA) OF REGION
         476+     0  TRISDUP    RES       100          =1 IF THIS REGION IS REFERENCED IN A DUP INSTR ELSEWHERE (IE THIS REGION IS DUPLICATED)
         576+     0  TRSIZE     RES       100          NUMBER OF STEPS OF REGION (NOT COUNTING EOR)
         676+     0  TREQTMP    RES       100          NUMBER OF NEEDED TEMP VARS IN REGION (=NUM OF STEPS REFERENCED AS RESULT OF STEP)
         776+     0  TREXSIZE   RES       100          EXPANDED NUMBER OF STEPS OF REGION (NOT COUNTING EOR)
         876+     0  TREXTMP    RES       100          EXPANDED NUMBER OF NEEDED TEMP VARS IN REGION (=NUM OF STEPS REFERENCED AS RESULT OF STEP)
         976+     0  ZERO       DEF       0
         977+     0             DEF       0
         978+     1  ONE        DEF       1
         979+     2  TWO        DEF       2
         980+     4  D4         DEF       4
         981+    22  D22        DEF       22
         982+   200  D200       DEF       200
         983+     0  IREG       DEF       0            REGION NUMBER BEING PROCESSED (INDEX IN TREGIONS, IREG=1 -> FIRST ENTRY IN TREGIONS TABLE)
         984+     0  IREGDUP    DEF       0
         985+     0  STEPCNT    DEF       0            STEP COUNT: TOTAL NUMBER OF STEPS IN REGION (NOT COUNTING EOR RECORD)
         986+     0  EQTMPCNT   DEF       0            COUNT OF DIFFERENT STEPS REFERENCED AS "RESULT OF STEP" 
         987+     0  PASS       DEF       0            NUMBER OF CURRENT PASS
         988+     0  DUPLOOP    DEF       0            =1 IF HIT A DUP REGION LOOP 
         989+     0  NPENDING   DEF       0            NUMBER OF PENDING TO COMPUTE REGIONS=0
         990+     0  NCOMP      DEF       0            NUMBER OF COMPUTED REGIONS=0
         991- 69955  ERRREGNF   TXT       "REGION NOT FOUND",0
         992- 49706  
         993-  1275  
         994- 73746  
         995- 63818  
         996- 36864  
         997+     0  
         998- 56619  ERRDUPLO   TXT       "LOOP IN DUP REGIONS",0
         999- 64533  
        1000- 59920  
        1001- 77376  
        1002- 69955  
        1003- 49706  
        1004- 71424  
        1005+     0  
        1006- 35881  MSGSTART   TXT       "COMPUTE FINAL REGION SIZE",0
        1007- 66128  
        1008- 39186  
        1009- 49645  
        1010- 55326  
        1011- 40101  
        1012- 63456  
        1013- 72470  
        1014- 39168  
        1015+     0  
        1016- 40432  MSGDONE    TXT       "END OF PASS",0
        1017-  1314  
        1018-  1357  
        1019- 72912  
        1020+     0  
        1021- 72977  MSGSTP     TXT       "STEPS",0
        1022- 66000  
        1023+     0  
        1024+15 1038 CLRBUF   + LOAD MQ   IOCL
        1025+14 1043          + STORE MQ  BUFIO
        1026+15 1064          + LOAD MQ   IOSTORE         
        1027+ 1 1035          + TR        INIT2
        1028+15 1060 READCRD  + LOAD MQ   IORDCRD
        1029+ 1 1033          + TR        INIT1
        1030+15 1062 WRITECRD + LOAD MQ   IOWRCRD
        1031+ 1 1033          + TR        INIT1
        1032+15 1063 PRINTCRD + LOAD MQ   IOPRCRD
        1033+14 1043 INIT1    + STORE MQ  BUFIO
        1034+15 1061          + LOAD MQ   IOCOPY         
        1035+14 1044 INIT2    + STORE MQ  BUFROW
        1036+ 9 1070          + ADD       TWO          
        1037+13 1059          + STORE A   EXIT
        1038+10 1066 IOCL     + R ADD     ZERO         RESET TO INITIAL COPY LOOP ADDRESS     
        1039+13 1044          + STORE A   BUFROW       FOR BUFFER
        1040+10 1044          + R ADD     BUFROW       X .*echo Print
        1041+ 5 1071          + SUB       D48          X 
        1042+12 1068          + STORE     ENDLP        X LOOP END VALUE
        1043- 0    0   BUFIO  - STOP      /   /        READ OR WRITE
        1044-31    0   BUFROW - COPY      /   /        COPY WORD TO/FROM PRINTER/CARDREADER
        1045+ 1 1049          + TR        BUFOK2       NORMAL PROCESSING 
        1046+ 1 1056          + TR        EODECK       FOR COPY READING END OF REG (=END OF DECK BEING READ)
        1047+ 6 1070          + R SUB     TWO          END OF FILE -> NO CARD TO READ -> STOP with Acc=-2
        1048+ 0 1043          + STOP      BUFIO        ON PRESSING START RETRY CARD READ
        1049+10 1044   BUFOK2 + R ADD     BUFROW       X
        1050+ 5 1070          + SUB       TWO          INCR BUF ADDR
        1051+13 1044          + STORE A   BUFROW       X
        1052+ 5 1068          + SUB       ENDLP        CHECK FOR END
        1053+ 4 1058          + TR 0      ENDIO
        1054+10 1066          + R ADD     ZERO         CLEAR ACC IN CASE WE ARE CLEANING THE BUFFER
        1055+ 1 1044          + TR        BUFROW
        1056+10 1069 EODECK   + R ADD     ONE          SET OV FLAG TO SIGNAL END OF DECK CONDITION
        1057+22   36          + A LEFT    36
        1058+26 2052 ENDIO    + WRITE     2052         END OF I/O: INSURE THAT MQ NOT IN USE            
        1059+ 1    0 EXIT     + TR        /   /
        1060+24 2048 IORDCRD  + READ      2048         PREPARE TO READ FROM CARD READER
        1061-31    0 IOCOPY   - COPY      /   /   
        1062+26 1024 IOWRCRD  + WRITE     1024         PREPARE TO PUNCH CARD 
        1063+26  512 IOPRCRD  + WRITE     0512         PREPARE WRITE PRTBUF ON PRINTER
        1064-12    0 IOSTORE  - STORE     /   /        CLEAR BUFFER
        1065+     0             ORG       EVEN           
        1066+     0  ZERO       DEF       0            
        1067+     0             DEF       0            
        1068+     0  ENDLP      DEF       0            LOOP END VALUE
        1069+     1  ONE        DEF       1
        1070+     2  TWO        DEF       2
        1071+    48  D48        DEF       48
        1072+ 9 1343 PRTPARM2 + ADD       TWO          GET 2 PARAMS: LEN AND COL (EITHER VALUE OR VAR ADDR)
        1073+13 1092          + STORE A   PRTPRMEX
        1074+10 1082          + R ADD     PRTP1
        1075+ 9 1343          + ADD       TWO          PRINT PACKED TEXT FROM FULL-WORD VALUE IN MQ REGISTER 
        1076+13 1082          + STORE A   PRTP1        STORE ADDR OF FIRST PARAM (LEN)
        1077+ 9 1342          + ADD       ONE
        1078+13 1084          + STORE A   PRTP2        STORE ADDR OF SECOND PARAM (COL)
        1079+ 9 1342          + ADD       ONE
        1080+13 1159          + STORE A   EXIT
        1081-14 1332          - STORE MQ  NUM          SAVE VALUE TO PRINT PARAM MQ (NUM IS ALIASED TO TXT)
        1082+10    0   PRTP1  + R ADD     /   /        GET LEN: NUMBER OF CHARS TO PRINT (1..6)
        1083+12 1336          + STORE     LEN
        1084+10    0   PRTP2  + R ADD     /   /        GET COLUMN PARAM 1..72
        1085+ 3 1088          + TR +      PRTP4
        1086+13 1087          + STORE A   PRTP3        COL<0 -> INTERPRET COL AS LOC(COL) = ADDR OF COL VAR
        1087+10    0   PRTP3  + R ADD     /   /        READ VAR COL PASED AS PARAM
        1088+ 4 1159   PRTP4  + TR 0      EXIT         COL=0 -> EXIT
        1089+ 3 1091          + TR +      PRTP5
        1090+ 1 1159          + TR        EXIT         COL<0 -> EXIT
        1091+12 1142   PRTP5  + STORE     COL
        1092+ 1    0 PRTPRMEX + TR        /   /        RETURN TO CALLER
        1093+13 1082 PRTSTR   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        1094+10 1094          + R ADD     *            FOR PRINT STRINGZ FROM MEM
        1095+ 1 1072          + TR        PRTPARM2
        1096+12 1106          + STORE     COLSZ
        1097+10 1336          + R ADD     LEN          LEN IS IN FACT THE LOCATION WHERE THE STRING STARTS
        1098+13 1101          + STORE A   STRZAD
        1099+10 1159          + R ADD     EXIT
        1100+13 1114          + STORE A   STRZEX
        1101+10    0 STRZAD   + R ADD     /   /        GET HALF-WORD WITH NEXT 3 CHARS TO PRINT
        1102+ 4 1114          + TR 0      STRZEX       IF +0 -> END OF STRING (-0 DOES NOT TERMINATES THE STRING)
        1103+21   35          + L RIGHT   0035         MQ=3-CHARS TO PRINT
        1104+10 1104          + R ADD     *            
        1105+ 1 1116          + TR        PRTALF       PRINT 3 CHARS
        1106+ 0    0 COLSZ    + STOP      0000         COL 
        1107+10 1101 STRZ1    + R ADD     STRZAD       INCR STRING ADDRESS
        1108+ 9 1342          + ADD       ONE
        1109+13 1101          + STORE A   STRZAD
        1110+10 1106          + R ADD     COLSZ        INCR COLUMN
        1111+ 9 1344          + ADD       D3
        1112+13 1106          + STORE A   COLSZ
        1113+ 1 1101          + TR        STRZAD
        1114+ 3    0 STRZEX   + TR +      /   /        IF ZERO -> END OF STRING
        1115+ 1 1107          + TR        STRZ1
        1116+ 9 1343 PRTALF   + ADD       TWO          PRINT 3-PACKED CHARS IN MQ REGISTER 
        1117+14 1338          + STORE MQ  TXT          SAVE TEXT TO PRINT (IN LEFT HALF WORD)
        1118+13 1121          + STORE A   PRTAP2       STORE ADDR OF PARAM (COL)
        1119+ 9 1342          + ADD       ONE
        1120+13 1159          + STORE A   EXIT
        1121+10    0   PRTAP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        1122+ 3 1125          + TR +      PRTAP4
        1123+13 1124          + STORE A   PRTAP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        1124+10    0   PRTAP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        1125+12 1142   PRTAP4 + STORE     COL
        1126+10 1344          + R ADD     D3
        1127+12 1336          + STORE     LEN
        1128+10 1326 PRT1     + R ADD     ZERO         UNPACK LEFTMOST CHAR 
        1129+11 1338          + ADD AB    TXT          GET TEXT DISCARD SIGN
        1130+21   35          + L RIGHT   0035         MQ=Acc
        1131+10 1326          + R ADD     ZERO
        1132+18 1351          + DIV       D48X48
        1133+12 1338          + STORE     TXT          remainder=char to print, mq=c2 * 48 + c3 in right half-word
        1134+10 1326          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        1135+20   18          + L LEFT    0018         put c2 and c3 in left half-word of MQ to be saved in CHAR half word
        1136+14 1337          + STORE MQ  CHAR         CHAR TO PRINT
        1137+10 1337          + R ADD     CHAR 
        1138+ 4 1143          + TR 0      NXTCHR       IF BLANK PROCEED TO NEXT COL
        1139+21   35          + L RIGHT   0035         MQ=CHAR TO PRINT
        1140+10 1140          + R ADD     *            PRINT CHAR
        1141+ 1 1236          + TR        PRTCHR
        1142+ 0    0 COL      + STOP      0000         COL: COLUMN NUMBER TO PRINT (1..72)
        1143+10 1336 NXTCHR   + R ADD     LEN          DECR LEN COUNT
        1144+ 5 1342          + SUB       ONE
        1145+12 1336          + STORE     LEN
        1146+ 4 1159          + TR 0      EXIT         IF NO MORE CHARS TO PRINT EXIT
        1147+10 1142          + R ADD     COL          INCR COL POSITION
        1148+ 9 1342          + ADD       ONE
        1149+12 1142          + STORE     COL
        1150+ 5 1350          + SUB       D72          IF COL > 72 RETURN TO CALLER
        1151+ 4 1153          + TR 0      GNXTCHR      ELSE PROCEED WITH NEXT CHAR
        1152+ 3 1159          + TR +      EXIT
        1153+10 1326 GNXTCHR  + R ADD     ZERO         GET NEXT CHAR 
        1154+15 1338          + LOAD MQ   TXT
        1155+16 1349          + MPY       D48
        1156+22   17          + A LEFT    0017         GET RESULT IN LEFT HALF-WORD OF ACC
        1157+12 1338          + STORE     TXT
        1158+ 1 1128          + TR        PRT1         PROCEED TO PRINT CHAR
        1159+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        1160+13 1082 PRTOCT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        1161+10 1161          + R ADD     *            FOR PRINT OCTIONARY VALUE
        1162+ 1 1072          + TR        PRTPARM2
        1163+10 1336          + R ADD     LEN          LEN = OCTAL DIGITS TO PRINT
        1164+ 9 1142          + ADD       COL
        1165+ 5 1342          + SUB       ONE
        1166+12 1178          + STORE     COLN         COL POINTS TO LEAST SIGNIFICANT DIGIT
        1167+10 1332 PRTIOCG  + R ADD     NUM          GENERATE OCTINARY DIGIT
        1168+15 1326          + LOAD MQ   ZERO         CLEAR MQ
        1169+21   21          + L RIGHT   0021         3 LSB BITS OF LEFT HALF-WORD OF ACC TO MQ
        1170+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 3 BIT)
        1171+12 1332          + STORE     NUM          SAVE BACK NUM WITH RIGHTMOST OCTIONARY DIGIY EXTRACTED (NUM'=NUM/8)
        1172+10 1326          + R ADD     ZERO
        1173+20   21          + L LEFT    0021         LEFT HALF-WORD OF ACC IS NOW RIGHTMOST OCTINARY DIGIT EXTRACTED FROM NUM 
        1174+ 4 1192          + TR 0      PRTIOZ       TR IF THIS DIGIT IS ZERO TO PRINT A '0' (BASE48 CODE = 10) INSTEAD OF A BLANK (BASE48 CODE = 0)
        1175+21   35          + L RIGHT   0035         PUT DIGIT 1..9 TO PRINT IN MQ
        1176+10 1176 PRTOCTD  + R ADD     *            PRINT OCTINARY DIGIT
        1177+ 1 1236          + TR        PRTCHR
        1178+ 0    0 COLN     + STOP      0000
        1179+10 1178          + R ADD     COLN        DECR COL NUMBER TO PRINT NEXT DIGIT
        1180+ 5 1342          + SUB       ONE
        1181+12 1178          + STORE     COLN
        1182+10 1336          + R ADD     LEN          DECR COL NUMBER TO PRINT NEXT DIGIT
        1183+ 5 1342          + SUB       ONE
        1184+ 4 1159          + TR 0      EXIT         PRINTED LEN OCTINARY DIGITS -> EXIT
        1185+12 1336          + STORE     LEN
        1186+10 1332          + R ADD     NUM          IF NUM < 0, ADD SIGN BIT TO LEFTMOST DIGIT
        1187+ 3 1167          + TR +      PRTIOCG
        1188+10 1352          + R ADD     OCT04K       
        1189+ 5 1332          + SUB       NUM
        1190+12 1332          + STORE     NUM
        1191+ 1 1167          + TR        PRTIOCG
        1192+15 1345   PRTIOZ + LOAD MQ   D10          ACC=BASE48 CODE FOR '0'
        1193+ 1 1176          + TR        PRTOCTD      TR TO PRINT IT
        1194+13 1082 PRTINT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        1195+10 1195          + R ADD     *            FOR PRINT OCTIONARY VALUE
        1196+ 1 1072          + TR        PRTPARM2
        1197+10 1142          + R ADD     COL          PRINT DECIMAL NUMBER. VALUE OF LEN = DIGITS TO PRINT, NOT INCLUDING SIGN
        1198+ 9 1336          + ADD       LEN
        1199+ 5 1342          + SUB       ONE          
        1200+12 1221          + STORE     COLNI        COL POINTS TO END OF NUMBER
        1201+10 1326          + R ADD     ZERO
        1202+12 1335          + STORE     SGN          SIGN IS POSITIVE
        1203+10 1332          + R ADD     NUM
        1204+ 3 1209          + TR +      PRTINTG
        1205+ 6 1332          + R SUB     NUM          NUM IS NEGATIVE. CONVERT TO POSITIVE
        1206+12 1332          + STORE     NUM          AND SET SGN=1
        1207+10 1342          + R ADD     ONE
        1208+12 1335          + STORE     SGN          
        1209+10 1332 PRTINTG  + R ADD     NUM          GENERATE DECIMAL DIGIT
        1210+21   35          + L RIGHT   0035         MQ=Acc
        1211+10 1326          + R ADD     ZERO
        1212+18 1345          + DIV       D10
        1213+ 4 1234          + TR 0      PRTINZ
        1214+12 1337 PRTINTG2 + STORE     CHAR         acc=remainder=digit to print, mq=num/10
        1215+10 1326          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        1216+20   18          + L LEFT    0018         digit in left half-word of MQ to be saved in CHAR half word
        1217+14 1332          + STORE MQ  NUM 
        1218+15 1337          + LOAD MQ   CHAR 
        1219+10 1219 PRTINTD  + R ADD     *            PRINT DECIMAL DIGIT
        1220+ 1 1236          + TR        PRTCHR
        1221+ 0    0 COLNI    + STOP      0000
        1222+10 1221          + R ADD     COLNI        DECR COL NUMBER TO PRINT NEXT DIGIT
        1223+ 5 1342          + SUB       ONE
        1224+12 1221          + STORE     COLNI
        1225+10 1332          + R ADD     NUM          DO NOT CARE ABOUT LEN, JUST CHECK IF NUM=0 
        1226+ 4 1228          + TR 0      PRTINS       (SO NO MORE DIGITS REMAINS TO BE PRINTED)
        1227+ 1 1209          + TR        PRTINTG      NUM NOT FINISHED, PROCEED WITH NEXT DIGIT
        1228+10 1335 PRTINS   + R ADD     SGN
        1229+ 4 1159          + TR 0      EXIT         NO SIGN -> NUM FINISHED
        1230+10 1326          + R ADD     ZERO
        1231+12 1335          + STORE     SGN          CLEAR SGN FLAG
        1232+15 1346          + LOAD MQ   D11          BASE48 CODE FOR '-' (MINUS) CHAR
        1233+ 1 1219          + TR        PRTINTD      GO TO PRINT IT
        1234+10 1345   PRTINZ + R ADD     D10          ACC=BASE48 CODE FOR '0'
        1235+ 1 1214          + TR        PRTINTG2     TR TO PRINT IT
        1236+ 9 1343 PRTCHR   + ADD       TWO          PRINT CHAR IN MQ REGISTER 
        1237+14 1337          + STORE MQ  CHAR         SAVE CHAR TO PRINT (IN LEFT HALF WORD)
        1238+13 1242          + STORE A   PRTCP2       STORE ADDR OF PARAM (COL)
        1239+ 9 1342          + ADD       ONE
        1240+13 1320          + STORE A   PRTCEX
        1241+ 2 1242          + TR OV     PRTCP2       CLEAR OV JUST IN CASE
        1242+10    0   PRTCP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        1243+ 3 1246          + TR +      PRTCP4
        1244+13 1245          + STORE A   PRTCP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        1245+10    0   PRTCP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        1246+ 5 1342   PRTCP4 + SUB       ONE
        1247+12 1340          + STORE     N            N=COL-1 -> IN RANGE 0..71
        1248+ 3 1250          + TR +      PRTSA        IF N >= 0 PROCEED WITH BASE BUFFER ADDR CALCULATION
        1249+ 1 1320          + TR        PRTCEX       IF N<0 EXIT
        1250+10 1326    PRTSA + R ADD     ZERO         CARD BUFFER USES LOCATION 0..47
        1251+13 1339          + STORE A   PRTROWAD     DETERMINE ADDRESS OF LOWER ROW TO PRINT
        1252+10 1340          + R ADD     N
        1253+ 5 1348          + SUB       D36
        1254+ 3 1256          + TR +      PRTC0
        1255+ 1 1262          + TR        PRTC1
        1256+12 1340    PRTC0 + STORE     N            COL NOW 0..35 
        1257+ 5 1348          + SUB       D36
        1258+ 3 1320          + TR +      PRTCEX       IF COL >= 36 (IE COL PASSED AS PARAM > 72) THEN EXIT
        1259+10 1339          + R ADD     PRTROWAD
        1260+ 9 1343          + ADD       TWO
        1261+13 1339          + STORE A   PRTROWAD     SET BASE BUFFER ADDR 
        1262+10 1342    PRTC1 + R ADD     ONE          DETERMINE MASKCOL WITH MASK TO SET IN CARD BUFFER
        1263+21   53          + L RIGHT   53           SET RIGHTMOST BIT OF MQ TO 1 (SHIFT 35+18=53)
        1264+10 1347          + R ADD     D35
        1265+ 5 1340          + SUB       N
        1266+13 1268          + STORE A   PRTC2
        1267+10 1326          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW
        1268+20    0    PRTC2 + L LEFT    /   /        SHIFT MQ LEFT N PLACES
        1269+ 4 1272          + TR 0      PRTC3        IF ACC STILL ZERO -> MASKCOL VALID
        1270+ 6 1342          + R SUB     ONE          ACC NOT ZERO -> SHOULD GENERATE -0 TO SET SIGN BIT ON
        1271+21   72          + L RIGHT   0072         NOW MQ = -0 -> LEFTMOST BIT OF MQ SET
        1272-14 1328    PRTC3 - STORE MQ  MASKCOL
        1273+10 1326          + R ADD     ZERO         READ THE BITMAP OF CHAR 
        1274+11 1337          + ADD AB    CHAR         DISCARD SIGN OF CHAR, IF ANY
        1275+12 1337          + STORE     CHAR
        1276+ 5 1349          + SUB       D48
        1277+ 3 1320          + TR +      PRTCEX       IF CHAR >= 48 EXIT
        1278+10 1334          + R ADD     BITMAPAD     IF ADDR OF BASE48 BITMAP NOT COMPUTED
        1279+ 4 1321          + TR 0      GETBMP1      TR TO LOAD IT
        1280+ 9 1337  GETBMP2 + ADD       CHAR         READ THE BITMAP OF CHAR 
        1281+13 1282          + STORE A   PRTC4        INDICATES THE BITS TO SET IN SELECTED 
        1282+10    0    PRTC4 + R ADD     /   /        COLUMN OF CARD BUFFER 
        1283+12 1341          + STORE     BITS
        1284+ 6 1342          + R SUB     ONE
        1285+12 1340          + STORE     N            SET TO -1
        1286+10 1340    LOOP1 + R ADD     N            CURRENT ROW (STARTS AT ZERO) = OFFSET ON PRTROWAD     
        1287+ 9 1342          + ADD       ONE
        1288+12 1340          + STORE     N
        1289+10 1341          + R ADD     BITS         EXTRACT RIGHTMOST BIT OF LEFT HALF OF ACC TO MQ
        1290+ 4 1320          + TR 0      PRTCEX       NO MORE BITS -> EXIT
        1291+21   19          + L RIGHT   0019         LSB BIT OF LEFT HALF-WORD OF ACC TO MQ
        1292+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 1 BIT)
        1293+12 1341          + STORE     BITS         SAVE BACK BITS. LSB HAS BEEN EXTACTED, CONTENTS SHIFTED RIGHT ONE PLACE
        1294+10 1326          + R ADD     ZERO
        1295+20    1          + L LEFT    0001         PUT EXTACTED BIT BACK INTO ACC
        1296+ 4 1286          + TR 0      LOOP1        NO BIT 
        1297+10 1340          + R ADD     N            READ THE ROW N AT CARD BUFFER 
        1298+22    2          + A LEFT    0002         MULT N BY 4 AS THERE ARE 4 HALF WORDS PER ROW
        1299+ 9 1339          + ADD       PRTROWAD     
        1300+13 1302          + STORE A   PRTROWR
        1301+13 1318          + STORE A   PRTROWW
        1302-10    0  PRTROWR - R ADD     /   /        
        1303-12 1330          - STORE     ROW          CURRENT CONTENTS OF ROW
        1304-10 1328          - R ADD     MASKCOL      "OR" MASKCOL IN SELECTED ROW
        1305+ 3 1313          + TR +      PRTW2
        1306-10 1330          - R ADD     ROW 
        1307+ 4 1311          + TR 0      PRTW1         
        1308+10 1326          + R ADD     ZERO         MASKCOL IS MINUS ZERO AND ROW IS NOT-EMPTY (EITHER POSITIVE OR NEGATIVE) -> SET ROW AS NEGATIVE
        1309- 7 1330          - SUB AB    ROW 
        1310+ 1 1318          + TR        PRTROWW
        1311-10 1328    PRTW1 - R ADD     MASKCOL      MASKCOL IS MINUS ZERO AND ROW IS EMPTY -> SET ROW = MASKCOL = MINUS ZERO
        1312+ 1 1318          + TR        PRTROWW
        1313-10 1330    PRTW2 - R ADD     ROW          
        1314+ 3 1317          + TR +      PRTW3              
        1315- 5 1328          - SUB       MASKCOL      MASKCOL IS POSITIVE AND ROW IS NEGATIVE -> SUB MASKCOL FROM ROW
        1316+ 1 1318          + TR        PRTROWW
        1317- 9 1328    PRTW3 - ADD       MASKCOL      MASKCOL IS POSITIVE AND ROW IS POSITIVE OR EMPTY -> ADD MASKCOL TO ROW         
        1318-12    0  PRTROWW - STORE     /   /        ROW UPDTATE
        1319+ 1 1286          + TR        LOOP1        PROCEED TO NEXT ROW
        1320+ 1    0 PRTCEX   + TR        /   /
        1321+10 1321 GETBMP1  + R ADD     *
        1322+ 1   85          + TR        BMPAD        GET BASE48 CHARS BITMAP ADDRESS
        1323+12 1334          + STORE     BITMAPAD     
        1324+ 1 1280          + TR        GETBMP2      RETURN
        1325+     0             ORG       EVEN
        1326+     0  ZERO       DEF       0            
        1327+     0             DEF       0            
        1328+     0  MASKCOL    DEF       0
        1329+     0             DEF       0
        1330+     0  ROW        DEF       0
        1331+     0             DEF       0
        1332+     0  NUM        DEF       0
        1333+     0             DEF       0
        1334+     0  BITMAPAD   DEF       0
        1335+     0  SGN        DEF       0
        1336+     0  LEN        DEF       0
        1337+     0  CHAR       DEF       0
        1338+     0  TXT        DEF       0
        1339+     0  PRTROWAD   DEF       0
        1340+     0  N          DEF       0
        1341+     0  BITS       DEF       0
        1342+     1  ONE        DEF       1
        1343+     2  TWO        DEF       2
        1344+     3  D3         DEF       3
        1345+    10  D10        DEF       10
        1346+    11  D11        DEF       11
        1347+    35  D35        DEF       35
        1348+    36  D36        DEF       36
        1349+    48  D48        DEF       48
        1350+    72  D72        DEF       72
        1351+  2304  D48X48     DEF       2304
        1352+ 16384  OCT04K     DEF       *040000      BIT SIGN ON 5TH OCTINARY DIGIT
        1354+ 9 1429 PRTNLINE + ADD       TWO          PRINT A NEW LINE OF DATA
        1355+12 1432          + STORE     PARAM        SAVE PARAM LIST ADDR
        1356+10 1356          + R ADD     *            CLEAR CARD BUFFER
        1357+ 1   73          + TR        CLRBUF 
        1358+10 1432 GPARAM   + R ADD     PARAM        GET PARAM PAIR FMT/DATA
        1359+13 1364          + STORE A   P1
        1360+ 9 1428          + ADD       ONE
        1361+13 1368          + STORE A   P2
        1362+ 9 1428          + ADD       ONE
        1363+12 1432          + STORE     PARAM
        1364+10    0 P1       + R ADD     /   /
        1365+12 1434          + STORE     FMT
        1366+ 3 1368          + TR +      P2           IF FMT < 0 THEM SKIP THIS PAIR FMT/DATA
        1367+ 1 1358          + TR        GPARAM
        1368+10    0 P2       + R ADD     /   /
        1369+12 1394          + STORE     DATALOC      GET DATA ADDRESS PASED AS PARAM
        1370+13 1371          + STORE A   P2A
        1371+10    0 P2A      + R ADD     /   /
        1372+12 1433          + STORE     DATA         GET EFFECTIVE DATA
        1373+10 1427          + R ADD     ZERO
        1374+15 1434          + LOAD MQ   FMT
        1375+18 1431          + DIV       D100         ACC=REMAINDER=COL NUMBER, MQ=QUOTIEN=TYPE OF DATA
        1376+12 1435          + STORE     COL
        1377+10 1427          + R ADD     ZERO
        1378+20   18          + L LEFT    0018
        1379+14 1434          + STORE MQ  FMT
        1380+15 1433          + LOAD MQ   DATA
        1381+10 1385          + R ADD     TYPETRAD
        1382+ 9 1434          + ADD       FMT
        1383+13 1384          + STORE A   TYPETR
        1384+ 1    0 TYPETR   + TR        /   /        TR SELECTED ROUTINE
        1385+ 0 1386 TYPETRAD + STOP      TYPETRT      TYPE TRANSFER TABLE ADDRESS
        1386+ 1 1415 TYPETRT  + TR        EOL          FMT=0..6 (IE <100) -> END OF PARAM LIST -> END OF LINE 
        1387+ 1 1392          + TR        TYSTR        FMT=1 -> PRINT A STRINGZ
        1388+ 1 1397          + TR        TYINT        FMT=2 -> PRINT AN INT
        1389+ 1 1402          + TR        TYOCT        FMT=3 -> PRINT AN OCT
        1390+ 1 1407          + TR        TYCHR        FMT=4 -> PRINT A CHAR
        1391+ 1 1411          + TR        TYALF        FMT=5 -> PRINT A 3-CHR PACKED ALFA STRING
        1392+10 1392 TYSTR    + R ADD     *            PRINT STRINGZ
        1393+ 1   55          + TR        PRTSTR
        1394+ 0    0 DATALOC  + STOP      /   /
        1395- 0 1435          - STOP      COL          COLUMN WHERE TXT STARTS
        1396+ 1 1358          + TR        GPARAM
        1397+10 1397 TYINT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1398+ 1   57          + TR        PRTINT
        1399+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        1400- 0 1435          - STOP      COL          COLUMN WHERE TXT STARTS
        1401+ 1 1358          + TR        GPARAM
        1402+10 1402 TYOCT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1403+ 1   83          + TR        PRTOCT
        1404+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        1405- 0 1435          - STOP      COL          COLUMN WHERE TXT STARTS
        1406+ 1 1358          + TR        GPARAM
        1407+10 1407 TYCHR    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1408+ 1   81          + TR        PRTCHR
        1409- 0 1435          - STOP      COL          COLUMN WHERE TXT STARTS
        1410+ 1 1358          + TR        GPARAM
        1411+10 1411 TYALF    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1412+ 1   79          + TR        PRTALF
        1413- 0 1435          - STOP      COL          COLUMN WHERE TXT STARTS
        1414+ 1 1358          + TR        GPARAM
        1415+10 1435 EOL      + R ADD     COL          SEND CARD BUFFER TO PRINTER AND RETURN TO CALLER
        1416+ 4 1421          + TR 0      DOPRINT      =0 -> PRINT ALLWAYS (NO SENSE SW CHECK)
        1417+ 9 1430          + ADD       D68          =1..6 -> SENSE 69..74 = OPERATOR'S PANEL SENSE SWITCH 1..6
        1418+13 1419          + STORE A   CHKSW
        1419+30    0 CHKSW    + SENSE     /   /         
        1420+ 1 1423          + TR        RETURN       SW NOT AT ON POSITION
        1421+10 1421 DOPRINT  + R ADD     *            PRINT CARD BUFFER
        1422+ 1   59          + TR        PRINTCRD
        1423+10 1432 RETURN   + R ADD     PARAM        PARAM-1 IS THE RETURN ADDR      
        1424+ 5 1428          + SUB       ONE
        1425+13 1426          + STORE A   EXIT
        1426+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        1427+ 0    0 ZERO     + STOP      0000
        1428+ 0    1 ONE      + STOP      0001
        1429+ 0    2 TWO      + STOP      0002
        1430+ 0   68 D68      + STOP      0068
        1431+ 0  100 D100     + STOP      100
        1432+ 0    0 PARAM    + STOP      0000
        1433+ 0    0 DATA     + STOP      0000
        1434+ 0    0 FMT      + STOP      0000
        1435+ 0    0 COL      + STOP      0000
        1436+ 9 1450 BMPAD    + ADD       TWO
        1437+13 1439          + STORE A   EXIT
        1438+10 1440          + R ADD     BITMAPAD
        1439+ 1    0 EXIT     + TR        /   /
        1440+ 0 1442 BITMAPAD + STOP      BITMAP
        1441+     0             ORG       EVEN
        1442+     0  BITMAP     DEF       0              <blank>     0     <none>
        1443+   256             DEF       256               1        1       1        256          =  256   
        1444+   128             DEF       128               2        2       2        128          =  128   
        1445+    64             DEF       64                3        3       3         64          =   64   
        1446+    32             DEF       32                4        4       4         32          =   32   
        1447+    16             DEF       16                5        5       5         16          =   16   
        1448+     8             DEF       8                 6        6       6          8          =    8   
        1449+     4             DEF       4                 7        7       7          4          =    4   
        1450+     2  TWO        DEF       2                 8        8       8          2          =    2   
        1451+     1             DEF       1                 9        9       9          1          =    1   
        1452+   512             DEF       512               0       10       0        512          =  512   
        1453+  1024             DEF       1024              -       11       X       1024          = 1024   
        1454+  2048             DEF       2048              +       12       Y       2048          = 2048   
        1455+  2304             DEF       2304              A       13      Y-1        256+2048    = 2304   
        1456+  2176             DEF       2176              B       14      Y-2        128+2048    = 2176   
        1457+  2112             DEF       2112              C       15      Y-3         64+2048    = 2112   
        1458+  2080             DEF       2080              D       16      Y-4         32+2048    = 2080   
        1459+  2064             DEF       2064              E       17      Y-5         16+2048    = 2064   
        1460+  2056             DEF       2056              F       18      Y-6          8+2048    = 2056   
        1461+  2052             DEF       2052              G       19      Y-7          4+2048    = 2052   
        1462+  2050             DEF       2050              H       20      Y-8          2+2048    = 2050   
        1463+  2049             DEF       2049              I       21      Y-9          1+2048    = 2049   
        1464+  1280             DEF       1280              J       22      X-1        256+1024    = 1280   
        1465+  1152             DEF       1152              K       23      X-2        128+1024    = 1152   
        1466+  1088             DEF       1088              L       24      X-3         64+1024    = 1088   
        1467+  1056             DEF       1056              M       25      X-4         32+1024    = 1056   
        1468+  1040             DEF       1040              N       26      X-5         16+1024    = 1040   
        1469+  1032             DEF       1032              O       27      X-6          8+1024    = 1032   
        1470+  1028             DEF       1028              P       28      X-7          4+1024    = 1028   
        1471+  1026             DEF       1026              Q       29      X-8          2+1024    = 1026   
        1472+  1025             DEF       1025              R       30      X-9          1+1024    = 1025   
        1473+   640             DEF       640               S       31      0-2        128+512     = 640    
        1474+   576             DEF       576               T       32      0-3         64+512     = 576    
        1475+   544             DEF       544               U       33      0-4         32+512     = 544    
        1476+   528             DEF       528               V       34      0-5         16+512     = 528    
        1477+   520             DEF       520               W       35      0-6          8+512     = 520    
        1478+   516             DEF       516               X       36      0-7          4+512     = 516    
        1479+   514             DEF       514               Y       37      0-8          2+512     = 514    
        1480+   513             DEF       513               Z       38      0-9          1+512     = 513    
        1481+   578             DEF       578               ,       39      8-3-0        2+64+512  = 578    
        1482+   546             DEF       546               %       40      8-4-0        2+32+512  = 546    
        1483+  1090             DEF       1090              $       41      8-3-X        2+64+1024 = 1090   
        1484+  1058             DEF       1058              *       42      8-4-X        2+32+1024 = 1058   
        1485+  2114             DEF       2114              .       43      8-3-Y        2+64+2048 = 2114   
        1486+  2082             DEF       2082              #       44      8-4-Y        2+32+2048 = 2082   
        1487+   768             DEF       768               /       45      0-1          512+256   = 768    
        1488+    66             DEF       66                +       46      8-3          2+64      = 66     
        1489+    34             DEF       34                -       47      8-4          2+32      = 34    This is the non-minus-sign separator
        1490+ 9 1514 CLMEM    + ADD       TWO 
        1491+13 1496          + STORE A   P1           PARM: ADDR 
        1492+ 9 1513          + ADD       ONE          
        1493+13 1498          + STORE A   P2           PARM: LOCATION OF LEN=NUMBER OF HALF-WORDS TO CLEAR 
        1494+ 9 1513          + ADD       ONE          
        1495+13 1504          + STORE A   EXIT
        1496+10    0 P1       + R ADD     /   /        GET ADDR TO CLEAR
        1497+13 1507          + STORE A   MEM
        1498+10    0 P2       + R ADD     /   /        GET LEN ADDR
        1499+13 1500          + STORE A   P2A
        1500+10    0 P2A      + R ADD     /   /        GET LEN 
        1501+12 1515          + STORE     LEN
        1502+15 1512          + LOAD MQ   ZERO
        1503+10 1515 LOOP     + R ADD     LEN
        1504+ 4    0 EXIT     + TR 0      /   /
        1505+ 5 1513          + SUB       ONE
        1506+12 1515          + STORE     LEN
        1507+14    0 MEM      + STORE MQ  /   /        
        1508+10 1507          + R ADD     MEM
        1509+ 9 1513          + ADD       ONE
        1510+13 1507          + STORE A   MEM
        1511+ 1 1503          + TR        LOOP
        1512+ 0    0 ZERO     + STOP      0000
        1513+ 0    1 ONE      + STOP      0001         constant 1
        1514+ 0    2 TWO      + STOP      0002         constant 2
        1515+ 0    0 LEN      + STOP      0000
        1516+15 1583 SRCHTBL  + LOAD MQ   ZERO
        1517+ 1 1521          + TR        START
        1518+15 1584 EQTBL    + LOAD MQ   ONE
        1519+ 1 1521          + TR        START
        1520+15 1585 READTBL  + LOAD MQ   TWO
        1521+ 9 1585 START    + ADD       TWO 
        1522+13 1529          + STORE A   P1           PARM: ADDR OF TABLE
        1523+ 9 1584          + ADD       ONE          
        1524+13 1531          + STORE A   P2           PARM: LEN OF TABLE
        1525+ 9 1584          + ADD       ONE          
        1526+13 1536          + STORE A   P3           PARM: VAL TO FIND
        1527+ 9 1584          + ADD       ONE          
        1528+13 1577          + STORE A   EXIT
        1529+10    0 P1       + R ADD     /   /        GET ADDR OF TABLE
        1530+13 1580          + STORE A   TBL
        1531+10    0 P2       + R ADD     /   /        GET ADDR OF LEN OF TABLE/ENTRY ON TABLE
        1532+13 1533          + STORE A   P2A
        1533+10    0 P2A      + R ADD     /   /        DERREFERENCE -> ACC=LEN/ENTRY (1..LEN)
        1534+12 1578          + STORE     N
        1535+ 4 1577          + TR 0      EXIT         EXIT, CANNOT READ/STORE ON ENTRY 0, SEARCH ON EMPTY TABLE
        1536+10    0 P3       + R ADD     /   /        GET ADDR OF VAL TO FIND
        1537+13 1553          + STORE A   WRVAL
        1538+13 1539          + STORE A   P3A
        1539+10    0 P3A      + R ADD     /   /        DERREFERENCE -> ACC=VAL
        1540+12 1579          + STORE     VAL
        1541+14 1582          + STORE MQ  TEMP         JUMP TABLE DISPATCH
        1542+10 1582          + R ADD     TEMP
        1543+ 4 1558          + TR 0      LOOP0        TR TO SEARCH TABLE
        1544+10 1578          + R ADD     N            SUB ONE AS FIRST ENTRY ON TABLE IS "1"
        1545+ 5 1584          + SUB       ONE          
        1546+ 9 1580          + ADD       TBL          TABLE BASE ADDR
        1547+13 1556          + STORE A   WRTBL
        1548+13 1552          + STORE A   RDTBL2
        1549+10 1582          + R ADD     TEMP
        1550+ 5 1584          + SUB       ONE
        1551+ 4 1555          + TR 0      STORETBL 
        1552+10    0 RDTBL2   + R ADD     /   /        VAL=TBL[ENT]
        1553+12    0 WRVAL    + STORE     /   /
        1554+ 1 1577          + TR        EXIT
        1555+10 1579 STORETBL + R ADD     VAL          TBL[ENT]=VAL
        1556+12    0 WRTBL    + STORE     /   /    
        1557+ 1 1577          + TR        EXIT
        1558+10 1580 LOOP0    + R ADD     TBL
        1559+13 1565          + STORE A   RDTBL
        1560+10 1565          + R ADD     RDTBL
        1561+12 1581          + STORE     TBL0
        1562+ 9 1578          + ADD       N
        1563+12 1582          + STORE     TEMP         THE END ADDR OF TABLE
        1564+10 1579 LOOP     + R ADD     VAL          ACC=THE SEARCHED VALUE
        1565+ 5    0 RDTBL    + SUB       /   /    
        1566+ 2 1567          + TR OV     OVOK         CLEAR OV JUST IN CASE
        1567+ 4 1574 OVOK     + TR 0      FOUND        TR IF VAL FOUND IN ENTRY N
        1568+10 1565          + R ADD     RDTBL
        1569+ 9 1584          + ADD       ONE
        1570+13 1565          + STORE A   RDTBL
        1571+ 5 1582          + SUB       TEMP
        1572+ 4 1577          + TR 0      EXIT         NOT FOUND -> RETURN ZERO
        1573+ 1 1564          + TR        LOOP
        1574+10 1565 FOUND    + R ADD     RDTBL        RETURN ENTRY FOUND
        1575+ 5 1581          + SUB       TBL0
        1576+ 9 1584          + ADD       ONE
        1577+ 1    0 EXIT     + TR        /   /
        1578+ 0    0 N        + STOP      0000
        1579+ 0    0 VAL      + STOP      0000
        1580+ 0    0 TBL      + STOP      0000
        1581+ 0    0 TBL0     + STOP      0000
        1582+ 0    0 TEMP     + STOP      0000
        1583+ 0    0 ZERO     + STOP      0000
        1584+ 0    1 ONE      + STOP      0001         constant 1
        1585+ 0    2 TWO      + STOP      0002         constant 2
        1586+ 9 1659 RWDRUM   + ADD       TWO 
        1587+13 1596          + STORE A   PDR1         PARM1: DRUM INSTR: READ/WRITE 0128  0129  0130  0131
        1588+ 9 1658          + ADD       ONE          
        1589+13 1598          + STORE A   PDR2         PARM2: DRUM ADDRESS (0..4094)
        1590+ 9 1658          + ADD       ONE          
        1591+13 1600          + STORE A   PDR3         PARM3: BUF START ADDRESS
        1592+ 9 1658          + ADD       ONE          
        1593+13 1602          + STORE A   PDR4         PARM4: LEN: NUMBER OF HALF-WORDS (MUST BE EVEN)
        1594+ 9 1658          + ADD       ONE          
        1595+13 1656          + STORE A   EXIT               
        1596+10    0 PDR1     + R ADD     /   /        GET DRUM INSTR
        1597+12 1604          + STORE     DRIO
        1598+10    0 PDR2     + R ADD     /   /        GET DRUM ADDR
        1599+13 1605          + STORE A   DRADDR
        1600+10    0 PDR3     + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1601+13 1643          + STORE A   RWCOPY    
        1602+10    0 PDR4     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        1603+12 1660          + STORE     LEN
        1604+ 0    0 DRIO     + STOP      /   /        INSTR: READ/WRITE 0128  0129  0130  0131
        1605+29    0 DRADDR   + SET DR    /   /
        1606+ 1 1639          + TR        LOOP
        1607+ 9 1659 RDTAPE   + ADD       TWO 
        1608+13 1615          + STORE A   PR1          PARM1: TAPE ADDRESS
        1609+ 9 1658          + ADD       ONE          
        1610+13 1617          + STORE A   PR2          PARM2: BUF START ADDRESS
        1611+ 9 1658          + ADD       ONE          
        1612+13 1656          + STORE A   EXIT
        1613+ 2 1614          + TR OV     CLOV1        CLEAR OV THAT MAY HAVE BEEN SET
        1614+ 8    0    CLOV1 + NOOP      0000
        1615+10    0 PR1      + R ADD     /   /        GET TAPE ADDR
        1616+13 1619          + STORE A   RTAPAD       TAPE UNITS: 0256  0257  0258  0259
        1617+10    0 PR2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1618+13 1643          + STORE A   RWCOPY    
        1619+24    0 RTAPAD   + READ      /   /
        1620+10 1657          + R ADD     ZERO
        1621+ 1 1641          + TR        LOOP1
        1622+ 9 1659 WRTAPE   + ADD       TWO 
        1623+13 1630          + STORE A   PW1          PARM1: TAPE ADDRESS
        1624+ 9 1658          + ADD       ONE          
        1625+13 1632          + STORE A   PW2          PARM2: BUF START ADDRESS
        1626+ 9 1658          + ADD       ONE          
        1627+13 1634          + STORE A   PW3          PARM3: BUF LEN
        1628+ 9 1658          + ADD       ONE          
        1629+13 1656          + STORE A   EXIT
        1630+10    0 PW1      + R ADD     /   /        GET TAPE ADDR
        1631+13 1638          + STORE A   WTAPAD       TAPE UNITS: 0256  0257  0258  0259
        1632+10    0 PW2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1633+13 1643          + STORE A   RWCOPY    
        1634+10    0 PW3      + R ADD     /   /        GET ADDR OF LEN 
        1635+13 1636          + STORE A   PW3A
        1636+10    0 PW3A     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        1637+12 1660          + STORE     LEN
        1638+26    0 WTAPAD   + WRITE     /   /        PREPARE TO WRITE ON TAPE
        1639+10 1660 LOOP     + R ADD     LEN
        1640+ 4 1655          + TR 0      RWOK
        1641+ 5 1659 LOOP1    + SUB       TWO
        1642+12 1660          + STORE     LEN
        1643-31    0 RWCOPY   - COPY      /   /        WRITE BUFFER TO TAPE
        1644+ 1 1647          + TR        GO 
        1645+ 1 1651          + TR        EOF          END OF FILE
        1646+ 1 1653          + TR        EOR          END OF RECORD
        1647+10 1643 GO       + R ADD     RWCOPY
        1648+ 5 1659          + SUB       TWO
        1649+13 1643          + STORE A   RWCOPY
        1650+ 1 1639          + TR        LOOP
        1651+10 1658 EOF      + R ADD     ONE          SET OV FLAG TO SIGNAL END OF FILE CONDITION
        1652+22   36          + A LEFT    36
        1653+ 6 1660 EOR      + R SUB     LEN          RETURN NUMBER OF HALF-WORDS READ
        1654+ 5 1659          + SUB       TWO
        1655+26 2052 RWOK     + WRITE     2052         INSURE THAT MQ NOT IN USE            
        1656+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        1657+ 0    0 ZERO     + STOP      0000
        1658+ 0    1 ONE      + STOP      0001         
        1659+ 0    2 TWO      + STOP      0002         
        1660+     0  LEN        RES       1
        1662+ 9 1677 CHAIN    + ADD       TWO
        1663+13 1664          + STORE A   CHP1
        1664+10    0 CHP1     + R ADD     /   /        GET TAPE NUMBER
        1665+13 1672          + STORE A   TAPELOAD
        1666+30   70          + SENSE     0070         SENSE SWITCH 2                                  
        1667+ 1 1671 CONTAD   + TR        ENDSTOP      (ON POSITION MAKES SENSE OPCODE TO SKIP NEXT INSTR)
        1668+10 1667          + R ADD     CONTAD       IF SW2 IS ON, A +STOP 4095 IS EXECUTED.  
        1669+12 4095          + STORE     4095         IF THEN USER PRESS START, EXECUTION WILL BE RESUMED 
        1670+ 0 4095          + STOP      4095         AND CHAINED PROGRAM WILL BE LOADED AND EXECUTED
        1671+ 8    0 ENDSTOP  + NOOP      0000
        1672+24    0 TAPELOAD + READ      0000         
        1673-31    0 TL0      - COPY      0000         READ 1ST WORD OF SELF-LOADER FROM TAPE
        1674+ 1    0          + TR        0000         TR TO SELF-LOADER
        1675+ 0 2221          + STOP      2221         ERROR LOADING: UNEXPECTED END OF FILE
        1676+ 0 2222          + STOP      2222         ERROR LOADING: UNEXPECTED END OF RECORD 
        1677+ 0    2 TWO      + STOP      0002         ERROR LOADING: UNEXPECTED END OF FILE
          48-     0  ROUTINE INIT
          49+ 1  126 ENTRY POINT
          50-     0  ROUTINE CHAIN
          51+ 1 1662 ENTRY POINT
          52-     0  ROUTINE PRTNLINE
          53+ 1 1354 ENTRY POINT
          54-     0  ROUTINE PRTSTR
          55+ 1 1093 ENTRY POINT
          56-     0  ROUTINE PRTINT
          57+ 1 1194 ENTRY POINT
          58-     0  ROUTINE PRINTCRD
          59+ 1 1032 ENTRY POINT
          60-     0  ROUTINE RDTAPE
          61+ 1 1607 ENTRY POINT
          62-     0  ROUTINE RWDRUM
          63+ 1 1586 ENTRY POINT
          64-     0  ROUTINE CLMEM
          65+ 1 1490 ENTRY POINT
          66-     0  ROUTINE SRCHTBL
          67+ 1 1516 ENTRY POINT
          68-     0  ROUTINE EQTBL
          69+ 1 1518 ENTRY POINT
          70-     0  ROUTINE READTBL
          71+ 1 1520 ENTRY POINT
          72-     0  ROUTINE CLRBUF
          73+ 1 1024 ENTRY POINT
          74-     0  ROUTINE READCRD
          75+ 1 1028 ENTRY POINT
          76-     0  ROUTINE WRITECRD
          77+ 1 1030 ENTRY POINT
          78-     0  ROUTINE PRTALF
          79+ 1 1116 ENTRY POINT
          80-     0  ROUTINE PRTCHR
          81+ 1 1236 ENTRY POINT
          82-     0  ROUTINE PRTOCT
          83+ 1 1160 ENTRY POINT
          84-     0  ROUTINE BMPAD
          85+ 1 1436 ENTRY POINT
          86-     0  ROUTINE WRTAPE
          87+ 1 1622 ENTRY POINT
        4094+    48  REGION ORIGIN TABLE LOCATION
        4095+   126  INITIAL REGION
           0+ 1  126          + TR        INIT         PROGRAM START
