        DEC
        NNNN OP ADDR COMMENTS
          90+ 9 1739 SRCHREG  + ADD       TWO          SEARCH REGION IN TREGIONS. TR TO ERROR IF NOT FOUND 
          91+13   98          + STORE A   SRCHREX      RETURN IN ACC THE ENTRY IN TREGIONS FOUND
          92+10   92          + R ADD     *
          93+ 1   69          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
          94+ 0  434          + STOP      TREGIONS     ... TREGIONS TABLE
          95+ 0  433          + STOP      NREGIONS     ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NREGIONS 
          96+ 0  413          + STOP      FACT         ... THE VALUE TO FIND 
          97+ 4   99          + TR 0      SREGNFER
          98+ 1    0 SRCHREX  + TR        /   /
          99+10   99 SREGNFER + R ADD     *            
         100+ 1  374          + TR        ERROR
         101+ 0 1748          + STOP      ERRREGNF     ERROR: REGION DO NOT EXISTS
         102+ 9 1739 LOADCC   + ADD       TWO          LOAD PACTSCR INTO CARD IMAGE SO 
         103+13  122          + STORE A   CPCCEX       CURRENT PACT SOURCE CODE CAN BE PRINTED
         104+10 1736          + R ADD     ZERO         COPY TO LEFT SIDE OF SOURCE CODE CARD IMAGE
         105+13  109          + STORE A   CPCC1        AT 0..46 FROM PACTSCR
         106+10  125          + R ADD     CPCC2
         107+13  108          + STORE A   CPCC 
         108-10    0 CPCC     - R ADD     /   /
         109-12    0 CPCC1    - STORE     /   /
         110+10  109          + R ADD     CPCC1
         111+ 5 1739          + SUB       TWO
         112+13  114          + STORE A   CPCC1B
         113+10 1736          + R ADD     ZERO
         114-12    0 CPCC1B   - STORE     /   /
         115+10  108          + R ADD     CPCC
         116+ 5 1739          + SUB       TWO
         117+13  108          + STORE A   CPCC
         118+10  109          + R ADD     CPCC1
         119+ 5 1740          + SUB       D4
         120+13  109          + STORE A   CPCC1
         121+ 5  124          + SUB       CPCCE
         122+ 4    0 CPCCEX   + TR 0      /   /        RETURN TO CALLER
         123+ 1  108          + TR        CPCC
         124-12   48 CPCCE    - STORE     0048         LAST LOCATION TO COPY FROM 
         125+ 8  386 CPCC2    + NOOP      PACTSRC      PACTSRC = FIRST LOCATION TO COPY FROM
         126+10  126 INIT     + R ADD     *            
         127+ 1   53          + TR        PRTNLINE     
         128+ 0  101          + STOP      0101         STRINGZ AT COL 1
         129+ 0 1767          + STOP      MSGSTART     "ABSTRACT ASSEMBLY PASS 1"
         130+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         131+10  131          + R ADD     *
         132+ 1   65          + TR        RWDRUM       READ TREGIONS ARRAY FROM DRUM
         133+24  128          + READ      0128         DRUM INSTR
         134+ 0    0          + STOP      0000         DRUM ADDR 
         135+ 0  432          + STOP      MAXNREGS     ADDR OF START OF TABLES
         136+ 0  202          + STOP      0202         MAXNREGS (1 HALF-WORD) + NREGIONS (1 HW) + TREGIONS (100 HW)
         137+10  137          + R ADD     *
         138+ 1   65          + TR        RWDRUM       READ TREGIONS ARRAY FROM DRUM
         139+24  128          + READ      0128         DRUM INSTR
         140+ 0  402          + STOP      0402         DRUM ADDR 
         141+ 0  734          + STOP      TREXSIZE     ADDR OF START OF TABLES
         142+ 0  200          + STOP      0200         LEN=TREXSIZE (100 HW) + TREXTMP (100 HW)
         143+10  143          + R ADD     *            CLEAR TABLE
         144+ 1   67          + TR        CLMEM        
         145+ 0  634          + STOP      TRNEEDCA   
         146+ 0  432          + STOP      MAXNREGS
         147+10  147          + R ADD     *            CLEAR TABLE
         148+ 1   67          + TR        CLMEM        TREFSN
         149+ 0 1336          + STOP      TREFSN
         150+ 0  934          + STOP      MAXNREFS
         151+10 1736          + R ADD     ZERO         CLEAR CC RECORD
         152+12  410          + STORE     REGION     
         153+12  411          + STORE     STEP       
         154+12  412          + STORE     OP         
         155+12  413          + STORE     FACT       
         156+12  414          + STORE     S1         
         157+12  415          + STORE     S2         
         158+12  416          + STORE     QR         
         159+12  417          + STORE     QF         
         160-12  418          - STORE     NUM        
         161+12  420          + STORE     CLUE       
         162+12  421          + STORE     STEPN      
         163+12  422          + STORE     FACTN      
         164+12  423          + STORE     FACTREG    
         165+12  424          + STORE     S1N        
         166+12  425          + STORE     S2N        
         167+12  426          + STORE     D1N        
         168+12  427          + STORE     D2N        
         169+12  428          + STORE     NINST      
         170+12  429          + STORE     NINCR 
         171+10  430          + R ADD     CCLEN        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         172+10 1736          + R ADD     ZERO
         173+12 1744          + STORE     IREG         REGION NUMBER BEING PROCESSED
         174+28  257          + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE)
         175+28  258          + REWIND    TAPEINR      REWIND TAPE IN WITH STEP REFERENCES 
         176+28  259          + REWIND    TAPEOUTR     REWIND TAPE OUT WITH STEP REFERENCES UPDATED
         177+10 1736 READREG  + R ADD     ZERO         INIT READ REGION
         178+12 1747          + STORE     STEPCNT      STEP* COUNT FOR REGION
         179+12 1746          + STORE     TMPN         CURRENT TEMP VARS FOR RESULT OF STEP IN THIS REGION 
         180+10 1744          + R ADD     IREG         SELECT NEXT REGION
         181+ 9 1738          + ADD       ONE
         182+12 1744          + STORE     IREG
         183+ 8  936 TREFSAD  + NOOP      TREFS        INIT TREFAD POINTER TO WALT THRU
         184+10  183          + R ADD     TREFSAD      TREFS TABLE
         185+13  212          + STORE A   RDREF
         186+10  186          + R ADD     *       
         187+ 1   61          + TR        RDTAPE       READ MAGNETIC TAPE (READ REFERENCES TABLE TREFS)
         188+ 0  258          + STOP      TAPEINR
         189+ 0  934          + STOP      MAXNREFS     BUF TO READ FROM TAPE: MAXNREFS (1HW) + NREFS (1HW) + TREFS
         190+ 2  196          + TR OV     EOFREFS      TR IF END OF FILE
         191+10  191          + R ADD     *            CLEAR TABLE
         192+ 1   67          + TR        CLMEM        TREFSN
         193+ 0 1336          + STOP      TREFSN
         194+ 0  934          + STOP      MAXNREFS
         195+ 1  198          + TR        READSTEP     PROCEED WITH FIRST STEP OF REGION
         196+10 1736 EOFREFS  + R ADD     ZERO
         197+12  936          + STORE     TREFS        SIGNAL NO REFERENCES ON TAPE
         198+10  198 READSTEP + R ADD     *            READ PACT USER PROGRAM SOURCE CODE FROM TAPE IN
         199+ 1   61          + TR        RDTAPE
         200+ 0  257          + STOP      TAPEIN
         201+ 0  386          + STOP      CCODE        BUF TO READ IN FROM TAPE
         202+ 2  351          + TR OV     EOF          TR IF END OF FILE
         203+10  412          + R ADD     OP
         204+ 4  323          + TR 0      EOR          TR IF END OF REGION
         205+10  205          + R ADD     *            LOAD PACTSCR INTO CARD IMAGE SO 
         206+ 1  102          + TR        LOADCC       CURRENT PACT SOURCE CODE CAN BE PRINTED
         207+10 1747          + R ADD     STEPCNT      COMPUTE STEPN FOR CURRENT STEP
         208+ 9 1738          + ADD       ONE
         209+12 1747          + STORE     STEPCNT      VALUE OF STEPN FOR CURRENT STEP
         210+ 5 1738          + SUB       ONE
         211+ 4  281          + TR 0      STEP1        TR IF THIS IS THE FIRST STEP OF REGION
         212+10    0 RDREF    + R ADD     /   /
         213+12 1743          + STORE     REF          GET NEXT REFERENCE TO CHECK
         214+ 4  270          + TR 0      ENDREF       =0 -> NO MORE REFERENCES TO RESOLVE
         215+10 1736          + R ADD     ZERO
         216+11 1743          + ADD AB    REF
         217+ 5  411          + SUB       STEP
         218+ 4  224          + TR 0      FNDREF       TR IF HIT A REFERENCED STEP
         219+ 3  270          + TR +      ENDREF       ABS(REF) > STEP -> NOT ARRIVED YET TO REFERENCES STEP -> CONTINUE
         220+10  212 NXTREF   + R ADD     RDREF        ADVANCE TO NEXT REFERENCE
         221+ 9 1738          + ADD       ONE
         222+13  212          + STORE A   RDREF       
         223+ 1  212          + TR        RDREF
         224+10 1743 FNDREF   + R ADD     REF
         225+ 3  256          + TR +      TRREF        IF REFERENCE FOUND IS >0 -> STEP IS THE DESTINATION OF A TRANSFER
         226+10 1746          + R ADD     TMPN         CURRENT STEP IS REFERENCED AS "RESULT OF STEP". SO 
         227+ 9 1738          + ADD       ONE          MUST SAVE THE CURRENT STEP IN ONE TEMP VAR
         228+12 1746          + STORE     TMPN         (SIGNAL IT INCREMENTING NUM OF TEMP VARS USED)
         229+30   74          + SENSE     0074         SENSE SWITCH 6
         230+ 1  240          + TR        ENDLOG1A     TR IF NO LOG SELECTED
         231+10  231          + R ADD     *
         232+ 1   55          + TR        PRTSTR
         233+ 0 1786          + STOP      MSGRESTP     "RSLT OF STEP"
         234+ 0   40          + STOP      0040         COL 40
         235+15 1746          + LOAD MQ   TMPN
         236+10  236          + R ADD     *
         237+ 1   57          + TR        PRTINT
         238+ 0    3          + STOP      0003         3-DIGITS NUMS          
         239+ 0   53          + STOP      0053         COL 53
         240+ 8    0 ENDLOG1A + NOOP      0000
         241+10 1747          + R ADD     STEPCNT      ALSO A "EQ TEMP VAR" INSTR WILL BE INSERTED
         242+ 9 1738          + ADD       ONE          INCR STEPN TO REFLECT THIS 
         243+12 1747          + STORE     STEPCNT      
         244+10  416          + R ADD     QR           IF THE RESULT OF STEP IS CALLED-IN ELSEWHERE
         245+ 4  253          + TR 0      ERRNOQR1     IT CANNOT HAVE ITS QR TO ZERO
         246+22   10          + A LEFT    0010         SHIFT TO PACK QR IN BITS 17-10, WITH SGN (BIT 18)
         247+ 3  250          + TR +      PKQ1         AND         TMPN In BITS 0-9, NO SIGN         
         248+ 5 1746          + SUB       TMPN         THE PACKED VALUE IS STORED IN MQ
         249+ 1  251          + TR        PKQ2
         250+ 9 1746 PKQ1     + ADD       TMPN
         251+21   35 PKQ2     + L RIGHT   0035         MQ=ACC         
         252+ 1  265          + TR        UPDTREF      TR TO UPDATE REF WITH MQ VALUE TO UNPACK IT WHEN CALLING-IN THE RESULT OF STEP
         253+10  253 ERRNOQR1 + R ADD     *
         254+ 1  374          + TR        ERROR
         255+ 0 1755          + STOP      ERRNOQR      ERROR: QR CANNOT BE BLANK IN A STEP CALLED-IN AS RESULT OF STEP
         256+ 8    0 TRREF    + NOOP      0000         STEPN IS DESTINATION OF A TRANSFER. 
         257+30   74          + SENSE     0074         SENSE SWITCH 6
         258+ 1  263          + TR        ENDLOG2A     TR IF NO LOG SELECTED
         259+10  259          + R ADD     *
         260+ 1   55          + TR        PRTSTR
         261+ 0 1791          + STOP      MSGTRDST     "TR DEST"
         262+ 0   40          + STOP      0040         COL 40
         263+ 8    0 ENDLOG2A + NOOP      0000
         264+15 1747          + LOAD MQ   STEPCNT      UPDATE REFERENCE WITH STEPN  
         265+10  212 UPDTREF  + R ADD     RDREF        SAVE THE VALUE OF REFERENCE RESOLUTION 
         266+ 9  934          + ADD       MAXNREFS
         267+13  268          + STORE A   WRREFN
         268+14    0 WRREFN   + STORE MQ  /   /       
         269+ 1  220          + TR        NXTREF       DONE, TR TO SELECT AND PROCESS NEXT REF
         270+ 8    0 ENDREF   + NOOP      0000         END OF REFERENCE RESOLUTION
         271+10  412          + R ADD     OP
         272+ 5 1741          + SUB       OPDUP
         273+ 4  303          + TR 0      CHKDUP       OP="DUP REGION" -> TR TO INCR STEPN, TMPN WITH SIZE OF REGION
         274+ 8    0 NEXT     + NOOP      0000         CONTINUE WITH NEXT STEP RECORD
         275+30   74          + SENSE     0074         SENSE SWITCH 6
         276+ 1  279          + TR        ENDLOG1      TR IF NO LOG SELECTED
         277+10  277          + R ADD     *            PRINT STEP JUST PROCESSED
         278+ 1   59          + TR        PRINTCRD
         279+ 8    0 ENDLOG1  + NOOP      0000 
         280+ 1  198          + TR        READSTEP
         281+10  412 STEP1    + R ADD     OP           CHECK FIRST STEP OF REGION. IF IT IS
         282+ 5 1742          + SUB       OPCALL       CALL -> CONTINUE AS A REGION CAN START WITH CALL INSTR
         283+ 4  212          + TR 0      RDREF        
         284+10  284          + R ADD     *            HERE REGION DOES NOT STARTS WITH CALL
         285+ 1   73          + TR        READTBL
         286+ 0  534          + STOP      TRISDUP      ... VAL=TRISDUP[IREG] =1 IF CURRENT REGION IS TO BE DUPLICATED
         287+ 0 1744          + STOP      IREG
         288+ 0  431          + STOP      VAL
         289+10  431          + R ADD     VAL          IF VAL=0 -> THIS REGIONS IS NOT DUPLICATED -> SHOULD START WITH CALL INSTR
         290+ 4  292          + TR 0      STEP1A       TR TO COUNT THE MISSING (WILL BE ADDED LATE) CALL INSTR
         291+ 1  212          + TR        RDREF        IF VAL=1 -> THIS REGIONS IS DUPLICATED -> PROCEED AS NO NEED TO ADD EXTRA CALL INSTR 
         292+10 1747 STEP1A   + R ADD     STEPCNT      INCR STEPN COUNT TO LEAVE ROOM FOR CALL INSTR TO BE ADDED LATER
         293+ 9 1738          + ADD       ONE
         294+12 1747          + STORE     STEPCNT
         295+10 1738          + R ADD     ONE          SIGNAL THIS REGION NEEDS A CALL INSTR AS FIRST
         296+12  431          + STORE     VAL          STEP OF REGION.  
         297+10  297          + R ADD     *            
         298+ 1   71          + TR        EQTBL
         299+ 0  634          + STOP      TRNEEDCA     ... TRNEEDCA[IREG]=VAL -> TRNEEDCA[IREG]=1
         300+ 0 1744          + STOP      IREG         
         301+ 0  431          + STOP      VAL
         302+ 1  212          + TR        RDREF        AND PROCEED
         303+10  303 CHKDUP   + R ADD     *            SEARCH REGION STATED IN FACTOR VAR = THE DUPLICATED REGION NAME
         304+ 1   90          + TR        SRCHREG      ERROR IF REGION DO NOT EXISTS IN TREGS TABLE
         305+13 1745          + STORE A   IREGDUP      STORE THE DUPLICATED REGION INDEX NUMBER
         306+10  306          + R ADD     *            
         307+ 1   73          + TR        READTBL
         308+ 0  734          + STOP      TREXSIZE     ... VAL=TREXSIZE[IREGDUP] GET CURRENT EXTENDED SIZE FOR DUPLICATED REGION
         309+ 0 1745          + STOP      IREGDUP
         310+ 0  431          + STOP      VAL
         311+ 4  274          + TR 0      NEXT         IF EXTENDED SIZE=0 -> REGION NOT RESOLVED -> JUST IGNORE THE DUP INSTR
         312+ 5 1738          + SUB       ONE
         313+ 9 1747          + ADD       STEPCNT      THE FINAL (EXPANDED) SIZE OF REGION TO BE DUPLICATED HERE IS FULLY KNOW. ADD IT
         314+12 1747          + STORE     STEPCNT      TO THE SIZE OF CURRENT REGION
         315+10  315          + R ADD     *            
         316+ 1   73          + TR        READTBL
         317+ 0  834          + STOP      TREXTMP      ... VAL=TREXSIZE[IREGDUP] GET CURRENT EXTENDED SIZE FOR DUPLICATED REGION
         318+ 0 1745          + STOP      IREGDUP
         319+ 0  431          + STOP      VAL
         320+ 9 1746          + ADD       TMPN         ADD THE NUMBER OF TEMP VARS NEEDED BY DUPLICATED REGION TO THE TOTAL FOR CURRENT REGION
         321+12 1746          + STORE     TMPN
         322+ 1  274          + TR        NEXT         TR TO NEXT TO CONTINUE PROCESSING STEPS 
         323+ 8    0 EOR      + NOOP      0000         END OF REGION  
         324+10  324          + R ADD     *
         325+ 1   53          + TR        PRTNLINE     
         326+ 0  101          + STOP      0101         STRINGZ AT COL 1
         327+ 0 1776          + STOP      MSGNREFS     "REFERENCES"
         328+ 0  210          + STOP      0210         INT AT COL 10
         329+ 0  935          + STOP      NREFS        NUMBER OF REFERENCES IN REGION
         330+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         331+10  935          + R ADD     NREFS        SAVE UPDATED (RESOLVED) REFERENCE LIST
         332+ 9 1738          + ADD       ONE          NUMBER OF FULL-WORDS TO SAVE ON TAPE
         333+21   19          + L RIGHT   0019         ((NREFS + 1) AND OCT 7776) + 2
         334+22   19          + A LEFT    0019
         335+ 9 1739          + ADD       TWO
         336+12  431          + STORE     VAL
         337+10  348          + R ADD     TREFAD1      SAVE TO TAPE TREFSN, THEN TREFS
         338+ 9  934          + ADD       MAXNREFS
         339+13  343          + STORE A   TREFAD2
         340+10  340          + R ADD     *            
         341+ 1   63          + TR        WRTAPE       WRITE MAGNETIC TAPE (REFERENCES TABLE)
         342+ 0  259          + STOP      TAPEOUTR
         343+ 0    0 TREFAD2  + STOP      /   /        BUF TO WRITE TO TAPE: DUMMY (2HW) + TREFSN
         344+ 0  431          + STOP      VAL          LEN
         345+10  345          + R ADD     *            
         346+ 1   63          + TR        WRTAPE       WRITE MAGNETIC TAPE (REFERENCES TABLE)
         347+ 0  259          + STOP      TAPEOUTR
         348+ 0  934 TREFAD1  + STOP      MAXNREFS     BUF TO WRITE TO TAPE: MAXNREFS (1HW) + NREFS (1HW) + TREFS
         349+ 0  431          + STOP      VAL          LEN
         350+ 1  177          + TR        READREG      PROCEED WITH NEXT REGION
         351+ 8    0 EOF      + NOOP      0000         END OF FILE
         352+27  259          + WRITE EF  TAPEOUTR     WRITE EOF IN TAPE OUT (STEP REFERENCES)
         353+30   74          + SENSE     0074         SENSE SWITCH 6
         354+ 1  360          + TR        ENDLOG1B     TR IF NO LOG SELECTED
         355+10  355          + R ADD     *
         356+ 1   53          + TR        PRTNLINE     
         357+ 0  101          + STOP      0101         STRINGZ AT COL 1
         358+ 0 1781          + STOP      MSGDONE      "END OF PASS"
         359+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         360+ 8    0 ENDLOG1B + NOOP      0000
         361+10  361          + R ADD     *
         362+ 1   65          + TR        RWDRUM       READ TREGIONS ARRAY FROM DRUM
         363+26  128          + WRITE     0128         DRUM INSTR
         364+ 0  202          + STOP      0202         DRUM ADDR 
         365+ 0  634          + STOP      TRNEEDCA     ADDR OF START OF TABLES
         366+ 0  100          + STOP      0100         LEN=TRNEEDCA (100 HW)
         367+28  257          + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE)
         368+28  258          + REWIND    TAPEINR      REWIND TAPE IN WITH STEP REFERENCES 
         369+28  259          + REWIND    TAPEOUTR     REWIND TAPE OUT WITH STEP REFERENCES UPDATED
         370+10  370          + R ADD     *
         371+ 1   51          + TR        CHAIN        IF SW2 IS ON, A +STOP 4095 IS EXECUTED 
         372+ 0  256          + STOP      PACTCOMP     CHAIN TO NEXT STAGE IN PACT COMPILER TAPE
         373+ 0 4095          + STOP      4095
         374+ 9 1739 ERROR    + ADD       TWO
         375+13  376          + STORE A   ERRP1
         376+10    0 ERRP1    + R ADD     /   /
         377+13  383          + STORE A   ERRSTRZ      SAVE ADDR OF ERROR TXT MESSAGE
         378+10  378          + R ADD     *            PRINT USER PROGRAM SOURCE CODE CARD JUST PROCESSED
         379+ 1   59          + TR        PRINTCRD
         380+10  380          + R ADD     *
         381+ 1   53          + TR        PRTNLINE     
         382+ 0  101          + STOP      0101         STRINGZ AT COL 1
         383+ 0    0 ERRSTRZ  + STOP      /   /        ERROR MESSAGE
         384+ 0    0          + STOP      0000         END OF LINE
         385+ 0  198          + STOP      READSTEP     IF USER PRESS STARTS, PROGRAM RESUMES PROCESSING NEXT SOURCE CODE STEP 
         386+     0  PACTSRC    RES       24           CARD IMAGE OF PACT SOURCE CODE CARD (12 FULL WORDS)
         410+     0  REGION     DEF       0
         411+     0  STEP       DEF       0            REGION = ALFA (<0)
         412+     0  OP         DEF       0            STEP   = INT (>0)
         413+     0  FACT       DEF       0            OP     = 0..43    =0 MEANS END OF REGION
         414+     0  S1         DEF       0            FACT   < 0 -> FACTOR IS AN ALFA SYMBOL (VAR, REGION, ...) 
         415+     0  S2         DEF       0            FACT = 0 -> BLANK FACTOR
         416+     0  QR         DEF       0            FACT = 0..9999 -> DESTINATION STEP FOR TRANSFER/RESULT OF STEP
         417+     0  QF         DEF       0            CLUE = -, R OR N
         418+     0  NUM        DEF       0            
         419+     0             DEF       0            S1/S2 = 0 -> BLANK, >0 -> INTEGER, <0 -> ALFA 
         420+     0  CLUE       DEF       0
         421+     0  STEPN      DEF       0            QR = +/- INTEGER OR BLANK. 
         422+     0  FACTN      DEF       0            QF = SET IF THERE IS AN INTEGER FACTOR/NUMBER IN CARD
         423+     0  FACTREG    DEF       0
         424+     0  S1N        DEF       0
         425+     0  S2N        DEF       0
         426+     0  D1N        DEF       0
         427+     0  D2N        DEF       0
         428+     0  NINST      DEF       0
         429+     0  NINCR      DEF       0
         430+    44  CCLEN      DEF       0044         LENGTH OF COMPACT CODE RECORD 
         431+     0  VAL        DEF       0            TEMP VAR (HERE TO MAKE TABLES START AT EVEN LOCATION)
         432+   100  MAXNREGS   DEF       100          MAX 100 REGIONS CAN DE DEFINED IN ONE PROGRAM 
         433+     0  NREGIONS   DEF       0            NUMBER OF REGIONS DEFINED
         434+     0  TREGIONS   RES       100          EACH ENTRY IN TABLE IS 1 HALF-WORD. HAS THE NAME (ALFA) OF REGION
         534+     0  TRISDUP    RES       100          =1 IF THIS REGION IS REFERENCED IN A DUP INSTR ELSEWHERE (IE THIS REGION IS DUPLICATED)
         634+     0  TRNEEDCA   RES       100          =1 IF REGION NEEDS A CALL INSTR AS FIRST STEP
         734+     0  TREXSIZE   RES       100          EXPANDED NUMBER OF STEPS OF REGION (NOT COUNTING EOR)
         834+     0  TREXTMP    RES       100          EXPANDED NUMBER OF NEEDED TEMP VARS IN REGION (=NUM OF STEPS REFERENCED AS RESULT OF STEP)
         934+   400  MAXNREFS   DEF       400          MAX 400 STEPS REFERENCES CAN DE DEFINED IN ONE REGION
         935+     0  NREFS      DEF       0            NUMBER OF ENTRIES IN TREFS TABLE
         936+     0  TREFS      RES       400          EACH ENTRY IN TABLE IS THE STEP REFERNECED
        1336+     0  TREFSN     RES       400          THE CORRESPONDING STEPN/TEMP VAR NUMBER
        1736+     0  ZERO       DEF       0
        1737+     0             DEF       0
        1738+     1  ONE        DEF       1
        1739+     2  TWO        DEF       2
        1740+     4  D4         DEF       4
        1741+    22  D22        DEF       22
        1742+    26  D26        DEF       26
        1743+     0  REF        DEF       0            REFERENCED STEP
        1744+     0  IREG       DEF       0            REGION NUMBER BEING PROCESSED (INDEX IN TREGIONS, IREG=1 -> FIRST ENTRY IN TREGIONS TABLE)
        1745+     0  IREGDUP    DEF       0
        1746+     0  TMPN       DEF       0            NUMBER OF TEMP VARS USED
        1747+     0  STEPCNT    DEF       0            STEP COUNTER TO SET STEPN
        1748- 69955  ERRREGNF   TXT       "REGION NOT FOUND",0
        1749- 49706  
        1750-  1275  
        1751- 73746  
        1752- 63818  
        1753- 36864  
        1754+     0  
        1755- 69967  ERRNOQR    TXT       "RESULT OF STEP SHOULD HAVE QR SET",0       ERROR: QR CANNOT BE BLANK IN A STEP CALLED-IN AS RESULT OF STEP
        1756- 77216  
        1757-  1314  
        1758-  1520  
        1759- 40512  
        1760- 72411  
        1761- 77200  
        1762-   973  
        1763- 79152  
        1764- 68256  
        1765- 72272  
        1766+     0  
        1767- 30655  MSGSTART   TXT       "ABSTRACT ASSEMBLY PASS 1",0
        1768- 75181  
        1769- 36096  
        1770- 31471  
        1771- 40382  
        1772- 57072  
        1773- 65167  
        1774- 71425  
        1775+     0  
        1776- 69954  MSGNREFS   TXT       "REFERENCES",0
        1777- 40625  
        1778- 60641  
        1779- 71424  
        1780+     0  
        1781- 40432  MSGDONE    TXT       "END OF PASS",0
        1782-  1314  
        1783-  1357  
        1784- 72912  
        1785+     0  
        1786- 70632  MSGRESTP   TXT       "RSLT OF STEP",0
        1787- 73755  
        1788- 41503  
        1789- 74572  
        1790+     0  
        1791- 75168  MSGTRDST   TXT       "TR DEST",0
        1792- 37711  
        1793- 73728  
        1794+     0  
        1796+15 1810 CLRBUF   + LOAD MQ   IOCL
        1797+14 1815          + STORE MQ  BUFIO
        1798+15 1836          + LOAD MQ   IOSTORE         
        1799+ 1 1807          + TR        INIT2
        1800+15 1832 READCRD  + LOAD MQ   IORDCRD
        1801+ 1 1805          + TR        INIT1
        1802+15 1834 WRITECRD + LOAD MQ   IOWRCRD
        1803+ 1 1805          + TR        INIT1
        1804+15 1835 PRINTCRD + LOAD MQ   IOPRCRD
        1805+14 1815 INIT1    + STORE MQ  BUFIO
        1806+15 1833          + LOAD MQ   IOCOPY         
        1807+14 1816 INIT2    + STORE MQ  BUFROW
        1808+ 9 1842          + ADD       TWO          
        1809+13 1831          + STORE A   EXIT
        1810+10 1838 IOCL     + R ADD     ZERO         RESET TO INITIAL COPY LOOP ADDRESS     
        1811+13 1816          + STORE A   BUFROW       FOR BUFFER
        1812+10 1816          + R ADD     BUFROW       X .*echo Print
        1813+ 5 1843          + SUB       D48          X 
        1814+12 1840          + STORE     ENDLP        X LOOP END VALUE
        1815- 0    0   BUFIO  - STOP      /   /        READ OR WRITE
        1816-31    0   BUFROW - COPY      /   /        COPY WORD TO/FROM PRINTER/CARDREADER
        1817+ 1 1821          + TR        BUFOK2       NORMAL PROCESSING 
        1818+ 1 1828          + TR        EODECK       FOR COPY READING END OF REG (=END OF DECK BEING READ)
        1819+ 6 1842          + R SUB     TWO          END OF FILE -> NO CARD TO READ -> STOP with Acc=-2
        1820+ 0 1815          + STOP      BUFIO        ON PRESSING START RETRY CARD READ
        1821+10 1816   BUFOK2 + R ADD     BUFROW       X
        1822+ 5 1842          + SUB       TWO          INCR BUF ADDR
        1823+13 1816          + STORE A   BUFROW       X
        1824+ 5 1840          + SUB       ENDLP        CHECK FOR END
        1825+ 4 1830          + TR 0      ENDIO
        1826+10 1838          + R ADD     ZERO         CLEAR ACC IN CASE WE ARE CLEANING THE BUFFER
        1827+ 1 1816          + TR        BUFROW
        1828+10 1841 EODECK   + R ADD     ONE          SET OV FLAG TO SIGNAL END OF DECK CONDITION
        1829+22   36          + A LEFT    36
        1830+26 2052 ENDIO    + WRITE     2052         END OF I/O: INSURE THAT MQ NOT IN USE            
        1831+ 1    0 EXIT     + TR        /   /
        1832+24 2048 IORDCRD  + READ      2048         PREPARE TO READ FROM CARD READER
        1833-31    0 IOCOPY   - COPY      /   /   
        1834+26 1024 IOWRCRD  + WRITE     1024         PREPARE TO PUNCH CARD 
        1835+26  512 IOPRCRD  + WRITE     0512         PREPARE WRITE PRTBUF ON PRINTER
        1836-12    0 IOSTORE  - STORE     /   /        CLEAR BUFFER
        1837+     0             ORG       EVEN           
        1838+     0  ZERO       DEF       0            
        1839+     0             DEF       0            
        1840+     0  ENDLP      DEF       0            LOOP END VALUE
        1841+     1  ONE        DEF       1
        1842+     2  TWO        DEF       2
        1843+    48  D48        DEF       48
        1844+ 9 2115 PRTPARM2 + ADD       TWO          GET 2 PARAMS: LEN AND COL (EITHER VALUE OR VAR ADDR)
        1845+13 1864          + STORE A   PRTPRMEX
        1846+10 1854          + R ADD     PRTP1
        1847+ 9 2115          + ADD       TWO          PRINT PACKED TEXT FROM FULL-WORD VALUE IN MQ REGISTER 
        1848+13 1854          + STORE A   PRTP1        STORE ADDR OF FIRST PARAM (LEN)
        1849+ 9 2114          + ADD       ONE
        1850+13 1856          + STORE A   PRTP2        STORE ADDR OF SECOND PARAM (COL)
        1851+ 9 2114          + ADD       ONE
        1852+13 1931          + STORE A   EXIT
        1853-14 2104          - STORE MQ  NUM          SAVE VALUE TO PRINT PARAM MQ (NUM IS ALIASED TO TXT)
        1854+10    0   PRTP1  + R ADD     /   /        GET LEN: NUMBER OF CHARS TO PRINT (1..6)
        1855+12 2108          + STORE     LEN
        1856+10    0   PRTP2  + R ADD     /   /        GET COLUMN PARAM 1..72
        1857+ 3 1860          + TR +      PRTP4
        1858+13 1859          + STORE A   PRTP3        COL<0 -> INTERPRET COL AS LOC(COL) = ADDR OF COL VAR
        1859+10    0   PRTP3  + R ADD     /   /        READ VAR COL PASED AS PARAM
        1860+ 4 1931   PRTP4  + TR 0      EXIT         COL=0 -> EXIT
        1861+ 3 1863          + TR +      PRTP5
        1862+ 1 1931          + TR        EXIT         COL<0 -> EXIT
        1863+12 1914   PRTP5  + STORE     COL
        1864+ 1    0 PRTPRMEX + TR        /   /        RETURN TO CALLER
        1865+13 1854 PRTSTR   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        1866+10 1866          + R ADD     *            FOR PRINT STRINGZ FROM MEM
        1867+ 1 1844          + TR        PRTPARM2
        1868+12 1878          + STORE     COLSZ
        1869+10 2108          + R ADD     LEN          LEN IS IN FACT THE LOCATION WHERE THE STRING STARTS
        1870+13 1873          + STORE A   STRZAD
        1871+10 1931          + R ADD     EXIT
        1872+13 1886          + STORE A   STRZEX
        1873+10    0 STRZAD   + R ADD     /   /        GET HALF-WORD WITH NEXT 3 CHARS TO PRINT
        1874+ 4 1886          + TR 0      STRZEX       IF +0 -> END OF STRING (-0 DOES NOT TERMINATES THE STRING)
        1875+21   35          + L RIGHT   0035         MQ=3-CHARS TO PRINT
        1876+10 1876          + R ADD     *            
        1877+ 1 1888          + TR        PRTALF       PRINT 3 CHARS
        1878+ 0    0 COLSZ    + STOP      0000         COL 
        1879+10 1873 STRZ1    + R ADD     STRZAD       INCR STRING ADDRESS
        1880+ 9 2114          + ADD       ONE
        1881+13 1873          + STORE A   STRZAD
        1882+10 1878          + R ADD     COLSZ        INCR COLUMN
        1883+ 9 2116          + ADD       D3
        1884+13 1878          + STORE A   COLSZ
        1885+ 1 1873          + TR        STRZAD
        1886+ 3    0 STRZEX   + TR +      /   /        IF ZERO -> END OF STRING
        1887+ 1 1879          + TR        STRZ1
        1888+ 9 2115 PRTALF   + ADD       TWO          PRINT 3-PACKED CHARS IN MQ REGISTER 
        1889+14 2110          + STORE MQ  TXT          SAVE TEXT TO PRINT (IN LEFT HALF WORD)
        1890+13 1893          + STORE A   PRTAP2       STORE ADDR OF PARAM (COL)
        1891+ 9 2114          + ADD       ONE
        1892+13 1931          + STORE A   EXIT
        1893+10    0   PRTAP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        1894+ 3 1897          + TR +      PRTAP4
        1895+13 1896          + STORE A   PRTAP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        1896+10    0   PRTAP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        1897+12 1914   PRTAP4 + STORE     COL
        1898+10 2116          + R ADD     D3
        1899+12 2108          + STORE     LEN
        1900+10 2098 PRT1     + R ADD     ZERO         UNPACK LEFTMOST CHAR 
        1901+11 2110          + ADD AB    TXT          GET TEXT DISCARD SIGN
        1902+21   35          + L RIGHT   0035         MQ=Acc
        1903+10 2098          + R ADD     ZERO
        1904+18 2123          + DIV       D48X48
        1905+12 2110          + STORE     TXT          remainder=char to print, mq=c2 * 48 + c3 in right half-word
        1906+10 2098          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        1907+20   18          + L LEFT    0018         put c2 and c3 in left half-word of MQ to be saved in CHAR half word
        1908+14 2109          + STORE MQ  CHAR         CHAR TO PRINT
        1909+10 2109          + R ADD     CHAR 
        1910+ 4 1915          + TR 0      NXTCHR       IF BLANK PROCEED TO NEXT COL
        1911+21   35          + L RIGHT   0035         MQ=CHAR TO PRINT
        1912+10 1912          + R ADD     *            PRINT CHAR
        1913+ 1 2008          + TR        PRTCHR
        1914+ 0    0 COL      + STOP      0000         COL: COLUMN NUMBER TO PRINT (1..72)
        1915+10 2108 NXTCHR   + R ADD     LEN          DECR LEN COUNT
        1916+ 5 2114          + SUB       ONE
        1917+12 2108          + STORE     LEN
        1918+ 4 1931          + TR 0      EXIT         IF NO MORE CHARS TO PRINT EXIT
        1919+10 1914          + R ADD     COL          INCR COL POSITION
        1920+ 9 2114          + ADD       ONE
        1921+12 1914          + STORE     COL
        1922+ 5 2122          + SUB       D72          IF COL > 72 RETURN TO CALLER
        1923+ 4 1925          + TR 0      GNXTCHR      ELSE PROCEED WITH NEXT CHAR
        1924+ 3 1931          + TR +      EXIT
        1925+10 2098 GNXTCHR  + R ADD     ZERO         GET NEXT CHAR 
        1926+15 2110          + LOAD MQ   TXT
        1927+16 2121          + MPY       D48
        1928+22   17          + A LEFT    0017         GET RESULT IN LEFT HALF-WORD OF ACC
        1929+12 2110          + STORE     TXT
        1930+ 1 1900          + TR        PRT1         PROCEED TO PRINT CHAR
        1931+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        1932+13 1854 PRTOCT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        1933+10 1933          + R ADD     *            FOR PRINT OCTIONARY VALUE
        1934+ 1 1844          + TR        PRTPARM2
        1935+10 2108          + R ADD     LEN          LEN = OCTAL DIGITS TO PRINT
        1936+ 9 1914          + ADD       COL
        1937+ 5 2114          + SUB       ONE
        1938+12 1950          + STORE     COLN         COL POINTS TO LEAST SIGNIFICANT DIGIT
        1939+10 2104 PRTIOCG  + R ADD     NUM          GENERATE OCTINARY DIGIT
        1940+15 2098          + LOAD MQ   ZERO         CLEAR MQ
        1941+21   21          + L RIGHT   0021         3 LSB BITS OF LEFT HALF-WORD OF ACC TO MQ
        1942+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 3 BIT)
        1943+12 2104          + STORE     NUM          SAVE BACK NUM WITH RIGHTMOST OCTIONARY DIGIY EXTRACTED (NUM'=NUM/8)
        1944+10 2098          + R ADD     ZERO
        1945+20   21          + L LEFT    0021         LEFT HALF-WORD OF ACC IS NOW RIGHTMOST OCTINARY DIGIT EXTRACTED FROM NUM 
        1946+ 4 1964          + TR 0      PRTIOZ       TR IF THIS DIGIT IS ZERO TO PRINT A '0' (BASE48 CODE = 10) INSTEAD OF A BLANK (BASE48 CODE = 0)
        1947+21   35          + L RIGHT   0035         PUT DIGIT 1..9 TO PRINT IN MQ
        1948+10 1948 PRTOCTD  + R ADD     *            PRINT OCTINARY DIGIT
        1949+ 1 2008          + TR        PRTCHR
        1950+ 0    0 COLN     + STOP      0000
        1951+10 1950          + R ADD     COLN        DECR COL NUMBER TO PRINT NEXT DIGIT
        1952+ 5 2114          + SUB       ONE
        1953+12 1950          + STORE     COLN
        1954+10 2108          + R ADD     LEN          DECR COL NUMBER TO PRINT NEXT DIGIT
        1955+ 5 2114          + SUB       ONE
        1956+ 4 1931          + TR 0      EXIT         PRINTED LEN OCTINARY DIGITS -> EXIT
        1957+12 2108          + STORE     LEN
        1958+10 2104          + R ADD     NUM          IF NUM < 0, ADD SIGN BIT TO LEFTMOST DIGIT
        1959+ 3 1939          + TR +      PRTIOCG
        1960+10 2124          + R ADD     OCT04K       
        1961+ 5 2104          + SUB       NUM
        1962+12 2104          + STORE     NUM
        1963+ 1 1939          + TR        PRTIOCG
        1964+15 2117   PRTIOZ + LOAD MQ   D10          ACC=BASE48 CODE FOR '0'
        1965+ 1 1948          + TR        PRTOCTD      TR TO PRINT IT
        1966+13 1854 PRTINT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        1967+10 1967          + R ADD     *            FOR PRINT OCTIONARY VALUE
        1968+ 1 1844          + TR        PRTPARM2
        1969+10 1914          + R ADD     COL          PRINT DECIMAL NUMBER. VALUE OF LEN = DIGITS TO PRINT, NOT INCLUDING SIGN
        1970+ 9 2108          + ADD       LEN
        1971+ 5 2114          + SUB       ONE          
        1972+12 1993          + STORE     COLNI        COL POINTS TO END OF NUMBER
        1973+10 2098          + R ADD     ZERO
        1974+12 2107          + STORE     SGN          SIGN IS POSITIVE
        1975+10 2104          + R ADD     NUM
        1976+ 3 1981          + TR +      PRTINTG
        1977+ 6 2104          + R SUB     NUM          NUM IS NEGATIVE. CONVERT TO POSITIVE
        1978+12 2104          + STORE     NUM          AND SET SGN=1
        1979+10 2114          + R ADD     ONE
        1980+12 2107          + STORE     SGN          
        1981+10 2104 PRTINTG  + R ADD     NUM          GENERATE DECIMAL DIGIT
        1982+21   35          + L RIGHT   0035         MQ=Acc
        1983+10 2098          + R ADD     ZERO
        1984+18 2117          + DIV       D10
        1985+ 4 2006          + TR 0      PRTINZ
        1986+12 2109 PRTINTG2 + STORE     CHAR         acc=remainder=digit to print, mq=num/10
        1987+10 2098          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        1988+20   18          + L LEFT    0018         digit in left half-word of MQ to be saved in CHAR half word
        1989+14 2104          + STORE MQ  NUM 
        1990+15 2109          + LOAD MQ   CHAR 
        1991+10 1991 PRTINTD  + R ADD     *            PRINT DECIMAL DIGIT
        1992+ 1 2008          + TR        PRTCHR
        1993+ 0    0 COLNI    + STOP      0000
        1994+10 1993          + R ADD     COLNI        DECR COL NUMBER TO PRINT NEXT DIGIT
        1995+ 5 2114          + SUB       ONE
        1996+12 1993          + STORE     COLNI
        1997+10 2104          + R ADD     NUM          DO NOT CARE ABOUT LEN, JUST CHECK IF NUM=0 
        1998+ 4 2000          + TR 0      PRTINS       (SO NO MORE DIGITS REMAINS TO BE PRINTED)
        1999+ 1 1981          + TR        PRTINTG      NUM NOT FINISHED, PROCEED WITH NEXT DIGIT
        2000+10 2107 PRTINS   + R ADD     SGN
        2001+ 4 1931          + TR 0      EXIT         NO SIGN -> NUM FINISHED
        2002+10 2098          + R ADD     ZERO
        2003+12 2107          + STORE     SGN          CLEAR SGN FLAG
        2004+15 2118          + LOAD MQ   D11          BASE48 CODE FOR '-' (MINUS) CHAR
        2005+ 1 1991          + TR        PRTINTD      GO TO PRINT IT
        2006+10 2117   PRTINZ + R ADD     D10          ACC=BASE48 CODE FOR '0'
        2007+ 1 1986          + TR        PRTINTG2     TR TO PRINT IT
        2008+ 9 2115 PRTCHR   + ADD       TWO          PRINT CHAR IN MQ REGISTER 
        2009+14 2109          + STORE MQ  CHAR         SAVE CHAR TO PRINT (IN LEFT HALF WORD)
        2010+13 2014          + STORE A   PRTCP2       STORE ADDR OF PARAM (COL)
        2011+ 9 2114          + ADD       ONE
        2012+13 2092          + STORE A   PRTCEX
        2013+ 2 2014          + TR OV     PRTCP2       CLEAR OV JUST IN CASE
        2014+10    0   PRTCP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        2015+ 3 2018          + TR +      PRTCP4
        2016+13 2017          + STORE A   PRTCP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        2017+10    0   PRTCP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        2018+ 5 2114   PRTCP4 + SUB       ONE
        2019+12 2112          + STORE     N            N=COL-1 -> IN RANGE 0..71
        2020+ 3 2022          + TR +      PRTSA        IF N >= 0 PROCEED WITH BASE BUFFER ADDR CALCULATION
        2021+ 1 2092          + TR        PRTCEX       IF N<0 EXIT
        2022+10 2098    PRTSA + R ADD     ZERO         CARD BUFFER USES LOCATION 0..47
        2023+13 2111          + STORE A   PRTROWAD     DETERMINE ADDRESS OF LOWER ROW TO PRINT
        2024+10 2112          + R ADD     N
        2025+ 5 2120          + SUB       D36
        2026+ 3 2028          + TR +      PRTC0
        2027+ 1 2034          + TR        PRTC1
        2028+12 2112    PRTC0 + STORE     N            COL NOW 0..35 
        2029+ 5 2120          + SUB       D36
        2030+ 3 2092          + TR +      PRTCEX       IF COL >= 36 (IE COL PASSED AS PARAM > 72) THEN EXIT
        2031+10 2111          + R ADD     PRTROWAD
        2032+ 9 2115          + ADD       TWO
        2033+13 2111          + STORE A   PRTROWAD     SET BASE BUFFER ADDR 
        2034+10 2114    PRTC1 + R ADD     ONE          DETERMINE MASKCOL WITH MASK TO SET IN CARD BUFFER
        2035+21   53          + L RIGHT   53           SET RIGHTMOST BIT OF MQ TO 1 (SHIFT 35+18=53)
        2036+10 2119          + R ADD     D35
        2037+ 5 2112          + SUB       N
        2038+13 2040          + STORE A   PRTC2
        2039+10 2098          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW
        2040+20    0    PRTC2 + L LEFT    /   /        SHIFT MQ LEFT N PLACES
        2041+ 4 2044          + TR 0      PRTC3        IF ACC STILL ZERO -> MASKCOL VALID
        2042+ 6 2114          + R SUB     ONE          ACC NOT ZERO -> SHOULD GENERATE -0 TO SET SIGN BIT ON
        2043+21   72          + L RIGHT   0072         NOW MQ = -0 -> LEFTMOST BIT OF MQ SET
        2044-14 2100    PRTC3 - STORE MQ  MASKCOL
        2045+10 2098          + R ADD     ZERO         READ THE BITMAP OF CHAR 
        2046+11 2109          + ADD AB    CHAR         DISCARD SIGN OF CHAR, IF ANY
        2047+12 2109          + STORE     CHAR
        2048+ 5 2121          + SUB       D48
        2049+ 3 2092          + TR +      PRTCEX       IF CHAR >= 48 EXIT
        2050+10 2106          + R ADD     BITMAPAD     IF ADDR OF BASE48 BITMAP NOT COMPUTED
        2051+ 4 2093          + TR 0      GETBMP1      TR TO LOAD IT
        2052+ 9 2109  GETBMP2 + ADD       CHAR         READ THE BITMAP OF CHAR 
        2053+13 2054          + STORE A   PRTC4        INDICATES THE BITS TO SET IN SELECTED 
        2054+10    0    PRTC4 + R ADD     /   /        COLUMN OF CARD BUFFER 
        2055+12 2113          + STORE     BITS
        2056+ 6 2114          + R SUB     ONE
        2057+12 2112          + STORE     N            SET TO -1
        2058+10 2112    LOOP1 + R ADD     N            CURRENT ROW (STARTS AT ZERO) = OFFSET ON PRTROWAD     
        2059+ 9 2114          + ADD       ONE
        2060+12 2112          + STORE     N
        2061+10 2113          + R ADD     BITS         EXTRACT RIGHTMOST BIT OF LEFT HALF OF ACC TO MQ
        2062+ 4 2092          + TR 0      PRTCEX       NO MORE BITS -> EXIT
        2063+21   19          + L RIGHT   0019         LSB BIT OF LEFT HALF-WORD OF ACC TO MQ
        2064+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 1 BIT)
        2065+12 2113          + STORE     BITS         SAVE BACK BITS. LSB HAS BEEN EXTACTED, CONTENTS SHIFTED RIGHT ONE PLACE
        2066+10 2098          + R ADD     ZERO
        2067+20    1          + L LEFT    0001         PUT EXTACTED BIT BACK INTO ACC
        2068+ 4 2058          + TR 0      LOOP1        NO BIT 
        2069+10 2112          + R ADD     N            READ THE ROW N AT CARD BUFFER 
        2070+22    2          + A LEFT    0002         MULT N BY 4 AS THERE ARE 4 HALF WORDS PER ROW
        2071+ 9 2111          + ADD       PRTROWAD     
        2072+13 2074          + STORE A   PRTROWR
        2073+13 2090          + STORE A   PRTROWW
        2074-10    0  PRTROWR - R ADD     /   /        
        2075-12 2102          - STORE     ROW          CURRENT CONTENTS OF ROW
        2076-10 2100          - R ADD     MASKCOL      "OR" MASKCOL IN SELECTED ROW
        2077+ 3 2085          + TR +      PRTW2
        2078-10 2102          - R ADD     ROW 
        2079+ 4 2083          + TR 0      PRTW1         
        2080+10 2098          + R ADD     ZERO         MASKCOL IS MINUS ZERO AND ROW IS NOT-EMPTY (EITHER POSITIVE OR NEGATIVE) -> SET ROW AS NEGATIVE
        2081- 7 2102          - SUB AB    ROW 
        2082+ 1 2090          + TR        PRTROWW
        2083-10 2100    PRTW1 - R ADD     MASKCOL      MASKCOL IS MINUS ZERO AND ROW IS EMPTY -> SET ROW = MASKCOL = MINUS ZERO
        2084+ 1 2090          + TR        PRTROWW
        2085-10 2102    PRTW2 - R ADD     ROW          
        2086+ 3 2089          + TR +      PRTW3              
        2087- 5 2100          - SUB       MASKCOL      MASKCOL IS POSITIVE AND ROW IS NEGATIVE -> SUB MASKCOL FROM ROW
        2088+ 1 2090          + TR        PRTROWW
        2089- 9 2100    PRTW3 - ADD       MASKCOL      MASKCOL IS POSITIVE AND ROW IS POSITIVE OR EMPTY -> ADD MASKCOL TO ROW         
        2090-12    0  PRTROWW - STORE     /   /        ROW UPDTATE
        2091+ 1 2058          + TR        LOOP1        PROCEED TO NEXT ROW
        2092+ 1    0 PRTCEX   + TR        /   /
        2093+10 2093 GETBMP1  + R ADD     *
        2094+ 1   87          + TR        BMPAD        GET BASE48 CHARS BITMAP ADDRESS
        2095+12 2106          + STORE     BITMAPAD     
        2096+ 1 2052          + TR        GETBMP2      RETURN
        2097+     0             ORG       EVEN
        2098+     0  ZERO       DEF       0            
        2099+     0             DEF       0            
        2100+     0  MASKCOL    DEF       0
        2101+     0             DEF       0
        2102+     0  ROW        DEF       0
        2103+     0             DEF       0
        2104+     0  NUM        DEF       0
        2105+     0             DEF       0
        2106+     0  BITMAPAD   DEF       0
        2107+     0  SGN        DEF       0
        2108+     0  LEN        DEF       0
        2109+     0  CHAR       DEF       0
        2110+     0  TXT        DEF       0
        2111+     0  PRTROWAD   DEF       0
        2112+     0  N          DEF       0
        2113+     0  BITS       DEF       0
        2114+     1  ONE        DEF       1
        2115+     2  TWO        DEF       2
        2116+     3  D3         DEF       3
        2117+    10  D10        DEF       10
        2118+    11  D11        DEF       11
        2119+    35  D35        DEF       35
        2120+    36  D36        DEF       36
        2121+    48  D48        DEF       48
        2122+    72  D72        DEF       72
        2123+  2304  D48X48     DEF       2304
        2124+ 16384  OCT04K     DEF       *040000      BIT SIGN ON 5TH OCTINARY DIGIT
        2126+ 9 2201 PRTNLINE + ADD       TWO          PRINT A NEW LINE OF DATA
        2127+12 2204          + STORE     PARAM        SAVE PARAM LIST ADDR
        2128+10 2128          + R ADD     *            CLEAR CARD BUFFER
        2129+ 1   75          + TR        CLRBUF 
        2130+10 2204 GPARAM   + R ADD     PARAM        GET PARAM PAIR FMT/DATA
        2131+13 2136          + STORE A   P1
        2132+ 9 2200          + ADD       ONE
        2133+13 2140          + STORE A   P2
        2134+ 9 2200          + ADD       ONE
        2135+12 2204          + STORE     PARAM
        2136+10    0 P1       + R ADD     /   /
        2137+12 2206          + STORE     FMT
        2138+ 3 2140          + TR +      P2           IF FMT < 0 THEM SKIP THIS PAIR FMT/DATA
        2139+ 1 2130          + TR        GPARAM
        2140+10    0 P2       + R ADD     /   /
        2141+12 2166          + STORE     DATALOC      GET DATA ADDRESS PASED AS PARAM
        2142+13 2143          + STORE A   P2A
        2143+10    0 P2A      + R ADD     /   /
        2144+12 2205          + STORE     DATA         GET EFFECTIVE DATA
        2145+10 2199          + R ADD     ZERO
        2146+15 2206          + LOAD MQ   FMT
        2147+18 2203          + DIV       D100         ACC=REMAINDER=COL NUMBER, MQ=QUOTIEN=TYPE OF DATA
        2148+12 2207          + STORE     COL
        2149+10 2199          + R ADD     ZERO
        2150+20   18          + L LEFT    0018
        2151+14 2206          + STORE MQ  FMT
        2152+15 2205          + LOAD MQ   DATA
        2153+10 2157          + R ADD     TYPETRAD
        2154+ 9 2206          + ADD       FMT
        2155+13 2156          + STORE A   TYPETR
        2156+ 1    0 TYPETR   + TR        /   /        TR SELECTED ROUTINE
        2157+ 0 2158 TYPETRAD + STOP      TYPETRT      TYPE TRANSFER TABLE ADDRESS
        2158+ 1 2187 TYPETRT  + TR        EOL          FMT=0..6 (IE <100) -> END OF PARAM LIST -> END OF LINE 
        2159+ 1 2164          + TR        TYSTR        FMT=1 -> PRINT A STRINGZ
        2160+ 1 2169          + TR        TYINT        FMT=2 -> PRINT AN INT
        2161+ 1 2174          + TR        TYOCT        FMT=3 -> PRINT AN OCT
        2162+ 1 2179          + TR        TYCHR        FMT=4 -> PRINT A CHAR
        2163+ 1 2183          + TR        TYALF        FMT=5 -> PRINT A 3-CHR PACKED ALFA STRING
        2164+10 2164 TYSTR    + R ADD     *            PRINT STRINGZ
        2165+ 1   55          + TR        PRTSTR
        2166+ 0    0 DATALOC  + STOP      /   /
        2167- 0 2207          - STOP      COL          COLUMN WHERE TXT STARTS
        2168+ 1 2130          + TR        GPARAM
        2169+10 2169 TYINT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2170+ 1   57          + TR        PRTINT
        2171+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        2172- 0 2207          - STOP      COL          COLUMN WHERE TXT STARTS
        2173+ 1 2130          + TR        GPARAM
        2174+10 2174 TYOCT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2175+ 1   85          + TR        PRTOCT
        2176+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        2177- 0 2207          - STOP      COL          COLUMN WHERE TXT STARTS
        2178+ 1 2130          + TR        GPARAM
        2179+10 2179 TYCHR    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2180+ 1   83          + TR        PRTCHR
        2181- 0 2207          - STOP      COL          COLUMN WHERE TXT STARTS
        2182+ 1 2130          + TR        GPARAM
        2183+10 2183 TYALF    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2184+ 1   81          + TR        PRTALF
        2185- 0 2207          - STOP      COL          COLUMN WHERE TXT STARTS
        2186+ 1 2130          + TR        GPARAM
        2187+10 2207 EOL      + R ADD     COL          SEND CARD BUFFER TO PRINTER AND RETURN TO CALLER
        2188+ 4 2193          + TR 0      DOPRINT      =0 -> PRINT ALLWAYS (NO SENSE SW CHECK)
        2189+ 9 2202          + ADD       D68          =1..6 -> SENSE 69..74 = OPERATOR'S PANEL SENSE SWITCH 1..6
        2190+13 2191          + STORE A   CHKSW
        2191+30    0 CHKSW    + SENSE     /   /         
        2192+ 1 2195          + TR        RETURN       SW NOT AT ON POSITION
        2193+10 2193 DOPRINT  + R ADD     *            PRINT CARD BUFFER
        2194+ 1   59          + TR        PRINTCRD
        2195+10 2204 RETURN   + R ADD     PARAM        PARAM-1 IS THE RETURN ADDR      
        2196+ 5 2200          + SUB       ONE
        2197+13 2198          + STORE A   EXIT
        2198+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        2199+ 0    0 ZERO     + STOP      0000
        2200+ 0    1 ONE      + STOP      0001
        2201+ 0    2 TWO      + STOP      0002
        2202+ 0   68 D68      + STOP      0068
        2203+ 0  100 D100     + STOP      100
        2204+ 0    0 PARAM    + STOP      0000
        2205+ 0    0 DATA     + STOP      0000
        2206+ 0    0 FMT      + STOP      0000
        2207+ 0    0 COL      + STOP      0000
        2208+ 9 2222 BMPAD    + ADD       TWO
        2209+13 2211          + STORE A   EXIT
        2210+10 2212          + R ADD     BITMAPAD
        2211+ 1    0 EXIT     + TR        /   /
        2212+ 0 2214 BITMAPAD + STOP      BITMAP
        2213+     0             ORG       EVEN
        2214+     0  BITMAP     DEF       0              <blank>     0     <none>
        2215+   256             DEF       256               1        1       1        256          =  256   
        2216+   128             DEF       128               2        2       2        128          =  128   
        2217+    64             DEF       64                3        3       3         64          =   64   
        2218+    32             DEF       32                4        4       4         32          =   32   
        2219+    16             DEF       16                5        5       5         16          =   16   
        2220+     8             DEF       8                 6        6       6          8          =    8   
        2221+     4             DEF       4                 7        7       7          4          =    4   
        2222+     2  TWO        DEF       2                 8        8       8          2          =    2   
        2223+     1             DEF       1                 9        9       9          1          =    1   
        2224+   512             DEF       512               0       10       0        512          =  512   
        2225+  1024             DEF       1024              -       11       X       1024          = 1024   
        2226+  2048             DEF       2048              +       12       Y       2048          = 2048   
        2227+  2304             DEF       2304              A       13      Y-1        256+2048    = 2304   
        2228+  2176             DEF       2176              B       14      Y-2        128+2048    = 2176   
        2229+  2112             DEF       2112              C       15      Y-3         64+2048    = 2112   
        2230+  2080             DEF       2080              D       16      Y-4         32+2048    = 2080   
        2231+  2064             DEF       2064              E       17      Y-5         16+2048    = 2064   
        2232+  2056             DEF       2056              F       18      Y-6          8+2048    = 2056   
        2233+  2052             DEF       2052              G       19      Y-7          4+2048    = 2052   
        2234+  2050             DEF       2050              H       20      Y-8          2+2048    = 2050   
        2235+  2049             DEF       2049              I       21      Y-9          1+2048    = 2049   
        2236+  1280             DEF       1280              J       22      X-1        256+1024    = 1280   
        2237+  1152             DEF       1152              K       23      X-2        128+1024    = 1152   
        2238+  1088             DEF       1088              L       24      X-3         64+1024    = 1088   
        2239+  1056             DEF       1056              M       25      X-4         32+1024    = 1056   
        2240+  1040             DEF       1040              N       26      X-5         16+1024    = 1040   
        2241+  1032             DEF       1032              O       27      X-6          8+1024    = 1032   
        2242+  1028             DEF       1028              P       28      X-7          4+1024    = 1028   
        2243+  1026             DEF       1026              Q       29      X-8          2+1024    = 1026   
        2244+  1025             DEF       1025              R       30      X-9          1+1024    = 1025   
        2245+   640             DEF       640               S       31      0-2        128+512     = 640    
        2246+   576             DEF       576               T       32      0-3         64+512     = 576    
        2247+   544             DEF       544               U       33      0-4         32+512     = 544    
        2248+   528             DEF       528               V       34      0-5         16+512     = 528    
        2249+   520             DEF       520               W       35      0-6          8+512     = 520    
        2250+   516             DEF       516               X       36      0-7          4+512     = 516    
        2251+   514             DEF       514               Y       37      0-8          2+512     = 514    
        2252+   513             DEF       513               Z       38      0-9          1+512     = 513    
        2253+   578             DEF       578               ,       39      8-3-0        2+64+512  = 578    
        2254+   546             DEF       546               %       40      8-4-0        2+32+512  = 546    
        2255+  1090             DEF       1090              $       41      8-3-X        2+64+1024 = 1090   
        2256+  1058             DEF       1058              *       42      8-4-X        2+32+1024 = 1058   
        2257+  2114             DEF       2114              .       43      8-3-Y        2+64+2048 = 2114   
        2258+  2082             DEF       2082              #       44      8-4-Y        2+32+2048 = 2082   
        2259+   768             DEF       768               /       45      0-1          512+256   = 768    
        2260+    66             DEF       66                +       46      8-3          2+64      = 66     
        2261+    34             DEF       34                -       47      8-4          2+32      = 34    This is the non-minus-sign separator
        2262+ 9 2286 CLMEM    + ADD       TWO 
        2263+13 2268          + STORE A   P1           PARM: ADDR 
        2264+ 9 2285          + ADD       ONE          
        2265+13 2270          + STORE A   P2           PARM: LOCATION OF LEN=NUMBER OF HALF-WORDS TO CLEAR 
        2266+ 9 2285          + ADD       ONE          
        2267+13 2276          + STORE A   EXIT
        2268+10    0 P1       + R ADD     /   /        GET ADDR TO CLEAR
        2269+13 2279          + STORE A   MEM
        2270+10    0 P2       + R ADD     /   /        GET LEN ADDR
        2271+13 2272          + STORE A   P2A
        2272+10    0 P2A      + R ADD     /   /        GET LEN 
        2273+12 2287          + STORE     LEN
        2274+15 2284          + LOAD MQ   ZERO
        2275+10 2287 LOOP     + R ADD     LEN
        2276+ 4    0 EXIT     + TR 0      /   /
        2277+ 5 2285          + SUB       ONE
        2278+12 2287          + STORE     LEN
        2279+14    0 MEM      + STORE MQ  /   /        
        2280+10 2279          + R ADD     MEM
        2281+ 9 2285          + ADD       ONE
        2282+13 2279          + STORE A   MEM
        2283+ 1 2275          + TR        LOOP
        2284+ 0    0 ZERO     + STOP      0000
        2285+ 0    1 ONE      + STOP      0001         constant 1
        2286+ 0    2 TWO      + STOP      0002         constant 2
        2287+ 0    0 LEN      + STOP      0000
        2288+15 2355 SRCHTBL  + LOAD MQ   ZERO
        2289+ 1 2293          + TR        START
        2290+15 2356 EQTBL    + LOAD MQ   ONE
        2291+ 1 2293          + TR        START
        2292+15 2357 READTBL  + LOAD MQ   TWO
        2293+ 9 2357 START    + ADD       TWO 
        2294+13 2301          + STORE A   P1           PARM: ADDR OF TABLE
        2295+ 9 2356          + ADD       ONE          
        2296+13 2303          + STORE A   P2           PARM: LEN OF TABLE
        2297+ 9 2356          + ADD       ONE          
        2298+13 2308          + STORE A   P3           PARM: VAL TO FIND
        2299+ 9 2356          + ADD       ONE          
        2300+13 2349          + STORE A   EXIT
        2301+10    0 P1       + R ADD     /   /        GET ADDR OF TABLE
        2302+13 2352          + STORE A   TBL
        2303+10    0 P2       + R ADD     /   /        GET ADDR OF LEN OF TABLE/ENTRY ON TABLE
        2304+13 2305          + STORE A   P2A
        2305+10    0 P2A      + R ADD     /   /        DERREFERENCE -> ACC=LEN/ENTRY (1..LEN)
        2306+12 2350          + STORE     N
        2307+ 4 2349          + TR 0      EXIT         EXIT, CANNOT READ/STORE ON ENTRY 0, SEARCH ON EMPTY TABLE
        2308+10    0 P3       + R ADD     /   /        GET ADDR OF VAL TO FIND
        2309+13 2325          + STORE A   WRVAL
        2310+13 2311          + STORE A   P3A
        2311+10    0 P3A      + R ADD     /   /        DERREFERENCE -> ACC=VAL
        2312+12 2351          + STORE     VAL
        2313+14 2354          + STORE MQ  TEMP         JUMP TABLE DISPATCH
        2314+10 2354          + R ADD     TEMP
        2315+ 4 2330          + TR 0      LOOP0        TR TO SEARCH TABLE
        2316+10 2350          + R ADD     N            SUB ONE AS FIRST ENTRY ON TABLE IS "1"
        2317+ 5 2356          + SUB       ONE          
        2318+ 9 2352          + ADD       TBL          TABLE BASE ADDR
        2319+13 2328          + STORE A   WRTBL
        2320+13 2324          + STORE A   RDTBL2
        2321+10 2354          + R ADD     TEMP
        2322+ 5 2356          + SUB       ONE
        2323+ 4 2327          + TR 0      STORETBL 
        2324+10    0 RDTBL2   + R ADD     /   /        VAL=TBL[ENT]
        2325+12    0 WRVAL    + STORE     /   /
        2326+ 1 2349          + TR        EXIT
        2327+10 2351 STORETBL + R ADD     VAL          TBL[ENT]=VAL
        2328+12    0 WRTBL    + STORE     /   /    
        2329+ 1 2349          + TR        EXIT
        2330+10 2352 LOOP0    + R ADD     TBL
        2331+13 2337          + STORE A   RDTBL
        2332+10 2337          + R ADD     RDTBL
        2333+12 2353          + STORE     TBL0
        2334+ 9 2350          + ADD       N
        2335+12 2354          + STORE     TEMP         THE END ADDR OF TABLE
        2336+10 2351 LOOP     + R ADD     VAL          ACC=THE SEARCHED VALUE
        2337+ 5    0 RDTBL    + SUB       /   /    
        2338+ 2 2339          + TR OV     OVOK         CLEAR OV JUST IN CASE
        2339+ 4 2346 OVOK     + TR 0      FOUND        TR IF VAL FOUND IN ENTRY N
        2340+10 2337          + R ADD     RDTBL
        2341+ 9 2356          + ADD       ONE
        2342+13 2337          + STORE A   RDTBL
        2343+ 5 2354          + SUB       TEMP
        2344+ 4 2349          + TR 0      EXIT         NOT FOUND -> RETURN ZERO
        2345+ 1 2336          + TR        LOOP
        2346+10 2337 FOUND    + R ADD     RDTBL        RETURN ENTRY FOUND
        2347+ 5 2353          + SUB       TBL0
        2348+ 9 2356          + ADD       ONE
        2349+ 1    0 EXIT     + TR        /   /
        2350+ 0    0 N        + STOP      0000
        2351+ 0    0 VAL      + STOP      0000
        2352+ 0    0 TBL      + STOP      0000
        2353+ 0    0 TBL0     + STOP      0000
        2354+ 0    0 TEMP     + STOP      0000
        2355+ 0    0 ZERO     + STOP      0000
        2356+ 0    1 ONE      + STOP      0001         constant 1
        2357+ 0    2 TWO      + STOP      0002         constant 2
        2358+ 9 2431 RWDRUM   + ADD       TWO 
        2359+13 2368          + STORE A   PDR1         PARM1: DRUM INSTR: READ/WRITE 0128  0129  0130  0131
        2360+ 9 2430          + ADD       ONE          
        2361+13 2370          + STORE A   PDR2         PARM2: DRUM ADDRESS (0..4094)
        2362+ 9 2430          + ADD       ONE          
        2363+13 2372          + STORE A   PDR3         PARM3: BUF START ADDRESS
        2364+ 9 2430          + ADD       ONE          
        2365+13 2374          + STORE A   PDR4         PARM4: LEN: NUMBER OF HALF-WORDS (MUST BE EVEN)
        2366+ 9 2430          + ADD       ONE          
        2367+13 2428          + STORE A   EXIT               
        2368+10    0 PDR1     + R ADD     /   /        GET DRUM INSTR
        2369+12 2376          + STORE     DRIO
        2370+10    0 PDR2     + R ADD     /   /        GET DRUM ADDR
        2371+13 2377          + STORE A   DRADDR
        2372+10    0 PDR3     + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        2373+13 2415          + STORE A   RWCOPY    
        2374+10    0 PDR4     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        2375+12 2432          + STORE     LEN
        2376+ 0    0 DRIO     + STOP      /   /        INSTR: READ/WRITE 0128  0129  0130  0131
        2377+29    0 DRADDR   + SET DR    /   /
        2378+ 1 2411          + TR        LOOP
        2379+ 9 2431 RDTAPE   + ADD       TWO 
        2380+13 2387          + STORE A   PR1          PARM1: TAPE ADDRESS
        2381+ 9 2430          + ADD       ONE          
        2382+13 2389          + STORE A   PR2          PARM2: BUF START ADDRESS
        2383+ 9 2430          + ADD       ONE          
        2384+13 2428          + STORE A   EXIT
        2385+ 2 2386          + TR OV     CLOV1        CLEAR OV THAT MAY HAVE BEEN SET
        2386+ 8    0    CLOV1 + NOOP      0000
        2387+10    0 PR1      + R ADD     /   /        GET TAPE ADDR
        2388+13 2391          + STORE A   RTAPAD       TAPE UNITS: 0256  0257  0258  0259
        2389+10    0 PR2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        2390+13 2415          + STORE A   RWCOPY    
        2391+24    0 RTAPAD   + READ      /   /
        2392+10 2429          + R ADD     ZERO
        2393+ 1 2413          + TR        LOOP1
        2394+ 9 2431 WRTAPE   + ADD       TWO 
        2395+13 2402          + STORE A   PW1          PARM1: TAPE ADDRESS
        2396+ 9 2430          + ADD       ONE          
        2397+13 2404          + STORE A   PW2          PARM2: BUF START ADDRESS
        2398+ 9 2430          + ADD       ONE          
        2399+13 2406          + STORE A   PW3          PARM3: BUF LEN
        2400+ 9 2430          + ADD       ONE          
        2401+13 2428          + STORE A   EXIT
        2402+10    0 PW1      + R ADD     /   /        GET TAPE ADDR
        2403+13 2410          + STORE A   WTAPAD       TAPE UNITS: 0256  0257  0258  0259
        2404+10    0 PW2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        2405+13 2415          + STORE A   RWCOPY    
        2406+10    0 PW3      + R ADD     /   /        GET ADDR OF LEN 
        2407+13 2408          + STORE A   PW3A
        2408+10    0 PW3A     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        2409+12 2432          + STORE     LEN
        2410+26    0 WTAPAD   + WRITE     /   /        PREPARE TO WRITE ON TAPE
        2411+10 2432 LOOP     + R ADD     LEN
        2412+ 4 2427          + TR 0      RWOK
        2413+ 5 2431 LOOP1    + SUB       TWO
        2414+12 2432          + STORE     LEN
        2415-31    0 RWCOPY   - COPY      /   /        WRITE BUFFER TO TAPE
        2416+ 1 2419          + TR        GO 
        2417+ 1 2423          + TR        EOF          END OF FILE
        2418+ 1 2425          + TR        EOR          END OF RECORD
        2419+10 2415 GO       + R ADD     RWCOPY
        2420+ 5 2431          + SUB       TWO
        2421+13 2415          + STORE A   RWCOPY
        2422+ 1 2411          + TR        LOOP
        2423+10 2430 EOF      + R ADD     ONE          SET OV FLAG TO SIGNAL END OF FILE CONDITION
        2424+22   36          + A LEFT    36
        2425+ 6 2432 EOR      + R SUB     LEN          RETURN NUMBER OF HALF-WORDS READ
        2426+ 5 2431          + SUB       TWO
        2427+26 2052 RWOK     + WRITE     2052         INSURE THAT MQ NOT IN USE            
        2428+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        2429+ 0    0 ZERO     + STOP      0000
        2430+ 0    1 ONE      + STOP      0001         
        2431+ 0    2 TWO      + STOP      0002         
        2432+     0  LEN        RES       1
        2434+ 9 2449 CHAIN    + ADD       TWO
        2435+13 2436          + STORE A   CHP1
        2436+10    0 CHP1     + R ADD     /   /        GET TAPE NUMBER
        2437+13 2444          + STORE A   TAPELOAD
        2438+30   70          + SENSE     0070         SENSE SWITCH 2                                  
        2439+ 1 2443 CONTAD   + TR        ENDSTOP      (ON POSITION MAKES SENSE OPCODE TO SKIP NEXT INSTR)
        2440+10 2439          + R ADD     CONTAD       IF SW2 IS ON, A +STOP 4095 IS EXECUTED.  
        2441+12 4095          + STORE     4095         IF THEN USER PRESS START, EXECUTION WILL BE RESUMED 
        2442+ 0 4095          + STOP      4095         AND CHAINED PROGRAM WILL BE LOADED AND EXECUTED
        2443+ 8    0 ENDSTOP  + NOOP      0000
        2444+24    0 TAPELOAD + READ      0000         
        2445-31    0 TL0      - COPY      0000         READ 1ST WORD OF SELF-LOADER FROM TAPE
        2446+ 1    0          + TR        0000         TR TO SELF-LOADER
        2447+ 0 2221          + STOP      2221         ERROR LOADING: UNEXPECTED END OF FILE
        2448+ 0 2222          + STOP      2222         ERROR LOADING: UNEXPECTED END OF RECORD 
        2449+ 0    2 TWO      + STOP      0002         ERROR LOADING: UNEXPECTED END OF FILE
          48-     0  ROUTINE INIT
          49+ 1  126 ENTRY POINT
          50-     0  ROUTINE CHAIN
          51+ 1 2434 ENTRY POINT
          52-     0  ROUTINE PRTNLINE
          53+ 1 2126 ENTRY POINT
          54-     0  ROUTINE PRTSTR
          55+ 1 1865 ENTRY POINT
          56-     0  ROUTINE PRTINT
          57+ 1 1966 ENTRY POINT
          58-     0  ROUTINE PRINTCRD
          59+ 1 1804 ENTRY POINT
          60-     0  ROUTINE RDTAPE
          61+ 1 2379 ENTRY POINT
          62-     0  ROUTINE WRTAPE
          63+ 1 2394 ENTRY POINT
          64-     0  ROUTINE RWDRUM
          65+ 1 2358 ENTRY POINT
          66-     0  ROUTINE CLMEM
          67+ 1 2262 ENTRY POINT
          68-     0  ROUTINE SRCHTBL
          69+ 1 2288 ENTRY POINT
          70-     0  ROUTINE EQTBL
          71+ 1 2290 ENTRY POINT
          72-     0  ROUTINE READTBL
          73+ 1 2292 ENTRY POINT
          74-     0  ROUTINE CLRBUF
          75+ 1 1796 ENTRY POINT
          76-     0  ROUTINE READCRD
          77+ 1 1800 ENTRY POINT
          78-     0  ROUTINE WRITECRD
          79+ 1 1802 ENTRY POINT
          80-     0  ROUTINE PRTALF
          81+ 1 1888 ENTRY POINT
          82-     0  ROUTINE PRTCHR
          83+ 1 2008 ENTRY POINT
          84-     0  ROUTINE PRTOCT
          85+ 1 1932 ENTRY POINT
          86-     0  ROUTINE BMPAD
          87+ 1 2208 ENTRY POINT
        4094+    48  REGION ORIGIN TABLE LOCATION
        4095+   126  INITIAL REGION
           0+ 1  126          + TR        INIT         PROGRAM START
