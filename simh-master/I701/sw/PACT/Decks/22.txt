        DEC
        NNNN OP ADDR COMMENTS
          90+ 9 1887 SRCHREG  + ADD       TWO          SEARCH REGION IN TREGIONS. TR TO ERROR IF NOT FOUND 
          91+13   98          + STORE A   SRCHREX      RETURN IN ACC THE ENTRY IN TREGIONS FOUND
          92+10   92          + R ADD     *
          93+ 1   65          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
          94+ 0  582          + STOP      TREGIONS     ... TREGIONS TABLE
          95+ 0  581          + STOP      NREGIONS     ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NREGIONS 
          96+ 0  561          + STOP      FACT         ... THE VALUE TO FIND 
          97+ 4   99          + TR 0      SREGNFER
          98+ 1    0 SRCHREX  + TR        /   /
          99+10   99 SREGNFER + R ADD     *            
         100+ 1  521          + TR        ERROR
         101+ 0 1905          + STOP      ERRREGNF     ERROR: REGION DO NOT EXISTS
         102+ 9 1887 LOADCC   + ADD       TWO          LOAD PACTSCR INTO CARD IMAGE SO 
         103+13  122          + STORE A   CPCCEX       CURRENT PACT SOURCE CODE CAN BE PRINTED
         104+10 1884          + R ADD     ZERO         COPY TO LEFT SIDE OF SOURCE CODE CARD IMAGE
         105+13  109          + STORE A   CPCC1        AT 0..46 FROM PACTSCR
         106+10  125          + R ADD     CPCC2
         107+13  108          + STORE A   CPCC 
         108-10    0 CPCC     - R ADD     /   /
         109-12    0 CPCC1    - STORE     /   /
         110+10  109          + R ADD     CPCC1
         111+ 5 1887          + SUB       TWO
         112+13  114          + STORE A   CPCC1B
         113+10 1884          + R ADD     ZERO
         114-12    0 CPCC1B   - STORE     /   /
         115+10  108          + R ADD     CPCC
         116+ 5 1887          + SUB       TWO
         117+13  108          + STORE A   CPCC
         118+10  109          + R ADD     CPCC1
         119+ 5 1888          + SUB       D4
         120+13  109          + STORE A   CPCC1
         121+ 5  124          + SUB       CPCCE
         122+ 4    0 CPCCEX   + TR 0      /   /        RETURN TO CALLER
         123+ 1  108          + TR        CPCC
         124-12   48 CPCCE    - STORE     0048         LAST LOCATION TO COPY FROM 
         125+ 8  534 CPCC2    + NOOP      PACTSRC      PACTSRC = FIRST LOCATION TO COPY FROM
         126+10  126 INIT     + R ADD     *            
         127+ 1   53          + TR        PRTNLINE     
         128+ 0  101          + STOP      0101         STRINGZ AT COL 1
         129+ 0 1931          + STOP      MSGSTART     "ABSTRACT ASSEMBLY PASS 2"
         130+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         131+10  131          + R ADD     *
         132+ 1   61          + TR        RWDRUM       READ TREGIONS ARRAY FROM DRUM
         133+24  128          + READ      0128         DRUM INSTR
         134+ 0    0          + STOP      0000         DRUM ADDR 
         135+ 0  580          + STOP      MAXNREGS     ADDR OF START OF TABLES
         136+ 0  302          + STOP      0302         MAXNREGS (1 HALF-WORD) + NREGIONS (1 HW) + TREGIONS (100 HW)
         137+10  137          + R ADD     *
         138+ 1   61          + TR        RWDRUM       READ TREGIONS ARRAY FROM DRUM
         139+24  128          + READ      0128         DRUM INSTR
         140+ 0  402          + STOP      0402         DRUM ADDR 
         141+ 0  882          + STOP      TREXSIZE     ADDR OF START OF TABLES
         142+ 0  200          + STOP      0200         LEN=TREXSIZE (100 HW) + TREXTMP (100 HW)
         143+10 1884          + R ADD     ZERO         CLEAR CC RECORD
         144+12  558          + STORE     REGION     
         145+12  559          + STORE     STEP       
         146+12  560          + STORE     OP         
         147+12  561          + STORE     FACT       
         148+12  562          + STORE     S1         
         149+12  563          + STORE     S2         
         150+12  564          + STORE     QR         
         151+12  565          + STORE     QF         
         152-12  566          - STORE     NUM        
         153+12  568          + STORE     CLUE       
         154+12  569          + STORE     STEPN      
         155+12  570          + STORE     FACTN      
         156+12  571          + STORE     FACTREG    
         157+12  572          + STORE     S1N        
         158+12  573          + STORE     S2N        
         159+12  574          + STORE     D1N        
         160+12  575          + STORE     D2N        
         161+12  576          + STORE     NINST      
         162+12  577          + STORE     NINCR 
         163+10  578          + R ADD     CCLEN        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         164+10  682          + R ADD     TRISDUP      NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         165+10 1884          + R ADD     ZERO
         166+12 1896          + STORE     IREG         REGION NUMBER BEING PROCESSED
         167+28  257          + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE)
         168+28  259          + REWIND    TAPEINR      REWIND TAPE IN WITH STEP REFERENCES 
         169+28  258          + REWIND    TAPEOUT      REWIND TAPE OUT WITH UPDATED PACT COMPACT CODE
         170+10 1884 READREG  + R ADD     ZERO         INIT READ REGION
         171+12 1902          + STORE     STEPCNT      STEP* COUNT FOR REGION
         172+12 1899          + STORE     TMPN         CURRENT TEMP VARS FOR RESULT OF STEP IN THIS REGION 
         173+12 1903          + STORE     PVREG        INIT PREVIOUS REGION VAR 
         174+12  560          + STORE     OP           INIT OPERATION VAR (THAT WILL INIT PVOP ON START OF READSTEP)
         175+10 1896          + R ADD     IREG         SELECT NEXT REGION
         176+ 9 1886          + ADD       ONE
         177+12 1896          + STORE     IREG
         178+10  178          + R ADD     *            CHECK IF MUST ADD A CALL INST AS FIRST STEP OF REGION 
         179+ 1   67          + TR        READTBL
         180+ 0  782          + STOP      TRNEEDCA     ... VAL=TRNEEDCA[IREG] =1 IF NEEDS TO ADD A CALL INSTR 
         181+ 0 1896          + STOP      IREG
         182+ 0  579          + STOP      VAL
         183+10  579          + R ADD     VAL          IF VAL=1 THEN
         184+ 4  187          + TR 0      TREFSAD        GENERATE A CALL INSTR
         185+10  185          + R ADD     *
         186+ 1  397          + TR        GENCALL
         187+ 8 1084 TREFSAD  + NOOP      TREFS        INIT TREFAD POINTER TO WALT THRU
         188+10  187          + R ADD     TREFSAD      TREFS TABLE
         189+13  226          + STORE A   RDREF
         190+10  200          + R ADD     TREFAD1      READ RESOLVED REFERENCE LIST
         191+ 9 1082          + ADD       MAXNREFS     READ FROM TAPE TREFSN, THEN TREFS
         192+13  196          + STORE A   TREFAD2
         193+10  193          + R ADD     *            
         194+ 1   57          + TR        RDTAPE       READ MAGNETIC TAPE (REFERENCES TABLE)
         195+ 0  259          + STOP      TAPEINR
         196+ 0    0 TREFAD2  + STOP      /   /        BUF TO READ FROM TAPE: DUMMY (2HW) + TREFSN
         197+10  197          + R ADD     *            
         198+ 1   57          + TR        RDTAPE       READ MAGNETIC TAPE (REFERENCES TABLE)
         199+ 0  259          + STOP      TAPEINR
         200+ 0 1082 TREFAD1  + STOP      MAXNREFS     BUF TO READ FROM TAPE: MAXNREFS (1HW) + NREFS (1HW) + TREFS
         201+10  560 READSTEP + R ADD     OP
         202+12 1904          + STORE     PVOP         SAVE PREVIOUS OPERATION
         203+10  203          + R ADD     *            READ PACT USER PROGRAM SOURCE CODE FROM TAPE IN
         204+ 1   57          + TR        RDTAPE
         205+ 0  257          + STOP      TAPEIN
         206+ 0  534          + STOP      CCODE        BUF TO READ IN FROM TAPE
         207+ 2  504          + TR OV     EOF          TR IF END OF FILE
         208+10  560          + R ADD     OP
         209+ 4  467          + TR 0      EOR          TR IF END OF REGION
         210+10  210          + R ADD     *            LOAD PACTSCR INTO CARD IMAGE SO 
         211+ 1  102          + TR        LOADCC       CURRENT PACT SOURCE CODE CAN BE PRINTED
         212+10 1884          + R ADD     ZERO         INIT EQTOTMP. LATER, IF EQTOTMP>0 -> SHOULD 
         213+12 1901          + STORE     EQTOTMP      GENERATE AN EQ TMP INSTRUCTION 
         214+10  558          + R ADD     REGION       SAVE CURRENT REGION AS PREVIOUS REGION VAR 
         215+12 1903          + STORE     PVREG        TO UPDATE THE EOR STEP
         216+10 1902          + R ADD     STEPCNT      COMPUTE STEPN FOR CURRENT STEP
         217+ 9 1886          + ADD       ONE
         218+12 1902          + STORE     STEPCNT
         219+12  569          + STORE     STEPN        VALUE OF STEPN FOR CURRENT STEP
         220+ 6  561          + R SUB     FACT         IF FACT > 0 -> FACTOR IS A STEP REFERENCE ...
         221+ 4  225          + TR 0      RS1
         222+ 3  225          + TR +      RS1
         223+10  223          + R ADD     *
         224+ 3  288          + TR +      SOLVEREF     ... USE TREFS TO COMPUTE FACTORN
         225+ 8    0 RS1      + NOOP      0000
         226+10    0 RDREF    + R ADD     /   /
         227+12 1895          + STORE     REF          GET NEXT REFERENCE TO CHECK
         228+ 4  247          + TR 0      ENDREF       =0 -> NO MORE REFERENCES TO RESOLVE
         229+10 1884          + R ADD     ZERO
         230+11 1895          + ADD AB    REF
         231+ 5  559          + SUB       STEP
         232+ 4  238          + TR 0      FNDREF       TR IF HIT A REFERENCED STEP
         233+ 3  247          + TR +      ENDREF       ABS(REF) > STEP -> NOT ARRIVED YET TO REFERENCES STEP -> CONTINUE
         234+10  226 NXTREF   + R ADD     RDREF        ADVANCE TO NEXT REFERENCE
         235+ 9 1886          + ADD       ONE
         236+13  226          + STORE A   RDREF       
         237+ 1  226          + TR        RDREF
         238+10 1895 FNDREF   + R ADD     REF
         239+ 3  234          + TR +      NXTREF       IF REFERENCE FOUND IS >0 -> STEP IS THE DESTINATION OF A TRANSFER -> NOTHING TO DO
         240+10 1899          + R ADD     TMPN         CURRENT STEP IS REFERENCED AS "RESULT OF STEP". SO 
         241+ 9 1886          + ADD       ONE          MUST SAVE THE CURRENT STEP IN ONE TEMP VAR
         242+12 1899          + STORE     TMPN         (SIGNAL IT INCREMENTING NUM OF TEMP VARS USED)
         243+12 1901          + STORE     EQTOTMP      THIS IS THE TEMP VAR TO USE   
         244+ 6 1895          + R SUB     REF
         245+12 1900          + STORE     RSLTSTP      MINUS REF IS THE STEP TAKEN AS RESULT OF STEP 
         246+ 1  234          + TR        NXTREF       DONE, TR TO SELECT AND PROCESS NEXT REF
         247+ 8    0 ENDREF   + NOOP      0000         END OF REFERENCE RESOLUTION
         248+10  560          + R ADD     OP
         249+ 5 1891          + SUB       OPDUP
         250+ 4  268          + TR 0      CHKDUP       OP="DUP REGION" -> TR TO INCR STEPN, TMPN WITH SIZE OF REGION
         251+ 8    0 NEXT     + NOOP      0000         CONTINUE 
         252+10  252          + R ADD     *
         253+ 1   59          + TR        WRTAPE       WRITE MAGNETIC TAPE TAPEOUT (PACT COMPACT CODE)
         254+ 0  258          + STOP      TAPEOUT
         255+ 0  534          + STOP      CCODE        BUF TO WRITE TO TAPE
         256+ 0  578          + STOP      CCLEN        LEN
         257+30   74          + SENSE     0074         SENSE SWITCH 6
         258+ 1  261          + TR        ENDLOG1      TR IF NO LOG SELECTED
         259+10  259          + R ADD     *            PRINT STEP JUST PROCESSED
         260+ 1   55          + TR        PRINTCRD
         261+ 8    0 ENDLOG1  + NOOP      0000 
         262+10 1901          + R ADD     EQTOTMP      IS THERE A "EQ TMP" INSTR PENDING TO BE GENERATED?
         263+ 4  266          + TR 0      ENDEQTMP     IF = 0 -> NO, DO NOT ADD ANY INSTR
         264+10  264          + R ADD     *
         265+ 1  336          + TR        GENEQ        GENERATE "EQ TMP" INSTR (SAVE TO TAPE & PRINT IT IF SW6 IS ON)
         266+ 8    0 ENDEQTMP + NOOP      0000      
         267+ 1  201          + TR        READSTEP
         268+10  268 CHKDUP   + R ADD     *            SEARCH REGION STATED IN FACTOR VAR = THE DUPLICATED REGION NAME
         269+ 1   90          + TR        SRCHREG      ERROR IF REGION DO NOT EXISTS IN TREGS TABLE
         270+13 1897          + STORE A   IREGDUP      STORE THE DUPLICATED REGION INDEX NUMBER
         271+10  271          + R ADD     *            
         272+ 1   67          + TR        READTBL
         273+ 0  882          + STOP      TREXSIZE     ... VAL=TREXSIZE[IREGDUP] GET CURRENT EXTENDED SIZE FOR DUPLICATED REGION
         274+ 0 1897          + STOP      IREGDUP
         275+ 0  579          + STOP      VAL
         276+ 4  251          + TR 0      NEXT         IF EXTENDED SIZE=0 -> REGION NOT RESOLVED -> JUST IGNORE THE DUP INSTR
         277+ 5 1886          + SUB       ONE
         278+ 9 1902          + ADD       STEPCNT      THE FINAL (EXPANDED) SIZE OF REGION TO BE DUPLICATED HERE IS FULLY KNOW. ADD IT
         279+12 1902          + STORE     STEPCNT      TO THE SIZE OF CURRENT REGION
         280+10  280          + R ADD     *            
         281+ 1   67          + TR        READTBL
         282+ 0  982          + STOP      TREXTMP      ... VAL=TREXSIZE[IREGDUP] GET CURRENT EXTENDED SIZE FOR DUPLICATED REGION
         283+ 0 1897          + STOP      IREGDUP
         284+ 0  579          + STOP      VAL
         285+ 9 1899          + ADD       TMPN         ADD THE NUMBER OF TEMP VARS NEEDED BY DUPLICATED REGION TO THE TOTAL FOR CURRENT REGION
         286+12 1899          + STORE     TMPN
         287+ 1  251          + TR        NEXT         TR TO NEXT TO CONTINUE PROCESSING STEPS 
         288+ 9 1887 SOLVEREF + ADD       TWO          RESOLVE REFERENCE TO A STEP (TRANSFER TO STEP, USE RESULT OF STEP)
         289+13  327          + STORE A   SOLVEX       THE RESOLVED STEP IS STORED IN FACTN
         290+10  568          + R ADD     CLUE         SEARCH REFERENCED STEP IN FACTOR FILED INTO TREFS TABLE 
         291+ 4  294          + TR 0      SR1A         BLANK CLUE -> IT IS A TRANSFER -> REFERENCED STEP IN TREFS IS POSITIVE
         292+ 6  561          + R SUB     FACT         ELSE IT IS A REFERENCE TO A RESULT OF STEP -> REFERENCED STEP IN TREFS IS NEGATIVE
         293+ 1  295          + TR        SR2A
         294+10  561 SR1A     + R ADD     FACT
         295+12  579 SR2A     + STORE     VAL
         296+10  296          + R ADD     *
         297+ 1   65          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         298+ 0 1084          + STOP      TREFS        ... TREFS TABLE
         299+ 0 1083          + STOP      NREFS        ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NREGIONS 
         300+ 0  579          + STOP      VAL          ... THE VALUE TO FIND 
         301+ 4  328          + TR 0      SRNOTFND     REFERENCE NOT FOUND (SHOULD NOT OCCURS, AS TREFS SHOULD CONTAIN ALL REFERENCES)
         302+12 1898          + STORE     IREF         THE FOUND REFERENCE
         303+10  303          + R ADD     *            
         304+ 1   67          + TR        READTBL
         305+ 0 1484          + STOP      TREFSN       ... VAL=TREFSN[IREF] GET STEPN FOR GIVEN STEP REFERENCED
         306+ 0 1898          + STOP      IREF
         307+ 0  579          + STOP      VAL
         308+10  579          + R ADD     VAL
         309+ 4  328          + TR 0      SRNOTFND     REFERENCE FOUND, BUT WAS NOT RESOLVED (BECAUSE REFERENCES A NON EXISTING STEP)
         310+10  568          + R ADD     CLUE         REFERENCE RESOLVED. APPLY IT
         311+ 4  325          + TR 0      SR1B         BLANK CLUE -> IT IS A TRANSFER -> VAL IS STEPN TO TRANSFER TO -> SAVE IT AS FACTN
         312+ 6  561          + R SUB     FACT         ELSE IT IS A REFERENCE TO A RESULT OF STEP -> EXTRACT QF/TEMP-VAR FROM VAL
         313+10  579          + R ADD     VAL          CALLING IN RESULT OF STEP
         314+23   10          + A RIGHT   0010         SET QF OF CALLED IN STEP (CAN BE NEGATIVE)
         315+12  565          + STORE     QF           IN UPPER 8 BITS (SGN+7BITS) OF VAL
         316+10 1884          + R ADD     ZERO
         317+11  579          + ADD AB    VAL          GET TMPN FROM LOWER 10 BITS OF VAL, NO SIGN
         318+21   28          + L RIGHT   0028         STORE TMPN*2 (THE TEMP VAR ADDR) IN FACTN
         319+10 1884          + R ADD     ZERO         STORE 'T' IN FACTREG    
         320+20   29          + L LEFT    0029
         321+12  570          + STORE     FACTN
         322+10 1894          + R ADD     D32          BASE48 CHAR 'T'
         323+12  571          + STORE     FACTREG    
         324+ 1  327          + TR        SOLVEX
         325+10  579 SR1B     + R ADD     VAL          IT IS A TRANSFER -> FACTN IS THE DESTINATION STEPN
         326+12  570          + STORE     FACTN
         327+ 1    0 SOLVEX   + TR        /   /
         328+10  568 SRNOTFND + R ADD     CLUE         BLANK CLUE -> UNRESOLVED REF MEANS TRANSFER TO NON EXISTANT STEP
         329+ 4  333          + TR 0      SRTRNF       ELSE IT IS A REFERENCE TO RESULT OF NON EXISTANT STEP
         330+10  330          + R ADD     *            
         331+ 1  521          + TR        ERROR
         332+ 0 1912          + STOP      ERRRSNF      ERROR: CALLING-IN RESULT OF NON-EXISTANT STEP
         333+10  333 SRTRNF   + R ADD     *            
         334+ 1  521          + TR        ERROR
         335+ 0 1920          + STOP      ERRTRNF      ERROR: TRANSFER TO NON-EXISTANT STEP
         336+ 9 1887 GENEQ    + ADD       TWO          GENERATE INST "EQ TMP" TO SAVE THE RESULT OF STEP
         337+13  396          + STORE A   GENEX        IN TEMP VAR TO BE USED LATER WHEN RESULT OF STEP
         338+10 1902          + R ADD     STEPCNT      INCR STEPN FOR NEW STEP
         339+ 9 1886          + ADD       ONE    
         340+12 1902          + STORE     STEPCNT      
         341+12  569          + STORE     STEPN        
         342+10 1884          + R ADD     ZERO         PREPARE THE "EQ INSTR". KEEPS SAME REGION
         343+12  559          + STORE     STEP         NO STEP NUMBER (AS INSTR HAS BEEN GENERATED BY COMPILER)
         344+10 1889          + R ADD     OPEQ
         345+12  560          + STORE     OP           OPERATION = EQ       
         346+10 1900          + R ADD     RSLTSTP
         347+12  561          + STORE     FACT         FACT = THE REFERENCED STEP = THE RESULT OF STEP SAVED
         348+10 1884          + R ADD     ZERO
         349+12  562          + STORE     S1           CLEARS S1, S2, QF AND NUM
         350+12  563          + STORE     S2
         351+12  566          + STORE     NUM
         352+10 1893          + R ADD     D30          SET CLUE='R'
         353+12  568          + STORE     CLUE
         354+10 1901          + R ADD     EQTOTMP      STORE TMPN*2 (THE TEMP VAR ADDR) IN FACTN
         355+22    1          + A LEFT    0001         STORE 'T' IN FACTREG    
         356+12  570          + STORE     FACTN
         357+10 1894          + R ADD     D32          BASE48 CHAR 'T'
         358+12  571          + STORE     FACTREG    
         359+10  564          + R ADD     QR           SET QF SAME AS QR
         360+12  565          + STORE     QF
         361+10  361          + R ADD     *
         362+ 1   53          + TR        PRTNLINE
         363+ 0  501          + STOP      0501         PRINT ALF AT COL 1
         364+ 0  558          + STOP      REGION
         365+ 0  508          + STOP      0508         PRINT ALF AT COL 8
         366+ 0 1949          + STOP      ALFEQ        "EQ "
         367+ 0  412          + STOP      0412         PRINT BASE48 CHAR AT COL 12         
         368+ 0  568          + STOP      CLUE         'R'
         369+ 0  211          + STOP      0211         PRINT INT6 (6 DIGITS) AT COL 11
         370+ 0  561          + STOP      FACT         nnnn, RESULT SAVED FOR THIS STEP
         371+ 0  219          + STOP      0219         PRINT INT6 (6 DIGITS) AT COL 19
         372+ 0  564          + STOP      QR           
         373+ 0    6          + STOP      0006         PRINT IS SW6 IS ON. IF SW6 IS OFF, NO PRINT (BUF WILL BE ANYWAY BE SAVED ON CC)
         374+10 1884 BCP      + R ADD     ZERO         COPY LEFT SIDE OF SOURCE CODE CARD IMAGE
         375+13  378          + STORE A   BCPCC1       AT 0..46 TO PACTSCR
         376+10  390          + R ADD     BCPCC2
         377+13  379          + STORE A   BCPCC 
         378-10    0 BCPCC1   - R ADD     /   /
         379-12    0 BCPCC    - STORE     /   /
         380+10  379          + R ADD     BCPCC
         381+ 5 1887          + SUB       TWO
         382+13  379          + STORE A   BCPCC
         383+10  378          + R ADD     BCPCC1
         384+ 5 1888          + SUB       D4
         385+13  378          + STORE A   BCPCC1
         386+ 5  389          + SUB       BCPCCE
         387+ 4  390          + TR 0      BCPCC2
         388+ 1  378          + TR        BCPCC1 
         389-10   48 BCPCCE   - R ADD     0048         LAST LOCATION TO COPY FROM 
         390+ 8  534 BCPCC2   + NOOP      PACTSRC      PACTSRC = FIRST LOCATION TO COPY TO 
         391+10  391          + R ADD     *
         392+ 1   59          + TR        WRTAPE       WRITE MAGNETIC TAPE TAPEOUT (PACT COMPACT CODE)
         393+ 0  258          + STOP      TAPEOUT
         394+ 0  534          + STOP      CCODE        BUF TO WRITE TO TAPE
         395+ 0  578          + STOP      CCLEN        LEN
         396+ 1    0 GENEX    + TR        /   /    
         397+ 9 1887 GENCALL  + ADD       TWO          GENERATE INST "CALL" AS FIRST STEP OF REGION
         398+13  396          + STORE A   GENEX        SAVE INST TO TAPE & PRINT IT IF SW6 IS ON
         399+10 1902          + R ADD     STEPCNT      INCR STEPN FOR NEW STEP
         400+ 9 1886          + ADD       ONE    
         401+12 1902          + STORE     STEPCNT      
         402+12  569          + STORE     STEPN        
         403+10  403          + R ADD     *            
         404+ 1   67          + TR        READTBL
         405+ 0  582          + STOP      TREGIONS     ... VAL=TREGUONS[IREG] GET CURRENT REGION NAME
         406+ 0 1896          + STOP      IREG
         407+ 0  558          + STOP      REGION
         408+12  561          + STORE     FACT         
         409+10 1884          + R ADD     ZERO         PREPARE THE "CALL INSTR". 
         410+12  559          + STORE     STEP         NO STEP NUMBER (AS INSTR HAS BEEN GENERATED BY COMPILER)
         411+10 1892          + R ADD     OPCALL
         412+12  560          + STORE     OP           OPERATION = CALL
         413+10 1884          + R ADD     ZERO
         414+12  570          + STORE     FACTN
         415+12  571          + STORE     FACTREG    
         416+12  562          + STORE     S1           
         417+12  563          + STORE     S2
         418+12  566          + STORE     NUM
         419+12  568          + STORE     CLUE
         420+12  565          + STORE     QF
         421+12  564          + STORE     QR
         422-12  566          - STORE     NUM
         423+10  423          + R ADD     *
         424+ 1   53          + TR        PRTNLINE
         425+ 0  501          + STOP      0501         PRINT ALF AT COL 1
         426+ 0  558          + STOP      REGION
         427+ 0  508          + STOP      0508         PRINT ALF AT COL 8
         428+ 0 1950          + STOP      ALFCAL1      "CAL"
         429+ 0  511          + STOP      0511         PRINT ALF AT COL 11
         430+ 0 1951          + STOP      ALFCAL2      "L  "
         431+ 0  513          + STOP      0513         PRINT ALF AT COL 13
         432+ 0  558          + STOP      REGION
         433+ 0    6          + STOP      0006         PRINT IS SW6 IS ON. IF SW6 IS OFF, NO PRINT (BUF WILL BE ANYWAY BE SAVED ON CC)
         434+ 1  374          + TR        BCP          TR TO SAVE 
         435+ 9 1887 GENEXIT  + ADD       TWO          GENERATE INST "EXIT" AS LAST STEP OF REGION
         436+13  396          + STORE A   GENEX        SAVE INST TO TAPE & PRINT IT IF SW6 IS ON
         437+10 1903          + R ADD     PVREG        POPULATE THE REGION FIELD OF EOR STEP WITH THE VALUE TAKEN 
         438+12  558          + STORE     REGION       FROM PREVIOUS STEP
         439+10 1902          + R ADD     STEPCNT      INCR STEPN FOR NEW STEP
         440+ 9 1886          + ADD       ONE    
         441+12 1902          + STORE     STEPCNT      
         442+12  569          + STORE     STEPN        
         443+10 1884          + R ADD     ZERO         PREPARE THE "EXIT INSTR". 
         444+12  559          + STORE     STEP         NO STEP NUMBER (AS INSTR HAS BEEN GENERATED BY COMPILER)
         445+10 1890          + R ADD     OPEXIT
         446+12  560          + STORE     OP           OPERATION = CALL
         447+10 1884          + R ADD     ZERO
         448+12  570          + STORE     FACTN
         449+12  571          + STORE     FACTREG    
         450+12  562          + STORE     S1           
         451+12  563          + STORE     S2
         452+12  566          + STORE     NUM
         453+12  568          + STORE     CLUE
         454+12  565          + STORE     QF
         455+12  564          + STORE     QR
         456-12  566          - STORE     NUM
         457+10  457          + R ADD     *
         458+ 1   53          + TR        PRTNLINE
         459+ 0  501          + STOP      0501         PRINT ALF AT COL 1
         460+ 0  558          + STOP      REGION
         461+ 0  508          + STOP      0508         PRINT ALF AT COL 8
         462+ 0 1952          + STOP      ALFEXI1      "EXI"
         463+ 0  511          + STOP      0511         PRINT ALF AT COL 11
         464+ 0 1953          + STOP      ALFEXI2      "T  "
         465+ 0    6          + STOP      0006         PRINT IS SW6 IS ON. IF SW6 IS OFF, NO PRINT (BUF WILL BE ANYWAY BE SAVED ON CC)
         466+ 1  374          + TR        BCP          TR TO SAVE 
         467+ 8    0 EOR      + NOOP      0000         END OF REGION  
         468+10 1904          + R ADD     PVOP
         469+ 5 1890          + SUB       OPEXIT
         470+ 4  485          + TR 0      WREORSTP     REGION ALREADY TERMINATES WITH AN EXIT STEP -> JUST WRITE EOR RECORD
         471+10  471          + R ADD     *            CHECK IF MUST ADD A CALL INST AS FIRST STEP OF REGION 
         472+ 1   67          + TR        READTBL
         473+ 0  682          + STOP      TRISDUP     ... VAL=TRISDUP[IREG] =1 IF REGION IS DUPLICATED
         474+ 0 1896          + STOP      IREG
         475+ 0  579          + STOP      VAL
         476+10  579          + R ADD     VAL          IF VAL=1 THEN REGION IS DUPLICATED -> NO NEED TO ADD EXIT AT END OF REGION
         477+ 4  479          + TR 0      GE1
         478+ 1  485          + TR        WREORSTP     
         479+10  479 GE1      + R ADD     *            ADD A EXIT STEP AS LAST STEP OF REGION, JUST BEFORE EOR RECORD
         480+ 1  435          + TR        GENEXIT
         481+10  481          + R ADD     *            CLEAR CC
         482+ 1   63          + TR        CLMEM        
         483+ 0  534          + STOP      CCODE
         484+ 0  578          + STOP      CCLEN
         485+10 1903 WREORSTP + R ADD     PVREG        POPULATE THE REGION FIELD OF EOR STEP WITH THE VALUE TAKEN 
         486+12  558          + STORE     REGION       FROM PREVIOUS STEP
         487+10 1902          + R ADD     STEPCNT      INCR STEPN FOR NEW STEP
         488+ 9 1886          + ADD       ONE    
         489+12 1902          + STORE     STEPCNT      
         490+12  569          + STORE     STEPN                 
         491+10  491          + R ADD     *            WRITE IN TAPE THE EOR STEP
         492+ 1   59          + TR        WRTAPE       WRITE MAGNETIC TAPE TAPEOUT (PACT COMPACT CODE)
         493+ 0  258          + STOP      TAPEOUT
         494+ 0  534          + STOP      CCODE        BUF TO WRITE TO TAPE
         495+ 0  578          + STOP      CCLEN        LEN
         496+10  496          + R ADD     *
         497+ 1   53          + TR        PRTNLINE     
         498+ 0  101          + STOP      0101         STRINGZ AT COL 1
         499+ 0 1940          + STOP      MSGNTMPN     "TEMP VARS"
         500+ 0  210          + STOP      0210         INT AT COL 10
         501+ 0 1899          + STOP      TMPN         HIGH NUMBER OF TEMP VAR USED
         502+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         503+ 1  170          + TR        READREG      PROCEED WITH NEXT REGION
         504+ 8    0 EOF      + NOOP      0000         END OF FILE
         505+27  258          + WRITE EF  TAPEOUT      WRITE EOF IN TAPE OUT (COMPACT CODE)
         506+30   74          + SENSE     0074         SENSE SWITCH 6
         507+ 1  513          + TR        ENDLOG1B     TR IF NO LOG SELECTED
         508+10  508          + R ADD     *
         509+ 1   53          + TR        PRTNLINE     
         510+ 0  101          + STOP      0101         STRINGZ AT COL 1
         511+ 0 1944          + STOP      MSGDONE      "END OF PASS"
         512+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         513+ 8    0 ENDLOG1B + NOOP      0000
         514+28  257          + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE)
         515+28  259          + REWIND    TAPEINR      REWIND TAPE IN WITH STEP REFERENCES 
         516+28  258          + REWIND    TAPEOUT      REWIND TAPE OUT WITH UPDATED PACT COMPACT CODE
         517+10  517          + R ADD     *
         518+ 1   51          + TR        CHAIN        IF SW2 IS ON, A +STOP 4095 IS EXECUTED 
         519+ 0  256          + STOP      PACTCOMP     CHAIN TO NEXT STAGE IN PACT COMPILER TAPE
         520+ 0 4095          + STOP      4095
         521+ 9 1887 ERROR    + ADD       TWO
         522+13  523          + STORE A   ERRP1
         523+10    0 ERRP1    + R ADD     /   /
         524+13  530          + STORE A   ERRSTRZ      SAVE ADDR OF ERROR TXT MESSAGE
         525+10  525          + R ADD     *            PRINT USER PROGRAM SOURCE CODE CARD JUST PROCESSED
         526+ 1   55          + TR        PRINTCRD
         527+10  527          + R ADD     *
         528+ 1   53          + TR        PRTNLINE     
         529+ 0  101          + STOP      0101         STRINGZ AT COL 1
         530+ 0    0 ERRSTRZ  + STOP      /   /        ERROR MESSAGE
         531+ 0    0          + STOP      0000         END OF LINE
         532+ 0  201          + STOP      READSTEP     IF USER PRESS STARTS, PROGRAM RESUMES PROCESSING NEXT SOURCE CODE STEP 
         533+     0             ORG       EVEN
         534+     0  PACTSRC    RES       24           CARD IMAGE OF PACT SOURCE CODE CARD (12 FULL WORDS)
         558+     0  REGION     DEF       0
         559+     0  STEP       DEF       0            REGION = ALFA (<0)
         560+     0  OP         DEF       0            STEP   = INT (>0)
         561+     0  FACT       DEF       0            OP     = 0..43    =0 MEANS END OF REGION
         562+     0  S1         DEF       0            FACT   < 0 -> FACTOR IS AN ALFA SYMBOL (VAR, REGION, ...) 
         563+     0  S2         DEF       0            FACT = 0 -> BLANK FACTOR
         564+     0  QR         DEF       0            FACT = 0..9999 -> DESTINATION STEP FOR TRANSFER/RESULT OF STEP
         565+     0  QF         DEF       0            CLUE = -, R OR N
         566+     0  NUM        DEF       0            
         567+     0             DEF       0            S1/S2 = 0 -> BLANK, >0 -> INTEGER, <0 -> ALFA 
         568+     0  CLUE       DEF       0
         569+     0  STEPN      DEF       0            QR = +/- INTEGER OR BLANK. 
         570+     0  FACTN      DEF       0            QF = SET IF THERE IS AN INTEGER FACTOR/NUMBER IN CARD
         571+     0  FACTREG    DEF       0
         572+     0  S1N        DEF       0            STEPN = SEQUENTIAL NUMBER OF STEP            
         573+     0  S2N        DEF       0            IF OP IS TRANSFER -> FACTN=DESTINATION STEPN
         574+     0  D1N        DEF       0               OP CALLS IN A RESULT OF STEP -> FACTN=TEMP ADDR (2, 4, ..)
         575+     0  D2N        DEF       0                                               FACTREG='T'
         576+     0  NINST      DEF       0
         577+     0  NINCR      DEF       0
         578+    44  CCLEN      DEF       0044         LENGTH OF COMPACT CODE RECORD 
         579+     0  VAL        DEF       0            TEMP VAR (HERE TO MAKE TABLES START AT EVEN LOCATION)
         580+   100  MAXNREGS   DEF       100          MAX 100 REGIONS CAN DE DEFINED IN ONE PROGRAM 
         581+     0  NREGIONS   DEF       0            NUMBER OF REGIONS DEFINED
         582+     0  TREGIONS   RES       100          EACH ENTRY IN TABLE IS 1 HALF-WORD. HAS THE NAME (ALFA) OF REGION
         682+     0  TRISDUP    RES       100          =1 IF THIS REGION IS REFERENCED IN A DUP INSTR ELSEWHERE (IE THIS REGION IS DUPLICATED)
         782+     0  TRNEEDCA   RES       100          =1 IF REGION NEEDS A CALL INSTR AS FIRST STEP
         882+     0  TREXSIZE   RES       100          EXPANDED NUMBER OF STEPS OF REGION (NOT COUNTING EOR)
         982+     0  TREXTMP    RES       100          EXPANDED NUMBER OF NEEDED TEMP VARS IN REGION (=NUM OF STEPS REFERENCED AS RESULT OF STEP)
        1082+   400  MAXNREFS   DEF       400          MAX 400 STEPS REFERENCES CAN DE DEFINED IN ONE REGION
        1083+     0  NREFS      DEF       0            NUMBER OF ENTRIES IN TREFS TABLE
        1084+     0  TREFS      RES       400          EACH ENTRY IN TABLE IS THE STEP REFERNECED
        1484+     0  TREFSN     RES       400          THE CORRESPONDING STEPN/TEMP VAR NUMBER
        1884+     0  ZERO       DEF       0
        1885+     0             DEF       0
        1886+     1  ONE        DEF       1
        1887+     2  TWO        DEF       2
        1888+     4  D4         DEF       4
        1889+     7  D7         DEF       7
        1890+    21  D21        DEF       21
        1891+    22  D22        DEF       22
        1892+    26  D26        DEF       26
        1893+    30  D30        DEF       30
        1894+    32  D32        DEF       32
        1895+     0  REF        DEF       0            REFERENCED STEP
        1896+     0  IREG       DEF       0            REGION NUMBER BEING PROCESSED (INDEX IN TREGIONS, IREG=1 -> FIRST ENTRY IN TREGIONS TABLE)
        1897+     0  IREGDUP    DEF       0
        1898+     0  IREF       DEF       0
        1899+     0  TMPN       DEF       0            NUMBER OF TEMP VARS USED
        1900+     0  RSLTSTP    DEF       0            FACT FOR EQ RESULT OF STEP
        1901+     0  EQTOTMP    DEF       0            FLAG TO GENERATE "EQ TEMP" INSTR
        1902+     0  STEPCNT    DEF       0            STEP COUNTER TO SET STEPN
        1903+     0  PVREG      DEF       0            THE REGION OF PREVIOUS STEP
        1904+     0  PVOP       DEF       0            THE OPERATION ON PREVIOUS STEP
        1905- 69955  ERRREGNF   TXT       "REGION NOT FOUND",0
        1906- 49706  
        1907-  1275  
        1908- 73746  
        1909- 63818  
        1910- 36864  
        1911+     0  
        1912- 72977  ERRRSNF    TXT       "STEP DOES NOT EXISTS",0              ERROR: CALLING-IN RESULT OF NON-EXISTANT STEP
        1913- 64528  
        1914- 63055  
        1915-  1275  
        1916- 73745  
        1917- 83983  
        1918- 75216  
        1919+     0  
        1920- 75181  ERRTRNF    TXT       "TRANSFER TO NON EXISTANT STEP",0     ERROR: TRANSFER TO NON-EXISTANT STEP
        1921- 61410  
        1922- 40608  
        1923- 75024  
        1924- 61226  
        1925-   852  
        1926- 49904  
        1927- 31232  
        1928-  1520  
        1929- 40512  
        1930+     0  
        1931- 30655  MSGSTART   TXT       "ABSTRACT ASSEMBLY PASS 2",0
        1932- 75181  
        1933- 36096  
        1934- 31471  
        1935- 40382  
        1936- 57072  
        1937- 65167  
        1938- 71426  
        1939+     0  
        1940- 74569  MSGNTMPN   TXT       "TEMP VARS",0
        1941- 64546  
        1942- 31423  
        1943+     0  
        1944- 40432  MSGDONE    TXT       "END OF PASS",0
        1945-  1314  
        1946-  1357  
        1947- 72912  
        1948+     0  
        1949- 40560  ALFEQ      TXT       'EQ '
        1950- 35208  ALFCAL1    TXT       'CAL'
        1951- 55296  ALFCAL2    TXT       'L  '
        1952- 40917  ALFEXI1    TXT       'EXI'
        1953- 73728  ALFEXI2    TXT       'T  '
        1954+15 1968 CLRBUF   + LOAD MQ   IOCL
        1955+14 1973          + STORE MQ  BUFIO
        1956+15 1994          + LOAD MQ   IOSTORE         
        1957+ 1 1965          + TR        INIT2
        1958+15 1990 READCRD  + LOAD MQ   IORDCRD
        1959+ 1 1963          + TR        INIT1
        1960+15 1992 WRITECRD + LOAD MQ   IOWRCRD
        1961+ 1 1963          + TR        INIT1
        1962+15 1993 PRINTCRD + LOAD MQ   IOPRCRD
        1963+14 1973 INIT1    + STORE MQ  BUFIO
        1964+15 1991          + LOAD MQ   IOCOPY         
        1965+14 1974 INIT2    + STORE MQ  BUFROW
        1966+ 9 2000          + ADD       TWO          
        1967+13 1989          + STORE A   EXIT
        1968+10 1996 IOCL     + R ADD     ZERO         RESET TO INITIAL COPY LOOP ADDRESS     
        1969+13 1974          + STORE A   BUFROW       FOR BUFFER
        1970+10 1974          + R ADD     BUFROW       X .*echo Print
        1971+ 5 2001          + SUB       D48          X 
        1972+12 1998          + STORE     ENDLP        X LOOP END VALUE
        1973- 0    0   BUFIO  - STOP      /   /        READ OR WRITE
        1974-31    0   BUFROW - COPY      /   /        COPY WORD TO/FROM PRINTER/CARDREADER
        1975+ 1 1979          + TR        BUFOK2       NORMAL PROCESSING 
        1976+ 1 1986          + TR        EODECK       FOR COPY READING END OF REG (=END OF DECK BEING READ)
        1977+ 6 2000          + R SUB     TWO          END OF FILE -> NO CARD TO READ -> STOP with Acc=-2
        1978+ 0 1973          + STOP      BUFIO        ON PRESSING START RETRY CARD READ
        1979+10 1974   BUFOK2 + R ADD     BUFROW       X
        1980+ 5 2000          + SUB       TWO          INCR BUF ADDR
        1981+13 1974          + STORE A   BUFROW       X
        1982+ 5 1998          + SUB       ENDLP        CHECK FOR END
        1983+ 4 1988          + TR 0      ENDIO
        1984+10 1996          + R ADD     ZERO         CLEAR ACC IN CASE WE ARE CLEANING THE BUFFER
        1985+ 1 1974          + TR        BUFROW
        1986+10 1999 EODECK   + R ADD     ONE          SET OV FLAG TO SIGNAL END OF DECK CONDITION
        1987+22   36          + A LEFT    36
        1988+26 2052 ENDIO    + WRITE     2052         END OF I/O: INSURE THAT MQ NOT IN USE            
        1989+ 1    0 EXIT     + TR        /   /
        1990+24 2048 IORDCRD  + READ      2048         PREPARE TO READ FROM CARD READER
        1991-31    0 IOCOPY   - COPY      /   /   
        1992+26 1024 IOWRCRD  + WRITE     1024         PREPARE TO PUNCH CARD 
        1993+26  512 IOPRCRD  + WRITE     0512         PREPARE WRITE PRTBUF ON PRINTER
        1994-12    0 IOSTORE  - STORE     /   /        CLEAR BUFFER
        1995+     0             ORG       EVEN           
        1996+     0  ZERO       DEF       0            
        1997+     0             DEF       0            
        1998+     0  ENDLP      DEF       0            LOOP END VALUE
        1999+     1  ONE        DEF       1
        2000+     2  TWO        DEF       2
        2001+    48  D48        DEF       48
        2002+ 9 2273 PRTPARM2 + ADD       TWO          GET 2 PARAMS: LEN AND COL (EITHER VALUE OR VAR ADDR)
        2003+13 2022          + STORE A   PRTPRMEX
        2004+10 2012          + R ADD     PRTP1
        2005+ 9 2273          + ADD       TWO          PRINT PACKED TEXT FROM FULL-WORD VALUE IN MQ REGISTER 
        2006+13 2012          + STORE A   PRTP1        STORE ADDR OF FIRST PARAM (LEN)
        2007+ 9 2272          + ADD       ONE
        2008+13 2014          + STORE A   PRTP2        STORE ADDR OF SECOND PARAM (COL)
        2009+ 9 2272          + ADD       ONE
        2010+13 2089          + STORE A   EXIT
        2011-14 2262          - STORE MQ  NUM          SAVE VALUE TO PRINT PARAM MQ (NUM IS ALIASED TO TXT)
        2012+10    0   PRTP1  + R ADD     /   /        GET LEN: NUMBER OF CHARS TO PRINT (1..6)
        2013+12 2266          + STORE     LEN
        2014+10    0   PRTP2  + R ADD     /   /        GET COLUMN PARAM 1..72
        2015+ 3 2018          + TR +      PRTP4
        2016+13 2017          + STORE A   PRTP3        COL<0 -> INTERPRET COL AS LOC(COL) = ADDR OF COL VAR
        2017+10    0   PRTP3  + R ADD     /   /        READ VAR COL PASED AS PARAM
        2018+ 4 2089   PRTP4  + TR 0      EXIT         COL=0 -> EXIT
        2019+ 3 2021          + TR +      PRTP5
        2020+ 1 2089          + TR        EXIT         COL<0 -> EXIT
        2021+12 2072   PRTP5  + STORE     COL
        2022+ 1    0 PRTPRMEX + TR        /   /        RETURN TO CALLER
        2023+13 2012 PRTSTR   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2024+10 2024          + R ADD     *            FOR PRINT STRINGZ FROM MEM
        2025+ 1 2002          + TR        PRTPARM2
        2026+12 2036          + STORE     COLSZ
        2027+10 2266          + R ADD     LEN          LEN IS IN FACT THE LOCATION WHERE THE STRING STARTS
        2028+13 2031          + STORE A   STRZAD
        2029+10 2089          + R ADD     EXIT
        2030+13 2044          + STORE A   STRZEX
        2031+10    0 STRZAD   + R ADD     /   /        GET HALF-WORD WITH NEXT 3 CHARS TO PRINT
        2032+ 4 2044          + TR 0      STRZEX       IF +0 -> END OF STRING (-0 DOES NOT TERMINATES THE STRING)
        2033+21   35          + L RIGHT   0035         MQ=3-CHARS TO PRINT
        2034+10 2034          + R ADD     *            
        2035+ 1 2046          + TR        PRTALF       PRINT 3 CHARS
        2036+ 0    0 COLSZ    + STOP      0000         COL 
        2037+10 2031 STRZ1    + R ADD     STRZAD       INCR STRING ADDRESS
        2038+ 9 2272          + ADD       ONE
        2039+13 2031          + STORE A   STRZAD
        2040+10 2036          + R ADD     COLSZ        INCR COLUMN
        2041+ 9 2274          + ADD       D3
        2042+13 2036          + STORE A   COLSZ
        2043+ 1 2031          + TR        STRZAD
        2044+ 3    0 STRZEX   + TR +      /   /        IF ZERO -> END OF STRING
        2045+ 1 2037          + TR        STRZ1
        2046+ 9 2273 PRTALF   + ADD       TWO          PRINT 3-PACKED CHARS IN MQ REGISTER 
        2047+14 2268          + STORE MQ  TXT          SAVE TEXT TO PRINT (IN LEFT HALF WORD)
        2048+13 2051          + STORE A   PRTAP2       STORE ADDR OF PARAM (COL)
        2049+ 9 2272          + ADD       ONE
        2050+13 2089          + STORE A   EXIT
        2051+10    0   PRTAP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        2052+ 3 2055          + TR +      PRTAP4
        2053+13 2054          + STORE A   PRTAP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        2054+10    0   PRTAP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        2055+12 2072   PRTAP4 + STORE     COL
        2056+10 2274          + R ADD     D3
        2057+12 2266          + STORE     LEN
        2058+10 2256 PRT1     + R ADD     ZERO         UNPACK LEFTMOST CHAR 
        2059+11 2268          + ADD AB    TXT          GET TEXT DISCARD SIGN
        2060+21   35          + L RIGHT   0035         MQ=Acc
        2061+10 2256          + R ADD     ZERO
        2062+18 2281          + DIV       D48X48
        2063+12 2268          + STORE     TXT          remainder=char to print, mq=c2 * 48 + c3 in right half-word
        2064+10 2256          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        2065+20   18          + L LEFT    0018         put c2 and c3 in left half-word of MQ to be saved in CHAR half word
        2066+14 2267          + STORE MQ  CHAR         CHAR TO PRINT
        2067+10 2267          + R ADD     CHAR 
        2068+ 4 2073          + TR 0      NXTCHR       IF BLANK PROCEED TO NEXT COL
        2069+21   35          + L RIGHT   0035         MQ=CHAR TO PRINT
        2070+10 2070          + R ADD     *            PRINT CHAR
        2071+ 1 2166          + TR        PRTCHR
        2072+ 0    0 COL      + STOP      0000         COL: COLUMN NUMBER TO PRINT (1..72)
        2073+10 2266 NXTCHR   + R ADD     LEN          DECR LEN COUNT
        2074+ 5 2272          + SUB       ONE
        2075+12 2266          + STORE     LEN
        2076+ 4 2089          + TR 0      EXIT         IF NO MORE CHARS TO PRINT EXIT
        2077+10 2072          + R ADD     COL          INCR COL POSITION
        2078+ 9 2272          + ADD       ONE
        2079+12 2072          + STORE     COL
        2080+ 5 2280          + SUB       D72          IF COL > 72 RETURN TO CALLER
        2081+ 4 2083          + TR 0      GNXTCHR      ELSE PROCEED WITH NEXT CHAR
        2082+ 3 2089          + TR +      EXIT
        2083+10 2256 GNXTCHR  + R ADD     ZERO         GET NEXT CHAR 
        2084+15 2268          + LOAD MQ   TXT
        2085+16 2279          + MPY       D48
        2086+22   17          + A LEFT    0017         GET RESULT IN LEFT HALF-WORD OF ACC
        2087+12 2268          + STORE     TXT
        2088+ 1 2058          + TR        PRT1         PROCEED TO PRINT CHAR
        2089+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        2090+13 2012 PRTOCT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2091+10 2091          + R ADD     *            FOR PRINT OCTIONARY VALUE
        2092+ 1 2002          + TR        PRTPARM2
        2093+10 2266          + R ADD     LEN          LEN = OCTAL DIGITS TO PRINT
        2094+ 9 2072          + ADD       COL
        2095+ 5 2272          + SUB       ONE
        2096+12 2108          + STORE     COLN         COL POINTS TO LEAST SIGNIFICANT DIGIT
        2097+10 2262 PRTIOCG  + R ADD     NUM          GENERATE OCTINARY DIGIT
        2098+15 2256          + LOAD MQ   ZERO         CLEAR MQ
        2099+21   21          + L RIGHT   0021         3 LSB BITS OF LEFT HALF-WORD OF ACC TO MQ
        2100+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 3 BIT)
        2101+12 2262          + STORE     NUM          SAVE BACK NUM WITH RIGHTMOST OCTIONARY DIGIY EXTRACTED (NUM'=NUM/8)
        2102+10 2256          + R ADD     ZERO
        2103+20   21          + L LEFT    0021         LEFT HALF-WORD OF ACC IS NOW RIGHTMOST OCTINARY DIGIT EXTRACTED FROM NUM 
        2104+ 4 2122          + TR 0      PRTIOZ       TR IF THIS DIGIT IS ZERO TO PRINT A '0' (BASE48 CODE = 10) INSTEAD OF A BLANK (BASE48 CODE = 0)
        2105+21   35          + L RIGHT   0035         PUT DIGIT 1..9 TO PRINT IN MQ
        2106+10 2106 PRTOCTD  + R ADD     *            PRINT OCTINARY DIGIT
        2107+ 1 2166          + TR        PRTCHR
        2108+ 0    0 COLN     + STOP      0000
        2109+10 2108          + R ADD     COLN        DECR COL NUMBER TO PRINT NEXT DIGIT
        2110+ 5 2272          + SUB       ONE
        2111+12 2108          + STORE     COLN
        2112+10 2266          + R ADD     LEN          DECR COL NUMBER TO PRINT NEXT DIGIT
        2113+ 5 2272          + SUB       ONE
        2114+ 4 2089          + TR 0      EXIT         PRINTED LEN OCTINARY DIGITS -> EXIT
        2115+12 2266          + STORE     LEN
        2116+10 2262          + R ADD     NUM          IF NUM < 0, ADD SIGN BIT TO LEFTMOST DIGIT
        2117+ 3 2097          + TR +      PRTIOCG
        2118+10 2282          + R ADD     OCT04K       
        2119+ 5 2262          + SUB       NUM
        2120+12 2262          + STORE     NUM
        2121+ 1 2097          + TR        PRTIOCG
        2122+15 2275   PRTIOZ + LOAD MQ   D10          ACC=BASE48 CODE FOR '0'
        2123+ 1 2106          + TR        PRTOCTD      TR TO PRINT IT
        2124+13 2012 PRTINT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2125+10 2125          + R ADD     *            FOR PRINT OCTIONARY VALUE
        2126+ 1 2002          + TR        PRTPARM2
        2127+10 2072          + R ADD     COL          PRINT DECIMAL NUMBER. VALUE OF LEN = DIGITS TO PRINT, NOT INCLUDING SIGN
        2128+ 9 2266          + ADD       LEN
        2129+ 5 2272          + SUB       ONE          
        2130+12 2151          + STORE     COLNI        COL POINTS TO END OF NUMBER
        2131+10 2256          + R ADD     ZERO
        2132+12 2265          + STORE     SGN          SIGN IS POSITIVE
        2133+10 2262          + R ADD     NUM
        2134+ 3 2139          + TR +      PRTINTG
        2135+ 6 2262          + R SUB     NUM          NUM IS NEGATIVE. CONVERT TO POSITIVE
        2136+12 2262          + STORE     NUM          AND SET SGN=1
        2137+10 2272          + R ADD     ONE
        2138+12 2265          + STORE     SGN          
        2139+10 2262 PRTINTG  + R ADD     NUM          GENERATE DECIMAL DIGIT
        2140+21   35          + L RIGHT   0035         MQ=Acc
        2141+10 2256          + R ADD     ZERO
        2142+18 2275          + DIV       D10
        2143+ 4 2164          + TR 0      PRTINZ
        2144+12 2267 PRTINTG2 + STORE     CHAR         acc=remainder=digit to print, mq=num/10
        2145+10 2256          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        2146+20   18          + L LEFT    0018         digit in left half-word of MQ to be saved in CHAR half word
        2147+14 2262          + STORE MQ  NUM 
        2148+15 2267          + LOAD MQ   CHAR 
        2149+10 2149 PRTINTD  + R ADD     *            PRINT DECIMAL DIGIT
        2150+ 1 2166          + TR        PRTCHR
        2151+ 0    0 COLNI    + STOP      0000
        2152+10 2151          + R ADD     COLNI        DECR COL NUMBER TO PRINT NEXT DIGIT
        2153+ 5 2272          + SUB       ONE
        2154+12 2151          + STORE     COLNI
        2155+10 2262          + R ADD     NUM          DO NOT CARE ABOUT LEN, JUST CHECK IF NUM=0 
        2156+ 4 2158          + TR 0      PRTINS       (SO NO MORE DIGITS REMAINS TO BE PRINTED)
        2157+ 1 2139          + TR        PRTINTG      NUM NOT FINISHED, PROCEED WITH NEXT DIGIT
        2158+10 2265 PRTINS   + R ADD     SGN
        2159+ 4 2089          + TR 0      EXIT         NO SIGN -> NUM FINISHED
        2160+10 2256          + R ADD     ZERO
        2161+12 2265          + STORE     SGN          CLEAR SGN FLAG
        2162+15 2276          + LOAD MQ   D11          BASE48 CODE FOR '-' (MINUS) CHAR
        2163+ 1 2149          + TR        PRTINTD      GO TO PRINT IT
        2164+10 2275   PRTINZ + R ADD     D10          ACC=BASE48 CODE FOR '0'
        2165+ 1 2144          + TR        PRTINTG2     TR TO PRINT IT
        2166+ 9 2273 PRTCHR   + ADD       TWO          PRINT CHAR IN MQ REGISTER 
        2167+14 2267          + STORE MQ  CHAR         SAVE CHAR TO PRINT (IN LEFT HALF WORD)
        2168+13 2172          + STORE A   PRTCP2       STORE ADDR OF PARAM (COL)
        2169+ 9 2272          + ADD       ONE
        2170+13 2250          + STORE A   PRTCEX
        2171+ 2 2172          + TR OV     PRTCP2       CLEAR OV JUST IN CASE
        2172+10    0   PRTCP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        2173+ 3 2176          + TR +      PRTCP4
        2174+13 2175          + STORE A   PRTCP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        2175+10    0   PRTCP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        2176+ 5 2272   PRTCP4 + SUB       ONE
        2177+12 2270          + STORE     N            N=COL-1 -> IN RANGE 0..71
        2178+ 3 2180          + TR +      PRTSA        IF N >= 0 PROCEED WITH BASE BUFFER ADDR CALCULATION
        2179+ 1 2250          + TR        PRTCEX       IF N<0 EXIT
        2180+10 2256    PRTSA + R ADD     ZERO         CARD BUFFER USES LOCATION 0..47
        2181+13 2269          + STORE A   PRTROWAD     DETERMINE ADDRESS OF LOWER ROW TO PRINT
        2182+10 2270          + R ADD     N
        2183+ 5 2278          + SUB       D36
        2184+ 3 2186          + TR +      PRTC0
        2185+ 1 2192          + TR        PRTC1
        2186+12 2270    PRTC0 + STORE     N            COL NOW 0..35 
        2187+ 5 2278          + SUB       D36
        2188+ 3 2250          + TR +      PRTCEX       IF COL >= 36 (IE COL PASSED AS PARAM > 72) THEN EXIT
        2189+10 2269          + R ADD     PRTROWAD
        2190+ 9 2273          + ADD       TWO
        2191+13 2269          + STORE A   PRTROWAD     SET BASE BUFFER ADDR 
        2192+10 2272    PRTC1 + R ADD     ONE          DETERMINE MASKCOL WITH MASK TO SET IN CARD BUFFER
        2193+21   53          + L RIGHT   53           SET RIGHTMOST BIT OF MQ TO 1 (SHIFT 35+18=53)
        2194+10 2277          + R ADD     D35
        2195+ 5 2270          + SUB       N
        2196+13 2198          + STORE A   PRTC2
        2197+10 2256          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW
        2198+20    0    PRTC2 + L LEFT    /   /        SHIFT MQ LEFT N PLACES
        2199+ 4 2202          + TR 0      PRTC3        IF ACC STILL ZERO -> MASKCOL VALID
        2200+ 6 2272          + R SUB     ONE          ACC NOT ZERO -> SHOULD GENERATE -0 TO SET SIGN BIT ON
        2201+21   72          + L RIGHT   0072         NOW MQ = -0 -> LEFTMOST BIT OF MQ SET
        2202-14 2258    PRTC3 - STORE MQ  MASKCOL
        2203+10 2256          + R ADD     ZERO         READ THE BITMAP OF CHAR 
        2204+11 2267          + ADD AB    CHAR         DISCARD SIGN OF CHAR, IF ANY
        2205+12 2267          + STORE     CHAR
        2206+ 5 2279          + SUB       D48
        2207+ 3 2250          + TR +      PRTCEX       IF CHAR >= 48 EXIT
        2208+10 2264          + R ADD     BITMAPAD     IF ADDR OF BASE48 BITMAP NOT COMPUTED
        2209+ 4 2251          + TR 0      GETBMP1      TR TO LOAD IT
        2210+ 9 2267  GETBMP2 + ADD       CHAR         READ THE BITMAP OF CHAR 
        2211+13 2212          + STORE A   PRTC4        INDICATES THE BITS TO SET IN SELECTED 
        2212+10    0    PRTC4 + R ADD     /   /        COLUMN OF CARD BUFFER 
        2213+12 2271          + STORE     BITS
        2214+ 6 2272          + R SUB     ONE
        2215+12 2270          + STORE     N            SET TO -1
        2216+10 2270    LOOP1 + R ADD     N            CURRENT ROW (STARTS AT ZERO) = OFFSET ON PRTROWAD     
        2217+ 9 2272          + ADD       ONE
        2218+12 2270          + STORE     N
        2219+10 2271          + R ADD     BITS         EXTRACT RIGHTMOST BIT OF LEFT HALF OF ACC TO MQ
        2220+ 4 2250          + TR 0      PRTCEX       NO MORE BITS -> EXIT
        2221+21   19          + L RIGHT   0019         LSB BIT OF LEFT HALF-WORD OF ACC TO MQ
        2222+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 1 BIT)
        2223+12 2271          + STORE     BITS         SAVE BACK BITS. LSB HAS BEEN EXTACTED, CONTENTS SHIFTED RIGHT ONE PLACE
        2224+10 2256          + R ADD     ZERO
        2225+20    1          + L LEFT    0001         PUT EXTACTED BIT BACK INTO ACC
        2226+ 4 2216          + TR 0      LOOP1        NO BIT 
        2227+10 2270          + R ADD     N            READ THE ROW N AT CARD BUFFER 
        2228+22    2          + A LEFT    0002         MULT N BY 4 AS THERE ARE 4 HALF WORDS PER ROW
        2229+ 9 2269          + ADD       PRTROWAD     
        2230+13 2232          + STORE A   PRTROWR
        2231+13 2248          + STORE A   PRTROWW
        2232-10    0  PRTROWR - R ADD     /   /        
        2233-12 2260          - STORE     ROW          CURRENT CONTENTS OF ROW
        2234-10 2258          - R ADD     MASKCOL      "OR" MASKCOL IN SELECTED ROW
        2235+ 3 2243          + TR +      PRTW2
        2236-10 2260          - R ADD     ROW 
        2237+ 4 2241          + TR 0      PRTW1         
        2238+10 2256          + R ADD     ZERO         MASKCOL IS MINUS ZERO AND ROW IS NOT-EMPTY (EITHER POSITIVE OR NEGATIVE) -> SET ROW AS NEGATIVE
        2239- 7 2260          - SUB AB    ROW 
        2240+ 1 2248          + TR        PRTROWW
        2241-10 2258    PRTW1 - R ADD     MASKCOL      MASKCOL IS MINUS ZERO AND ROW IS EMPTY -> SET ROW = MASKCOL = MINUS ZERO
        2242+ 1 2248          + TR        PRTROWW
        2243-10 2260    PRTW2 - R ADD     ROW          
        2244+ 3 2247          + TR +      PRTW3              
        2245- 5 2258          - SUB       MASKCOL      MASKCOL IS POSITIVE AND ROW IS NEGATIVE -> SUB MASKCOL FROM ROW
        2246+ 1 2248          + TR        PRTROWW
        2247- 9 2258    PRTW3 - ADD       MASKCOL      MASKCOL IS POSITIVE AND ROW IS POSITIVE OR EMPTY -> ADD MASKCOL TO ROW         
        2248-12    0  PRTROWW - STORE     /   /        ROW UPDTATE
        2249+ 1 2216          + TR        LOOP1        PROCEED TO NEXT ROW
        2250+ 1    0 PRTCEX   + TR        /   /
        2251+10 2251 GETBMP1  + R ADD     *
        2252+ 1   87          + TR        BMPAD        GET BASE48 CHARS BITMAP ADDRESS
        2253+12 2264          + STORE     BITMAPAD     
        2254+ 1 2210          + TR        GETBMP2      RETURN
        2255+     0             ORG       EVEN
        2256+     0  ZERO       DEF       0            
        2257+     0             DEF       0            
        2258+     0  MASKCOL    DEF       0
        2259+     0             DEF       0
        2260+     0  ROW        DEF       0
        2261+     0             DEF       0
        2262+     0  NUM        DEF       0
        2263+     0             DEF       0
        2264+     0  BITMAPAD   DEF       0
        2265+     0  SGN        DEF       0
        2266+     0  LEN        DEF       0
        2267+     0  CHAR       DEF       0
        2268+     0  TXT        DEF       0
        2269+     0  PRTROWAD   DEF       0
        2270+     0  N          DEF       0
        2271+     0  BITS       DEF       0
        2272+     1  ONE        DEF       1
        2273+     2  TWO        DEF       2
        2274+     3  D3         DEF       3
        2275+    10  D10        DEF       10
        2276+    11  D11        DEF       11
        2277+    35  D35        DEF       35
        2278+    36  D36        DEF       36
        2279+    48  D48        DEF       48
        2280+    72  D72        DEF       72
        2281+  2304  D48X48     DEF       2304
        2282+ 16384  OCT04K     DEF       *040000      BIT SIGN ON 5TH OCTINARY DIGIT
        2284+ 9 2359 PRTNLINE + ADD       TWO          PRINT A NEW LINE OF DATA
        2285+12 2362          + STORE     PARAM        SAVE PARAM LIST ADDR
        2286+10 2286          + R ADD     *            CLEAR CARD BUFFER
        2287+ 1   69          + TR        CLRBUF 
        2288+10 2362 GPARAM   + R ADD     PARAM        GET PARAM PAIR FMT/DATA
        2289+13 2294          + STORE A   P1
        2290+ 9 2358          + ADD       ONE
        2291+13 2298          + STORE A   P2
        2292+ 9 2358          + ADD       ONE
        2293+12 2362          + STORE     PARAM
        2294+10    0 P1       + R ADD     /   /
        2295+12 2364          + STORE     FMT
        2296+ 3 2298          + TR +      P2           IF FMT < 0 THEM SKIP THIS PAIR FMT/DATA
        2297+ 1 2288          + TR        GPARAM
        2298+10    0 P2       + R ADD     /   /
        2299+12 2324          + STORE     DATALOC      GET DATA ADDRESS PASED AS PARAM
        2300+13 2301          + STORE A   P2A
        2301+10    0 P2A      + R ADD     /   /
        2302+12 2363          + STORE     DATA         GET EFFECTIVE DATA
        2303+10 2357          + R ADD     ZERO
        2304+15 2364          + LOAD MQ   FMT
        2305+18 2361          + DIV       D100         ACC=REMAINDER=COL NUMBER, MQ=QUOTIEN=TYPE OF DATA
        2306+12 2365          + STORE     COL
        2307+10 2357          + R ADD     ZERO
        2308+20   18          + L LEFT    0018
        2309+14 2364          + STORE MQ  FMT
        2310+15 2363          + LOAD MQ   DATA
        2311+10 2315          + R ADD     TYPETRAD
        2312+ 9 2364          + ADD       FMT
        2313+13 2314          + STORE A   TYPETR
        2314+ 1    0 TYPETR   + TR        /   /        TR SELECTED ROUTINE
        2315+ 0 2316 TYPETRAD + STOP      TYPETRT      TYPE TRANSFER TABLE ADDRESS
        2316+ 1 2345 TYPETRT  + TR        EOL          FMT=0..6 (IE <100) -> END OF PARAM LIST -> END OF LINE 
        2317+ 1 2322          + TR        TYSTR        FMT=1 -> PRINT A STRINGZ
        2318+ 1 2327          + TR        TYINT        FMT=2 -> PRINT AN INT
        2319+ 1 2332          + TR        TYOCT        FMT=3 -> PRINT AN OCT
        2320+ 1 2337          + TR        TYCHR        FMT=4 -> PRINT A CHAR
        2321+ 1 2341          + TR        TYALF        FMT=5 -> PRINT A 3-CHR PACKED ALFA STRING
        2322+10 2322 TYSTR    + R ADD     *            PRINT STRINGZ
        2323+ 1   77          + TR        PRTSTR
        2324+ 0    0 DATALOC  + STOP      /   /
        2325- 0 2365          - STOP      COL          COLUMN WHERE TXT STARTS
        2326+ 1 2288          + TR        GPARAM
        2327+10 2327 TYINT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2328+ 1   81          + TR        PRTINT
        2329+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        2330- 0 2365          - STOP      COL          COLUMN WHERE TXT STARTS
        2331+ 1 2288          + TR        GPARAM
        2332+10 2332 TYOCT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2333+ 1   83          + TR        PRTOCT
        2334+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        2335- 0 2365          - STOP      COL          COLUMN WHERE TXT STARTS
        2336+ 1 2288          + TR        GPARAM
        2337+10 2337 TYCHR    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2338+ 1   79          + TR        PRTCHR
        2339- 0 2365          - STOP      COL          COLUMN WHERE TXT STARTS
        2340+ 1 2288          + TR        GPARAM
        2341+10 2341 TYALF    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2342+ 1   75          + TR        PRTALF
        2343- 0 2365          - STOP      COL          COLUMN WHERE TXT STARTS
        2344+ 1 2288          + TR        GPARAM
        2345+10 2365 EOL      + R ADD     COL          SEND CARD BUFFER TO PRINTER AND RETURN TO CALLER
        2346+ 4 2351          + TR 0      DOPRINT      =0 -> PRINT ALLWAYS (NO SENSE SW CHECK)
        2347+ 9 2360          + ADD       D68          =1..6 -> SENSE 69..74 = OPERATOR'S PANEL SENSE SWITCH 1..6
        2348+13 2349          + STORE A   CHKSW
        2349+30    0 CHKSW    + SENSE     /   /         
        2350+ 1 2353          + TR        RETURN       SW NOT AT ON POSITION
        2351+10 2351 DOPRINT  + R ADD     *            PRINT CARD BUFFER
        2352+ 1   55          + TR        PRINTCRD
        2353+10 2362 RETURN   + R ADD     PARAM        PARAM-1 IS THE RETURN ADDR      
        2354+ 5 2358          + SUB       ONE
        2355+13 2356          + STORE A   EXIT
        2356+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        2357+ 0    0 ZERO     + STOP      0000
        2358+ 0    1 ONE      + STOP      0001
        2359+ 0    2 TWO      + STOP      0002
        2360+ 0   68 D68      + STOP      0068
        2361+ 0  100 D100     + STOP      100
        2362+ 0    0 PARAM    + STOP      0000
        2363+ 0    0 DATA     + STOP      0000
        2364+ 0    0 FMT      + STOP      0000
        2365+ 0    0 COL      + STOP      0000
        2366+ 9 2380 BMPAD    + ADD       TWO
        2367+13 2369          + STORE A   EXIT
        2368+10 2370          + R ADD     BITMAPAD
        2369+ 1    0 EXIT     + TR        /   /
        2370+ 0 2372 BITMAPAD + STOP      BITMAP
        2371+     0             ORG       EVEN
        2372+     0  BITMAP     DEF       0              <blank>     0     <none>
        2373+   256             DEF       256               1        1       1        256          =  256   
        2374+   128             DEF       128               2        2       2        128          =  128   
        2375+    64             DEF       64                3        3       3         64          =   64   
        2376+    32             DEF       32                4        4       4         32          =   32   
        2377+    16             DEF       16                5        5       5         16          =   16   
        2378+     8             DEF       8                 6        6       6          8          =    8   
        2379+     4             DEF       4                 7        7       7          4          =    4   
        2380+     2  TWO        DEF       2                 8        8       8          2          =    2   
        2381+     1             DEF       1                 9        9       9          1          =    1   
        2382+   512             DEF       512               0       10       0        512          =  512   
        2383+  1024             DEF       1024              -       11       X       1024          = 1024   
        2384+  2048             DEF       2048              +       12       Y       2048          = 2048   
        2385+  2304             DEF       2304              A       13      Y-1        256+2048    = 2304   
        2386+  2176             DEF       2176              B       14      Y-2        128+2048    = 2176   
        2387+  2112             DEF       2112              C       15      Y-3         64+2048    = 2112   
        2388+  2080             DEF       2080              D       16      Y-4         32+2048    = 2080   
        2389+  2064             DEF       2064              E       17      Y-5         16+2048    = 2064   
        2390+  2056             DEF       2056              F       18      Y-6          8+2048    = 2056   
        2391+  2052             DEF       2052              G       19      Y-7          4+2048    = 2052   
        2392+  2050             DEF       2050              H       20      Y-8          2+2048    = 2050   
        2393+  2049             DEF       2049              I       21      Y-9          1+2048    = 2049   
        2394+  1280             DEF       1280              J       22      X-1        256+1024    = 1280   
        2395+  1152             DEF       1152              K       23      X-2        128+1024    = 1152   
        2396+  1088             DEF       1088              L       24      X-3         64+1024    = 1088   
        2397+  1056             DEF       1056              M       25      X-4         32+1024    = 1056   
        2398+  1040             DEF       1040              N       26      X-5         16+1024    = 1040   
        2399+  1032             DEF       1032              O       27      X-6          8+1024    = 1032   
        2400+  1028             DEF       1028              P       28      X-7          4+1024    = 1028   
        2401+  1026             DEF       1026              Q       29      X-8          2+1024    = 1026   
        2402+  1025             DEF       1025              R       30      X-9          1+1024    = 1025   
        2403+   640             DEF       640               S       31      0-2        128+512     = 640    
        2404+   576             DEF       576               T       32      0-3         64+512     = 576    
        2405+   544             DEF       544               U       33      0-4         32+512     = 544    
        2406+   528             DEF       528               V       34      0-5         16+512     = 528    
        2407+   520             DEF       520               W       35      0-6          8+512     = 520    
        2408+   516             DEF       516               X       36      0-7          4+512     = 516    
        2409+   514             DEF       514               Y       37      0-8          2+512     = 514    
        2410+   513             DEF       513               Z       38      0-9          1+512     = 513    
        2411+   578             DEF       578               ,       39      8-3-0        2+64+512  = 578    
        2412+   546             DEF       546               %       40      8-4-0        2+32+512  = 546    
        2413+  1090             DEF       1090              $       41      8-3-X        2+64+1024 = 1090   
        2414+  1058             DEF       1058              *       42      8-4-X        2+32+1024 = 1058   
        2415+  2114             DEF       2114              .       43      8-3-Y        2+64+2048 = 2114   
        2416+  2082             DEF       2082              #       44      8-4-Y        2+32+2048 = 2082   
        2417+   768             DEF       768               /       45      0-1          512+256   = 768    
        2418+    66             DEF       66                +       46      8-3          2+64      = 66     
        2419+    34             DEF       34                -       47      8-4          2+32      = 34    This is the non-minus-sign separator
        2420+ 9 2444 CLMEM    + ADD       TWO 
        2421+13 2426          + STORE A   P1           PARM: ADDR 
        2422+ 9 2443          + ADD       ONE          
        2423+13 2428          + STORE A   P2           PARM: LOCATION OF LEN=NUMBER OF HALF-WORDS TO CLEAR 
        2424+ 9 2443          + ADD       ONE          
        2425+13 2434          + STORE A   EXIT
        2426+10    0 P1       + R ADD     /   /        GET ADDR TO CLEAR
        2427+13 2437          + STORE A   MEM
        2428+10    0 P2       + R ADD     /   /        GET LEN ADDR
        2429+13 2430          + STORE A   P2A
        2430+10    0 P2A      + R ADD     /   /        GET LEN 
        2431+12 2445          + STORE     LEN
        2432+15 2442          + LOAD MQ   ZERO
        2433+10 2445 LOOP     + R ADD     LEN
        2434+ 4    0 EXIT     + TR 0      /   /
        2435+ 5 2443          + SUB       ONE
        2436+12 2445          + STORE     LEN
        2437+14    0 MEM      + STORE MQ  /   /        
        2438+10 2437          + R ADD     MEM
        2439+ 9 2443          + ADD       ONE
        2440+13 2437          + STORE A   MEM
        2441+ 1 2433          + TR        LOOP
        2442+ 0    0 ZERO     + STOP      0000
        2443+ 0    1 ONE      + STOP      0001         constant 1
        2444+ 0    2 TWO      + STOP      0002         constant 2
        2445+ 0    0 LEN      + STOP      0000
        2446+15 2513 SRCHTBL  + LOAD MQ   ZERO
        2447+ 1 2451          + TR        START
        2448+15 2514 EQTBL    + LOAD MQ   ONE
        2449+ 1 2451          + TR        START
        2450+15 2515 READTBL  + LOAD MQ   TWO
        2451+ 9 2515 START    + ADD       TWO 
        2452+13 2459          + STORE A   P1           PARM: ADDR OF TABLE
        2453+ 9 2514          + ADD       ONE          
        2454+13 2461          + STORE A   P2           PARM: LEN OF TABLE
        2455+ 9 2514          + ADD       ONE          
        2456+13 2466          + STORE A   P3           PARM: VAL TO FIND
        2457+ 9 2514          + ADD       ONE          
        2458+13 2507          + STORE A   EXIT
        2459+10    0 P1       + R ADD     /   /        GET ADDR OF TABLE
        2460+13 2510          + STORE A   TBL
        2461+10    0 P2       + R ADD     /   /        GET ADDR OF LEN OF TABLE/ENTRY ON TABLE
        2462+13 2463          + STORE A   P2A
        2463+10    0 P2A      + R ADD     /   /        DERREFERENCE -> ACC=LEN/ENTRY (1..LEN)
        2464+12 2508          + STORE     N
        2465+ 4 2507          + TR 0      EXIT         EXIT, CANNOT READ/STORE ON ENTRY 0, SEARCH ON EMPTY TABLE
        2466+10    0 P3       + R ADD     /   /        GET ADDR OF VAL TO FIND
        2467+13 2483          + STORE A   WRVAL
        2468+13 2469          + STORE A   P3A
        2469+10    0 P3A      + R ADD     /   /        DERREFERENCE -> ACC=VAL
        2470+12 2509          + STORE     VAL
        2471+14 2512          + STORE MQ  TEMP         JUMP TABLE DISPATCH
        2472+10 2512          + R ADD     TEMP
        2473+ 4 2488          + TR 0      LOOP0        TR TO SEARCH TABLE
        2474+10 2508          + R ADD     N            SUB ONE AS FIRST ENTRY ON TABLE IS "1"
        2475+ 5 2514          + SUB       ONE          
        2476+ 9 2510          + ADD       TBL          TABLE BASE ADDR
        2477+13 2486          + STORE A   WRTBL
        2478+13 2482          + STORE A   RDTBL2
        2479+10 2512          + R ADD     TEMP
        2480+ 5 2514          + SUB       ONE
        2481+ 4 2485          + TR 0      STORETBL 
        2482+10    0 RDTBL2   + R ADD     /   /        VAL=TBL[ENT]
        2483+12    0 WRVAL    + STORE     /   /
        2484+ 1 2507          + TR        EXIT
        2485+10 2509 STORETBL + R ADD     VAL          TBL[ENT]=VAL
        2486+12    0 WRTBL    + STORE     /   /    
        2487+ 1 2507          + TR        EXIT
        2488+10 2510 LOOP0    + R ADD     TBL
        2489+13 2495          + STORE A   RDTBL
        2490+10 2495          + R ADD     RDTBL
        2491+12 2511          + STORE     TBL0
        2492+ 9 2508          + ADD       N
        2493+12 2512          + STORE     TEMP         THE END ADDR OF TABLE
        2494+10 2509 LOOP     + R ADD     VAL          ACC=THE SEARCHED VALUE
        2495+ 5    0 RDTBL    + SUB       /   /    
        2496+ 2 2497          + TR OV     OVOK         CLEAR OV JUST IN CASE
        2497+ 4 2504 OVOK     + TR 0      FOUND        TR IF VAL FOUND IN ENTRY N
        2498+10 2495          + R ADD     RDTBL
        2499+ 9 2514          + ADD       ONE
        2500+13 2495          + STORE A   RDTBL
        2501+ 5 2512          + SUB       TEMP
        2502+ 4 2507          + TR 0      EXIT         NOT FOUND -> RETURN ZERO
        2503+ 1 2494          + TR        LOOP
        2504+10 2495 FOUND    + R ADD     RDTBL        RETURN ENTRY FOUND
        2505+ 5 2511          + SUB       TBL0
        2506+ 9 2514          + ADD       ONE
        2507+ 1    0 EXIT     + TR        /   /
        2508+ 0    0 N        + STOP      0000
        2509+ 0    0 VAL      + STOP      0000
        2510+ 0    0 TBL      + STOP      0000
        2511+ 0    0 TBL0     + STOP      0000
        2512+ 0    0 TEMP     + STOP      0000
        2513+ 0    0 ZERO     + STOP      0000
        2514+ 0    1 ONE      + STOP      0001         constant 1
        2515+ 0    2 TWO      + STOP      0002         constant 2
        2516+ 9 2589 RWDRUM   + ADD       TWO 
        2517+13 2526          + STORE A   PDR1         PARM1: DRUM INSTR: READ/WRITE 0128  0129  0130  0131
        2518+ 9 2588          + ADD       ONE          
        2519+13 2528          + STORE A   PDR2         PARM2: DRUM ADDRESS (0..4094)
        2520+ 9 2588          + ADD       ONE          
        2521+13 2530          + STORE A   PDR3         PARM3: BUF START ADDRESS
        2522+ 9 2588          + ADD       ONE          
        2523+13 2532          + STORE A   PDR4         PARM4: LEN: NUMBER OF HALF-WORDS (MUST BE EVEN)
        2524+ 9 2588          + ADD       ONE          
        2525+13 2586          + STORE A   EXIT               
        2526+10    0 PDR1     + R ADD     /   /        GET DRUM INSTR
        2527+12 2534          + STORE     DRIO
        2528+10    0 PDR2     + R ADD     /   /        GET DRUM ADDR
        2529+13 2535          + STORE A   DRADDR
        2530+10    0 PDR3     + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        2531+13 2573          + STORE A   RWCOPY    
        2532+10    0 PDR4     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        2533+12 2590          + STORE     LEN
        2534+ 0    0 DRIO     + STOP      /   /        INSTR: READ/WRITE 0128  0129  0130  0131
        2535+29    0 DRADDR   + SET DR    /   /
        2536+ 1 2569          + TR        LOOP
        2537+ 9 2589 RDTAPE   + ADD       TWO 
        2538+13 2545          + STORE A   PR1          PARM1: TAPE ADDRESS
        2539+ 9 2588          + ADD       ONE          
        2540+13 2547          + STORE A   PR2          PARM2: BUF START ADDRESS
        2541+ 9 2588          + ADD       ONE          
        2542+13 2586          + STORE A   EXIT
        2543+ 2 2544          + TR OV     CLOV1        CLEAR OV THAT MAY HAVE BEEN SET
        2544+ 8    0    CLOV1 + NOOP      0000
        2545+10    0 PR1      + R ADD     /   /        GET TAPE ADDR
        2546+13 2549          + STORE A   RTAPAD       TAPE UNITS: 0256  0257  0258  0259
        2547+10    0 PR2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        2548+13 2573          + STORE A   RWCOPY    
        2549+24    0 RTAPAD   + READ      /   /
        2550+10 2587          + R ADD     ZERO
        2551+ 1 2571          + TR        LOOP1
        2552+ 9 2589 WRTAPE   + ADD       TWO 
        2553+13 2560          + STORE A   PW1          PARM1: TAPE ADDRESS
        2554+ 9 2588          + ADD       ONE          
        2555+13 2562          + STORE A   PW2          PARM2: BUF START ADDRESS
        2556+ 9 2588          + ADD       ONE          
        2557+13 2564          + STORE A   PW3          PARM3: BUF LEN
        2558+ 9 2588          + ADD       ONE          
        2559+13 2586          + STORE A   EXIT
        2560+10    0 PW1      + R ADD     /   /        GET TAPE ADDR
        2561+13 2568          + STORE A   WTAPAD       TAPE UNITS: 0256  0257  0258  0259
        2562+10    0 PW2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        2563+13 2573          + STORE A   RWCOPY    
        2564+10    0 PW3      + R ADD     /   /        GET ADDR OF LEN 
        2565+13 2566          + STORE A   PW3A
        2566+10    0 PW3A     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        2567+12 2590          + STORE     LEN
        2568+26    0 WTAPAD   + WRITE     /   /        PREPARE TO WRITE ON TAPE
        2569+10 2590 LOOP     + R ADD     LEN
        2570+ 4 2585          + TR 0      RWOK
        2571+ 5 2589 LOOP1    + SUB       TWO
        2572+12 2590          + STORE     LEN
        2573-31    0 RWCOPY   - COPY      /   /        WRITE BUFFER TO TAPE
        2574+ 1 2577          + TR        GO 
        2575+ 1 2581          + TR        EOF          END OF FILE
        2576+ 1 2583          + TR        EOR          END OF RECORD
        2577+10 2573 GO       + R ADD     RWCOPY
        2578+ 5 2589          + SUB       TWO
        2579+13 2573          + STORE A   RWCOPY
        2580+ 1 2569          + TR        LOOP
        2581+10 2588 EOF      + R ADD     ONE          SET OV FLAG TO SIGNAL END OF FILE CONDITION
        2582+22   36          + A LEFT    36
        2583+ 6 2590 EOR      + R SUB     LEN          RETURN NUMBER OF HALF-WORDS READ
        2584+ 5 2589          + SUB       TWO
        2585+26 2052 RWOK     + WRITE     2052         INSURE THAT MQ NOT IN USE            
        2586+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        2587+ 0    0 ZERO     + STOP      0000
        2588+ 0    1 ONE      + STOP      0001         
        2589+ 0    2 TWO      + STOP      0002         
        2590+     0  LEN        RES       1
        2592+ 9 2607 CHAIN    + ADD       TWO
        2593+13 2594          + STORE A   CHP1
        2594+10    0 CHP1     + R ADD     /   /        GET TAPE NUMBER
        2595+13 2602          + STORE A   TAPELOAD
        2596+30   70          + SENSE     0070         SENSE SWITCH 2                                  
        2597+ 1 2601 CONTAD   + TR        ENDSTOP      (ON POSITION MAKES SENSE OPCODE TO SKIP NEXT INSTR)
        2598+10 2597          + R ADD     CONTAD       IF SW2 IS ON, A +STOP 4095 IS EXECUTED.  
        2599+12 4095          + STORE     4095         IF THEN USER PRESS START, EXECUTION WILL BE RESUMED 
        2600+ 0 4095          + STOP      4095         AND CHAINED PROGRAM WILL BE LOADED AND EXECUTED
        2601+ 8    0 ENDSTOP  + NOOP      0000
        2602+24    0 TAPELOAD + READ      0000         
        2603-31    0 TL0      - COPY      0000         READ 1ST WORD OF SELF-LOADER FROM TAPE
        2604+ 1    0          + TR        0000         TR TO SELF-LOADER
        2605+ 0 2221          + STOP      2221         ERROR LOADING: UNEXPECTED END OF FILE
        2606+ 0 2222          + STOP      2222         ERROR LOADING: UNEXPECTED END OF RECORD 
        2607+ 0    2 TWO      + STOP      0002         ERROR LOADING: UNEXPECTED END OF FILE
          48-     0  ROUTINE INIT
          49+ 1  126 ENTRY POINT
          50-     0  ROUTINE CHAIN
          51+ 1 2592 ENTRY POINT
          52-     0  ROUTINE PRTNLINE
          53+ 1 2284 ENTRY POINT
          54-     0  ROUTINE PRINTCRD
          55+ 1 1962 ENTRY POINT
          56-     0  ROUTINE RDTAPE
          57+ 1 2537 ENTRY POINT
          58-     0  ROUTINE WRTAPE
          59+ 1 2552 ENTRY POINT
          60-     0  ROUTINE RWDRUM
          61+ 1 2516 ENTRY POINT
          62-     0  ROUTINE CLMEM
          63+ 1 2420 ENTRY POINT
          64-     0  ROUTINE SRCHTBL
          65+ 1 2446 ENTRY POINT
          66-     0  ROUTINE READTBL
          67+ 1 2450 ENTRY POINT
          68-     0  ROUTINE CLRBUF
          69+ 1 1954 ENTRY POINT
          70-     0  ROUTINE READCRD
          71+ 1 1958 ENTRY POINT
          72-     0  ROUTINE WRITECRD
          73+ 1 1960 ENTRY POINT
          74-     0  ROUTINE PRTALF
          75+ 1 2046 ENTRY POINT
          76-     0  ROUTINE PRTSTR
          77+ 1 2023 ENTRY POINT
          78-     0  ROUTINE PRTCHR
          79+ 1 2166 ENTRY POINT
          80-     0  ROUTINE PRTINT
          81+ 1 2124 ENTRY POINT
          82-     0  ROUTINE PRTOCT
          83+ 1 2090 ENTRY POINT
          84-     0  ROUTINE EQTBL
          85+ 1 2448 ENTRY POINT
          86-     0  ROUTINE BMPAD
          87+ 1 2366 ENTRY POINT
        4094+    48  REGION ORIGIN TABLE LOCATION
        4095+   126  INITIAL REGION
           0+ 1  126          + TR        INIT         PROGRAM START
