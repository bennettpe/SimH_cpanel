        DEC
        NNNN OP ADDR COMMENTS
          88+ 9  477 LOADCC   + ADD       TWO          LOAD PACTSCR INTO CARD IMAGE SO 
          89+13  108          + STORE A   CPCCEX       CURRENT PACT SOURCE CODE CAN BE PRINTED
          90+10  474          + R ADD     ZERO         COPY TO LEFT SIDE OF SOURCE CODE CARD IMAGE
          91+13   95          + STORE A   CPCC1        AT 0..46 FROM PACTSCR
          92+10  111          + R ADD     CPCC2
          93+13   94          + STORE A   CPCC 
          94-10    0 CPCC     - R ADD     /   /
          95-12    0 CPCC1    - STORE     /   /
          96+10   95          + R ADD     CPCC1
          97+ 5  477          + SUB       TWO
          98+13  100          + STORE A   CPCC1B
          99+10  474          + R ADD     ZERO
         100-12    0 CPCC1B   - STORE     /   /
         101+10   94          + R ADD     CPCC
         102+ 5  477          + SUB       TWO
         103+13   94          + STORE A   CPCC
         104+10   95          + R ADD     CPCC1
         105+ 5  478          + SUB       D4
         106+13   95          + STORE A   CPCC1
         107+ 5  110          + SUB       CPCCE
         108+ 4    0 CPCCEX   + TR 0      /   /        RETURN TO CALLER
         109+ 1   94          + TR        CPCC
         110-12   48 CPCCE    - STORE     0048         LAST LOCATION TO COPY FROM 
         111+ 8  226 CPCC2    + NOOP      PACTSRC      PACTSRC = FIRST LOCATION TO COPY FROM
         112+10  112 INIT     + R ADD     *            
         113+ 1   53          + TR        PRTNLINE     
         114+ 0  101          + STOP      0101         STRINGZ AT COL 1
         115+ 0  482          + STOP      MSGSTART     "PREPARE REGIONS TO DUP"
         116+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         117+10  117          + R ADD     *
         118+ 1   63          + TR        RWDRUM       READ TREGIONS ARRAY FROM DRUM
         119+24  128          + READ      0128         DRUM INSTR
         120+ 0    0          + STOP      0000         DRUM ADDR 
         121+ 0  272          + STOP      MAXNREGS     ADDR OF START OF TABLES
         122+ 0  202          + STOP      0202         MAXNREGS (1 HALF-WORD) + NREGIONS (1 HW) + TREGIONS (100 HW) + TRISDUP (100 HW)
         123+10  474          + R ADD     ZERO         CLEAR CC RECORD
         124+12  250          + STORE     REGION     
         125+12  251          + STORE     STEP       
         126+12  252          + STORE     OP         
         127+12  253          + STORE     FACT       
         128+12  254          + STORE     S1         
         129+12  255          + STORE     S2         
         130+12  256          + STORE     QR         
         131+12  257          + STORE     QF         
         132-12  258          - STORE     NUM        
         133+12  260          + STORE     CLUE       
         134+12  261          + STORE     STEPN      
         135+12  262          + STORE     FACTN      
         136+12  263          + STORE     FACTREG    
         137+12  264          + STORE     S1N        
         138+12  265          + STORE     S2N        
         139+12  266          + STORE     D1N        
         140+12  267          + STORE     D2N        
         141+12  268          + STORE     NINST      
         142+12  269          + STORE     NINCR 
         143+10  270          + R ADD     CCLEN        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         144+10  273          + R ADD     NREGIONS     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         145+10  274          + R ADD     TREGIONS     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         146+10  271          + R ADD     DUMMY        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         147+10  474          + R ADD     ZERO
         148+12  479          + STORE     IREG         REGION NUMBER BEING PROCESSED
         149+12  480          + STORE     NDUPREGS     NUMBER OF REGIONES TO BE DUPLICATED
         150+28  258          + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE)
         151+28  257          + REWIND    TAPEOUT      REWIND TAPE OUT WITH NON-DUPLICATED REGIONS
         152+28  259          + REWIND    TAPEOUTD     REWIND TAPE OUT WITH DUPLICATED REGIONS
         153+10  479 READREG  + R ADD     IREG         SELECT NEXT REGION
         154+ 9  476          + ADD       ONE
         155+12  479          + STORE     IREG
         156+10  156          + R ADD     *            
         157+ 1   65          + TR        READTBL
         158+ 0  374          + STOP      TRISDUP      ... VAL=TRISDUP[IREG] =1 IF THIS REGION IS REFERENCED IN A DUP INSTR ELSEWHERE (IE THIS REGION IS DUPLICATED)
         159+ 0  479          + STOP      IREG
         160+ 0  481          + STOP      ISDUP
         161+10  481          + R ADD     ISDUP        KEEP TRACK OF NUMBER OF DUPLICATED REGIONS
         162+ 4  166          + TR 0      RR1
         163+10  480          + R ADD     NDUPREGS     
         164+ 9  476          + ADD       ONE
         165+12  480          + STORE     NDUPREGS     
         166+ 8    0 RR1      + NOOP      0000         
         167+10  167 READSTEP + R ADD     *            READ PACT USER PROGRAM SOURCE CODE FROM TAPE IN
         168+ 1   59          + TR        RDTAPE
         169+ 0  258          + STOP      TAPEIN
         170+ 0  226          + STOP      CCODE        BUF TO READ IN FROM TAPE
         171+ 2  205          + TR OV     EOF          TR IF END OF FILE
         172+10  172          + R ADD     *            LOAD PACTSCR INTO CARD IMAGE SO 
         173+ 1   88          + TR        LOADCC       CURRENT PACT SOURCE CODE CAN BE PRINTED
         174+ 8  257 NONDUP   + NOOP      TAPEOUT      NON DUPLICTAED REGIONS TAPE
         175+ 8  259 DUPREG   + NOOP      TAPEOUTD     DUPLICATED REGIONS TAPE
         176+10  174          + R ADD     NONDUP
         177+13  192          + STORE A   TAPEO
         178+10  481          + R ADD     ISDUP        IF REGION NOT DUPLICATED, SKIP
         179+ 4  189          + TR 0      RS1
         180+10  175          + R ADD     DUPREG       ID REGION DUPLICATED, WRITE TO TAPEOUTD
         181+13  192          + STORE A   TAPEO
         182+30   74          + SENSE     0074         SENSE SWITCH 6
         183+ 1  188          + TR        ENDLOG1A     TR IF NO LOG SELECTED
         184+15  496          + LOAD MQ   ALFDUP       PUT 'DUP' TEXT ON STEP PRINTOUT
         185+10  185          + R ADD     *
         186+ 1   57          + TR        PRTALF
         187+ 0   40          + STOP      0040         PRT AT COLUMN 40
         188+ 8    0 ENDLOG1A + NOOP      0000
         189+ 8    0 RS1      + NOOP      0000
         190+10  190          + R ADD     *
         191+ 1   61          + TR        WRTAPE       WRITE MAGNETIC TAPE TAPEOUT 
         192+ 0    0 TAPEO    + STOP      /   /        TAPE WHERE TO WRITE
         193+ 0  226          + STOP      CCODE        BUF TO WRITE TO TAPE
         194+ 0  270          + STOP      CCLEN        LEN
         195+10  252          + R ADD     OP
         196+ 4  203          + TR 0      EOR          TR IF END OF REGION
         197+30   74          + SENSE     0074         SENSE SWITCH 6
         198+ 1  201          + TR        ENDLOG1      TR IF NO LOG SELECTED
         199+10  199          + R ADD     *            PRINT STEP JUST PROCESSED
         200+ 1   55          + TR        PRINTCRD
         201+ 8    0 ENDLOG1  + NOOP      0000 
         202+ 1  167          + TR        READSTEP
         203+ 8    0 EOR      + NOOP      0000         END OF REGION  
         204+ 1  153          + TR        READREG      PROCEED WITH NEXT REGION
         205+ 8    0 EOF      + NOOP      0000         END OF FILE
         206+27  257          + WRITE EF  TAPEOUT      WRITE EOF IN TAPE OUT NON DUP REGIONS
         207+27  259          + WRITE EF  TAPEOUTD     WRITE EOF IN TAPE OUT DUP REGIONS
         208+30   74          + SENSE     0074         SENSE SWITCH 6
         209+ 1  217          + TR        ENDLOG1B     TR IF NO LOG SELECTED
         210+10  210          + R ADD     *
         211+ 1   53          + TR        PRTNLINE     
         212+ 0  101          + STOP      0101         STRINGZ AT COL 1
         213+ 0  491          + STOP      MSGDONE      "DUP REGIONS"
         214+ 0  210          + STOP      0210         INT AT COL 10
         215+ 0  480          + STOP      NDUPREGS     NUMBER OF DUPLICATED REGIONS 
         216+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         217+ 8    0 ENDLOG1B + NOOP      0000
         218+28  258          + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE)
         219+28  257          + REWIND    TAPEOUT      REWIND TAPE OUT WITH NON-DUPLICATED REGIONS
         220+28  259          + REWIND    TAPEOUTD     REWIND TAPE OUT WITH DUPLICATED REGIONS
         221+10  221          + R ADD     *
         222+ 1   51          + TR        CHAIN        IF SW2 IS ON, A +STOP 4095 IS EXECUTED 
         223+ 0  256          + STOP      PACTCOMP     CHAIN TO NEXT STAGE IN PACT COMPILER TAPE
         224+ 0 4095          + STOP      4095
         225+     0             ORG       EVEN
         226+     0  PACTSRC    RES       24           CARD IMAGE OF PACT SOURCE CODE CARD (12 FULL WORDS)
         250+     0  REGION     DEF       0
         251+     0  STEP       DEF       0            REGION = ALFA (<0)
         252+     0  OP         DEF       0            STEP   = INT (>0)
         253+     0  FACT       DEF       0            OP     = 0..43    =0 MEANS END OF REGION
         254+     0  S1         DEF       0            FACT   < 0 -> FACTOR IS AN ALFA SYMBOL (VAR, REGION, ...) 
         255+     0  S2         DEF       0            FACT = 0 -> BLANK FACTOR
         256+     0  QR         DEF       0            FACT = 0..9999 -> DESTINATION STEP FOR TRANSFER/RESULT OF STEP
         257+     0  QF         DEF       0            CLUE = -, R OR N
         258+     0  NUM        DEF       0            
         259+     0             DEF       0            S1/S2 = 0 -> BLANK, >0 -> INTEGER, <0 -> ALFA 
         260+     0  CLUE       DEF       0
         261+     0  STEPN      DEF       0            QR = +/- INTEGER OR BLANK. 
         262+     0  FACTN      DEF       0            QF = SET IF THERE IS AN INTEGER FACTOR/NUMBER IN CARD
         263+     0  FACTREG    DEF       0
         264+     0  S1N        DEF       0            STEPN = SEQUENTIAL NUMBER OF STEP            
         265+     0  S2N        DEF       0            IF OP IS TRANSFER -> FACTN=DESTINATION STEPN
         266+     0  D1N        DEF       0               OP CALLS IN A RESULT OF STEP -> FACTN=TEMP ADDR (2, 4, ..)
         267+     0  D2N        DEF       0                                               FACTREG='T'
         268+     0  NINST      DEF       0
         269+     0  NINCR      DEF       0
         270+    44  CCLEN      DEF       0044         LENGTH OF COMPACT CODE RECORD 
         271+     0  DUMMY      DEF       0            (HERE TO MAKE TABLES START AT EVEN LOCATION)
         272+   100  MAXNREGS   DEF       100          MAX 100 REGIONS CAN DE DEFINED IN ONE PROGRAM 
         273+     0  NREGIONS   DEF       0            NUMBER OF REGIONS DEFINED
         274+     0  TREGIONS   RES       100          EACH ENTRY IN TABLE IS 1 HALF-WORD. HAS THE NAME (ALFA) OF REGION
         374+     0  TRISDUP    RES       100          =1 IF THIS REGION IS REFERENCED IN A DUP INSTR ELSEWHERE (IE THIS REGION IS DUPLICATED)
         474+     0  ZERO       DEF       0
         475+     0             DEF       0
         476+     1  ONE        DEF       1
         477+     2  TWO        DEF       2
         478+     4  D4         DEF       4
         479+     0  IREG       DEF       0            REGION NUMBER BEING PROCESSED (INDEX IN TREGIONS, IREG=1 -> FIRST ENTRY IN TREGIONS TABLE)
         480+     0  NDUPREGS   DEF       0            NUMBER OF DUPLICATED REGIONS
         481+     0  ISDUP      DEF       0            =1 IF THIS REGION IS REFERENCED IN A DUP INSTR ELSEWHERE (IE THIS REGION IS DUPLICATED)
         482- 65969  MSGSTART   TXT       "PREPARE REGIONS TO DUP",0
         483- 65166  
         484- 39198  
         485- 40101  
         486- 63487  
         487-  1563  
         488-   801  
         489- 64512  
         490+     0  
         491- 38476  MSGDONE    TXT       "DUP REGIONS",0
         492-  1457  
         493- 44811  
         494- 61392  
         495+     0  
         496- 38476  ALFDUP     TXT       'DUP'
         498+15  512 CLRBUF   + LOAD MQ   IOCL
         499+14  517          + STORE MQ  BUFIO
         500+15  538          + LOAD MQ   IOSTORE         
         501+ 1  509          + TR        INIT2
         502+15  534 READCRD  + LOAD MQ   IORDCRD
         503+ 1  507          + TR        INIT1
         504+15  536 WRITECRD + LOAD MQ   IOWRCRD
         505+ 1  507          + TR        INIT1
         506+15  537 PRINTCRD + LOAD MQ   IOPRCRD
         507+14  517 INIT1    + STORE MQ  BUFIO
         508+15  535          + LOAD MQ   IOCOPY         
         509+14  518 INIT2    + STORE MQ  BUFROW
         510+ 9  544          + ADD       TWO          
         511+13  533          + STORE A   EXIT
         512+10  540 IOCL     + R ADD     ZERO         RESET TO INITIAL COPY LOOP ADDRESS     
         513+13  518          + STORE A   BUFROW       FOR BUFFER
         514+10  518          + R ADD     BUFROW       X .*echo Print
         515+ 5  545          + SUB       D48          X 
         516+12  542          + STORE     ENDLP        X LOOP END VALUE
         517- 0    0   BUFIO  - STOP      /   /        READ OR WRITE
         518-31    0   BUFROW - COPY      /   /        COPY WORD TO/FROM PRINTER/CARDREADER
         519+ 1  523          + TR        BUFOK2       NORMAL PROCESSING 
         520+ 1  530          + TR        EODECK       FOR COPY READING END OF REG (=END OF DECK BEING READ)
         521+ 6  544          + R SUB     TWO          END OF FILE -> NO CARD TO READ -> STOP with Acc=-2
         522+ 0  517          + STOP      BUFIO        ON PRESSING START RETRY CARD READ
         523+10  518   BUFOK2 + R ADD     BUFROW       X
         524+ 5  544          + SUB       TWO          INCR BUF ADDR
         525+13  518          + STORE A   BUFROW       X
         526+ 5  542          + SUB       ENDLP        CHECK FOR END
         527+ 4  532          + TR 0      ENDIO
         528+10  540          + R ADD     ZERO         CLEAR ACC IN CASE WE ARE CLEANING THE BUFFER
         529+ 1  518          + TR        BUFROW
         530+10  543 EODECK   + R ADD     ONE          SET OV FLAG TO SIGNAL END OF DECK CONDITION
         531+22   36          + A LEFT    36
         532+26 2052 ENDIO    + WRITE     2052         END OF I/O: INSURE THAT MQ NOT IN USE            
         533+ 1    0 EXIT     + TR        /   /
         534+24 2048 IORDCRD  + READ      2048         PREPARE TO READ FROM CARD READER
         535-31    0 IOCOPY   - COPY      /   /   
         536+26 1024 IOWRCRD  + WRITE     1024         PREPARE TO PUNCH CARD 
         537+26  512 IOPRCRD  + WRITE     0512         PREPARE WRITE PRTBUF ON PRINTER
         538-12    0 IOSTORE  - STORE     /   /        CLEAR BUFFER
         539+     0             ORG       EVEN           
         540+     0  ZERO       DEF       0            
         541+     0             DEF       0            
         542+     0  ENDLP      DEF       0            LOOP END VALUE
         543+     1  ONE        DEF       1
         544+     2  TWO        DEF       2
         545+    48  D48        DEF       48
         546+ 9  817 PRTPARM2 + ADD       TWO          GET 2 PARAMS: LEN AND COL (EITHER VALUE OR VAR ADDR)
         547+13  566          + STORE A   PRTPRMEX
         548+10  556          + R ADD     PRTP1
         549+ 9  817          + ADD       TWO          PRINT PACKED TEXT FROM FULL-WORD VALUE IN MQ REGISTER 
         550+13  556          + STORE A   PRTP1        STORE ADDR OF FIRST PARAM (LEN)
         551+ 9  816          + ADD       ONE
         552+13  558          + STORE A   PRTP2        STORE ADDR OF SECOND PARAM (COL)
         553+ 9  816          + ADD       ONE
         554+13  633          + STORE A   EXIT
         555-14  806          - STORE MQ  NUM          SAVE VALUE TO PRINT PARAM MQ (NUM IS ALIASED TO TXT)
         556+10    0   PRTP1  + R ADD     /   /        GET LEN: NUMBER OF CHARS TO PRINT (1..6)
         557+12  810          + STORE     LEN
         558+10    0   PRTP2  + R ADD     /   /        GET COLUMN PARAM 1..72
         559+ 3  562          + TR +      PRTP4
         560+13  561          + STORE A   PRTP3        COL<0 -> INTERPRET COL AS LOC(COL) = ADDR OF COL VAR
         561+10    0   PRTP3  + R ADD     /   /        READ VAR COL PASED AS PARAM
         562+ 4  633   PRTP4  + TR 0      EXIT         COL=0 -> EXIT
         563+ 3  565          + TR +      PRTP5
         564+ 1  633          + TR        EXIT         COL<0 -> EXIT
         565+12  616   PRTP5  + STORE     COL
         566+ 1    0 PRTPRMEX + TR        /   /        RETURN TO CALLER
         567+13  556 PRTSTR   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
         568+10  568          + R ADD     *            FOR PRINT STRINGZ FROM MEM
         569+ 1  546          + TR        PRTPARM2
         570+12  580          + STORE     COLSZ
         571+10  810          + R ADD     LEN          LEN IS IN FACT THE LOCATION WHERE THE STRING STARTS
         572+13  575          + STORE A   STRZAD
         573+10  633          + R ADD     EXIT
         574+13  588          + STORE A   STRZEX
         575+10    0 STRZAD   + R ADD     /   /        GET HALF-WORD WITH NEXT 3 CHARS TO PRINT
         576+ 4  588          + TR 0      STRZEX       IF +0 -> END OF STRING (-0 DOES NOT TERMINATES THE STRING)
         577+21   35          + L RIGHT   0035         MQ=3-CHARS TO PRINT
         578+10  578          + R ADD     *            
         579+ 1  590          + TR        PRTALF       PRINT 3 CHARS
         580+ 0    0 COLSZ    + STOP      0000         COL 
         581+10  575 STRZ1    + R ADD     STRZAD       INCR STRING ADDRESS
         582+ 9  816          + ADD       ONE
         583+13  575          + STORE A   STRZAD
         584+10  580          + R ADD     COLSZ        INCR COLUMN
         585+ 9  818          + ADD       D3
         586+13  580          + STORE A   COLSZ
         587+ 1  575          + TR        STRZAD
         588+ 3    0 STRZEX   + TR +      /   /        IF ZERO -> END OF STRING
         589+ 1  581          + TR        STRZ1
         590+ 9  817 PRTALF   + ADD       TWO          PRINT 3-PACKED CHARS IN MQ REGISTER 
         591+14  812          + STORE MQ  TXT          SAVE TEXT TO PRINT (IN LEFT HALF WORD)
         592+13  595          + STORE A   PRTAP2       STORE ADDR OF PARAM (COL)
         593+ 9  816          + ADD       ONE
         594+13  633          + STORE A   EXIT
         595+10    0   PRTAP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
         596+ 3  599          + TR +      PRTAP4
         597+13  598          + STORE A   PRTAP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
         598+10    0   PRTAP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
         599+12  616   PRTAP4 + STORE     COL
         600+10  818          + R ADD     D3
         601+12  810          + STORE     LEN
         602+10  800 PRT1     + R ADD     ZERO         UNPACK LEFTMOST CHAR 
         603+11  812          + ADD AB    TXT          GET TEXT DISCARD SIGN
         604+21   35          + L RIGHT   0035         MQ=Acc
         605+10  800          + R ADD     ZERO
         606+18  825          + DIV       D48X48
         607+12  812          + STORE     TXT          remainder=char to print, mq=c2 * 48 + c3 in right half-word
         608+10  800          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
         609+20   18          + L LEFT    0018         put c2 and c3 in left half-word of MQ to be saved in CHAR half word
         610+14  811          + STORE MQ  CHAR         CHAR TO PRINT
         611+10  811          + R ADD     CHAR 
         612+ 4  617          + TR 0      NXTCHR       IF BLANK PROCEED TO NEXT COL
         613+21   35          + L RIGHT   0035         MQ=CHAR TO PRINT
         614+10  614          + R ADD     *            PRINT CHAR
         615+ 1  710          + TR        PRTCHR
         616+ 0    0 COL      + STOP      0000         COL: COLUMN NUMBER TO PRINT (1..72)
         617+10  810 NXTCHR   + R ADD     LEN          DECR LEN COUNT
         618+ 5  816          + SUB       ONE
         619+12  810          + STORE     LEN
         620+ 4  633          + TR 0      EXIT         IF NO MORE CHARS TO PRINT EXIT
         621+10  616          + R ADD     COL          INCR COL POSITION
         622+ 9  816          + ADD       ONE
         623+12  616          + STORE     COL
         624+ 5  824          + SUB       D72          IF COL > 72 RETURN TO CALLER
         625+ 4  627          + TR 0      GNXTCHR      ELSE PROCEED WITH NEXT CHAR
         626+ 3  633          + TR +      EXIT
         627+10  800 GNXTCHR  + R ADD     ZERO         GET NEXT CHAR 
         628+15  812          + LOAD MQ   TXT
         629+16  823          + MPY       D48
         630+22   17          + A LEFT    0017         GET RESULT IN LEFT HALF-WORD OF ACC
         631+12  812          + STORE     TXT
         632+ 1  602          + TR        PRT1         PROCEED TO PRINT CHAR
         633+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
         634+13  556 PRTOCT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
         635+10  635          + R ADD     *            FOR PRINT OCTIONARY VALUE
         636+ 1  546          + TR        PRTPARM2
         637+10  810          + R ADD     LEN          LEN = OCTAL DIGITS TO PRINT
         638+ 9  616          + ADD       COL
         639+ 5  816          + SUB       ONE
         640+12  652          + STORE     COLN         COL POINTS TO LEAST SIGNIFICANT DIGIT
         641+10  806 PRTIOCG  + R ADD     NUM          GENERATE OCTINARY DIGIT
         642+15  800          + LOAD MQ   ZERO         CLEAR MQ
         643+21   21          + L RIGHT   0021         3 LSB BITS OF LEFT HALF-WORD OF ACC TO MQ
         644+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 3 BIT)
         645+12  806          + STORE     NUM          SAVE BACK NUM WITH RIGHTMOST OCTIONARY DIGIY EXTRACTED (NUM'=NUM/8)
         646+10  800          + R ADD     ZERO
         647+20   21          + L LEFT    0021         LEFT HALF-WORD OF ACC IS NOW RIGHTMOST OCTINARY DIGIT EXTRACTED FROM NUM 
         648+ 4  666          + TR 0      PRTIOZ       TR IF THIS DIGIT IS ZERO TO PRINT A '0' (BASE48 CODE = 10) INSTEAD OF A BLANK (BASE48 CODE = 0)
         649+21   35          + L RIGHT   0035         PUT DIGIT 1..9 TO PRINT IN MQ
         650+10  650 PRTOCTD  + R ADD     *            PRINT OCTINARY DIGIT
         651+ 1  710          + TR        PRTCHR
         652+ 0    0 COLN     + STOP      0000
         653+10  652          + R ADD     COLN        DECR COL NUMBER TO PRINT NEXT DIGIT
         654+ 5  816          + SUB       ONE
         655+12  652          + STORE     COLN
         656+10  810          + R ADD     LEN          DECR COL NUMBER TO PRINT NEXT DIGIT
         657+ 5  816          + SUB       ONE
         658+ 4  633          + TR 0      EXIT         PRINTED LEN OCTINARY DIGITS -> EXIT
         659+12  810          + STORE     LEN
         660+10  806          + R ADD     NUM          IF NUM < 0, ADD SIGN BIT TO LEFTMOST DIGIT
         661+ 3  641          + TR +      PRTIOCG
         662+10  826          + R ADD     OCT04K       
         663+ 5  806          + SUB       NUM
         664+12  806          + STORE     NUM
         665+ 1  641          + TR        PRTIOCG
         666+15  819   PRTIOZ + LOAD MQ   D10          ACC=BASE48 CODE FOR '0'
         667+ 1  650          + TR        PRTOCTD      TR TO PRINT IT
         668+13  556 PRTINT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
         669+10  669          + R ADD     *            FOR PRINT OCTIONARY VALUE
         670+ 1  546          + TR        PRTPARM2
         671+10  616          + R ADD     COL          PRINT DECIMAL NUMBER. VALUE OF LEN = DIGITS TO PRINT, NOT INCLUDING SIGN
         672+ 9  810          + ADD       LEN
         673+ 5  816          + SUB       ONE          
         674+12  695          + STORE     COLNI        COL POINTS TO END OF NUMBER
         675+10  800          + R ADD     ZERO
         676+12  809          + STORE     SGN          SIGN IS POSITIVE
         677+10  806          + R ADD     NUM
         678+ 3  683          + TR +      PRTINTG
         679+ 6  806          + R SUB     NUM          NUM IS NEGATIVE. CONVERT TO POSITIVE
         680+12  806          + STORE     NUM          AND SET SGN=1
         681+10  816          + R ADD     ONE
         682+12  809          + STORE     SGN          
         683+10  806 PRTINTG  + R ADD     NUM          GENERATE DECIMAL DIGIT
         684+21   35          + L RIGHT   0035         MQ=Acc
         685+10  800          + R ADD     ZERO
         686+18  819          + DIV       D10
         687+ 4  708          + TR 0      PRTINZ
         688+12  811 PRTINTG2 + STORE     CHAR         acc=remainder=digit to print, mq=num/10
         689+10  800          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
         690+20   18          + L LEFT    0018         digit in left half-word of MQ to be saved in CHAR half word
         691+14  806          + STORE MQ  NUM 
         692+15  811          + LOAD MQ   CHAR 
         693+10  693 PRTINTD  + R ADD     *            PRINT DECIMAL DIGIT
         694+ 1  710          + TR        PRTCHR
         695+ 0    0 COLNI    + STOP      0000
         696+10  695          + R ADD     COLNI        DECR COL NUMBER TO PRINT NEXT DIGIT
         697+ 5  816          + SUB       ONE
         698+12  695          + STORE     COLNI
         699+10  806          + R ADD     NUM          DO NOT CARE ABOUT LEN, JUST CHECK IF NUM=0 
         700+ 4  702          + TR 0      PRTINS       (SO NO MORE DIGITS REMAINS TO BE PRINTED)
         701+ 1  683          + TR        PRTINTG      NUM NOT FINISHED, PROCEED WITH NEXT DIGIT
         702+10  809 PRTINS   + R ADD     SGN
         703+ 4  633          + TR 0      EXIT         NO SIGN -> NUM FINISHED
         704+10  800          + R ADD     ZERO
         705+12  809          + STORE     SGN          CLEAR SGN FLAG
         706+15  820          + LOAD MQ   D11          BASE48 CODE FOR '-' (MINUS) CHAR
         707+ 1  693          + TR        PRTINTD      GO TO PRINT IT
         708+10  819   PRTINZ + R ADD     D10          ACC=BASE48 CODE FOR '0'
         709+ 1  688          + TR        PRTINTG2     TR TO PRINT IT
         710+ 9  817 PRTCHR   + ADD       TWO          PRINT CHAR IN MQ REGISTER 
         711+14  811          + STORE MQ  CHAR         SAVE CHAR TO PRINT (IN LEFT HALF WORD)
         712+13  716          + STORE A   PRTCP2       STORE ADDR OF PARAM (COL)
         713+ 9  816          + ADD       ONE
         714+13  794          + STORE A   PRTCEX
         715+ 2  716          + TR OV     PRTCP2       CLEAR OV JUST IN CASE
         716+10    0   PRTCP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
         717+ 3  720          + TR +      PRTCP4
         718+13  719          + STORE A   PRTCP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
         719+10    0   PRTCP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
         720+ 5  816   PRTCP4 + SUB       ONE
         721+12  814          + STORE     N            N=COL-1 -> IN RANGE 0..71
         722+ 3  724          + TR +      PRTSA        IF N >= 0 PROCEED WITH BASE BUFFER ADDR CALCULATION
         723+ 1  794          + TR        PRTCEX       IF N<0 EXIT
         724+10  800    PRTSA + R ADD     ZERO         CARD BUFFER USES LOCATION 0..47
         725+13  813          + STORE A   PRTROWAD     DETERMINE ADDRESS OF LOWER ROW TO PRINT
         726+10  814          + R ADD     N
         727+ 5  822          + SUB       D36
         728+ 3  730          + TR +      PRTC0
         729+ 1  736          + TR        PRTC1
         730+12  814    PRTC0 + STORE     N            COL NOW 0..35 
         731+ 5  822          + SUB       D36
         732+ 3  794          + TR +      PRTCEX       IF COL >= 36 (IE COL PASSED AS PARAM > 72) THEN EXIT
         733+10  813          + R ADD     PRTROWAD
         734+ 9  817          + ADD       TWO
         735+13  813          + STORE A   PRTROWAD     SET BASE BUFFER ADDR 
         736+10  816    PRTC1 + R ADD     ONE          DETERMINE MASKCOL WITH MASK TO SET IN CARD BUFFER
         737+21   53          + L RIGHT   53           SET RIGHTMOST BIT OF MQ TO 1 (SHIFT 35+18=53)
         738+10  821          + R ADD     D35
         739+ 5  814          + SUB       N
         740+13  742          + STORE A   PRTC2
         741+10  800          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW
         742+20    0    PRTC2 + L LEFT    /   /        SHIFT MQ LEFT N PLACES
         743+ 4  746          + TR 0      PRTC3        IF ACC STILL ZERO -> MASKCOL VALID
         744+ 6  816          + R SUB     ONE          ACC NOT ZERO -> SHOULD GENERATE -0 TO SET SIGN BIT ON
         745+21   72          + L RIGHT   0072         NOW MQ = -0 -> LEFTMOST BIT OF MQ SET
         746-14  802    PRTC3 - STORE MQ  MASKCOL
         747+10  800          + R ADD     ZERO         READ THE BITMAP OF CHAR 
         748+11  811          + ADD AB    CHAR         DISCARD SIGN OF CHAR, IF ANY
         749+12  811          + STORE     CHAR
         750+ 5  823          + SUB       D48
         751+ 3  794          + TR +      PRTCEX       IF CHAR >= 48 EXIT
         752+10  808          + R ADD     BITMAPAD     IF ADDR OF BASE48 BITMAP NOT COMPUTED
         753+ 4  795          + TR 0      GETBMP1      TR TO LOAD IT
         754+ 9  811  GETBMP2 + ADD       CHAR         READ THE BITMAP OF CHAR 
         755+13  756          + STORE A   PRTC4        INDICATES THE BITS TO SET IN SELECTED 
         756+10    0    PRTC4 + R ADD     /   /        COLUMN OF CARD BUFFER 
         757+12  815          + STORE     BITS
         758+ 6  816          + R SUB     ONE
         759+12  814          + STORE     N            SET TO -1
         760+10  814    LOOP1 + R ADD     N            CURRENT ROW (STARTS AT ZERO) = OFFSET ON PRTROWAD     
         761+ 9  816          + ADD       ONE
         762+12  814          + STORE     N
         763+10  815          + R ADD     BITS         EXTRACT RIGHTMOST BIT OF LEFT HALF OF ACC TO MQ
         764+ 4  794          + TR 0      PRTCEX       NO MORE BITS -> EXIT
         765+21   19          + L RIGHT   0019         LSB BIT OF LEFT HALF-WORD OF ACC TO MQ
         766+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 1 BIT)
         767+12  815          + STORE     BITS         SAVE BACK BITS. LSB HAS BEEN EXTACTED, CONTENTS SHIFTED RIGHT ONE PLACE
         768+10  800          + R ADD     ZERO
         769+20    1          + L LEFT    0001         PUT EXTACTED BIT BACK INTO ACC
         770+ 4  760          + TR 0      LOOP1        NO BIT 
         771+10  814          + R ADD     N            READ THE ROW N AT CARD BUFFER 
         772+22    2          + A LEFT    0002         MULT N BY 4 AS THERE ARE 4 HALF WORDS PER ROW
         773+ 9  813          + ADD       PRTROWAD     
         774+13  776          + STORE A   PRTROWR
         775+13  792          + STORE A   PRTROWW
         776-10    0  PRTROWR - R ADD     /   /        
         777-12  804          - STORE     ROW          CURRENT CONTENTS OF ROW
         778-10  802          - R ADD     MASKCOL      "OR" MASKCOL IN SELECTED ROW
         779+ 3  787          + TR +      PRTW2
         780-10  804          - R ADD     ROW 
         781+ 4  785          + TR 0      PRTW1         
         782+10  800          + R ADD     ZERO         MASKCOL IS MINUS ZERO AND ROW IS NOT-EMPTY (EITHER POSITIVE OR NEGATIVE) -> SET ROW AS NEGATIVE
         783- 7  804          - SUB AB    ROW 
         784+ 1  792          + TR        PRTROWW
         785-10  802    PRTW1 - R ADD     MASKCOL      MASKCOL IS MINUS ZERO AND ROW IS EMPTY -> SET ROW = MASKCOL = MINUS ZERO
         786+ 1  792          + TR        PRTROWW
         787-10  804    PRTW2 - R ADD     ROW          
         788+ 3  791          + TR +      PRTW3              
         789- 5  802          - SUB       MASKCOL      MASKCOL IS POSITIVE AND ROW IS NEGATIVE -> SUB MASKCOL FROM ROW
         790+ 1  792          + TR        PRTROWW
         791- 9  802    PRTW3 - ADD       MASKCOL      MASKCOL IS POSITIVE AND ROW IS POSITIVE OR EMPTY -> ADD MASKCOL TO ROW         
         792-12    0  PRTROWW - STORE     /   /        ROW UPDTATE
         793+ 1  760          + TR        LOOP1        PROCEED TO NEXT ROW
         794+ 1    0 PRTCEX   + TR        /   /
         795+10  795 GETBMP1  + R ADD     *
         796+ 1   81          + TR        BMPAD        GET BASE48 CHARS BITMAP ADDRESS
         797+12  808          + STORE     BITMAPAD     
         798+ 1  754          + TR        GETBMP2      RETURN
         799+     0             ORG       EVEN
         800+     0  ZERO       DEF       0            
         801+     0             DEF       0            
         802+     0  MASKCOL    DEF       0
         803+     0             DEF       0
         804+     0  ROW        DEF       0
         805+     0             DEF       0
         806+     0  NUM        DEF       0
         807+     0             DEF       0
         808+     0  BITMAPAD   DEF       0
         809+     0  SGN        DEF       0
         810+     0  LEN        DEF       0
         811+     0  CHAR       DEF       0
         812+     0  TXT        DEF       0
         813+     0  PRTROWAD   DEF       0
         814+     0  N          DEF       0
         815+     0  BITS       DEF       0
         816+     1  ONE        DEF       1
         817+     2  TWO        DEF       2
         818+     3  D3         DEF       3
         819+    10  D10        DEF       10
         820+    11  D11        DEF       11
         821+    35  D35        DEF       35
         822+    36  D36        DEF       36
         823+    48  D48        DEF       48
         824+    72  D72        DEF       72
         825+  2304  D48X48     DEF       2304
         826+ 16384  OCT04K     DEF       *040000      BIT SIGN ON 5TH OCTINARY DIGIT
         828+ 9  903 PRTNLINE + ADD       TWO          PRINT A NEW LINE OF DATA
         829+12  906          + STORE     PARAM        SAVE PARAM LIST ADDR
         830+10  830          + R ADD     *            CLEAR CARD BUFFER
         831+ 1   67          + TR        CLRBUF 
         832+10  906 GPARAM   + R ADD     PARAM        GET PARAM PAIR FMT/DATA
         833+13  838          + STORE A   P1
         834+ 9  902          + ADD       ONE
         835+13  842          + STORE A   P2
         836+ 9  902          + ADD       ONE
         837+12  906          + STORE     PARAM
         838+10    0 P1       + R ADD     /   /
         839+12  908          + STORE     FMT
         840+ 3  842          + TR +      P2           IF FMT < 0 THEM SKIP THIS PAIR FMT/DATA
         841+ 1  832          + TR        GPARAM
         842+10    0 P2       + R ADD     /   /
         843+12  868          + STORE     DATALOC      GET DATA ADDRESS PASED AS PARAM
         844+13  845          + STORE A   P2A
         845+10    0 P2A      + R ADD     /   /
         846+12  907          + STORE     DATA         GET EFFECTIVE DATA
         847+10  901          + R ADD     ZERO
         848+15  908          + LOAD MQ   FMT
         849+18  905          + DIV       D100         ACC=REMAINDER=COL NUMBER, MQ=QUOTIEN=TYPE OF DATA
         850+12  909          + STORE     COL
         851+10  901          + R ADD     ZERO
         852+20   18          + L LEFT    0018
         853+14  908          + STORE MQ  FMT
         854+15  907          + LOAD MQ   DATA
         855+10  859          + R ADD     TYPETRAD
         856+ 9  908          + ADD       FMT
         857+13  858          + STORE A   TYPETR
         858+ 1    0 TYPETR   + TR        /   /        TR SELECTED ROUTINE
         859+ 0  860 TYPETRAD + STOP      TYPETRT      TYPE TRANSFER TABLE ADDRESS
         860+ 1  889 TYPETRT  + TR        EOL          FMT=0..6 (IE <100) -> END OF PARAM LIST -> END OF LINE 
         861+ 1  866          + TR        TYSTR        FMT=1 -> PRINT A STRINGZ
         862+ 1  871          + TR        TYINT        FMT=2 -> PRINT AN INT
         863+ 1  876          + TR        TYOCT        FMT=3 -> PRINT AN OCT
         864+ 1  881          + TR        TYCHR        FMT=4 -> PRINT A CHAR
         865+ 1  885          + TR        TYALF        FMT=5 -> PRINT A 3-CHR PACKED ALFA STRING
         866+10  866 TYSTR    + R ADD     *            PRINT STRINGZ
         867+ 1   73          + TR        PRTSTR
         868+ 0    0 DATALOC  + STOP      /   /
         869- 0  909          - STOP      COL          COLUMN WHERE TXT STARTS
         870+ 1  832          + TR        GPARAM
         871+10  871 TYINT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
         872+ 1   77          + TR        PRTINT
         873+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
         874- 0  909          - STOP      COL          COLUMN WHERE TXT STARTS
         875+ 1  832          + TR        GPARAM
         876+10  876 TYOCT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
         877+ 1   79          + TR        PRTOCT
         878+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
         879- 0  909          - STOP      COL          COLUMN WHERE TXT STARTS
         880+ 1  832          + TR        GPARAM
         881+10  881 TYCHR    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
         882+ 1   75          + TR        PRTCHR
         883- 0  909          - STOP      COL          COLUMN WHERE TXT STARTS
         884+ 1  832          + TR        GPARAM
         885+10  885 TYALF    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
         886+ 1   57          + TR        PRTALF
         887- 0  909          - STOP      COL          COLUMN WHERE TXT STARTS
         888+ 1  832          + TR        GPARAM
         889+10  909 EOL      + R ADD     COL          SEND CARD BUFFER TO PRINTER AND RETURN TO CALLER
         890+ 4  895          + TR 0      DOPRINT      =0 -> PRINT ALLWAYS (NO SENSE SW CHECK)
         891+ 9  904          + ADD       D68          =1..6 -> SENSE 69..74 = OPERATOR'S PANEL SENSE SWITCH 1..6
         892+13  893          + STORE A   CHKSW
         893+30    0 CHKSW    + SENSE     /   /         
         894+ 1  897          + TR        RETURN       SW NOT AT ON POSITION
         895+10  895 DOPRINT  + R ADD     *            PRINT CARD BUFFER
         896+ 1   55          + TR        PRINTCRD
         897+10  906 RETURN   + R ADD     PARAM        PARAM-1 IS THE RETURN ADDR      
         898+ 5  902          + SUB       ONE
         899+13  900          + STORE A   EXIT
         900+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
         901+ 0    0 ZERO     + STOP      0000
         902+ 0    1 ONE      + STOP      0001
         903+ 0    2 TWO      + STOP      0002
         904+ 0   68 D68      + STOP      0068
         905+ 0  100 D100     + STOP      100
         906+ 0    0 PARAM    + STOP      0000
         907+ 0    0 DATA     + STOP      0000
         908+ 0    0 FMT      + STOP      0000
         909+ 0    0 COL      + STOP      0000
         910+ 9  924 BMPAD    + ADD       TWO
         911+13  913          + STORE A   EXIT
         912+10  914          + R ADD     BITMAPAD
         913+ 1    0 EXIT     + TR        /   /
         914+ 0  916 BITMAPAD + STOP      BITMAP
         915+     0             ORG       EVEN
         916+     0  BITMAP     DEF       0              <blank>     0     <none>
         917+   256             DEF       256               1        1       1        256          =  256   
         918+   128             DEF       128               2        2       2        128          =  128   
         919+    64             DEF       64                3        3       3         64          =   64   
         920+    32             DEF       32                4        4       4         32          =   32   
         921+    16             DEF       16                5        5       5         16          =   16   
         922+     8             DEF       8                 6        6       6          8          =    8   
         923+     4             DEF       4                 7        7       7          4          =    4   
         924+     2  TWO        DEF       2                 8        8       8          2          =    2   
         925+     1             DEF       1                 9        9       9          1          =    1   
         926+   512             DEF       512               0       10       0        512          =  512   
         927+  1024             DEF       1024              -       11       X       1024          = 1024   
         928+  2048             DEF       2048              +       12       Y       2048          = 2048   
         929+  2304             DEF       2304              A       13      Y-1        256+2048    = 2304   
         930+  2176             DEF       2176              B       14      Y-2        128+2048    = 2176   
         931+  2112             DEF       2112              C       15      Y-3         64+2048    = 2112   
         932+  2080             DEF       2080              D       16      Y-4         32+2048    = 2080   
         933+  2064             DEF       2064              E       17      Y-5         16+2048    = 2064   
         934+  2056             DEF       2056              F       18      Y-6          8+2048    = 2056   
         935+  2052             DEF       2052              G       19      Y-7          4+2048    = 2052   
         936+  2050             DEF       2050              H       20      Y-8          2+2048    = 2050   
         937+  2049             DEF       2049              I       21      Y-9          1+2048    = 2049   
         938+  1280             DEF       1280              J       22      X-1        256+1024    = 1280   
         939+  1152             DEF       1152              K       23      X-2        128+1024    = 1152   
         940+  1088             DEF       1088              L       24      X-3         64+1024    = 1088   
         941+  1056             DEF       1056              M       25      X-4         32+1024    = 1056   
         942+  1040             DEF       1040              N       26      X-5         16+1024    = 1040   
         943+  1032             DEF       1032              O       27      X-6          8+1024    = 1032   
         944+  1028             DEF       1028              P       28      X-7          4+1024    = 1028   
         945+  1026             DEF       1026              Q       29      X-8          2+1024    = 1026   
         946+  1025             DEF       1025              R       30      X-9          1+1024    = 1025   
         947+   640             DEF       640               S       31      0-2        128+512     = 640    
         948+   576             DEF       576               T       32      0-3         64+512     = 576    
         949+   544             DEF       544               U       33      0-4         32+512     = 544    
         950+   528             DEF       528               V       34      0-5         16+512     = 528    
         951+   520             DEF       520               W       35      0-6          8+512     = 520    
         952+   516             DEF       516               X       36      0-7          4+512     = 516    
         953+   514             DEF       514               Y       37      0-8          2+512     = 514    
         954+   513             DEF       513               Z       38      0-9          1+512     = 513    
         955+   578             DEF       578               ,       39      8-3-0        2+64+512  = 578    
         956+   546             DEF       546               %       40      8-4-0        2+32+512  = 546    
         957+  1090             DEF       1090              $       41      8-3-X        2+64+1024 = 1090   
         958+  1058             DEF       1058              *       42      8-4-X        2+32+1024 = 1058   
         959+  2114             DEF       2114              .       43      8-3-Y        2+64+2048 = 2114   
         960+  2082             DEF       2082              #       44      8-4-Y        2+32+2048 = 2082   
         961+   768             DEF       768               /       45      0-1          512+256   = 768    
         962+    66             DEF       66                +       46      8-3          2+64      = 66     
         963+    34             DEF       34                -       47      8-4          2+32      = 34    This is the non-minus-sign separator
         964+15 1031 SRCHTBL  + LOAD MQ   ZERO
         965+ 1  969          + TR        START
         966+15 1032 EQTBL    + LOAD MQ   ONE
         967+ 1  969          + TR        START
         968+15 1033 READTBL  + LOAD MQ   TWO
         969+ 9 1033 START    + ADD       TWO 
         970+13  977          + STORE A   P1           PARM: ADDR OF TABLE
         971+ 9 1032          + ADD       ONE          
         972+13  979          + STORE A   P2           PARM: LEN OF TABLE
         973+ 9 1032          + ADD       ONE          
         974+13  984          + STORE A   P3           PARM: VAL TO FIND
         975+ 9 1032          + ADD       ONE          
         976+13 1025          + STORE A   EXIT
         977+10    0 P1       + R ADD     /   /        GET ADDR OF TABLE
         978+13 1028          + STORE A   TBL
         979+10    0 P2       + R ADD     /   /        GET ADDR OF LEN OF TABLE/ENTRY ON TABLE
         980+13  981          + STORE A   P2A
         981+10    0 P2A      + R ADD     /   /        DERREFERENCE -> ACC=LEN/ENTRY (1..LEN)
         982+12 1026          + STORE     N
         983+ 4 1025          + TR 0      EXIT         EXIT, CANNOT READ/STORE ON ENTRY 0, SEARCH ON EMPTY TABLE
         984+10    0 P3       + R ADD     /   /        GET ADDR OF VAL TO FIND
         985+13 1001          + STORE A   WRVAL
         986+13  987          + STORE A   P3A
         987+10    0 P3A      + R ADD     /   /        DERREFERENCE -> ACC=VAL
         988+12 1027          + STORE     VAL
         989+14 1030          + STORE MQ  TEMP         JUMP TABLE DISPATCH
         990+10 1030          + R ADD     TEMP
         991+ 4 1006          + TR 0      LOOP0        TR TO SEARCH TABLE
         992+10 1026          + R ADD     N            SUB ONE AS FIRST ENTRY ON TABLE IS "1"
         993+ 5 1032          + SUB       ONE          
         994+ 9 1028          + ADD       TBL          TABLE BASE ADDR
         995+13 1004          + STORE A   WRTBL
         996+13 1000          + STORE A   RDTBL2
         997+10 1030          + R ADD     TEMP
         998+ 5 1032          + SUB       ONE
         999+ 4 1003          + TR 0      STORETBL 
        1000+10    0 RDTBL2   + R ADD     /   /        VAL=TBL[ENT]
        1001+12    0 WRVAL    + STORE     /   /
        1002+ 1 1025          + TR        EXIT
        1003+10 1027 STORETBL + R ADD     VAL          TBL[ENT]=VAL
        1004+12    0 WRTBL    + STORE     /   /    
        1005+ 1 1025          + TR        EXIT
        1006+10 1028 LOOP0    + R ADD     TBL
        1007+13 1013          + STORE A   RDTBL
        1008+10 1013          + R ADD     RDTBL
        1009+12 1029          + STORE     TBL0
        1010+ 9 1026          + ADD       N
        1011+12 1030          + STORE     TEMP         THE END ADDR OF TABLE
        1012+10 1027 LOOP     + R ADD     VAL          ACC=THE SEARCHED VALUE
        1013+ 5    0 RDTBL    + SUB       /   /    
        1014+ 2 1015          + TR OV     OVOK         CLEAR OV JUST IN CASE
        1015+ 4 1022 OVOK     + TR 0      FOUND        TR IF VAL FOUND IN ENTRY N
        1016+10 1013          + R ADD     RDTBL
        1017+ 9 1032          + ADD       ONE
        1018+13 1013          + STORE A   RDTBL
        1019+ 5 1030          + SUB       TEMP
        1020+ 4 1025          + TR 0      EXIT         NOT FOUND -> RETURN ZERO
        1021+ 1 1012          + TR        LOOP
        1022+10 1013 FOUND    + R ADD     RDTBL        RETURN ENTRY FOUND
        1023+ 5 1029          + SUB       TBL0
        1024+ 9 1032          + ADD       ONE
        1025+ 1    0 EXIT     + TR        /   /
        1026+ 0    0 N        + STOP      0000
        1027+ 0    0 VAL      + STOP      0000
        1028+ 0    0 TBL      + STOP      0000
        1029+ 0    0 TBL0     + STOP      0000
        1030+ 0    0 TEMP     + STOP      0000
        1031+ 0    0 ZERO     + STOP      0000
        1032+ 0    1 ONE      + STOP      0001         constant 1
        1033+ 0    2 TWO      + STOP      0002         constant 2
        1034+ 9 1107 RWDRUM   + ADD       TWO 
        1035+13 1044          + STORE A   PDR1         PARM1: DRUM INSTR: READ/WRITE 0128  0129  0130  0131
        1036+ 9 1106          + ADD       ONE          
        1037+13 1046          + STORE A   PDR2         PARM2: DRUM ADDRESS (0..4094)
        1038+ 9 1106          + ADD       ONE          
        1039+13 1048          + STORE A   PDR3         PARM3: BUF START ADDRESS
        1040+ 9 1106          + ADD       ONE          
        1041+13 1050          + STORE A   PDR4         PARM4: LEN: NUMBER OF HALF-WORDS (MUST BE EVEN)
        1042+ 9 1106          + ADD       ONE          
        1043+13 1104          + STORE A   EXIT               
        1044+10    0 PDR1     + R ADD     /   /        GET DRUM INSTR
        1045+12 1052          + STORE     DRIO
        1046+10    0 PDR2     + R ADD     /   /        GET DRUM ADDR
        1047+13 1053          + STORE A   DRADDR
        1048+10    0 PDR3     + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1049+13 1091          + STORE A   RWCOPY    
        1050+10    0 PDR4     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        1051+12 1108          + STORE     LEN
        1052+ 0    0 DRIO     + STOP      /   /        INSTR: READ/WRITE 0128  0129  0130  0131
        1053+29    0 DRADDR   + SET DR    /   /
        1054+ 1 1087          + TR        LOOP
        1055+ 9 1107 RDTAPE   + ADD       TWO 
        1056+13 1063          + STORE A   PR1          PARM1: TAPE ADDRESS
        1057+ 9 1106          + ADD       ONE          
        1058+13 1065          + STORE A   PR2          PARM2: BUF START ADDRESS
        1059+ 9 1106          + ADD       ONE          
        1060+13 1104          + STORE A   EXIT
        1061+ 2 1062          + TR OV     CLOV1        CLEAR OV THAT MAY HAVE BEEN SET
        1062+ 8    0    CLOV1 + NOOP      0000
        1063+10    0 PR1      + R ADD     /   /        GET TAPE ADDR
        1064+13 1067          + STORE A   RTAPAD       TAPE UNITS: 0256  0257  0258  0259
        1065+10    0 PR2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1066+13 1091          + STORE A   RWCOPY    
        1067+24    0 RTAPAD   + READ      /   /
        1068+10 1105          + R ADD     ZERO
        1069+ 1 1089          + TR        LOOP1
        1070+ 9 1107 WRTAPE   + ADD       TWO 
        1071+13 1078          + STORE A   PW1          PARM1: TAPE ADDRESS
        1072+ 9 1106          + ADD       ONE          
        1073+13 1080          + STORE A   PW2          PARM2: BUF START ADDRESS
        1074+ 9 1106          + ADD       ONE          
        1075+13 1082          + STORE A   PW3          PARM3: BUF LEN
        1076+ 9 1106          + ADD       ONE          
        1077+13 1104          + STORE A   EXIT
        1078+10    0 PW1      + R ADD     /   /        GET TAPE ADDR
        1079+13 1086          + STORE A   WTAPAD       TAPE UNITS: 0256  0257  0258  0259
        1080+10    0 PW2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1081+13 1091          + STORE A   RWCOPY    
        1082+10    0 PW3      + R ADD     /   /        GET ADDR OF LEN 
        1083+13 1084          + STORE A   PW3A
        1084+10    0 PW3A     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        1085+12 1108          + STORE     LEN
        1086+26    0 WTAPAD   + WRITE     /   /        PREPARE TO WRITE ON TAPE
        1087+10 1108 LOOP     + R ADD     LEN
        1088+ 4 1103          + TR 0      RWOK
        1089+ 5 1107 LOOP1    + SUB       TWO
        1090+12 1108          + STORE     LEN
        1091-31    0 RWCOPY   - COPY      /   /        WRITE BUFFER TO TAPE
        1092+ 1 1095          + TR        GO 
        1093+ 1 1099          + TR        EOF          END OF FILE
        1094+ 1 1101          + TR        EOR          END OF RECORD
        1095+10 1091 GO       + R ADD     RWCOPY
        1096+ 5 1107          + SUB       TWO
        1097+13 1091          + STORE A   RWCOPY
        1098+ 1 1087          + TR        LOOP
        1099+10 1106 EOF      + R ADD     ONE          SET OV FLAG TO SIGNAL END OF FILE CONDITION
        1100+22   36          + A LEFT    36
        1101+ 6 1108 EOR      + R SUB     LEN          RETURN NUMBER OF HALF-WORDS READ
        1102+ 5 1107          + SUB       TWO
        1103+26 2052 RWOK     + WRITE     2052         INSURE THAT MQ NOT IN USE            
        1104+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        1105+ 0    0 ZERO     + STOP      0000
        1106+ 0    1 ONE      + STOP      0001         
        1107+ 0    2 TWO      + STOP      0002         
        1108+     0  LEN        RES       1
        1110+ 9 1125 CHAIN    + ADD       TWO
        1111+13 1112          + STORE A   CHP1
        1112+10    0 CHP1     + R ADD     /   /        GET TAPE NUMBER
        1113+13 1120          + STORE A   TAPELOAD
        1114+30   70          + SENSE     0070         SENSE SWITCH 2                                  
        1115+ 1 1119 CONTAD   + TR        ENDSTOP      (ON POSITION MAKES SENSE OPCODE TO SKIP NEXT INSTR)
        1116+10 1115          + R ADD     CONTAD       IF SW2 IS ON, A +STOP 4095 IS EXECUTED.  
        1117+12 4095          + STORE     4095         IF THEN USER PRESS START, EXECUTION WILL BE RESUMED 
        1118+ 0 4095          + STOP      4095         AND CHAINED PROGRAM WILL BE LOADED AND EXECUTED
        1119+ 8    0 ENDSTOP  + NOOP      0000
        1120+24    0 TAPELOAD + READ      0000         
        1121-31    0 TL0      - COPY      0000         READ 1ST WORD OF SELF-LOADER FROM TAPE
        1122+ 1    0          + TR        0000         TR TO SELF-LOADER
        1123+ 0 2221          + STOP      2221         ERROR LOADING: UNEXPECTED END OF FILE
        1124+ 0 2222          + STOP      2222         ERROR LOADING: UNEXPECTED END OF RECORD 
        1125+ 0    2 TWO      + STOP      0002         ERROR LOADING: UNEXPECTED END OF FILE
          48-     0  ROUTINE INIT
          49+ 1  112 ENTRY POINT
          50-     0  ROUTINE CHAIN
          51+ 1 1110 ENTRY POINT
          52-     0  ROUTINE PRTNLINE
          53+ 1  828 ENTRY POINT
          54-     0  ROUTINE PRINTCRD
          55+ 1  506 ENTRY POINT
          56-     0  ROUTINE PRTALF
          57+ 1  590 ENTRY POINT
          58-     0  ROUTINE RDTAPE
          59+ 1 1055 ENTRY POINT
          60-     0  ROUTINE WRTAPE
          61+ 1 1070 ENTRY POINT
          62-     0  ROUTINE RWDRUM
          63+ 1 1034 ENTRY POINT
          64-     0  ROUTINE READTBL
          65+ 1  968 ENTRY POINT
          66-     0  ROUTINE CLRBUF
          67+ 1  498 ENTRY POINT
          68-     0  ROUTINE READCRD
          69+ 1  502 ENTRY POINT
          70-     0  ROUTINE WRITECRD
          71+ 1  504 ENTRY POINT
          72-     0  ROUTINE PRTSTR
          73+ 1  567 ENTRY POINT
          74-     0  ROUTINE PRTCHR
          75+ 1  710 ENTRY POINT
          76-     0  ROUTINE PRTINT
          77+ 1  668 ENTRY POINT
          78-     0  ROUTINE PRTOCT
          79+ 1  634 ENTRY POINT
          80-     0  ROUTINE BMPAD
          81+ 1  910 ENTRY POINT
          82-     0  ROUTINE SRCHTBL
          83+ 1  964 ENTRY POINT
          84-     0  ROUTINE EQTBL
          85+ 1  966 ENTRY POINT
        4094+    48  REGION ORIGIN TABLE LOCATION
        4095+   112  INITIAL REGION
           0+ 1  112          + TR        INIT         PROGRAM START
