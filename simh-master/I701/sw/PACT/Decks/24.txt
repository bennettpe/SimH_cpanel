        DEC
        NNNN OP ADDR COMMENTS
          82+ 9  545 LOADCC   + ADD       TWO          LOAD PACTSCR INTO CARD IMAGE SO 
          83+13  102          + STORE A   CPCCEX       CURRENT PACT SOURCE CODE CAN BE PRINTED
          84+10  542          + R ADD     ZERO         COPY TO LEFT SIDE OF SOURCE CODE CARD IMAGE
          85+13   89          + STORE A   CPCC1        AT 0..46 FROM PACTSCR
          86+10  105          + R ADD     CPCC2
          87+13   88          + STORE A   CPCC 
          88-10    0 CPCC     - R ADD     /   /
          89-12    0 CPCC1    - STORE     /   /
          90+10   89          + R ADD     CPCC1
          91+ 5  545          + SUB       TWO
          92+13   94          + STORE A   CPCC1B
          93+10  542          + R ADD     ZERO
          94-12    0 CPCC1B   - STORE     /   /
          95+10   88          + R ADD     CPCC
          96+ 5  545          + SUB       TWO
          97+13   88          + STORE A   CPCC
          98+10   89          + R ADD     CPCC1
          99+ 5  546          + SUB       D4
         100+13   89          + STORE A   CPCC1
         101+ 5  104          + SUB       CPCCE
         102+ 4    0 CPCCEX   + TR 0      /   /        RETURN TO CALLER
         103+ 1   88          + TR        CPCC
         104-12   48 CPCCE    - STORE     0048         LAST LOCATION TO COPY FROM 
         105+ 8  454 CPCC2    + NOOP      PACTSRC      PACTSRC = FIRST LOCATION TO COPY FROM
         106+10  106 INIT     + R ADD     *            
         107+ 1   53          + TR        PRTNLINE     
         108+ 0  101          + STOP      0101         STRINGZ AT COL 1
         109+ 0  618          + STOP      MSGSTART     "EXPAND DUP INSTR"
         110+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         111+10  542          + R ADD     ZERO         CLEAR CC RECORD
         112+12  478          + STORE     REGION     
         113+12  479          + STORE     STEP       
         114+12  480          + STORE     OP         
         115+12  481          + STORE     FACT       
         116+12  482          + STORE     S1         
         117+12  483          + STORE     S2         
         118+12  484          + STORE     QR         
         119+12  485          + STORE     QF         
         120-12  486          - STORE     NUM        
         121+12  488          + STORE     CLUE       
         122+12  489          + STORE     STEPN      
         123+12  490          + STORE     FACTN      
         124+12  491          + STORE     FACTREG    
         125+12  492          + STORE     S1N        
         126+12  493          + STORE     S2N        
         127+12  494          + STORE     D1N        
         128+12  495          + STORE     D2N        
         129+12  496          + STORE     NINST      
         130+12  497          + STORE     NINCR 
         131+10  498          + R ADD     CCLEN        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         132+10  499          + R ADD     DUMMY        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         133+10  542          + R ADD     ZERO
         134+12  569          + STORE     NREGIONS     TOTAL NUMBER OF REGIONS IN PACT PROGRAM
         135+12  570          + STORE     STEPCNT      TOTAL NUMBER OF STEPS IN PACT PROGRAM
         136+12  576          + STORE     PVOP         PREVIOUS PACT OPERATION
         137+28  258          + REWIND    TAPEOUT      REWIND TAPE OUT (PACT COMPACT CODE)
         138+28  257          + REWIND    TAPEIN       REWIND TAPE IN WITH NON-DUPLICATED REGIONS
         139+28  259          + REWIND    TAPEIND      REWIND TAPE IN WITH DUPLICATED REGIONS
         140+10  542          + R ADD     ZERO
         141+12  568          + STORE     LEVEL        DUP LEVEL. 0=MAIN PROGRAM, 1=AT DUP PROG, 2=AT DUP DUP PROG
         142+12  571          + STORE     OFSTEPN      OFFSET FOR STEPN
         143+12  572          + STORE     OFACTN       OFFSET TEMP VARS (AT "EQ RESULT OF STEP")
         144+10  145          + R ADD     STATEAD0     ACC=START LOCATION OF STATE TABLE
         145+ 8  502 STATEAD0 + NOOP      STATE        
         146+13  501          + STORE A   STATEAD      INIT STATEAD VAR (=ADD WHERE TO SAVE CURRENT STATE BEFOR PROCESSING DUP INSTR)
         147+10  569 READREG  + R ADD     NREGIONS     INCR NUMBER OF REGIONS PROCESSED
         148+ 9  544          + ADD       ONE
         149+12  569          + STORE     NREGIONS
         150+10  542          + R ADD     ZERO
         151+12  576          + STORE     PVOP         INIT PREVIOUS PACT OPERATION
         152+10  568 READSTEP + R ADD     LEVEL        IF LEVEL=0 THEN ... 
         153+ 4  160          + TR 0      RDNODUP      ... TR TO READ STEPS FROM NON-DUPLICATED REGIONS INPUT TAPE
         154+10  154          + R ADD     *            READ PACT USER PROGRAM SOURCE CODE FROM DUPLICATED REGIONS TAPE
         155+ 1   59          + TR        RDTAPE
         156+ 0  259          + STOP      TAPEIND
         157+ 0  454          + STOP      CCODE        BUF TO READ IN FROM TAPE
         158+ 2  230          + TR OV     ERREOFD      ERROR: UNEXPECTED END OF FILE IN DUP REGIONS TAPE
         159+ 1  167          + TR        RDDONE
         160+10  160 RDNODUP  + R ADD     *            READ PACT USER PROGRAM SOURCE CODE FROM TAPE
         161+ 1   59          + TR        RDTAPE
         162+ 0  257          + STOP      TAPEIN
         163+ 0  454          + STOP      CCODE        BUF TO READ IN FROM TAPE
         164+ 2  412          + TR OV     EOF          TR IF END OF FILE
         165+10  478          + R ADD     REGION       SAVE THE NON-DUPLICATED REGION NAME THAT WILL RECEIVE
         166+12  575          + STORE     NDUPREG      STEPS FROM DUPLICATED REGION
         167+ 8    0 RDDONE   + NOOP      0000
         168+10  480          + R ADD     OP
         169+ 4  379          + TR 0      EOR          TR IF END OF REGION
         170+10  170          + R ADD     *            LOAD PACTSCR INTO CARD IMAGE SO 
         171+ 1   82          + TR        LOADCC       CURRENT PACT SOURCE CODE CAN BE PRINTED
         172+10  480          + R ADD     OP
         173+ 5  553          + SUB       OPDUP
         174+ 4  322          + TR 0      CHKDUP       OP="DUP REGION" -> TR TO PROCESS INSTR
         175+10  175          + R ADD     *
         176+ 1  234          + TR        DESAMB       DES-AMBIGUATE PACT INSTRUCTIONS
         177+10  489          + R ADD     STEPN        ADD OFFSET FOR STEPN
         178+ 9  571          + ADD       OFSTEPN
         179+12  489          + STORE     STEPN
         180+10  575          + R ADD     NDUPREG      SET NON DUPLICATED REGION NAME
         181+12  478          + STORE     REGION
         182+10  480          + R ADD     OP
         183+ 5  549          + SUB       OPTR
         184+ 3  186          + TR +      CHKTR1
         185+ 1  196          + TR        NOTR         OP < OPTR -> NOT A TRANSFER OP
         186+10  480 CHKTR1   + R ADD     OP
         187+ 5  551          + SUB       OPSET
         188+ 3  196          + TR +      NOTR         OP >= SET -> NOT A TRANSFER OP
         189+10  490          + R ADD     FACTN        HERE, OP IS A TRANSFER INSTR. CHECK IF FACTOR IS BLANK
         190+ 4  196          + TR 0      NOTR         IF FACTOR IS BLANK -> TEST INSTR WITHOUT DESTINATION STEP -> NO TRANSFER OP
         191+ 3  193          + TR +      CHKTR2
         192+ 1  196          + TR        NOTR         IF FACTOR < 0 -> FACTOR IS ALFA -> NOT A DESTINATIOn STEP -> No TRANSFER OP
         193+10  490 CHKTR2   + R ADD     FACTN        FACTN=TRANSFER DESTINATION STEPN
         194+ 9  571          + ADD       OFSTEPN      ADD OFFSET FOR STEPN
         195+12  490          + STORE     FACTN
         196+ 8    0 NOTR     + NOOP      0000
         197+10  491          + R ADD     FACTREG      ADD OFFSET FOR TEMP VAR IN EQ RESULT OF STEP
         198+ 5  558          + SUB       D32          BASE48 'T'
         199+ 4  201          + TR 0      EQROFS       TR IF RESULT OF STEP
         200+ 1  204          + TR        ENDROFS
         201+10  490 EQROFS   + R ADD     FACTN
         202+ 9  572          + ADD       OFACTN
         203+12  490          + STORE     FACTN
         204+ 8    0 ENDROFS  + NOOP      0000
         205+10  570          + R ADD     STEPCNT      INCR STEP COUNT FOR PROGRAM
         206+ 9  544          + ADD       ONE
         207+12  570          + STORE     STEPCNT      
         208+ 5  567          + SUB       D4094
         209+ 3  231          + TR +      ERRTOOBI     ERROR: REGION TOO BIG
         210+10  210          + R ADD     *
         211+ 1   61          + TR        WRTAPE       WRITE MAGNETIC TAPE TAPEOUT 
         212+ 0  258          + STOP      TAPEOUT      TAPE WHERE TO WRITE
         213+ 0  454          + STOP      CCODE        BUF TO WRITE TO TAPE
         214+ 0  498          + STOP      CCLEN        LEN
         215+10  568          + R ADD     LEVEL        IF LEVEL=0 THEN ... 
         216+ 4  223          + TR 0      ENDLOG1A     ... TR TO PRINT STEPS FROM NON-DUPLICATED REGIONS INPUT TAPE
         217+30   74          + SENSE     0074         SENSE SWITCH 6
         218+ 1  223          + TR        ENDLOG1A     TR IF NO LOG SELECTED
         219+10  219          + R ADD     *            PRINT 
         220+ 1   55          + TR        PRTSTR
         221+ 0  633          + STOP      MSGEXPND     "DUP EXPANDED"
         222+ 0   40          + STOP      0040         AT COL 40
         223+ 8    0 ENDLOG1A + NOOP      0000 
         224+30   74          + SENSE     0074         SENSE SWITCH 6
         225+ 1  228          + TR        ENDLOG1      TR IF NO LOG SELECTED
         226+10  226          + R ADD     *            PRINT STEP JUST PROCESSED
         227+ 1   57          + TR        PRINTCRD
         228+ 8    0 ENDLOG1  + NOOP      0000 
         229+ 1  152          + TR        READSTEP
         230+ 0 1111 ERREOFD  + STOP      1111         ERROR: UNEXPECTED END OF FILE IN DUP REGIONS TAPE
         231+10  231 ERRTOOBI + R ADD     *
         232+ 1  441          + TR        ERROR
         233+ 0  601          + STOP      ERRTOOBG     ERROR: REGION TOO BIG
         234+ 9  545 DESAMB   + ADD       TWO          DES-AMBIGUATE PACT INSTRUCTIONS
         235+13  321          + STORE A   DSEXIT
         236+10  480          + R ADD     OP           IS OP 'CALL ?
         237+ 5  557          + SUB       OPCALL
         238+ 4  240          + TR 0      DS1          
         239+ 1  246          + TR        DS2          NO, CONTINUE
         240+10  489 DS1      + R ADD     STEPN        CHECK CALL IS FIRST INST OP REGION (IE STEPN=1)
         241+ 5  544          + SUB       ONE
         242+ 4  258          + TR 0      NODS         TES, CALL IS FIRST INST OP REGION -> CONTINUE
         243+10  243          + R ADD     *            
         244+ 1  441          + TR        ERROR
         245+ 0  595          + STOP      ERRBADCA     ERROR: MISPLACED CALL INSTR. MUST BE THE FIRST INST OF REGION
         246+10  480 DS2      + R ADD     OP           IS OP 'RES ?
         247+ 5  548          + SUB       OPRES
         248+ 4  261          + TR 0      DSOPRES      YES, TR TO DESAMBIGUATE
         249+10  480          + R ADD     OP           IS OP 'ID ?
         250+ 5  555          + SUB       OPID       
         251+ 4  274          + TR 0      DSOPID       YES, TR TO DESAMBIGUATE
         252+10  480          + R ADD     OP           IS OP 'FOR ?
         253+ 5  556          + SUB       OPFOR      
         254+ 4  303          + TR 0      DSOPFOR      YES, TR TO DESAMBIGUATE
         255+10  480          + R ADD     OP           IS OP 'HALT ?
         256+ 5  550          + SUB       OPHALT      
         257+ 4  296          + TR 0      DSOPHALT     YES, TR TO CHECK IF FOLLOWS A ID FOR LIST
         258+10  480 NODS     + R ADD     OP           IF NO DISAMBIGUATION, UPDATE PREVIOUS OP
         259+12  576          + STORE     PVOP
         260+ 1  320          + TR        DSOPOK
         261+10  576 DSOPRES  + R ADD     PVOP         PREVIOUS OP WAS 'MULT ? 
         262+ 5  546          + SUB       OPMULT
         263+ 4  268          + TR 0      DSOPRESM     YES, TR TO DESAMBIGUATE
         264+10  576          + R ADD     PVOP         WAS 'DIV ? 
         265+ 5  547          + SUB       OPDIV
         266+ 4  271          + TR 0      DSOPRESD     YES, TR TO DESAMBIGUATE
         267+ 1  258          + TR        NODS         TR -> NO NEED TO DESAMBIGUATE
         268+10  560 DSOPRESM + R ADD     OPRESM
         269+12  480          + STORE     OP           SET NEW OP
         270+ 1  320          + TR        DSOPOK
         271+10  561 DSOPRESD + R ADD     OPRESD
         272+12  480          + STORE     OP           SET NEW OP
         273+ 1  320          + TR        DSOPOK
         274+10  576 DSOPID   + R ADD     PVOP         PREVIOUS OP WAS 'LIST ?
         275+ 5  559          + SUB       OPLIST
         276+ 4  287          + TR 0      DSOPIDLI     YES, TR TO DESAMBIGUATE
         277+10  576          + R ADD     PVOP
         278+ 5  554          + SUB       OPLIB        WAS LIB?
         279+ 4  290          + TR 0      DSOPIDDO     YES, TR TO DESAMBIGUATE
         280+10  576          + R ADD     PVOP
         281+ 5  552          + SUB       OPDO         WAS DO?
         282+ 4  290          + TR 0      DSOPIDDO     YES, TR TO DESAMBIGUATE
         283+10  576          + R ADD     PVOP
         284+ 5  557          + SUB       OPCALL       WAS CALL?
         285+ 4  293          + TR 0      DSOPIDCA     YES, TR TO DESAMBIGUATE
         286+ 1  312          + TR        DSOPNOK      TR TO MISPLACED ID
         287+10  562 DSOPIDLI + R ADD     OPIDLIST     
         288+12  480          + STORE     OP           SET NEW OP
         289+ 1  320          + TR        DSOPOK
         290+10  563 DSOPIDDO + R ADD     OPIDDO
         291+12  480          + STORE     OP           SET NEW OP
         292+ 1  320          + TR        DSOPOK
         293+10  564 DSOPIDCA + R ADD     OPIDCALL
         294+12  480          + STORE     OP           SET NEW OP
         295+ 1  320          + TR        DSOPOK
         296+10  576 DSOPHALT + R ADD     PVOP         CHECK IF HALT FOLLOWS A ID FOR LIST
         297+ 5  559          + SUB       OPLIST
         298+ 4  300          + TR 0      DSOPHA1
         299+ 1  258          + TR        NODS         TR -> NO NEED TO DESAMBIGUATE
         300+10  300 DSOPHA1  + R ADD     *            
         301+ 1  441          + TR        ERROR
         302+ 0  607          + STOP      ERRHAFLI     ERROR: HALT CANNOT FOLLOW AN ID FOR LIST
         303+10  576 DSOPFOR  + R ADD     PVOP         PREVIOUS OP WAS 'LIB ?
         304+ 5  554          + SUB       OPLIB        WAS LIB?
         305+ 4  315          + TR 0      DSOPFORD     YES, TR TO DESAMBIGUATE
         306+10  576          + R ADD     PVOP
         307+ 5  552          + SUB       OPDO         WAS DO?
         308+ 4  315          + TR 0      DSOPFORD     YES, TR TO DESAMBIGUATE
         309+10  576          + R ADD     PVOP
         310+ 5  557          + SUB       OPCALL       WAS CALL?
         311+ 4  318          + TR 0      DSOPFORC     YES, TR TO DESAMBIGUATE
         312+10  312 DSOPNOK  + R ADD     *            ERROR: MISPLACED ID
         313+ 1  441          + TR        ERROR
         314+ 0  587          + STOP      ERRBADID
         315+10  565 DSOPFORD + R ADD     OPFORDO
         316+12  480          + STORE     OP           SET NEW OP
         317+ 1  320          + TR        DSOPOK
         318+10  566 DSOPFORC + R ADD     OPFORCAL
         319+12  480          + STORE     OP           SET NEW OP
         320+ 8    0 DSOPOK   + NOOP      0000
         321+ 1    0 DSEXIT   + TR        /   /
         322+10  568 CHKDUP   + R ADD     LEVEL        "DUP REGION" INSTR PROCESSING
         323+ 5  500          + SUB       MAXLVLS
         324+ 4  577          + TR 0      ERROVDUP     ERROR: TOO MANY NESTED DUP
         325+10  568          + R ADD     LEVEL
         326+ 9  544          + ADD       ONE
         327+12  568          + STORE     LEVEL
         328+10  501          + R ADD     STATEAD      SAVE CURRENT STATE ON STATE TABLE
         329+13  339          + STORE A   SVST1
         330+ 9  544          + ADD       ONE
         331+13  341          + STORE A   SVST2
         332+ 9  544          + ADD       ONE
         333+13  343          + STORE A   SVST3
         334+ 9  544          + ADD       ONE
         335+13  345          + STORE A   SVST4
         336+ 9  544          + ADD       ONE
         337+12  501          + STORE     STATEAD
         338+10  478          + R ADD     REGION
         339+12    0 SVST1    + STORE     /   /        SAVE TO STATE TABLE
         340+10  489          + R ADD     STEPN
         341+12    0 SVST2    + STORE     /   /        SAVE TO STATE TABLE
         342+10  571          + R ADD     OFSTEPN      OFFSET FOR STEPN
         343+12    0 SVST3    + STORE     /   /        SAVE TO STATE TABLE
         344+10  572          + R ADD     OFACTN       OFFSET TEMP VARS 
         345+12    0 SVST4    + STORE     /   /        SAVE TO STATE TABLE
         346+10  489          + R ADD     STEPN
         347+ 5  544          + SUB       ONE          MINUS 1 BECAUSE DUP INSTR IS REPLACED BY FIRST INST OF DUP REGION
         348+ 9  571          + ADD       OFSTEPN
         349+12  571          + STORE     OFSTEPN      OFFSET FOR STEPN
         350+10  490          + R ADD     FACTN
         351+12  572          + STORE     OFACTN       OFFSET TEMP VARS 
         352+10  481          + R ADD     FACT         SAVE THE NAME OF THE REGION TO BE DUPLICATED.
         353+12  573          + STORE     DUPREG       WILL SEARCH DUPREG REGION IN DUPLICATED REGIONS INPUT TAPE
         354+10  544          + R ADD     ONE          WILL START DUPLICATING FROM 1ST STEPN 
         355+12  574          + STORE     DUPSTEPN     
         356+28  259 DSEARCH  + REWIND    TAPEIND      REWIND TAPE IN WITH DUPLICATED REGIONS TO START A NEW REGION SEARCH
         357+10  357 DSRCH0   + R ADD     *            READ PACT USER PROGRAM SOURCE CODE FROM DUPLICATED REGIONS TAPE
         358+ 1   59          + TR        RDTAPE
         359+ 0  259          + STOP      TAPEIND
         360+ 0  454          + STOP      CCODE        BUF TO READ IN FROM TAPE
         361+ 2  230          + TR OV     ERREOFD      ERROR: UNEXPECTED END OF FILE IN DUP REGIONS TAPE
         362+10  478          + R ADD     REGION       IF THIS IS NOT THE REGION WE ARE SEARCHING, TR TO CONTINUE READING THE TAPE
         363+ 5  573          + SUB       DUPREG
         364+ 4  366          + TR 0      DUPFND1
         365+ 1  357          + TR        DSRCH0       DESIRED DUPLICATED REGION NOT FOUND YET, KEEP SEARCHING
         366+10  480 DUPFND1  + R ADD     OP
         367+ 4  372          + TR 0      DUPFND2      IF HIT END OF DUPLICATED REGION, PROCEED AS IF STEP WAS FOUND (WE ARE RETURNING TO STEP FOLLWING LAST ONE OF DUP REGION)
         368+10  489          + R ADD     STEPN
         369+ 5  574          + SUB       DUPSTEPN     IF CURRENT STEPN >= THE SEARCHE FOR -> WE ARE PLACED AT DESIRED CC
         370+ 3  372          + TR +      DUPFND2
         371+ 1  357          + TR        DSRCH0       DESIRED STEP NOT FOUND YET, KEEP SEARCHING
         372+ 1  167 DUPFND2  + TR        RDDONE       DUP REGION FOUND -> TR TO PROCESS THE STEP
         373+10  373 EORNDUP  + R ADD     *            SAVE EOR STEP TO TAPE
         374+ 1   61          + TR        WRTAPE       WRITE MAGNETIC TAPE TAPEOUT 
         375+ 0  258          + STOP      TAPEOUT      TAPE WHERE TO WRITE
         376+ 0  454          + STOP      CCODE        BUF TO WRITE TO TAPE
         377+ 0  498          + STOP      CCLEN        LEN
         378+ 1  147          + TR        READREG      PROCEED WITH NEXT NON-DUPLICATED REGION
         379+ 8    0 EOR      + NOOP      0000         END OF REGION  
         380+10  568          + R ADD     LEVEL        IF LEVEL=0 THE THIS IS A REGULAR END OF REGION FOR
         381+ 4  373          + TR 0      EORNDUP      NON-DUPLICATED REGION -> TR TO SAVE EOR RECORD TO TAPE OUT
         382+ 5  544          + SUB       ONE          THIS IS THE END OF REGION FOR THE BEING INSERTED DUPLICATED REGION
         383+12  568          + STORE     LEVEL        DECR LEVEL, RESTORE STATE 
         384+10  501          + R ADD     STATEAD      RESTORE STATE FROM STATE TABLE
         385+ 5  546          + SUB       D4
         386+13  501          + STORE A   STATEAD
         387+13  396          + STORE A   RST1
         388+ 9  544          + ADD       ONE
         389+13  398          + STORE A   RST2
         390+ 9  544          + ADD       ONE
         391+13  400          + STORE A   RST3
         392+ 9  544          + ADD       ONE
         393+13  402          + STORE A   RST4
         394+ 9  544          + ADD       ONE
         395+ 5  546          + SUB       D4
         396+10    0 RST1     + R ADD     /   /        READ FROM STATE TABLE
         397+12  478          + STORE     REGION
         398+10    0 RST2     + R ADD     /   /        READ FROM STATE TABLE
         399+12  489          + STORE     STEPN
         400+10    0 RST3     + R ADD     /   /        READ FROM STATE TABLE
         401+12  571          + STORE     OFSTEPN      OFFSET FOR STEPN
         402+10    0 RST4     + R ADD     /   /        READ FROM STATE TABLE
         403+12  572          + STORE     OFACTN       OFFSET TEMP VARS 
         404+10  568          + R ADD     LEVEL        IF LEVEL=0 RETURN TO PROCESSING NON-DUPLI REGIONS
         405+ 4  152          + TR 0      READSTEP
         406+10  478          + R ADD     REGION       GET THE NAME OF THE DUPLICATED REGION TO BE RESUMEND
         407+12  573          + STORE     DUPREG       WILL LOOK FOR THIS REGION IN DUPLICATED REGIONS INPUT TAPE
         408+10  489          + R ADD     STEPN        GET THE STEPN FROM WICH THE DUPLICATION WILL RESUME
         409+ 9  544          + ADD       ONE          STEPN WAS POINTING TO DUP INST. INCR TP SELECT INST JUST AFTER DUP
         410+12  574          + STORE     DUPSTEPN     
         411+ 1  356          + TR        DSEARCH      RESUME THE DUPLICATION OF REGION
         412+ 8    0 EOF      + NOOP      0000         END OF FILE
         413+27  258          + WRITE EF  TAPEOUT      WRITE EOF IN TAPE OUT (COMPACT CODE)
         414+10  569          + R ADD     NREGIONS     DECR NREGIONS, AS LAST EOF COUNTS AS A REGION
         415+ 5  544          + SUB       ONE
         416+12  569          + STORE     NREGIONS
         417+30   74          + SENSE     0074         SENSE SWITCH 6
         418+ 1  433          + TR        ENDLOG1B     TR IF NO LOG SELECTED
         419+10  419          + R ADD     *
         420+ 1   53          + TR        PRTNLINE     
         421+ 0  101          + STOP      0101         STRINGZ AT COL 1
         422+ 0  626          + STOP      MSGDONE      "REGIONS"
         423+ 0  210          + STOP      0210         INT AT COL 10
         424+ 0  569          + STOP      NREGIONS     TOTAL NUMBER OF REGIONS 
         425+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         426+10  426          + R ADD     *
         427+ 1   53          + TR        PRTNLINE     
         428+ 0  101          + STOP      0101         STRINGZ AT COL 1
         429+ 0  630          + STOP      MSGSTEPS     "STEPS"
         430+ 0  210          + STOP      0210         INT AT COL 10
         431+ 0  570          + STOP      STEPCNT      TOTAL NUMBER OF STEPS
         432+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         433+ 8    0 ENDLOG1B + NOOP      0000
         434+28  258          + REWIND    TAPEOUT      REWIND TAPE OUT (PACT COMPACT CODE)
         435+28  257          + REWIND    TAPEIN       REWIND TAPE IN WITH NON-DUPLICATED REGIONS
         436+28  259          + REWIND    TAPEIND      REWIND TAPE IN WITH DUPLICATED REGIONS
         437+10  437          + R ADD     *
         438+ 1   51          + TR        CHAIN        IF SW2 IS ON, A +STOP 4095 IS EXECUTED 
         439+ 0  256          + STOP      PACTCOMP     CHAIN TO NEXT STAGE IN PACT COMPILER TAPE
         440+ 0 4095          + STOP      4095
         441+ 9  545 ERROR    + ADD       TWO
         442+13  443          + STORE A   ERRP1
         443+10    0 ERRP1    + R ADD     /   /
         444+13  450          + STORE A   ERRSTRZ      SAVE ADDR OF ERROR TXT MESSAGE
         445+10  445          + R ADD     *            PRINT USER PROGRAM SOURCE CODE CARD JUST PROCESSED
         446+ 1   57          + TR        PRINTCRD
         447+10  447          + R ADD     *
         448+ 1   53          + TR        PRTNLINE     
         449+ 0  101          + STOP      0101         STRINGZ AT COL 1
         450+ 0    0 ERRSTRZ  + STOP      /   /        ERROR MESSAGE
         451+ 0    0          + STOP      0000         END OF LINE
         452+ 0  152          + STOP      READSTEP     IF USER PRESS STARTS, PROGRAM RESUMES PROCESSING NEXT SOURCE CODE STEP 
         453+     0             ORG       EVEN
         454+     0  PACTSRC    RES       24           CARD IMAGE OF PACT SOURCE CODE CARD (12 FULL WORDS)
         478+     0  REGION     DEF       0
         479+     0  STEP       DEF       0            REGION = ALFA (<0)
         480+     0  OP         DEF       0            STEP   = INT (>0)
         481+     0  FACT       DEF       0            OP     = 0..43    =0 MEANS END OF REGION
         482+     0  S1         DEF       0            FACT   < 0 -> FACTOR IS AN ALFA SYMBOL (VAR, REGION, ...) 
         483+     0  S2         DEF       0            FACT = 0 -> BLANK FACTOR
         484+     0  QR         DEF       0            FACT = 0..9999 -> DESTINATION STEP FOR TRANSFER/RESULT OF STEP
         485+     0  QF         DEF       0            CLUE = -, R OR N
         486+     0  NUM        DEF       0            
         487+     0             DEF       0            S1/S2 = 0 -> BLANK, >0 -> INTEGER, <0 -> ALFA 
         488+     0  CLUE       DEF       0
         489+     0  STEPN      DEF       0            QR = +/- INTEGER OR BLANK. 
         490+     0  FACTN      DEF       0            QF = SET IF THERE IS AN INTEGER FACTOR/NUMBER IN CARD
         491+     0  FACTREG    DEF       0
         492+     0  S1N        DEF       0            STEPN = SEQUENTIAL NUMBER OF STEP            
         493+     0  S2N        DEF       0            IF OP IS TRANSFER -> FACTN=DESTINATION STEPN
         494+     0  D1N        DEF       0            IF OP CALLS IN A RESULT OF STEP -> FACTN=TEMP ADDR (2, 4, ..)
         495+     0  D2N        DEF       0                                               FACTREG='T'
         496+     0  NINST      DEF       0      
         497+     0  NINCR      DEF       0
         498+    44  CCLEN      DEF       0044         LENGTH OF COMPACT CODE RECORD 
         499+     0  DUMMY      DEF       0            (HERE TO MAKE TABLES START AT EVEN LOCATION)
         500+    10  MAXLVLS    DEF       10           MAX 10 NESTED DUP LEVELS
         501+     0  STATEAD    DEF       0            ADDR OF CURRENT POSITION ON STATE TABLE
         502+     0  STATE      RES       40           STATE TO BE SAVED ON EACH LEVEL CHANGE (=4 HALF WORDS * 10 LEVELS)
         542+     0  ZERO       DEF       0
         543+     0             DEF       0
         544+     1  ONE        DEF       1
         545+     2  TWO        DEF       2
         546+     4  D4         DEF       4
         547+     5  D5         DEF       5
         548+     6  D6         DEF       6
         549+    11  D11        DEF       11
         550+    16  D16        DEF       16
         551+    18  D18        DEF       18
         552+    20  D20        DEF       20
         553+    22  D22        DEF       22
         554+    23  D23        DEF       23
         555+    24  D24        DEF       24
         556+    25  D25        DEF       25
         557+    26  D26        DEF       26
         558+    32  D32        DEF       32
         559+    36  D36        DEF       36
         560+    37  D37        DEF       37
         561+    38  D38        DEF       38
         562+    39  D39        DEF       39
         563+    40  D40        DEF       40
         564+    41  D41        DEF       41
         565+    42  D42        DEF       42
         566+    43  D43        DEF       43
         567+  4094  D4094      DEF       4094
         568+     0  LEVEL      DEF       0            CURRENT DUP NESTING LEVEL
         569+     0  NREGIONS   DEF       0            NUMBER OF REGION BEING PROCESSED
         570+     0  STEPCNT    DEF       0            TOTAL NUMBER OF STEPS IN PACT PROGRAM
         571+     0  OFSTEPN    DEF       0            OFFSET FOR STEPN
         572+     0  OFACTN     DEF       0            OFFSET TEMP VARS (AT "EQ RESULT OF STEP")
         573+     0  DUPREG     DEF       0            DUPLICATED REGION TO SEARCH IN DUPLICATED TAPE
         574+     0  DUPSTEPN   DEF       0            STEPN IN DUPLICATED REGION FOUND WHERE TO START
         575+     0  NDUPREG    DEF       0            NON-DUPLICATED REGION THAT RECEIVES THE STEPS FROM DUP REGION
         576+     0  PVOP       DEF       0            PREVIOUS PACT OPERATION
         577- 75051  ERROVDUP   TXT       "TOO MANY NESTED DUP REGIONS",0
         578-  1213  
         579- 61680  
         580- 60751  
         581- 74560  
         582-   801  
         583- 64542  
         584- 40101  
         585- 63487  
         586+     0  
         587- 58639  ERRBADID   TXT       "MISPLACED ID OR FOR",0                    ID CAN ONLY FOLLOW LIST/CALL/DO/LIB, FOR CAN ONLY FOLLOW CALL/DO/LIB
         588- 65677  
         589- 35392  
         590-  1024  
         591-  1326  
         592-   891  
         593- 69120  
         594+     0  
         595- 58639  ERRBADCA   TXT       "MISPACED CALL",0                          ERROR: CALL MUST BE THE FIRST INST OF REGION
         596- 65151  
         597- 39936  
         598- 35208  
         599- 55296  
         600+     0  
         601- 69955  ERRTOOBG   TXT       "REGION TOO BIG",0                         REGION STEPS > 4090 
         602- 49706  
         603-  1563  
         604- 62222  
         605- 49296  
         606+     0  
         607- 46728  ERRHAFLI   TXT       "HALT CANNOT FOLLOW ID FOR LIST",0         ERROR: HALT CANNOT FOLLOW AN ID FOR LIST
         608- 73743  
         609- 31226  
         610- 63744  
         611- 42792  
         612- 56627  
         613-  1024  
         614-   891  
         615- 69144  
         616- 49904  
         617+     0  
         618- 38476  MSGSTART   TXT       "DUP INSTR EXPANSION",0
         619-  1034  
         620- 72990  
         621-   852  
         622- 65162  
         623- 72459  
         624- 59904  
         625+     0  
         626- 69955  MSGDONE    TXT       "REGIONS",0
         627- 49706  
         628- 71424  
         629+     0  
         630- 72977  MSGSTEPS   TXT       "STEPS",0
         631- 66000  
         632+     0  
         633- 38476  MSGEXPND   TXT       "DUP EXPANDED",0
         634-   852  
         635- 65162  
         636- 37696  
         637+     0  
         638+15  652 CLRBUF   + LOAD MQ   IOCL
         639+14  657          + STORE MQ  BUFIO
         640+15  678          + LOAD MQ   IOSTORE         
         641+ 1  649          + TR        INIT2
         642+15  674 READCRD  + LOAD MQ   IORDCRD
         643+ 1  647          + TR        INIT1
         644+15  676 WRITECRD + LOAD MQ   IOWRCRD
         645+ 1  647          + TR        INIT1
         646+15  677 PRINTCRD + LOAD MQ   IOPRCRD
         647+14  657 INIT1    + STORE MQ  BUFIO
         648+15  675          + LOAD MQ   IOCOPY         
         649+14  658 INIT2    + STORE MQ  BUFROW
         650+ 9  684          + ADD       TWO          
         651+13  673          + STORE A   EXIT
         652+10  680 IOCL     + R ADD     ZERO         RESET TO INITIAL COPY LOOP ADDRESS     
         653+13  658          + STORE A   BUFROW       FOR BUFFER
         654+10  658          + R ADD     BUFROW       X .*echo Print
         655+ 5  685          + SUB       D48          X 
         656+12  682          + STORE     ENDLP        X LOOP END VALUE
         657- 0    0   BUFIO  - STOP      /   /        READ OR WRITE
         658-31    0   BUFROW - COPY      /   /        COPY WORD TO/FROM PRINTER/CARDREADER
         659+ 1  663          + TR        BUFOK2       NORMAL PROCESSING 
         660+ 1  670          + TR        EODECK       FOR COPY READING END OF REG (=END OF DECK BEING READ)
         661+ 6  684          + R SUB     TWO          END OF FILE -> NO CARD TO READ -> STOP with Acc=-2
         662+ 0  657          + STOP      BUFIO        ON PRESSING START RETRY CARD READ
         663+10  658   BUFOK2 + R ADD     BUFROW       X
         664+ 5  684          + SUB       TWO          INCR BUF ADDR
         665+13  658          + STORE A   BUFROW       X
         666+ 5  682          + SUB       ENDLP        CHECK FOR END
         667+ 4  672          + TR 0      ENDIO
         668+10  680          + R ADD     ZERO         CLEAR ACC IN CASE WE ARE CLEANING THE BUFFER
         669+ 1  658          + TR        BUFROW
         670+10  683 EODECK   + R ADD     ONE          SET OV FLAG TO SIGNAL END OF DECK CONDITION
         671+22   36          + A LEFT    36
         672+26 2052 ENDIO    + WRITE     2052         END OF I/O: INSURE THAT MQ NOT IN USE            
         673+ 1    0 EXIT     + TR        /   /
         674+24 2048 IORDCRD  + READ      2048         PREPARE TO READ FROM CARD READER
         675-31    0 IOCOPY   - COPY      /   /   
         676+26 1024 IOWRCRD  + WRITE     1024         PREPARE TO PUNCH CARD 
         677+26  512 IOPRCRD  + WRITE     0512         PREPARE WRITE PRTBUF ON PRINTER
         678-12    0 IOSTORE  - STORE     /   /        CLEAR BUFFER
         679+     0             ORG       EVEN           
         680+     0  ZERO       DEF       0            
         681+     0             DEF       0            
         682+     0  ENDLP      DEF       0            LOOP END VALUE
         683+     1  ONE        DEF       1
         684+     2  TWO        DEF       2
         685+    48  D48        DEF       48
         686+ 9  957 PRTPARM2 + ADD       TWO          GET 2 PARAMS: LEN AND COL (EITHER VALUE OR VAR ADDR)
         687+13  706          + STORE A   PRTPRMEX
         688+10  696          + R ADD     PRTP1
         689+ 9  957          + ADD       TWO          PRINT PACKED TEXT FROM FULL-WORD VALUE IN MQ REGISTER 
         690+13  696          + STORE A   PRTP1        STORE ADDR OF FIRST PARAM (LEN)
         691+ 9  956          + ADD       ONE
         692+13  698          + STORE A   PRTP2        STORE ADDR OF SECOND PARAM (COL)
         693+ 9  956          + ADD       ONE
         694+13  773          + STORE A   EXIT
         695-14  946          - STORE MQ  NUM          SAVE VALUE TO PRINT PARAM MQ (NUM IS ALIASED TO TXT)
         696+10    0   PRTP1  + R ADD     /   /        GET LEN: NUMBER OF CHARS TO PRINT (1..6)
         697+12  950          + STORE     LEN
         698+10    0   PRTP2  + R ADD     /   /        GET COLUMN PARAM 1..72
         699+ 3  702          + TR +      PRTP4
         700+13  701          + STORE A   PRTP3        COL<0 -> INTERPRET COL AS LOC(COL) = ADDR OF COL VAR
         701+10    0   PRTP3  + R ADD     /   /        READ VAR COL PASED AS PARAM
         702+ 4  773   PRTP4  + TR 0      EXIT         COL=0 -> EXIT
         703+ 3  705          + TR +      PRTP5
         704+ 1  773          + TR        EXIT         COL<0 -> EXIT
         705+12  756   PRTP5  + STORE     COL
         706+ 1    0 PRTPRMEX + TR        /   /        RETURN TO CALLER
         707+13  696 PRTSTR   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
         708+10  708          + R ADD     *            FOR PRINT STRINGZ FROM MEM
         709+ 1  686          + TR        PRTPARM2
         710+12  720          + STORE     COLSZ
         711+10  950          + R ADD     LEN          LEN IS IN FACT THE LOCATION WHERE THE STRING STARTS
         712+13  715          + STORE A   STRZAD
         713+10  773          + R ADD     EXIT
         714+13  728          + STORE A   STRZEX
         715+10    0 STRZAD   + R ADD     /   /        GET HALF-WORD WITH NEXT 3 CHARS TO PRINT
         716+ 4  728          + TR 0      STRZEX       IF +0 -> END OF STRING (-0 DOES NOT TERMINATES THE STRING)
         717+21   35          + L RIGHT   0035         MQ=3-CHARS TO PRINT
         718+10  718          + R ADD     *            
         719+ 1  730          + TR        PRTALF       PRINT 3 CHARS
         720+ 0    0 COLSZ    + STOP      0000         COL 
         721+10  715 STRZ1    + R ADD     STRZAD       INCR STRING ADDRESS
         722+ 9  956          + ADD       ONE
         723+13  715          + STORE A   STRZAD
         724+10  720          + R ADD     COLSZ        INCR COLUMN
         725+ 9  958          + ADD       D3
         726+13  720          + STORE A   COLSZ
         727+ 1  715          + TR        STRZAD
         728+ 3    0 STRZEX   + TR +      /   /        IF ZERO -> END OF STRING
         729+ 1  721          + TR        STRZ1
         730+ 9  957 PRTALF   + ADD       TWO          PRINT 3-PACKED CHARS IN MQ REGISTER 
         731+14  952          + STORE MQ  TXT          SAVE TEXT TO PRINT (IN LEFT HALF WORD)
         732+13  735          + STORE A   PRTAP2       STORE ADDR OF PARAM (COL)
         733+ 9  956          + ADD       ONE
         734+13  773          + STORE A   EXIT
         735+10    0   PRTAP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
         736+ 3  739          + TR +      PRTAP4
         737+13  738          + STORE A   PRTAP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
         738+10    0   PRTAP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
         739+12  756   PRTAP4 + STORE     COL
         740+10  958          + R ADD     D3
         741+12  950          + STORE     LEN
         742+10  940 PRT1     + R ADD     ZERO         UNPACK LEFTMOST CHAR 
         743+11  952          + ADD AB    TXT          GET TEXT DISCARD SIGN
         744+21   35          + L RIGHT   0035         MQ=Acc
         745+10  940          + R ADD     ZERO
         746+18  965          + DIV       D48X48
         747+12  952          + STORE     TXT          remainder=char to print, mq=c2 * 48 + c3 in right half-word
         748+10  940          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
         749+20   18          + L LEFT    0018         put c2 and c3 in left half-word of MQ to be saved in CHAR half word
         750+14  951          + STORE MQ  CHAR         CHAR TO PRINT
         751+10  951          + R ADD     CHAR 
         752+ 4  757          + TR 0      NXTCHR       IF BLANK PROCEED TO NEXT COL
         753+21   35          + L RIGHT   0035         MQ=CHAR TO PRINT
         754+10  754          + R ADD     *            PRINT CHAR
         755+ 1  850          + TR        PRTCHR
         756+ 0    0 COL      + STOP      0000         COL: COLUMN NUMBER TO PRINT (1..72)
         757+10  950 NXTCHR   + R ADD     LEN          DECR LEN COUNT
         758+ 5  956          + SUB       ONE
         759+12  950          + STORE     LEN
         760+ 4  773          + TR 0      EXIT         IF NO MORE CHARS TO PRINT EXIT
         761+10  756          + R ADD     COL          INCR COL POSITION
         762+ 9  956          + ADD       ONE
         763+12  756          + STORE     COL
         764+ 5  964          + SUB       D72          IF COL > 72 RETURN TO CALLER
         765+ 4  767          + TR 0      GNXTCHR      ELSE PROCEED WITH NEXT CHAR
         766+ 3  773          + TR +      EXIT
         767+10  940 GNXTCHR  + R ADD     ZERO         GET NEXT CHAR 
         768+15  952          + LOAD MQ   TXT
         769+16  963          + MPY       D48
         770+22   17          + A LEFT    0017         GET RESULT IN LEFT HALF-WORD OF ACC
         771+12  952          + STORE     TXT
         772+ 1  742          + TR        PRT1         PROCEED TO PRINT CHAR
         773+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
         774+13  696 PRTOCT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
         775+10  775          + R ADD     *            FOR PRINT OCTIONARY VALUE
         776+ 1  686          + TR        PRTPARM2
         777+10  950          + R ADD     LEN          LEN = OCTAL DIGITS TO PRINT
         778+ 9  756          + ADD       COL
         779+ 5  956          + SUB       ONE
         780+12  792          + STORE     COLN         COL POINTS TO LEAST SIGNIFICANT DIGIT
         781+10  946 PRTIOCG  + R ADD     NUM          GENERATE OCTINARY DIGIT
         782+15  940          + LOAD MQ   ZERO         CLEAR MQ
         783+21   21          + L RIGHT   0021         3 LSB BITS OF LEFT HALF-WORD OF ACC TO MQ
         784+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 3 BIT)
         785+12  946          + STORE     NUM          SAVE BACK NUM WITH RIGHTMOST OCTIONARY DIGIY EXTRACTED (NUM'=NUM/8)
         786+10  940          + R ADD     ZERO
         787+20   21          + L LEFT    0021         LEFT HALF-WORD OF ACC IS NOW RIGHTMOST OCTINARY DIGIT EXTRACTED FROM NUM 
         788+ 4  806          + TR 0      PRTIOZ       TR IF THIS DIGIT IS ZERO TO PRINT A '0' (BASE48 CODE = 10) INSTEAD OF A BLANK (BASE48 CODE = 0)
         789+21   35          + L RIGHT   0035         PUT DIGIT 1..9 TO PRINT IN MQ
         790+10  790 PRTOCTD  + R ADD     *            PRINT OCTINARY DIGIT
         791+ 1  850          + TR        PRTCHR
         792+ 0    0 COLN     + STOP      0000
         793+10  792          + R ADD     COLN        DECR COL NUMBER TO PRINT NEXT DIGIT
         794+ 5  956          + SUB       ONE
         795+12  792          + STORE     COLN
         796+10  950          + R ADD     LEN          DECR COL NUMBER TO PRINT NEXT DIGIT
         797+ 5  956          + SUB       ONE
         798+ 4  773          + TR 0      EXIT         PRINTED LEN OCTINARY DIGITS -> EXIT
         799+12  950          + STORE     LEN
         800+10  946          + R ADD     NUM          IF NUM < 0, ADD SIGN BIT TO LEFTMOST DIGIT
         801+ 3  781          + TR +      PRTIOCG
         802+10  966          + R ADD     OCT04K       
         803+ 5  946          + SUB       NUM
         804+12  946          + STORE     NUM
         805+ 1  781          + TR        PRTIOCG
         806+15  959   PRTIOZ + LOAD MQ   D10          ACC=BASE48 CODE FOR '0'
         807+ 1  790          + TR        PRTOCTD      TR TO PRINT IT
         808+13  696 PRTINT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
         809+10  809          + R ADD     *            FOR PRINT OCTIONARY VALUE
         810+ 1  686          + TR        PRTPARM2
         811+10  756          + R ADD     COL          PRINT DECIMAL NUMBER. VALUE OF LEN = DIGITS TO PRINT, NOT INCLUDING SIGN
         812+ 9  950          + ADD       LEN
         813+ 5  956          + SUB       ONE          
         814+12  835          + STORE     COLNI        COL POINTS TO END OF NUMBER
         815+10  940          + R ADD     ZERO
         816+12  949          + STORE     SGN          SIGN IS POSITIVE
         817+10  946          + R ADD     NUM
         818+ 3  823          + TR +      PRTINTG
         819+ 6  946          + R SUB     NUM          NUM IS NEGATIVE. CONVERT TO POSITIVE
         820+12  946          + STORE     NUM          AND SET SGN=1
         821+10  956          + R ADD     ONE
         822+12  949          + STORE     SGN          
         823+10  946 PRTINTG  + R ADD     NUM          GENERATE DECIMAL DIGIT
         824+21   35          + L RIGHT   0035         MQ=Acc
         825+10  940          + R ADD     ZERO
         826+18  959          + DIV       D10
         827+ 4  848          + TR 0      PRTINZ
         828+12  951 PRTINTG2 + STORE     CHAR         acc=remainder=digit to print, mq=num/10
         829+10  940          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
         830+20   18          + L LEFT    0018         digit in left half-word of MQ to be saved in CHAR half word
         831+14  946          + STORE MQ  NUM 
         832+15  951          + LOAD MQ   CHAR 
         833+10  833 PRTINTD  + R ADD     *            PRINT DECIMAL DIGIT
         834+ 1  850          + TR        PRTCHR
         835+ 0    0 COLNI    + STOP      0000
         836+10  835          + R ADD     COLNI        DECR COL NUMBER TO PRINT NEXT DIGIT
         837+ 5  956          + SUB       ONE
         838+12  835          + STORE     COLNI
         839+10  946          + R ADD     NUM          DO NOT CARE ABOUT LEN, JUST CHECK IF NUM=0 
         840+ 4  842          + TR 0      PRTINS       (SO NO MORE DIGITS REMAINS TO BE PRINTED)
         841+ 1  823          + TR        PRTINTG      NUM NOT FINISHED, PROCEED WITH NEXT DIGIT
         842+10  949 PRTINS   + R ADD     SGN
         843+ 4  773          + TR 0      EXIT         NO SIGN -> NUM FINISHED
         844+10  940          + R ADD     ZERO
         845+12  949          + STORE     SGN          CLEAR SGN FLAG
         846+15  960          + LOAD MQ   D11          BASE48 CODE FOR '-' (MINUS) CHAR
         847+ 1  833          + TR        PRTINTD      GO TO PRINT IT
         848+10  959   PRTINZ + R ADD     D10          ACC=BASE48 CODE FOR '0'
         849+ 1  828          + TR        PRTINTG2     TR TO PRINT IT
         850+ 9  957 PRTCHR   + ADD       TWO          PRINT CHAR IN MQ REGISTER 
         851+14  951          + STORE MQ  CHAR         SAVE CHAR TO PRINT (IN LEFT HALF WORD)
         852+13  856          + STORE A   PRTCP2       STORE ADDR OF PARAM (COL)
         853+ 9  956          + ADD       ONE
         854+13  934          + STORE A   PRTCEX
         855+ 2  856          + TR OV     PRTCP2       CLEAR OV JUST IN CASE
         856+10    0   PRTCP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
         857+ 3  860          + TR +      PRTCP4
         858+13  859          + STORE A   PRTCP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
         859+10    0   PRTCP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
         860+ 5  956   PRTCP4 + SUB       ONE
         861+12  954          + STORE     N            N=COL-1 -> IN RANGE 0..71
         862+ 3  864          + TR +      PRTSA        IF N >= 0 PROCEED WITH BASE BUFFER ADDR CALCULATION
         863+ 1  934          + TR        PRTCEX       IF N<0 EXIT
         864+10  940    PRTSA + R ADD     ZERO         CARD BUFFER USES LOCATION 0..47
         865+13  953          + STORE A   PRTROWAD     DETERMINE ADDRESS OF LOWER ROW TO PRINT
         866+10  954          + R ADD     N
         867+ 5  962          + SUB       D36
         868+ 3  870          + TR +      PRTC0
         869+ 1  876          + TR        PRTC1
         870+12  954    PRTC0 + STORE     N            COL NOW 0..35 
         871+ 5  962          + SUB       D36
         872+ 3  934          + TR +      PRTCEX       IF COL >= 36 (IE COL PASSED AS PARAM > 72) THEN EXIT
         873+10  953          + R ADD     PRTROWAD
         874+ 9  957          + ADD       TWO
         875+13  953          + STORE A   PRTROWAD     SET BASE BUFFER ADDR 
         876+10  956    PRTC1 + R ADD     ONE          DETERMINE MASKCOL WITH MASK TO SET IN CARD BUFFER
         877+21   53          + L RIGHT   53           SET RIGHTMOST BIT OF MQ TO 1 (SHIFT 35+18=53)
         878+10  961          + R ADD     D35
         879+ 5  954          + SUB       N
         880+13  882          + STORE A   PRTC2
         881+10  940          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW
         882+20    0    PRTC2 + L LEFT    /   /        SHIFT MQ LEFT N PLACES
         883+ 4  886          + TR 0      PRTC3        IF ACC STILL ZERO -> MASKCOL VALID
         884+ 6  956          + R SUB     ONE          ACC NOT ZERO -> SHOULD GENERATE -0 TO SET SIGN BIT ON
         885+21   72          + L RIGHT   0072         NOW MQ = -0 -> LEFTMOST BIT OF MQ SET
         886-14  942    PRTC3 - STORE MQ  MASKCOL
         887+10  940          + R ADD     ZERO         READ THE BITMAP OF CHAR 
         888+11  951          + ADD AB    CHAR         DISCARD SIGN OF CHAR, IF ANY
         889+12  951          + STORE     CHAR
         890+ 5  963          + SUB       D48
         891+ 3  934          + TR +      PRTCEX       IF CHAR >= 48 EXIT
         892+10  948          + R ADD     BITMAPAD     IF ADDR OF BASE48 BITMAP NOT COMPUTED
         893+ 4  935          + TR 0      GETBMP1      TR TO LOAD IT
         894+ 9  951  GETBMP2 + ADD       CHAR         READ THE BITMAP OF CHAR 
         895+13  896          + STORE A   PRTC4        INDICATES THE BITS TO SET IN SELECTED 
         896+10    0    PRTC4 + R ADD     /   /        COLUMN OF CARD BUFFER 
         897+12  955          + STORE     BITS
         898+ 6  956          + R SUB     ONE
         899+12  954          + STORE     N            SET TO -1
         900+10  954    LOOP1 + R ADD     N            CURRENT ROW (STARTS AT ZERO) = OFFSET ON PRTROWAD     
         901+ 9  956          + ADD       ONE
         902+12  954          + STORE     N
         903+10  955          + R ADD     BITS         EXTRACT RIGHTMOST BIT OF LEFT HALF OF ACC TO MQ
         904+ 4  934          + TR 0      PRTCEX       NO MORE BITS -> EXIT
         905+21   19          + L RIGHT   0019         LSB BIT OF LEFT HALF-WORD OF ACC TO MQ
         906+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 1 BIT)
         907+12  955          + STORE     BITS         SAVE BACK BITS. LSB HAS BEEN EXTACTED, CONTENTS SHIFTED RIGHT ONE PLACE
         908+10  940          + R ADD     ZERO
         909+20    1          + L LEFT    0001         PUT EXTACTED BIT BACK INTO ACC
         910+ 4  900          + TR 0      LOOP1        NO BIT 
         911+10  954          + R ADD     N            READ THE ROW N AT CARD BUFFER 
         912+22    2          + A LEFT    0002         MULT N BY 4 AS THERE ARE 4 HALF WORDS PER ROW
         913+ 9  953          + ADD       PRTROWAD     
         914+13  916          + STORE A   PRTROWR
         915+13  932          + STORE A   PRTROWW
         916-10    0  PRTROWR - R ADD     /   /        
         917-12  944          - STORE     ROW          CURRENT CONTENTS OF ROW
         918-10  942          - R ADD     MASKCOL      "OR" MASKCOL IN SELECTED ROW
         919+ 3  927          + TR +      PRTW2
         920-10  944          - R ADD     ROW 
         921+ 4  925          + TR 0      PRTW1         
         922+10  940          + R ADD     ZERO         MASKCOL IS MINUS ZERO AND ROW IS NOT-EMPTY (EITHER POSITIVE OR NEGATIVE) -> SET ROW AS NEGATIVE
         923- 7  944          - SUB AB    ROW 
         924+ 1  932          + TR        PRTROWW
         925-10  942    PRTW1 - R ADD     MASKCOL      MASKCOL IS MINUS ZERO AND ROW IS EMPTY -> SET ROW = MASKCOL = MINUS ZERO
         926+ 1  932          + TR        PRTROWW
         927-10  944    PRTW2 - R ADD     ROW          
         928+ 3  931          + TR +      PRTW3              
         929- 5  942          - SUB       MASKCOL      MASKCOL IS POSITIVE AND ROW IS NEGATIVE -> SUB MASKCOL FROM ROW
         930+ 1  932          + TR        PRTROWW
         931- 9  942    PRTW3 - ADD       MASKCOL      MASKCOL IS POSITIVE AND ROW IS POSITIVE OR EMPTY -> ADD MASKCOL TO ROW         
         932-12    0  PRTROWW - STORE     /   /        ROW UPDTATE
         933+ 1  900          + TR        LOOP1        PROCEED TO NEXT ROW
         934+ 1    0 PRTCEX   + TR        /   /
         935+10  935 GETBMP1  + R ADD     *
         936+ 1   77          + TR        BMPAD        GET BASE48 CHARS BITMAP ADDRESS
         937+12  948          + STORE     BITMAPAD     
         938+ 1  894          + TR        GETBMP2      RETURN
         939+     0             ORG       EVEN
         940+     0  ZERO       DEF       0            
         941+     0             DEF       0            
         942+     0  MASKCOL    DEF       0
         943+     0             DEF       0
         944+     0  ROW        DEF       0
         945+     0             DEF       0
         946+     0  NUM        DEF       0
         947+     0             DEF       0
         948+     0  BITMAPAD   DEF       0
         949+     0  SGN        DEF       0
         950+     0  LEN        DEF       0
         951+     0  CHAR       DEF       0
         952+     0  TXT        DEF       0
         953+     0  PRTROWAD   DEF       0
         954+     0  N          DEF       0
         955+     0  BITS       DEF       0
         956+     1  ONE        DEF       1
         957+     2  TWO        DEF       2
         958+     3  D3         DEF       3
         959+    10  D10        DEF       10
         960+    11  D11        DEF       11
         961+    35  D35        DEF       35
         962+    36  D36        DEF       36
         963+    48  D48        DEF       48
         964+    72  D72        DEF       72
         965+  2304  D48X48     DEF       2304
         966+ 16384  OCT04K     DEF       *040000      BIT SIGN ON 5TH OCTINARY DIGIT
         968+ 9 1043 PRTNLINE + ADD       TWO          PRINT A NEW LINE OF DATA
         969+12 1046          + STORE     PARAM        SAVE PARAM LIST ADDR
         970+10  970          + R ADD     *            CLEAR CARD BUFFER
         971+ 1   63          + TR        CLRBUF 
         972+10 1046 GPARAM   + R ADD     PARAM        GET PARAM PAIR FMT/DATA
         973+13  978          + STORE A   P1
         974+ 9 1042          + ADD       ONE
         975+13  982          + STORE A   P2
         976+ 9 1042          + ADD       ONE
         977+12 1046          + STORE     PARAM
         978+10    0 P1       + R ADD     /   /
         979+12 1048          + STORE     FMT
         980+ 3  982          + TR +      P2           IF FMT < 0 THEM SKIP THIS PAIR FMT/DATA
         981+ 1  972          + TR        GPARAM
         982+10    0 P2       + R ADD     /   /
         983+12 1008          + STORE     DATALOC      GET DATA ADDRESS PASED AS PARAM
         984+13  985          + STORE A   P2A
         985+10    0 P2A      + R ADD     /   /
         986+12 1047          + STORE     DATA         GET EFFECTIVE DATA
         987+10 1041          + R ADD     ZERO
         988+15 1048          + LOAD MQ   FMT
         989+18 1045          + DIV       D100         ACC=REMAINDER=COL NUMBER, MQ=QUOTIEN=TYPE OF DATA
         990+12 1049          + STORE     COL
         991+10 1041          + R ADD     ZERO
         992+20   18          + L LEFT    0018
         993+14 1048          + STORE MQ  FMT
         994+15 1047          + LOAD MQ   DATA
         995+10  999          + R ADD     TYPETRAD
         996+ 9 1048          + ADD       FMT
         997+13  998          + STORE A   TYPETR
         998+ 1    0 TYPETR   + TR        /   /        TR SELECTED ROUTINE
         999+ 0 1000 TYPETRAD + STOP      TYPETRT      TYPE TRANSFER TABLE ADDRESS
        1000+ 1 1029 TYPETRT  + TR        EOL          FMT=0..6 (IE <100) -> END OF PARAM LIST -> END OF LINE 
        1001+ 1 1006          + TR        TYSTR        FMT=1 -> PRINT A STRINGZ
        1002+ 1 1011          + TR        TYINT        FMT=2 -> PRINT AN INT
        1003+ 1 1016          + TR        TYOCT        FMT=3 -> PRINT AN OCT
        1004+ 1 1021          + TR        TYCHR        FMT=4 -> PRINT A CHAR
        1005+ 1 1025          + TR        TYALF        FMT=5 -> PRINT A 3-CHR PACKED ALFA STRING
        1006+10 1006 TYSTR    + R ADD     *            PRINT STRINGZ
        1007+ 1   55          + TR        PRTSTR
        1008+ 0    0 DATALOC  + STOP      /   /
        1009- 0 1049          - STOP      COL          COLUMN WHERE TXT STARTS
        1010+ 1  972          + TR        GPARAM
        1011+10 1011 TYINT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1012+ 1   73          + TR        PRTINT
        1013+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        1014- 0 1049          - STOP      COL          COLUMN WHERE TXT STARTS
        1015+ 1  972          + TR        GPARAM
        1016+10 1016 TYOCT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1017+ 1   75          + TR        PRTOCT
        1018+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        1019- 0 1049          - STOP      COL          COLUMN WHERE TXT STARTS
        1020+ 1  972          + TR        GPARAM
        1021+10 1021 TYCHR    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1022+ 1   71          + TR        PRTCHR
        1023- 0 1049          - STOP      COL          COLUMN WHERE TXT STARTS
        1024+ 1  972          + TR        GPARAM
        1025+10 1025 TYALF    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1026+ 1   69          + TR        PRTALF
        1027- 0 1049          - STOP      COL          COLUMN WHERE TXT STARTS
        1028+ 1  972          + TR        GPARAM
        1029+10 1049 EOL      + R ADD     COL          SEND CARD BUFFER TO PRINTER AND RETURN TO CALLER
        1030+ 4 1035          + TR 0      DOPRINT      =0 -> PRINT ALLWAYS (NO SENSE SW CHECK)
        1031+ 9 1044          + ADD       D68          =1..6 -> SENSE 69..74 = OPERATOR'S PANEL SENSE SWITCH 1..6
        1032+13 1033          + STORE A   CHKSW
        1033+30    0 CHKSW    + SENSE     /   /         
        1034+ 1 1037          + TR        RETURN       SW NOT AT ON POSITION
        1035+10 1035 DOPRINT  + R ADD     *            PRINT CARD BUFFER
        1036+ 1   57          + TR        PRINTCRD
        1037+10 1046 RETURN   + R ADD     PARAM        PARAM-1 IS THE RETURN ADDR      
        1038+ 5 1042          + SUB       ONE
        1039+13 1040          + STORE A   EXIT
        1040+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        1041+ 0    0 ZERO     + STOP      0000
        1042+ 0    1 ONE      + STOP      0001
        1043+ 0    2 TWO      + STOP      0002
        1044+ 0   68 D68      + STOP      0068
        1045+ 0  100 D100     + STOP      100
        1046+ 0    0 PARAM    + STOP      0000
        1047+ 0    0 DATA     + STOP      0000
        1048+ 0    0 FMT      + STOP      0000
        1049+ 0    0 COL      + STOP      0000
        1050+ 9 1064 BMPAD    + ADD       TWO
        1051+13 1053          + STORE A   EXIT
        1052+10 1054          + R ADD     BITMAPAD
        1053+ 1    0 EXIT     + TR        /   /
        1054+ 0 1056 BITMAPAD + STOP      BITMAP
        1055+     0             ORG       EVEN
        1056+     0  BITMAP     DEF       0              <blank>     0     <none>
        1057+   256             DEF       256               1        1       1        256          =  256   
        1058+   128             DEF       128               2        2       2        128          =  128   
        1059+    64             DEF       64                3        3       3         64          =   64   
        1060+    32             DEF       32                4        4       4         32          =   32   
        1061+    16             DEF       16                5        5       5         16          =   16   
        1062+     8             DEF       8                 6        6       6          8          =    8   
        1063+     4             DEF       4                 7        7       7          4          =    4   
        1064+     2  TWO        DEF       2                 8        8       8          2          =    2   
        1065+     1             DEF       1                 9        9       9          1          =    1   
        1066+   512             DEF       512               0       10       0        512          =  512   
        1067+  1024             DEF       1024              -       11       X       1024          = 1024   
        1068+  2048             DEF       2048              +       12       Y       2048          = 2048   
        1069+  2304             DEF       2304              A       13      Y-1        256+2048    = 2304   
        1070+  2176             DEF       2176              B       14      Y-2        128+2048    = 2176   
        1071+  2112             DEF       2112              C       15      Y-3         64+2048    = 2112   
        1072+  2080             DEF       2080              D       16      Y-4         32+2048    = 2080   
        1073+  2064             DEF       2064              E       17      Y-5         16+2048    = 2064   
        1074+  2056             DEF       2056              F       18      Y-6          8+2048    = 2056   
        1075+  2052             DEF       2052              G       19      Y-7          4+2048    = 2052   
        1076+  2050             DEF       2050              H       20      Y-8          2+2048    = 2050   
        1077+  2049             DEF       2049              I       21      Y-9          1+2048    = 2049   
        1078+  1280             DEF       1280              J       22      X-1        256+1024    = 1280   
        1079+  1152             DEF       1152              K       23      X-2        128+1024    = 1152   
        1080+  1088             DEF       1088              L       24      X-3         64+1024    = 1088   
        1081+  1056             DEF       1056              M       25      X-4         32+1024    = 1056   
        1082+  1040             DEF       1040              N       26      X-5         16+1024    = 1040   
        1083+  1032             DEF       1032              O       27      X-6          8+1024    = 1032   
        1084+  1028             DEF       1028              P       28      X-7          4+1024    = 1028   
        1085+  1026             DEF       1026              Q       29      X-8          2+1024    = 1026   
        1086+  1025             DEF       1025              R       30      X-9          1+1024    = 1025   
        1087+   640             DEF       640               S       31      0-2        128+512     = 640    
        1088+   576             DEF       576               T       32      0-3         64+512     = 576    
        1089+   544             DEF       544               U       33      0-4         32+512     = 544    
        1090+   528             DEF       528               V       34      0-5         16+512     = 528    
        1091+   520             DEF       520               W       35      0-6          8+512     = 520    
        1092+   516             DEF       516               X       36      0-7          4+512     = 516    
        1093+   514             DEF       514               Y       37      0-8          2+512     = 514    
        1094+   513             DEF       513               Z       38      0-9          1+512     = 513    
        1095+   578             DEF       578               ,       39      8-3-0        2+64+512  = 578    
        1096+   546             DEF       546               %       40      8-4-0        2+32+512  = 546    
        1097+  1090             DEF       1090              $       41      8-3-X        2+64+1024 = 1090   
        1098+  1058             DEF       1058              *       42      8-4-X        2+32+1024 = 1058   
        1099+  2114             DEF       2114              .       43      8-3-Y        2+64+2048 = 2114   
        1100+  2082             DEF       2082              #       44      8-4-Y        2+32+2048 = 2082   
        1101+   768             DEF       768               /       45      0-1          512+256   = 768    
        1102+    66             DEF       66                +       46      8-3          2+64      = 66     
        1103+    34             DEF       34                -       47      8-4          2+32      = 34    This is the non-minus-sign separator
        1104+ 9 1177 RWDRUM   + ADD       TWO 
        1105+13 1114          + STORE A   PDR1         PARM1: DRUM INSTR: READ/WRITE 0128  0129  0130  0131
        1106+ 9 1176          + ADD       ONE          
        1107+13 1116          + STORE A   PDR2         PARM2: DRUM ADDRESS (0..4094)
        1108+ 9 1176          + ADD       ONE          
        1109+13 1118          + STORE A   PDR3         PARM3: BUF START ADDRESS
        1110+ 9 1176          + ADD       ONE          
        1111+13 1120          + STORE A   PDR4         PARM4: LEN: NUMBER OF HALF-WORDS (MUST BE EVEN)
        1112+ 9 1176          + ADD       ONE          
        1113+13 1174          + STORE A   EXIT               
        1114+10    0 PDR1     + R ADD     /   /        GET DRUM INSTR
        1115+12 1122          + STORE     DRIO
        1116+10    0 PDR2     + R ADD     /   /        GET DRUM ADDR
        1117+13 1123          + STORE A   DRADDR
        1118+10    0 PDR3     + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1119+13 1161          + STORE A   RWCOPY    
        1120+10    0 PDR4     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        1121+12 1178          + STORE     LEN
        1122+ 0    0 DRIO     + STOP      /   /        INSTR: READ/WRITE 0128  0129  0130  0131
        1123+29    0 DRADDR   + SET DR    /   /
        1124+ 1 1157          + TR        LOOP
        1125+ 9 1177 RDTAPE   + ADD       TWO 
        1126+13 1133          + STORE A   PR1          PARM1: TAPE ADDRESS
        1127+ 9 1176          + ADD       ONE          
        1128+13 1135          + STORE A   PR2          PARM2: BUF START ADDRESS
        1129+ 9 1176          + ADD       ONE          
        1130+13 1174          + STORE A   EXIT
        1131+ 2 1132          + TR OV     CLOV1        CLEAR OV THAT MAY HAVE BEEN SET
        1132+ 8    0    CLOV1 + NOOP      0000
        1133+10    0 PR1      + R ADD     /   /        GET TAPE ADDR
        1134+13 1137          + STORE A   RTAPAD       TAPE UNITS: 0256  0257  0258  0259
        1135+10    0 PR2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1136+13 1161          + STORE A   RWCOPY    
        1137+24    0 RTAPAD   + READ      /   /
        1138+10 1175          + R ADD     ZERO
        1139+ 1 1159          + TR        LOOP1
        1140+ 9 1177 WRTAPE   + ADD       TWO 
        1141+13 1148          + STORE A   PW1          PARM1: TAPE ADDRESS
        1142+ 9 1176          + ADD       ONE          
        1143+13 1150          + STORE A   PW2          PARM2: BUF START ADDRESS
        1144+ 9 1176          + ADD       ONE          
        1145+13 1152          + STORE A   PW3          PARM3: BUF LEN
        1146+ 9 1176          + ADD       ONE          
        1147+13 1174          + STORE A   EXIT
        1148+10    0 PW1      + R ADD     /   /        GET TAPE ADDR
        1149+13 1156          + STORE A   WTAPAD       TAPE UNITS: 0256  0257  0258  0259
        1150+10    0 PW2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1151+13 1161          + STORE A   RWCOPY    
        1152+10    0 PW3      + R ADD     /   /        GET ADDR OF LEN 
        1153+13 1154          + STORE A   PW3A
        1154+10    0 PW3A     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        1155+12 1178          + STORE     LEN
        1156+26    0 WTAPAD   + WRITE     /   /        PREPARE TO WRITE ON TAPE
        1157+10 1178 LOOP     + R ADD     LEN
        1158+ 4 1173          + TR 0      RWOK
        1159+ 5 1177 LOOP1    + SUB       TWO
        1160+12 1178          + STORE     LEN
        1161-31    0 RWCOPY   - COPY      /   /        WRITE BUFFER TO TAPE
        1162+ 1 1165          + TR        GO 
        1163+ 1 1169          + TR        EOF          END OF FILE
        1164+ 1 1171          + TR        EOR          END OF RECORD
        1165+10 1161 GO       + R ADD     RWCOPY
        1166+ 5 1177          + SUB       TWO
        1167+13 1161          + STORE A   RWCOPY
        1168+ 1 1157          + TR        LOOP
        1169+10 1176 EOF      + R ADD     ONE          SET OV FLAG TO SIGNAL END OF FILE CONDITION
        1170+22   36          + A LEFT    36
        1171+ 6 1178 EOR      + R SUB     LEN          RETURN NUMBER OF HALF-WORDS READ
        1172+ 5 1177          + SUB       TWO
        1173+26 2052 RWOK     + WRITE     2052         INSURE THAT MQ NOT IN USE            
        1174+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        1175+ 0    0 ZERO     + STOP      0000
        1176+ 0    1 ONE      + STOP      0001         
        1177+ 0    2 TWO      + STOP      0002         
        1178+     0  LEN        RES       1
        1180+ 9 1195 CHAIN    + ADD       TWO
        1181+13 1182          + STORE A   CHP1
        1182+10    0 CHP1     + R ADD     /   /        GET TAPE NUMBER
        1183+13 1190          + STORE A   TAPELOAD
        1184+30   70          + SENSE     0070         SENSE SWITCH 2                                  
        1185+ 1 1189 CONTAD   + TR        ENDSTOP      (ON POSITION MAKES SENSE OPCODE TO SKIP NEXT INSTR)
        1186+10 1185          + R ADD     CONTAD       IF SW2 IS ON, A +STOP 4095 IS EXECUTED.  
        1187+12 4095          + STORE     4095         IF THEN USER PRESS START, EXECUTION WILL BE RESUMED 
        1188+ 0 4095          + STOP      4095         AND CHAINED PROGRAM WILL BE LOADED AND EXECUTED
        1189+ 8    0 ENDSTOP  + NOOP      0000
        1190+24    0 TAPELOAD + READ      0000         
        1191-31    0 TL0      - COPY      0000         READ 1ST WORD OF SELF-LOADER FROM TAPE
        1192+ 1    0          + TR        0000         TR TO SELF-LOADER
        1193+ 0 2221          + STOP      2221         ERROR LOADING: UNEXPECTED END OF FILE
        1194+ 0 2222          + STOP      2222         ERROR LOADING: UNEXPECTED END OF RECORD 
        1195+ 0    2 TWO      + STOP      0002         ERROR LOADING: UNEXPECTED END OF FILE
          48-     0  ROUTINE INIT
          49+ 1  106 ENTRY POINT
          50-     0  ROUTINE CHAIN
          51+ 1 1180 ENTRY POINT
          52-     0  ROUTINE PRTNLINE
          53+ 1  968 ENTRY POINT
          54-     0  ROUTINE PRTSTR
          55+ 1  707 ENTRY POINT
          56-     0  ROUTINE PRINTCRD
          57+ 1  646 ENTRY POINT
          58-     0  ROUTINE RDTAPE
          59+ 1 1125 ENTRY POINT
          60-     0  ROUTINE WRTAPE
          61+ 1 1140 ENTRY POINT
          62-     0  ROUTINE CLRBUF
          63+ 1  638 ENTRY POINT
          64-     0  ROUTINE READCRD
          65+ 1  642 ENTRY POINT
          66-     0  ROUTINE WRITECRD
          67+ 1  644 ENTRY POINT
          68-     0  ROUTINE PRTALF
          69+ 1  730 ENTRY POINT
          70-     0  ROUTINE PRTCHR
          71+ 1  850 ENTRY POINT
          72-     0  ROUTINE PRTINT
          73+ 1  808 ENTRY POINT
          74-     0  ROUTINE PRTOCT
          75+ 1  774 ENTRY POINT
          76-     0  ROUTINE BMPAD
          77+ 1 1050 ENTRY POINT
          78-     0  ROUTINE RWDRUM
          79+ 1 1104 ENTRY POINT
        4094+    48  REGION ORIGIN TABLE LOCATION
        4095+   106  INITIAL REGION
           0+ 1  106          + TR        INIT         PROGRAM START
