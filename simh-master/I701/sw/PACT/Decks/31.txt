        DEC
        NNNN OP ADDR COMMENTS
          92+ 9  724 SRCHVAR  + ADD       TWO          SEARCH VAR 
          93+13  100          + STORE A   SRCHP1       PARAMS: ADDR OF VAR NAME TO SEARCH
          94+ 9  723          + ADD       ONE
          95+13  105          + STORE A   SRCHP2
          96+ 9  723          + ADD       ONE
          97+13  110          + STORE A   SRCHP3
          98+ 9  723          + ADD       ONE
          99+13  165          + STORE A   SRCHVAEX     RETURN INDEX POS IN ACC
         100+10    0 SRCHP1   + R ADD     /   /        GET ADDR OF NAME     
         101+13  141          + STORE A   SRCHN0   
         102+13  103          + STORE A   SRCHP1A
         103+10    0 SRCHP1A  + R ADD     /   /
         104+12  516          + STORE     FNDVAR      
         105+10    0 SRCHP2   + R ADD     /   /        GET ADDR OF NAME1
         106+13  145          + STORE A   SRCHN1
         107+13  108          + STORE A   SRCHP2A
         108+10    0 SRCHP2A  + R ADD     /   /
         109+12  517          + STORE     FNDVAR1
         110+10    0 SRCHP3   + R ADD     /   /        GET ADDR OF NAME2
         111+13  149          + STORE A   SRCHN2
         112+13  113          + STORE A   SRCHP3A
         113+10    0 SRCHP3A  + R ADD     /   /
         114+12  518          + STORE     FNDVAR2
         115+10  115          + R ADD     *            GET THE HASH OF VAR BEING SEARCHED
         116+ 1  166          + TR        GETHASH
         117+ 9  175          + ADD       HASHAD       ADD HASH TABLE ADDR
         118+13  119          + STORE A   SRCHHA1
         119+10    0 SRCHHA1  + R ADD     /   /        GET HASH[HASH VARNAME] -> VAR NUMBER
         120+ 4  164          + TR 0      SRCHNFND     =0 -> VAR NOT IN HASH TABLE -> VAR NOT EXISTS
         121+12  733          + STORE     N
         122+ 5  723          + SUB       ONE
         123+22    3          + A LEFT    0003         ADDR IN DRUM = 8*(NVAR -1)
         124+13  137          + STORE A   SRCHDRAD
         125+10  723          + R ADD     ONE
         126+12  735          + STORE     HASHFLAG     -> USING HASH VALUE
         127+ 1  134          + TR        SRCHTEST     TEST IF VAR FOUND USING HASH 
         128+10  733 SRCHLOOP + R ADD     N
         129+ 5  515          + SUB       NVARS
         130+ 4  164          + TR 0      SRCHNFND
         131+10  733          + R ADD     N
         132+ 9  723          + ADD       ONE
         133+12  733          + STORE     N
         134+10  134 SRCHTEST + R ADD     *
         135+ 1   67          + TR        RWDRUM       READ VAR FROM DRUM
         136+24  128          + READ      0128         DRUM INSTR
         137+ 0    0 SRCHDRAD + STOP      /   /        DRUM ADDR 
         138+ 0  516          + STOP      FNDVAR
         139+ 0    4          + STOP      0004         GET 4 HALF-WORD. ONLY 3 ARE NEEDED (THE NAME), BUT NUMER OF HW WORDS READ SHOULD BE EVEN
         140+10  516          + R ADD     FNDVAR
         141+ 5    0 SRCHN0   + SUB       /   /
         142+ 4  144          + TR 0      SRCHV1
         143+ 1  151          + TR        NXTSRCH
         144+10  517 SRCHV1   + R ADD     FNDVAR1
         145+ 5    0 SRCHN1   + SUB       /   /
         146+ 4  148          + TR 0      SRCHV2
         147+ 1  151          + TR        NXTSRCH
         148+10  518 SRCHV2   + R ADD     FNDVAR2
         149+ 5    0 SRCHN2   + SUB       /   /
         150+ 4  162          + TR 0      SRCHFND      VAR FOUND
         151+10  735 NXTSRCH  + R ADD     HASHFLAG     VAR NOT FOUND, SEARCH NEXT
         152+ 4  158          + TR 0      NXTSRCH2
         153+10  721          + R ADD     ZERO
         154+12  735          + STORE     HASHFLAG     VAR NOT FOUND USING HASH, START A SEQUENTIAL SEARCH
         155+12  733          + STORE     N
         156+13  137          + STORE A   SRCHDRAD
         157+ 1  128          + TR        SRCHLOOP 
         158+10  137 NXTSRCH2 + R ADD     SRCHDRAD
         159+ 9  725          + ADD       D8
         160+13  137          + STORE A   SRCHDRAD
         161+ 1  128          + TR        SRCHLOOP
         162+10  733 SRCHFND  + R ADD     N
         163+ 1  165          + TR        SRCHVAEX
         164+10  721 SRCHNFND + R ADD     ZERO
         165+ 1    0 SRCHVAEX + TR        /   /
         166+ 9  724 GETHASH  + ADD       TWO          CALC HASH VALUE (0..198) FOR VARIABLE NAME FNDVAR, FNDVAR1, FNDVAR2
         167+13  174          + STORE A   GETHAEX      RETURN HASH IN ACC
         168+10  721          + R ADD     ZERO
         169+11  516          + ADD AB    FNDVAR
         170+11  517          + ADD AB    FNDVAR1
         171+11  518          + ADD AB    FNDVAR2
         172+21   35          + L RIGHT   0035         MQ=ABS(VARIABLE FULL NAME)
         173+18  728          + DIV       D199         DIV BY 199, ACC=REMINDER
         174+ 1    0 GETHAEX  + TR        /   /
         175+ 0  520 HASHAD   + STOP      HASH         HASH TABLE ADDRESS
         176+ 9  724 RDALNUM  + ADD       TWO          READ 3 CHARS. RETURN ACC=0..999 IF IT IS A NUMERIC VALUE
         177+13  180          + STORE A   RDALN1       OR RETURN ACC=ALFA 3-CHAR PACKED STRING (IT IS NEGATIVE)
         178+ 9  723          + ADD       ONE
         179+13  188          + STORE A   RDALNEX
         180+10    0 RDALN1   + R ADD     /   /        READ PARAM: THE START COL
         181+12  184          + STORE     COL
         182+10  182          + R ADD     *           
         183+ 1   59          + TR        RDALF        READ 3 CHARS (CAN BE ALFA OR NUM)
         184+ 0    0 COL      + STOP      0000         STARTING AT COL GIVEN AS PARAM
         185+ 3  188          + TR +      RDALNEX      IF ACC>=0 THEN TR BECAUSE IT IS A NUMERIC VALUE
         186+10  721          + R ADD     ZERO         ACC WAS <0: READ AN ALFA VALUE
         187+20   35          + L LEFT    0035         ACC=THE ALFA VALUE OF FACTOR FROM MQ
         188+ 1    0 RDALNEX  + TR        /   /
         189+10  189 INIT     + R ADD     *
         190+ 1   63          + TR        PRTNLINE     
         191+ 0  101          + STOP      0101         STRINGZ AT COL 1
         192+ 0  835          + STOP      MSGSTART     "READ VARS"
         193+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         194+10  721          + R ADD     ZERO
         195+12  730          + STORE     NCARDS       TOTAL NUMBER OF PACT SOURCE CODE CARDS PROCESSED
         196+12  731          + STORE     LAST         FLAG FOR LAST CARD
         197+12  514          + STORE     RELNUM0      REL NUM ORIGIN
         198+10  198          + R ADD     *            CLEAR HASH TABLE
         199+ 1   69          + TR        CLMEM        
         200+ 0  520          + STOP      HASH
         201+ 0  729          + STOP      D200
         202+10  519          + R ADD     DUMMY        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         203+10  203 READCARD + R ADD     *            READ PACT USER PROGRAM VARIABLES SOURCE CODE CARD
         204+ 1   55          + TR        READCRD
         205+ 2  481          + TR OV     ERRUEOD      ERROR: UNEXPECTED END OF DECK (LASt CARD SHOULD BE MARKED WITH Y(12) ON COL 72
         206+10  730          + R ADD     NCARDS
         207+ 9  723          + ADD       ONE
         208+12  730          + STORE     NCARDS
         209+10  209          + R ADD     *           
         210+ 1   59          + TR        RDALF        READ REGION 
         211+ 0    1          + STOP      0001         STARTING AT COL 1         
         212+14  498          + STORE MQ  VARNAME      STORE ALFA 
         213+10  213          + R ADD     *           
         214+ 1  176          + TR        RDALNUM      READ S1 (ALFA OR NUM)
         215+ 0    4          + STOP      0004         AT COL 4
         216+12  499          + STORE     VARNAM1      (ALFA IF <0, NUM IF>0, BLANK/0 IF =0) 
         217+10  217          + R ADD     *           
         218+ 1  176          + TR        RDALNUM      READ S2 (ALFA OR NUM)
         219+ 0    7          + STOP      0007         AT COL 7
         220+12  500          + STORE     VARNAM2      (ALFA IF <0, NUM IF>0, BLANK/0 IF =0) 
         221+10  221          + R ADD     *           
         222+ 1   57          + TR        RDINT        READ Q OF VARIABLE
         223+ 0    3          + STOP      0003         LEN=3 CHARS
         224+ 0   10          + STOP      0010         STARTING AT COL 10
         225+12  503          + STORE     Q            STORE INTEGER
         226+10  226          + R ADD     *           
         227+ 1   57          + TR        RDINT        READ STEP
         228+ 0    3 D3       + STOP      0003         LEN=3 CHARS
         229+ 0   13          + STOP      0013         STARTING AT COL 13
         230+12  504          + STORE     D1           STORE INTEGER
         231+10  231          + R ADD     *           
         232+ 1   57          + TR        RDINT        READ STEP
         233+ 0    3          + STOP      0003         LEN=3 CHARS
         234+ 0   16          + STOP      0016         STARTING AT COL 16
         235+12  505          + STORE     D2           STORE INTEGER
         236+10  236          + R ADD     *           
         237+ 1   59          + TR        RDALF        READ CONSTRAINT
         238+ 0   19          + STOP      0019         STARTING AT COL 19         
         239+14  506          + STORE MQ  CONSTR       STORE ALFA 
         240+10  240          + R ADD     *           
         241+ 1   59          + TR        RDALF        READ CONSTRAINT 
         242+ 0   22          + STOP      0022         STARTING AT COL 22
         243+14  507          + STORE MQ  CONSTR1      STORE ALFA 
         244+10  244          + R ADD     *           
         245+ 1   59          + TR        RDALF        READ CONSTRAINT
         246+ 0   25          + STOP      0025         STARTING AT COL 25
         247+14  508          + STORE MQ  CONSTR2      STORE ALFA 
         248+10  248          + R ADD     *           
         249+ 1   59          + TR        RDALF        READ CONSTRAINT TYPE
         250+ 0   28          + STOP      0028         STARTING AT COL 28
         251+14  509          + STORE MQ  CTYPE        STORE ALFA 
         252+10  252          + R ADD     *           
         253+ 1   57          + TR        RDINT        READ REL LOC OF VAR
         254+ 0    4          + STOP      0004         LEN=4 CHARS
         255+ 0   31          + STOP      0031         STARTING AT COL 31
         256+12  732          + STORE     LOC          STORE INTEGER
         257+10  257          + R ADD     *            CHECK Y(12) ON COL 72 ON CARD BUFFER
         258+ 1   61          + TR        RDCHR        READ CHAR
         259+ 0   72          + STOP      0072         AT COL 72
         260+12  734          + STORE     CHAR         STORE BASE48 CHAR
         261+10  727          + R ADD     D12
         262+ 5  734          + SUB       CHAR
         263+ 4  265          + TR 0      LASTCRD      IF PUNCHED, THIS IS LAST CARD
         264+ 1  267          + TR        NOTLAST
         265+10  723 LASTCRD  + R ADD     ONE
         266+12  731          + STORE     LAST         LAST=1 TO SIGNAL THIS IS LAST CARD OF PACT SOURCE PROGRAM DECK
         267+ 8    0 NOTLAST  + NOOP      0000
         268+10  509          + R ADD     CTYPE        IS CONSTAINT TYPE = 'NUM'?
         269+ 5  844          + SUB       ALFNUM
         270+ 4  272          + TR 0      RNUM1        YES, TR RNUM1
         271+ 1  286          + TR        RNUM9
         272+10  514 RNUM1    + R ADD     RELNUM0      GET CURRENT REL NUM ORIGIN (=BASE ADDR FOR NUM CONSTANT IN PROGRAM)
         273+ 4  277          + TR 0      RNUM2        IS ALREADY SET? TR IF NOT SET YET
         274+10  274          + R ADD     *            YES -> ERROR
         275+ 1  486          + TR        ERROR
         276+ 0  745          + STOP      ERRRNUM0     ERROR: REL NUM ORIGIN ALREADY SET
         277+10  732 RNUM2    + R ADD     LOC          GET VALUE IN LOC FIELD
         278+12  514          + STORE     RELNUM0      STORE AS NEW REL NUM ORIGIN
         279+21   19          + L RIGHT   0019         IS EVEN?
         280+10  721          + R ADD     ZERO
         281+20    1          + L LEFT    0001
         282+ 4  286          + TR 0      RNUM9        IF =0 THEN IS RELNUM0 IS EVEN -> TR END OF PROCESSING
         283+10  283          + R ADD     *            YES -> ERROR
         284+ 1  486          + TR        ERROR
         285+ 0  755          + STOP      ERRRNNE      ERROR: REL NUM ORIGIN NOT EVEN
         286+ 8    0 RNUM9    + NOOP      0000         END OF PROCESSING NUM CONSTRAINT
         287+10  498          + R ADD     VARNAME      IF VAR IS BLANK AND LAST Y(12) PUNCH IS SET
         288+ 4  290          + TR 0      BLKVA1       THEN TERMINATE READING
         289+ 1  296          + TR        BLKVA9       ELSE ERROR BLANK VAR NAME
         290+10  731 BLKVA1   + R ADD     LAST
         291+ 4  293          + TR 0      BLKVA2
         292+ 1  449          + TR        NEXT  
         293+10  293 BLKVA2   + R ADD     *            
         294+ 1  486          + TR        ERROR
         295+ 0  764          + STOP      ERRNOVAR     ERROR: BLANK VAR NAME
         296+ 8    0 BLKVA9   + NOOP      0000         END OF PROCESSING BLANK VAR 
         297+10  504          + R ADD     D1           IF D1 < 1 THEN D1=1
         298+ 5  723          + SUB       ONE
         299+ 3  302          + TR +      D1A
         300+10  723          + R ADD     ONE
         301+12  504          + STORE     D1
         302+ 8    0 D1A      + NOOP      0000
         303+10  505          + R ADD     D2           IF D2 < 1 THEN D2=1
         304+ 5  723          + SUB       ONE
         305+ 3  308          + TR +      D2A
         306+10  723          + R ADD     ONE
         307+12  505          + STORE     D2
         308+ 8    0 D2A      + NOOP      0000
         309+10  723          + R ADD     ONE          VARIABLES CAN HAVE UP TO 2 DEFINITIVE (=THAT DEFINES) INDEX (SUBSCRIPTS)
         310+ 5  504          + SUB       D1           THIS MEANS THAT VAR NAME CAN HAVE UP TO 9 ALFA CHARS "VAR S1 S2"
         311+ 4  314          + TR 0      D1B          IF A DIMENSION IS DEFINED (>1), NO DEFINITIVE SUBSCRIPT ALLOWED
         312+10  721          + R ADD     ZERO         -> IF D1 > 1 THEN VARNAM1=0
         313+12  499          + STORE     VARNAM1
         314+ 8    0 D1B      + NOOP      0000  
         315+10  723          + R ADD     ONE          
         316+ 5  505          + SUB       D2           -> IF D2 > 1 THEN VARNAM2=0. CLEAR AS THERE IS A DIMENSION -> INDEX IS 
         317+ 4  320          + TR 0      D2B          INDUCTIVE, NOT DEFINITIVE
         318+10  721          + R ADD     ZERO         
         319+12  500          + STORE     VARNAM2
         320+ 8    0 D2B      + NOOP      0000  
         321+10  500          + R ADD     VARNAM2      IF (S1 = 0) AND (S2 <> 0) THEN ERROR
         322+ 4  329          + TR 0      D3B
         323+10  499          + R ADD     VARNAM1
         324+ 4  326          + TR 0      D3A
         325+ 1  329          + TR        D3B
         326+10  326 D3A      + R ADD     *            
         327+ 1  486          + TR        ERROR
         328+ 0  770          + STOP      ERRBADID     ERROR: S2 CANNOT BE DEFINITIVE INDEX IF S1 IS INDUCTIVE INDEX
         329+ 8    0 D3B      + NOOP      0000  
         330+10  330          + R ADD     *
         331+ 1   92          + TR        SRCHVAR      SEARCH VAR. RETURN INDEX POS IN ACC
         332+ 0  498          + STOP      VARNAME
         333+ 0  499          + STOP      VARNAM1
         334+ 0  500          + STOP      VARNAM2
         335+ 4  342          + TR 0      D4A          TR IF VAR NOT DEFINED
         336+10  336          + R ADD     *            
         337+ 1  486          + TR        ERROR
         338+ 0  789          + STOP      ERRREDEF     ERROR: VAR ALREADY DEFINED
         339+10  339 ADDVAROV + R ADD     *            
         340+ 1  486          + TR        ERROR
         341+ 0  797          + STOP      ERROVVAR     TOO MANY VARS DEFINED
         342+10  515 D4A      + R ADD     NVARS        INCR NUM OF VARS DEFINED
         343+ 9  723          + ADD       ONE
         344+12  515          + STORE     NVARS
         345+ 5  720          + SUB       MAXNVARS
         346+ 3  339          + TR +      ADDVAROV     ERROR IF > TABLE SIZE
         347+10  504          + R ADD     D1
         348+ 5  723          + SUB       ONE          IF (D1 = 1) AND (D2 > 1) THEN 
         349+ 4  351          + TR 0      D5A             D1=D2
         350+ 1  358          + TR        D5B             D2=1
         351+10  505 D5A      + R ADD     D2              ON VECTORS, THE DIMENSIOn OF VECTOR SHOULD BE SET IN D1
         352+ 5  723          + SUB       ONE
         353+ 4  358          + TR 0      D5B
         354+10  505          + R ADD     D2
         355+12  504          + STORE     D1
         356+10  723          + R ADD     ONE
         357+12  505          + STORE     D2 
         358+ 8    0 D5B      + NOOP      0000  
         359+15  723          + LOAD MQ   ONE          SET TYPE OF VAR: 1=SCALAR, 2=VECTOR, 3=MATRIX
         360+10  504          + R ADD     D1
         361+ 9  505          + ADD       D2
         362+ 5  724          + SUB       TWO
         363+ 4  369          + TR 0      D5C          IF=0 -> D1=1 AND D2=1 -> VAR IS A SCALAR
         364+15  724          + LOAD MQ   TWO          SET TYPE OF VAR: 1=SCALAR, 2=VECTOR, 3=MATRIX
         365+10  505          + R ADD     D2           
         366+ 5  723          + SUB       ONE
         367+ 4  369          + TR 0      D5C          IF=0 -> D1>1 AND D2=1 -> VAR IS A VECTOR
         368+15  228          + LOAD MQ   D3           SET TYPE OF VAR: 1=SCALAR, 2=VECTOR, 3=MATRIX
         369+14  501 D5C      + STORE MQ  VTYPE
         370+15  504          + LOAD MQ   D1           LEN = 2 * D1 * D2
         371+16  505          + MPY       D2
         372+22   18          + A LEFT    0018
         373+12  502          + STORE     LEN
         374+10  721          + R ADD     ZERO
         375+12  510          + STORE     RELADDR
         376+12  511          + STORE     PHASE
         377+12  512          + STORE     FLAG
         378+12  513          + STORE     SIZE
         379+15  726          + LOAD MQ   D9           CHECK IF CONSTRAINT = 'REL'
         380+10  509          + R ADD     CTYPE
         381+ 5  845          + SUB       ALFREL
         382+ 4  384          + TR 0      D6A          YES! -> TR
         383+ 1  387          + TR        D6B
         384+10  732 D6A      + R ADD     LOC          RELADDR = LOC STATED IN CARD 
         385+12  510          + STORE     RELADDR
         386+ 1  405          + TR        D6C
         387+15  228 D6B      + LOAD MQ   D3           CHECK IF CONSTRAINT = 'SUC'
         388+10  509          + R ADD     CTYPE
         389+ 5  846          + SUB       ALFSUC
         390+ 4  405          + TR 0      D6C
         391+15  724          + LOAD MQ   TWO          CHECK IF CONSTRAINT = 'IMS'
         392+10  509          + R ADD     CTYPE
         393+ 5  847          + SUB       ALFIMS
         394+ 4  405          + TR 0      D6C
         395+15  723          + LOAD MQ   ONE          CHECK IF CONSTRAINT = 'SYN'
         396+10  509          + R ADD     CTYPE
         397+ 5  848          + SUB       ALFSYN
         398+ 4  405          + TR 0      D6C
         399+15  721          + LOAD MQ   ZERO         CHECK IF CONSTRAINT = '  '
         400+10  509          + R ADD     CTYPE
         401+ 4  405          + TR 0      D6C
         402+10  402          + R ADD     *            
         403+ 1  486          + TR        ERROR
         404+ 0  805          + STOP      ERRINVCO     ERROR: INVALID CONSTRAINT FOR VAR
         405+14  509 D6C      + STORE MQ  CTYPE        CONSTRAINT TYPE. 0=NONE, 1=SYN, 2=IMS, 3=SUC, 9=REL
         406+10  509          + R ADD     CTYPE        IF (CTYPE=0 NONE) OR (CTYPE=9 REL) THEN TR CHECK NO CONSTRAINT VAR
         407+ 4  416          + TR 0      D7A       
         408+ 5  726          + SUB       D9
         409+ 4  416          + TR 0      D7A       
         410+10  506          + R ADD     CONSTR       CTYPE=1,2 OR 3 -> NEEDS A CONSTRAINT VAR -> ERROR IF CONSTR IS BLANK
         411+ 4  413          + TR 0      D7B
         412+ 1  421          + TR        D7C
         413+10  413 D7B      + R ADD     *            
         414+ 1  486          + TR        ERROR
         415+ 0  815          + STOP      ERRNOCO      ERROR: MISSING CONSTRAINT FOR VAR (NEEDED IF CONSTRAINT TYPE IS SYN, IMS OR SUC)
         416+10  506 D7A      + R ADD     CONSTR       CTYPE=0 OR 9 -> NO CONSTRAINT VAR ALLOWED -> ERROR IF CONSTR IS NOT BLANK
         417+ 4  421          + TR 0      D7C
         418+10  418          + R ADD     *            
         419+ 1  486          + TR        ERROR
         420+ 0  825          + STOP      ERRNACO      ERROR: NO CONSTRAINT VAR ALLOWED (IF NO CONSTRAINT TYPE, OR TYPE IS REL)
         421+ 8    0 D7C      + NOOP      0000
         422+10  515          + R ADD     NVARS
         423+ 5  723          + SUB       ONE          ADDRESS IN DRUM = (NVARS-1)*8 
         424+22    3          + A LEFT    0003      
         425+13  430          + STORE A   DRADDR1
         426+13  436          + STORE A   DRADDR2
         427+10  427          + R ADD     *
         428+ 1   67          + TR        RWDRUM       WRITE VAR RECORD TO DRUM
         429+26  128          + WRITE     0128         DRUM INSTR
         430+ 0    0 DRADDR1  + STOP      /   /        DRUM ADDR 
         431+ 0  498          + STOP      VARNAME      ADDR OF START OF FIRST HALF OF VAR RECORD
         432+ 0    8          + STOP      0008         8 HALF WORDS
         433+10  433          + R ADD     *
         434+ 1   67          + TR        RWDRUM       WRITE VAR RECORD TO DRUM
         435+26  129          + WRITE     0129         DRUM INSTR
         436+ 0    0 DRADDR2  + STOP      /   /        DRUM ADDR 
         437+ 0  506          + STOP      CONSTR       ADDR OF START OF SECOND HALF OF VAR RECORD
         438+ 0    8          + STOP      0008         8 HALF WORDS
         439+10  721          + R ADD     ZERO
         440+11  498          + ADD AB    VARNAME
         441+11  499          + ADD AB    VARNAM1
         442+11  500          + ADD AB    VARNAM2
         443+21   35          + L RIGHT   0035         MQ=ABS(VARIABLE FULL NAME)
         444+18  728          + DIV       D199         DIV BY 199, ACC=REMINDER
         445+ 9  175          + ADD       HASHAD       ADD HASH TABLE ADDR
         446+13  448          + STORE A   SETHA1
         447+10  515          + R ADD     NVARS
         448+12    0 SETHA1   + STORE     /   /        SET HASH[HASH VARNAME] = VAR NUMBER
         449+30   74 NEXT     + SENSE     0074         SENSE SWITCH 6
         450+ 1  453          + TR        ENDLOG1C     TR IF NO LOG SELECTED
         451+10  451          + R ADD     *            PRINT CARD JUST PROCESSED
         452+ 1   65          + TR        PRINTCRD
         453+10  731 ENDLOG1C + R ADD     LAST
         454+ 4  203          + TR 0      READCARD     IF NOT LAST CARD, TR TO PROCESS NEXT ONE
         455+10  455          + R ADD     *            
         456+ 1   67          + TR        RWDRUM       WRITE VARIABLE NAMES HASH TABLE TO DRUM
         457+26  128          + WRITE     0128         DRUM INSTR
         458+ 0 3800          + STOP      3800         DRUM ADDR 
         459+ 0  520          + STOP      HASH         ADDR OF DATA TO SAVE
         460+ 0  200          + STOP      0200         200 HALF WORDS
         461+10  461          + R ADD     *
         462+ 1   67          + TR        RWDRUM       WRITE RELNUM0 AND NVARS TO DRUM
         463+26  130          + WRITE     0130         DRUM INSTR
         464+ 0    0          + STOP      0000         DRUM ADDR 
         465+ 0  514          + STOP      RELNUM0      ADDR OF DATA TO SAVE
         466+ 0    2          + STOP      0002         2 HALF WORDS
         467+30   74          + SENSE     0074         SENSE SWITCH 6
         468+ 1  476          + TR        ENDLOG1B     TR IF NO LOG SELECTED
         469+10  469          + R ADD     *
         470+ 1   63          + TR        PRTNLINE     
         471+ 0  101          + STOP      0101         STRINGZ AT COL 1
         472+ 0  841          + STOP      MSGDONE      "CARDS"
         473+ 0  210          + STOP      0210         INT AT COL 10
         474+ 0  730          + STOP      NCARDS       NUMBER OF PACT SOURCE CODE CARDS PROCESSED
         475+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         476+ 8    0 ENDLOG1B + NOOP      0000
         477+10  477          + R ADD     *
         478+ 1   51          + TR        CHAIN        IF SW2 IS ON, A +STOP 4095 IS EXECUTED 
         479+ 0  256          + STOP      PACTCOMP     CHAIN TO NEXT STAGE IN PACT COMPILER TAPE
         480+ 0 4095          + STOP      4095
         481+10  481 ERRUEOD  + R ADD     *            CLEAR CARD BUFFER AS NO CARD HAS BEEN READ
         482+ 1   53          + TR        CLRBUF
         483+10  483          + R ADD     *
         484+ 1  486          + TR        ERROR
         485+ 0  736          + STOP      ERRUEODS     ERROR: UNEXPECTED END OF DECK (LASt CARD SHOULD BE MARKED WITH Y(12) ON COL 72
         486+ 9  724 ERROR    + ADD       TWO
         487+13  488          + STORE A   ERRP1
         488+10    0 ERRP1    + R ADD     /   /
         489+13  495          + STORE A   ERRSTRZ      SAVE ADDR OF ERROR TXT MESSAGE
         490+10  490          + R ADD     *            PRINT USER PROGRAM SOURCE CODE CARD JUST PROCESSED
         491+ 1   65          + TR        PRINTCRD
         492+10  492          + R ADD     *
         493+ 1   63          + TR        PRTNLINE     
         494+ 0  101          + STOP      0101         STRINGZ AT COL 1
         495+ 0    0 ERRSTRZ  + STOP      /   /        ERROR MESSAGE
         496+ 0    0          + STOP      0000         END OF LINE. PRINT ALLWAYS
         497+ 0  203          + STOP      READCARD     IF USER PRESS STARTS, PROGRAM RESUMES READING NEXT SOURCE CODE CARD 
         498+     0  VARNAME    DEF       0            VARIABLE NAME
         499+     0  VARNAM1    DEF       0            
         500+     0  VARNAM2    DEF       0            
         501+     0  VTYPE      DEF       0            VAR TYPE. 1=SCALAR, 2=VECTOR, 3=MATRIX
         502+     0  LEN        DEF       0            HALF-WORD USED BY VARS
         503+     0  Q          DEF       0
         504+     0  D1         DEF       0            DIMENSIONS
         505+     0  D2         DEF       0
         506+     0  CONSTR     DEF       0            CONSTRAINT VAR NAME
         507+     0  CONSTR1    DEF       0
         508+     0  CONSTR2    DEF       0
         509+     0  CTYPE      DEF       0            CONSTRAINT VAR TYPE. 0=NONE, 1=SYN, 2=IMS, 3=SUC, 9=REL
         510+     0  RELADDR    DEF       0            RELATIVE ADDR IN VAR POOL
         511+     0  PHASE      DEF       0
         512+     0  FLAG       DEF       0
         513+     0  SIZE       DEF       0            NUM OF HALF-WORDS NEEDED TO ACCOMODATE LEN USED BY SUB-CHAINS VARIABLES
         514+     0  RELNUM0    DEF       0            REL NUM ORIGIN
         515+     0  NVARS      DEF       0            NUMBER OF VARS DEFINED
         516+     0  FNDVAR     DEF       0            TEMP ON VAR SEARCH (SHOULD BE AT EVEN ADDR)
         517+     0  FNDVAR1    DEF       0            TEMP ON VAR SEARCH
         518+     0  FNDVAR2    DEF       0            TEMP ON VAR SEARCH
         519+     0  DUMMY      DEF       0            NEEDED AS RWDRUM NEED EVEN NUMBER OF HALF-WORDS
         520+     0  HASH       RES       200          VARIABLES NAMES HASH TABLE (199 ENTRIES)
         720+   341  MAXNVARS   DEF       341          MAX VARIABLES THAT CAN DE DEFINED IN ONE PROGRAM 
         721+     0  ZERO       DEF       0
         722+     0             DEF       0
         723+     1  ONE        DEF       1
         724+     2  TWO        DEF       2
         725+     8  D8         DEF       8
         726+     9  D9         DEF       9
         727+    12  D12        DEF       12
         728+   199  D199       DEF       199
         729+   200  D200       DEF       200
         730+     0  NCARDS     DEF       0            NUMBER OF INPUT CARDS PROCESSED
         731+     0  LAST       DEF       0            FLAG FOR LAST CARD
         732+     0  LOC        DEF       0
         733+     0  N          DEF       0            TEMP
         734+     0  CHAR       DEF       0            TEMP
         735+     0  HASHFLAG   DEF       0
         736- 77297  ERRUEODS   TXT       "UNEXPECTED END OF DECK",0          ERROR: UNEXPECTED END OF DECK (LASt CARD SHOULD BE MARKED WITH Y(12) ON COL 72
         737- 84305  
         738- 36113  
         739- 36881  
         740- 60672  
         741- 63072  
         742- 37695  
         743- 52992  
         744+     0  
         745- 69960  ERRRNUM0   TXT       "REL NUM ORIGIN ALREADY SET",0
         746-  1281  
         747- 57627  
         748- 70147  
         749- 49632  
         750- 31134  
         751- 39808  
         752- 85279  
         753- 40704  
         754+     0  
         755- 69960  ERRRNNE    TXT       "REL NUM ORIGIN NOT EVEN",0
         756-  1281  
         757- 57627  
         758- 70147  
         759- 49632  
         760- 61232  
         761-   850  
         762- 40416  
         763+     0  
         764- 33421  ERRNOVAR   TXT       "BLANK VAR NAME",0
         765- 61008  
         766- 78990  
         767-  1261  
         768- 58416  
         769+     0  
         770- 71520  ERRBADID   TXT       "S2 CANNOT BE DEFINITIVE INDEX IF S1 IS INDUCTIVE INDEX",0
         771- 35210  
         772- 61232  
         773-   689  
         774-   785  
         775- 42506  
         776- 49941  
         777- 79152  
         778- 49648  
         779- 40896  
         780- 49248  
         781- 71472  
         782- 49872  
         783- 49648  
         784- 76784  
         785- 50033  
         786-  1034  
         787- 37716  
         788+     0  
         789- 78990  ERRREDEF   TXT       "VAR ALREADY DEFINED",0
         790-   648  
         791- 69949  
         792- 38640  
         793- 37698  
         794- 49649  
         795- 36864  
         796+     0  
         797- 75051  ERROVVAR   TXT       "TOO MANY VARS DEFINED",0
         798-  1213  
         799- 61680  
         800- 78990  
         801- 71440  
         802- 40053  
         803- 60736  
         804+     0  
         805- 49666  ERRINVCO   TXT       "INVALID CONSTRAINT FOR VAR",0
         806- 31125  
         807- 36879  
         808- 63487  
         809- 75181  
         810- 49664  
         811-   891  
         812- 69154  
         813- 31392  
         814+     0  
         815- 58639  ERRNOCO    TXT       "MISSING CONSTRAINT FOR VAR",0      NEEDED IF CONSTRAINT TYPE IS SYN, IMS OR SUC
         816- 72458  
         817- 43791  
         818- 63487  
         819- 75181  
         820- 49664  
         821-   891  
         822- 69154  
         823- 31392  
         824+     0  
         825- 61200  ERRNACO    TXT       "NO CONSTRAINT VAR ALLOWED",0       IF NO CONSTRAINT TYPE, OR TYPE IS REL
         826- 35882  
         827- 72990  
         828- 30986  
         829- 73762  
         830- 31392  
         831- 31128  
         832- 63905  
         833- 36864  
         834+     0  
         835- 69949  MSGSTART   TXT       "READ VAR CARDS",0
         836- 36898  
         837- 31392  
         838- 35214  
         839- 38352  
         840+     0  
         841- 35214  MSGDONE    TXT       "CARDS",0
         842- 38352  
         843+     0  
         844- 61513  ALFNUM     TXT       'NUM'
         845- 69960  ALFREL     TXT       'REL'
         846- 73023  ALFSUC     TXT       'SUC'
         847- 49615  ALFIMS     TXT       'IMS'
         848- 73226  ALFSYN     TXT       'SYN'
         850+15  864 CLRBUF   + LOAD MQ   IOCL
         851+14  869          + STORE MQ  BUFIO
         852+15  890          + LOAD MQ   IOSTORE         
         853+ 1  861          + TR        INIT2
         854+15  886 READCRD  + LOAD MQ   IORDCRD
         855+ 1  859          + TR        INIT1
         856+15  888 WRITECRD + LOAD MQ   IOWRCRD
         857+ 1  859          + TR        INIT1
         858+15  889 PRINTCRD + LOAD MQ   IOPRCRD
         859+14  869 INIT1    + STORE MQ  BUFIO
         860+15  887          + LOAD MQ   IOCOPY         
         861+14  870 INIT2    + STORE MQ  BUFROW
         862+ 9  896          + ADD       TWO          
         863+13  885          + STORE A   EXIT
         864+10  892 IOCL     + R ADD     ZERO         RESET TO INITIAL COPY LOOP ADDRESS     
         865+13  870          + STORE A   BUFROW       FOR BUFFER
         866+10  870          + R ADD     BUFROW       X .*echo Print
         867+ 5  897          + SUB       D48          X 
         868+12  894          + STORE     ENDLP        X LOOP END VALUE
         869- 0    0   BUFIO  - STOP      /   /        READ OR WRITE
         870-31    0   BUFROW - COPY      /   /        COPY WORD TO/FROM PRINTER/CARDREADER
         871+ 1  875          + TR        BUFOK2       NORMAL PROCESSING 
         872+ 1  882          + TR        EODECK       FOR COPY READING END OF REG (=END OF DECK BEING READ)
         873+ 6  896          + R SUB     TWO          END OF FILE -> NO CARD TO READ -> STOP with Acc=-2
         874+ 0  869          + STOP      BUFIO        ON PRESSING START RETRY CARD READ
         875+10  870   BUFOK2 + R ADD     BUFROW       X
         876+ 5  896          + SUB       TWO          INCR BUF ADDR
         877+13  870          + STORE A   BUFROW       X
         878+ 5  894          + SUB       ENDLP        CHECK FOR END
         879+ 4  884          + TR 0      ENDIO
         880+10  892          + R ADD     ZERO         CLEAR ACC IN CASE WE ARE CLEANING THE BUFFER
         881+ 1  870          + TR        BUFROW
         882+10  895 EODECK   + R ADD     ONE          SET OV FLAG TO SIGNAL END OF DECK CONDITION
         883+22   36          + A LEFT    36
         884+26 2052 ENDIO    + WRITE     2052         END OF I/O: INSURE THAT MQ NOT IN USE            
         885+ 1    0 EXIT     + TR        /   /
         886+24 2048 IORDCRD  + READ      2048         PREPARE TO READ FROM CARD READER
         887-31    0 IOCOPY   - COPY      /   /   
         888+26 1024 IOWRCRD  + WRITE     1024         PREPARE TO PUNCH CARD 
         889+26  512 IOPRCRD  + WRITE     0512         PREPARE WRITE PRTBUF ON PRINTER
         890-12    0 IOSTORE  - STORE     /   /        CLEAR BUFFER
         891+     0             ORG       EVEN           
         892+     0  ZERO       DEF       0            
         893+     0             DEF       0            
         894+     0  ENDLP      DEF       0            LOOP END VALUE
         895+     1  ONE        DEF       1
         896+     2  TWO        DEF       2
         897+    48  D48        DEF       48
         898+ 9 1169 PRTPARM2 + ADD       TWO          GET 2 PARAMS: LEN AND COL (EITHER VALUE OR VAR ADDR)
         899+13  918          + STORE A   PRTPRMEX
         900+10  908          + R ADD     PRTP1
         901+ 9 1169          + ADD       TWO          PRINT PACKED TEXT FROM FULL-WORD VALUE IN MQ REGISTER 
         902+13  908          + STORE A   PRTP1        STORE ADDR OF FIRST PARAM (LEN)
         903+ 9 1168          + ADD       ONE
         904+13  910          + STORE A   PRTP2        STORE ADDR OF SECOND PARAM (COL)
         905+ 9 1168          + ADD       ONE
         906+13  985          + STORE A   EXIT
         907-14 1158          - STORE MQ  NUM          SAVE VALUE TO PRINT PARAM MQ (NUM IS ALIASED TO TXT)
         908+10    0   PRTP1  + R ADD     /   /        GET LEN: NUMBER OF CHARS TO PRINT (1..6)
         909+12 1162          + STORE     LEN
         910+10    0   PRTP2  + R ADD     /   /        GET COLUMN PARAM 1..72
         911+ 3  914          + TR +      PRTP4
         912+13  913          + STORE A   PRTP3        COL<0 -> INTERPRET COL AS LOC(COL) = ADDR OF COL VAR
         913+10    0   PRTP3  + R ADD     /   /        READ VAR COL PASED AS PARAM
         914+ 4  985   PRTP4  + TR 0      EXIT         COL=0 -> EXIT
         915+ 3  917          + TR +      PRTP5
         916+ 1  985          + TR        EXIT         COL<0 -> EXIT
         917+12  968   PRTP5  + STORE     COL
         918+ 1    0 PRTPRMEX + TR        /   /        RETURN TO CALLER
         919+13  908 PRTSTR   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
         920+10  920          + R ADD     *            FOR PRINT STRINGZ FROM MEM
         921+ 1  898          + TR        PRTPARM2
         922+12  932          + STORE     COLSZ
         923+10 1162          + R ADD     LEN          LEN IS IN FACT THE LOCATION WHERE THE STRING STARTS
         924+13  927          + STORE A   STRZAD
         925+10  985          + R ADD     EXIT
         926+13  940          + STORE A   STRZEX
         927+10    0 STRZAD   + R ADD     /   /        GET HALF-WORD WITH NEXT 3 CHARS TO PRINT
         928+ 4  940          + TR 0      STRZEX       IF +0 -> END OF STRING (-0 DOES NOT TERMINATES THE STRING)
         929+21   35          + L RIGHT   0035         MQ=3-CHARS TO PRINT
         930+10  930          + R ADD     *            
         931+ 1  942          + TR        PRTALF       PRINT 3 CHARS
         932+ 0    0 COLSZ    + STOP      0000         COL 
         933+10  927 STRZ1    + R ADD     STRZAD       INCR STRING ADDRESS
         934+ 9 1168          + ADD       ONE
         935+13  927          + STORE A   STRZAD
         936+10  932          + R ADD     COLSZ        INCR COLUMN
         937+ 9 1170          + ADD       D3
         938+13  932          + STORE A   COLSZ
         939+ 1  927          + TR        STRZAD
         940+ 3    0 STRZEX   + TR +      /   /        IF ZERO -> END OF STRING
         941+ 1  933          + TR        STRZ1
         942+ 9 1169 PRTALF   + ADD       TWO          PRINT 3-PACKED CHARS IN MQ REGISTER 
         943+14 1164          + STORE MQ  TXT          SAVE TEXT TO PRINT (IN LEFT HALF WORD)
         944+13  947          + STORE A   PRTAP2       STORE ADDR OF PARAM (COL)
         945+ 9 1168          + ADD       ONE
         946+13  985          + STORE A   EXIT
         947+10    0   PRTAP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
         948+ 3  951          + TR +      PRTAP4
         949+13  950          + STORE A   PRTAP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
         950+10    0   PRTAP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
         951+12  968   PRTAP4 + STORE     COL
         952+10 1170          + R ADD     D3
         953+12 1162          + STORE     LEN
         954+10 1152 PRT1     + R ADD     ZERO         UNPACK LEFTMOST CHAR 
         955+11 1164          + ADD AB    TXT          GET TEXT DISCARD SIGN
         956+21   35          + L RIGHT   0035         MQ=Acc
         957+10 1152          + R ADD     ZERO
         958+18 1177          + DIV       D48X48
         959+12 1164          + STORE     TXT          remainder=char to print, mq=c2 * 48 + c3 in right half-word
         960+10 1152          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
         961+20   18          + L LEFT    0018         put c2 and c3 in left half-word of MQ to be saved in CHAR half word
         962+14 1163          + STORE MQ  CHAR         CHAR TO PRINT
         963+10 1163          + R ADD     CHAR 
         964+ 4  969          + TR 0      NXTCHR       IF BLANK PROCEED TO NEXT COL
         965+21   35          + L RIGHT   0035         MQ=CHAR TO PRINT
         966+10  966          + R ADD     *            PRINT CHAR
         967+ 1 1062          + TR        PRTCHR
         968+ 0    0 COL      + STOP      0000         COL: COLUMN NUMBER TO PRINT (1..72)
         969+10 1162 NXTCHR   + R ADD     LEN          DECR LEN COUNT
         970+ 5 1168          + SUB       ONE
         971+12 1162          + STORE     LEN
         972+ 4  985          + TR 0      EXIT         IF NO MORE CHARS TO PRINT EXIT
         973+10  968          + R ADD     COL          INCR COL POSITION
         974+ 9 1168          + ADD       ONE
         975+12  968          + STORE     COL
         976+ 5 1176          + SUB       D72          IF COL > 72 RETURN TO CALLER
         977+ 4  979          + TR 0      GNXTCHR      ELSE PROCEED WITH NEXT CHAR
         978+ 3  985          + TR +      EXIT
         979+10 1152 GNXTCHR  + R ADD     ZERO         GET NEXT CHAR 
         980+15 1164          + LOAD MQ   TXT
         981+16 1175          + MPY       D48
         982+22   17          + A LEFT    0017         GET RESULT IN LEFT HALF-WORD OF ACC
         983+12 1164          + STORE     TXT
         984+ 1  954          + TR        PRT1         PROCEED TO PRINT CHAR
         985+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
         986+13  908 PRTOCT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
         987+10  987          + R ADD     *            FOR PRINT OCTIONARY VALUE
         988+ 1  898          + TR        PRTPARM2
         989+10 1162          + R ADD     LEN          LEN = OCTAL DIGITS TO PRINT
         990+ 9  968          + ADD       COL
         991+ 5 1168          + SUB       ONE
         992+12 1004          + STORE     COLN         COL POINTS TO LEAST SIGNIFICANT DIGIT
         993+10 1158 PRTIOCG  + R ADD     NUM          GENERATE OCTINARY DIGIT
         994+15 1152          + LOAD MQ   ZERO         CLEAR MQ
         995+21   21          + L RIGHT   0021         3 LSB BITS OF LEFT HALF-WORD OF ACC TO MQ
         996+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 3 BIT)
         997+12 1158          + STORE     NUM          SAVE BACK NUM WITH RIGHTMOST OCTIONARY DIGIY EXTRACTED (NUM'=NUM/8)
         998+10 1152          + R ADD     ZERO
         999+20   21          + L LEFT    0021         LEFT HALF-WORD OF ACC IS NOW RIGHTMOST OCTINARY DIGIT EXTRACTED FROM NUM 
        1000+ 4 1018          + TR 0      PRTIOZ       TR IF THIS DIGIT IS ZERO TO PRINT A '0' (BASE48 CODE = 10) INSTEAD OF A BLANK (BASE48 CODE = 0)
        1001+21   35          + L RIGHT   0035         PUT DIGIT 1..9 TO PRINT IN MQ
        1002+10 1002 PRTOCTD  + R ADD     *            PRINT OCTINARY DIGIT
        1003+ 1 1062          + TR        PRTCHR
        1004+ 0    0 COLN     + STOP      0000
        1005+10 1004          + R ADD     COLN        DECR COL NUMBER TO PRINT NEXT DIGIT
        1006+ 5 1168          + SUB       ONE
        1007+12 1004          + STORE     COLN
        1008+10 1162          + R ADD     LEN          DECR COL NUMBER TO PRINT NEXT DIGIT
        1009+ 5 1168          + SUB       ONE
        1010+ 4  985          + TR 0      EXIT         PRINTED LEN OCTINARY DIGITS -> EXIT
        1011+12 1162          + STORE     LEN
        1012+10 1158          + R ADD     NUM          IF NUM < 0, ADD SIGN BIT TO LEFTMOST DIGIT
        1013+ 3  993          + TR +      PRTIOCG
        1014+10 1178          + R ADD     OCT04K       
        1015+ 5 1158          + SUB       NUM
        1016+12 1158          + STORE     NUM
        1017+ 1  993          + TR        PRTIOCG
        1018+15 1171   PRTIOZ + LOAD MQ   D10          ACC=BASE48 CODE FOR '0'
        1019+ 1 1002          + TR        PRTOCTD      TR TO PRINT IT
        1020+13  908 PRTINT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        1021+10 1021          + R ADD     *            FOR PRINT OCTIONARY VALUE
        1022+ 1  898          + TR        PRTPARM2
        1023+10  968          + R ADD     COL          PRINT DECIMAL NUMBER. VALUE OF LEN = DIGITS TO PRINT, NOT INCLUDING SIGN
        1024+ 9 1162          + ADD       LEN
        1025+ 5 1168          + SUB       ONE          
        1026+12 1047          + STORE     COLNI        COL POINTS TO END OF NUMBER
        1027+10 1152          + R ADD     ZERO
        1028+12 1161          + STORE     SGN          SIGN IS POSITIVE
        1029+10 1158          + R ADD     NUM
        1030+ 3 1035          + TR +      PRTINTG
        1031+ 6 1158          + R SUB     NUM          NUM IS NEGATIVE. CONVERT TO POSITIVE
        1032+12 1158          + STORE     NUM          AND SET SGN=1
        1033+10 1168          + R ADD     ONE
        1034+12 1161          + STORE     SGN          
        1035+10 1158 PRTINTG  + R ADD     NUM          GENERATE DECIMAL DIGIT
        1036+21   35          + L RIGHT   0035         MQ=Acc
        1037+10 1152          + R ADD     ZERO
        1038+18 1171          + DIV       D10
        1039+ 4 1060          + TR 0      PRTINZ
        1040+12 1163 PRTINTG2 + STORE     CHAR         acc=remainder=digit to print, mq=num/10
        1041+10 1152          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        1042+20   18          + L LEFT    0018         digit in left half-word of MQ to be saved in CHAR half word
        1043+14 1158          + STORE MQ  NUM 
        1044+15 1163          + LOAD MQ   CHAR 
        1045+10 1045 PRTINTD  + R ADD     *            PRINT DECIMAL DIGIT
        1046+ 1 1062          + TR        PRTCHR
        1047+ 0    0 COLNI    + STOP      0000
        1048+10 1047          + R ADD     COLNI        DECR COL NUMBER TO PRINT NEXT DIGIT
        1049+ 5 1168          + SUB       ONE
        1050+12 1047          + STORE     COLNI
        1051+10 1158          + R ADD     NUM          DO NOT CARE ABOUT LEN, JUST CHECK IF NUM=0 
        1052+ 4 1054          + TR 0      PRTINS       (SO NO MORE DIGITS REMAINS TO BE PRINTED)
        1053+ 1 1035          + TR        PRTINTG      NUM NOT FINISHED, PROCEED WITH NEXT DIGIT
        1054+10 1161 PRTINS   + R ADD     SGN
        1055+ 4  985          + TR 0      EXIT         NO SIGN -> NUM FINISHED
        1056+10 1152          + R ADD     ZERO
        1057+12 1161          + STORE     SGN          CLEAR SGN FLAG
        1058+15 1172          + LOAD MQ   D11          BASE48 CODE FOR '-' (MINUS) CHAR
        1059+ 1 1045          + TR        PRTINTD      GO TO PRINT IT
        1060+10 1171   PRTINZ + R ADD     D10          ACC=BASE48 CODE FOR '0'
        1061+ 1 1040          + TR        PRTINTG2     TR TO PRINT IT
        1062+ 9 1169 PRTCHR   + ADD       TWO          PRINT CHAR IN MQ REGISTER 
        1063+14 1163          + STORE MQ  CHAR         SAVE CHAR TO PRINT (IN LEFT HALF WORD)
        1064+13 1068          + STORE A   PRTCP2       STORE ADDR OF PARAM (COL)
        1065+ 9 1168          + ADD       ONE
        1066+13 1146          + STORE A   PRTCEX
        1067+ 2 1068          + TR OV     PRTCP2       CLEAR OV JUST IN CASE
        1068+10    0   PRTCP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        1069+ 3 1072          + TR +      PRTCP4
        1070+13 1071          + STORE A   PRTCP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        1071+10    0   PRTCP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        1072+ 5 1168   PRTCP4 + SUB       ONE
        1073+12 1166          + STORE     N            N=COL-1 -> IN RANGE 0..71
        1074+ 3 1076          + TR +      PRTSA        IF N >= 0 PROCEED WITH BASE BUFFER ADDR CALCULATION
        1075+ 1 1146          + TR        PRTCEX       IF N<0 EXIT
        1076+10 1152    PRTSA + R ADD     ZERO         CARD BUFFER USES LOCATION 0..47
        1077+13 1165          + STORE A   PRTROWAD     DETERMINE ADDRESS OF LOWER ROW TO PRINT
        1078+10 1166          + R ADD     N
        1079+ 5 1174          + SUB       D36
        1080+ 3 1082          + TR +      PRTC0
        1081+ 1 1088          + TR        PRTC1
        1082+12 1166    PRTC0 + STORE     N            COL NOW 0..35 
        1083+ 5 1174          + SUB       D36
        1084+ 3 1146          + TR +      PRTCEX       IF COL >= 36 (IE COL PASSED AS PARAM > 72) THEN EXIT
        1085+10 1165          + R ADD     PRTROWAD
        1086+ 9 1169          + ADD       TWO
        1087+13 1165          + STORE A   PRTROWAD     SET BASE BUFFER ADDR 
        1088+10 1168    PRTC1 + R ADD     ONE          DETERMINE MASKCOL WITH MASK TO SET IN CARD BUFFER
        1089+21   53          + L RIGHT   53           SET RIGHTMOST BIT OF MQ TO 1 (SHIFT 35+18=53)
        1090+10 1173          + R ADD     D35
        1091+ 5 1166          + SUB       N
        1092+13 1094          + STORE A   PRTC2
        1093+10 1152          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW
        1094+20    0    PRTC2 + L LEFT    /   /        SHIFT MQ LEFT N PLACES
        1095+ 4 1098          + TR 0      PRTC3        IF ACC STILL ZERO -> MASKCOL VALID
        1096+ 6 1168          + R SUB     ONE          ACC NOT ZERO -> SHOULD GENERATE -0 TO SET SIGN BIT ON
        1097+21   72          + L RIGHT   0072         NOW MQ = -0 -> LEFTMOST BIT OF MQ SET
        1098-14 1154    PRTC3 - STORE MQ  MASKCOL
        1099+10 1152          + R ADD     ZERO         READ THE BITMAP OF CHAR 
        1100+11 1163          + ADD AB    CHAR         DISCARD SIGN OF CHAR, IF ANY
        1101+12 1163          + STORE     CHAR
        1102+ 5 1175          + SUB       D48
        1103+ 3 1146          + TR +      PRTCEX       IF CHAR >= 48 EXIT
        1104+10 1160          + R ADD     BITMAPAD     IF ADDR OF BASE48 BITMAP NOT COMPUTED
        1105+ 4 1147          + TR 0      GETBMP1      TR TO LOAD IT
        1106+ 9 1163  GETBMP2 + ADD       CHAR         READ THE BITMAP OF CHAR 
        1107+13 1108          + STORE A   PRTC4        INDICATES THE BITS TO SET IN SELECTED 
        1108+10    0    PRTC4 + R ADD     /   /        COLUMN OF CARD BUFFER 
        1109+12 1167          + STORE     BITS
        1110+ 6 1168          + R SUB     ONE
        1111+12 1166          + STORE     N            SET TO -1
        1112+10 1166    LOOP1 + R ADD     N            CURRENT ROW (STARTS AT ZERO) = OFFSET ON PRTROWAD     
        1113+ 9 1168          + ADD       ONE
        1114+12 1166          + STORE     N
        1115+10 1167          + R ADD     BITS         EXTRACT RIGHTMOST BIT OF LEFT HALF OF ACC TO MQ
        1116+ 4 1146          + TR 0      PRTCEX       NO MORE BITS -> EXIT
        1117+21   19          + L RIGHT   0019         LSB BIT OF LEFT HALF-WORD OF ACC TO MQ
        1118+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 1 BIT)
        1119+12 1167          + STORE     BITS         SAVE BACK BITS. LSB HAS BEEN EXTACTED, CONTENTS SHIFTED RIGHT ONE PLACE
        1120+10 1152          + R ADD     ZERO
        1121+20    1          + L LEFT    0001         PUT EXTACTED BIT BACK INTO ACC
        1122+ 4 1112          + TR 0      LOOP1        NO BIT 
        1123+10 1166          + R ADD     N            READ THE ROW N AT CARD BUFFER 
        1124+22    2          + A LEFT    0002         MULT N BY 4 AS THERE ARE 4 HALF WORDS PER ROW
        1125+ 9 1165          + ADD       PRTROWAD     
        1126+13 1128          + STORE A   PRTROWR
        1127+13 1144          + STORE A   PRTROWW
        1128-10    0  PRTROWR - R ADD     /   /        
        1129-12 1156          - STORE     ROW          CURRENT CONTENTS OF ROW
        1130-10 1154          - R ADD     MASKCOL      "OR" MASKCOL IN SELECTED ROW
        1131+ 3 1139          + TR +      PRTW2
        1132-10 1156          - R ADD     ROW 
        1133+ 4 1137          + TR 0      PRTW1         
        1134+10 1152          + R ADD     ZERO         MASKCOL IS MINUS ZERO AND ROW IS NOT-EMPTY (EITHER POSITIVE OR NEGATIVE) -> SET ROW AS NEGATIVE
        1135- 7 1156          - SUB AB    ROW 
        1136+ 1 1144          + TR        PRTROWW
        1137-10 1154    PRTW1 - R ADD     MASKCOL      MASKCOL IS MINUS ZERO AND ROW IS EMPTY -> SET ROW = MASKCOL = MINUS ZERO
        1138+ 1 1144          + TR        PRTROWW
        1139-10 1156    PRTW2 - R ADD     ROW          
        1140+ 3 1143          + TR +      PRTW3              
        1141- 5 1154          - SUB       MASKCOL      MASKCOL IS POSITIVE AND ROW IS NEGATIVE -> SUB MASKCOL FROM ROW
        1142+ 1 1144          + TR        PRTROWW
        1143- 9 1154    PRTW3 - ADD       MASKCOL      MASKCOL IS POSITIVE AND ROW IS POSITIVE OR EMPTY -> ADD MASKCOL TO ROW         
        1144-12    0  PRTROWW - STORE     /   /        ROW UPDTATE
        1145+ 1 1112          + TR        LOOP1        PROCEED TO NEXT ROW
        1146+ 1    0 PRTCEX   + TR        /   /
        1147+10 1147 GETBMP1  + R ADD     *
        1148+ 1   85          + TR        BMPAD        GET BASE48 CHARS BITMAP ADDRESS
        1149+12 1160          + STORE     BITMAPAD     
        1150+ 1 1106          + TR        GETBMP2      RETURN
        1151+     0             ORG       EVEN
        1152+     0  ZERO       DEF       0            
        1153+     0             DEF       0            
        1154+     0  MASKCOL    DEF       0
        1155+     0             DEF       0
        1156+     0  ROW        DEF       0
        1157+     0             DEF       0
        1158+     0  NUM        DEF       0
        1159+     0             DEF       0
        1160+     0  BITMAPAD   DEF       0
        1161+     0  SGN        DEF       0
        1162+     0  LEN        DEF       0
        1163+     0  CHAR       DEF       0
        1164+     0  TXT        DEF       0
        1165+     0  PRTROWAD   DEF       0
        1166+     0  N          DEF       0
        1167+     0  BITS       DEF       0
        1168+     1  ONE        DEF       1
        1169+     2  TWO        DEF       2
        1170+     3  D3         DEF       3
        1171+    10  D10        DEF       10
        1172+    11  D11        DEF       11
        1173+    35  D35        DEF       35
        1174+    36  D36        DEF       36
        1175+    48  D48        DEF       48
        1176+    72  D72        DEF       72
        1177+  2304  D48X48     DEF       2304
        1178+ 16384  OCT04K     DEF       *040000      BIT SIGN ON 5TH OCTINARY DIGIT
        1180+ 9 1255 PRTNLINE + ADD       TWO          PRINT A NEW LINE OF DATA
        1181+12 1258          + STORE     PARAM        SAVE PARAM LIST ADDR
        1182+10 1182          + R ADD     *            CLEAR CARD BUFFER
        1183+ 1   53          + TR        CLRBUF 
        1184+10 1258 GPARAM   + R ADD     PARAM        GET PARAM PAIR FMT/DATA
        1185+13 1190          + STORE A   P1
        1186+ 9 1254          + ADD       ONE
        1187+13 1194          + STORE A   P2
        1188+ 9 1254          + ADD       ONE
        1189+12 1258          + STORE     PARAM
        1190+10    0 P1       + R ADD     /   /
        1191+12 1260          + STORE     FMT
        1192+ 3 1194          + TR +      P2           IF FMT < 0 THEM SKIP THIS PAIR FMT/DATA
        1193+ 1 1184          + TR        GPARAM
        1194+10    0 P2       + R ADD     /   /
        1195+12 1220          + STORE     DATALOC      GET DATA ADDRESS PASED AS PARAM
        1196+13 1197          + STORE A   P2A
        1197+10    0 P2A      + R ADD     /   /
        1198+12 1259          + STORE     DATA         GET EFFECTIVE DATA
        1199+10 1253          + R ADD     ZERO
        1200+15 1260          + LOAD MQ   FMT
        1201+18 1257          + DIV       D100         ACC=REMAINDER=COL NUMBER, MQ=QUOTIEN=TYPE OF DATA
        1202+12 1261          + STORE     COL
        1203+10 1253          + R ADD     ZERO
        1204+20   18          + L LEFT    0018
        1205+14 1260          + STORE MQ  FMT
        1206+15 1259          + LOAD MQ   DATA
        1207+10 1211          + R ADD     TYPETRAD
        1208+ 9 1260          + ADD       FMT
        1209+13 1210          + STORE A   TYPETR
        1210+ 1    0 TYPETR   + TR        /   /        TR SELECTED ROUTINE
        1211+ 0 1212 TYPETRAD + STOP      TYPETRT      TYPE TRANSFER TABLE ADDRESS
        1212+ 1 1241 TYPETRT  + TR        EOL          FMT=0..6 (IE <100) -> END OF PARAM LIST -> END OF LINE 
        1213+ 1 1218          + TR        TYSTR        FMT=1 -> PRINT A STRINGZ
        1214+ 1 1223          + TR        TYINT        FMT=2 -> PRINT AN INT
        1215+ 1 1228          + TR        TYOCT        FMT=3 -> PRINT AN OCT
        1216+ 1 1233          + TR        TYCHR        FMT=4 -> PRINT A CHAR
        1217+ 1 1237          + TR        TYALF        FMT=5 -> PRINT A 3-CHR PACKED ALFA STRING
        1218+10 1218 TYSTR    + R ADD     *            PRINT STRINGZ
        1219+ 1   75          + TR        PRTSTR
        1220+ 0    0 DATALOC  + STOP      /   /
        1221- 0 1261          - STOP      COL          COLUMN WHERE TXT STARTS
        1222+ 1 1184          + TR        GPARAM
        1223+10 1223 TYINT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1224+ 1   79          + TR        PRTINT
        1225+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        1226- 0 1261          - STOP      COL          COLUMN WHERE TXT STARTS
        1227+ 1 1184          + TR        GPARAM
        1228+10 1228 TYOCT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1229+ 1   81          + TR        PRTOCT
        1230+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        1231- 0 1261          - STOP      COL          COLUMN WHERE TXT STARTS
        1232+ 1 1184          + TR        GPARAM
        1233+10 1233 TYCHR    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1234+ 1   77          + TR        PRTCHR
        1235- 0 1261          - STOP      COL          COLUMN WHERE TXT STARTS
        1236+ 1 1184          + TR        GPARAM
        1237+10 1237 TYALF    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1238+ 1   73          + TR        PRTALF
        1239- 0 1261          - STOP      COL          COLUMN WHERE TXT STARTS
        1240+ 1 1184          + TR        GPARAM
        1241+10 1261 EOL      + R ADD     COL          SEND CARD BUFFER TO PRINTER AND RETURN TO CALLER
        1242+ 4 1247          + TR 0      DOPRINT      =0 -> PRINT ALLWAYS (NO SENSE SW CHECK)
        1243+ 9 1256          + ADD       D68          =1..6 -> SENSE 69..74 = OPERATOR'S PANEL SENSE SWITCH 1..6
        1244+13 1245          + STORE A   CHKSW
        1245+30    0 CHKSW    + SENSE     /   /         
        1246+ 1 1249          + TR        RETURN       SW NOT AT ON POSITION
        1247+10 1247 DOPRINT  + R ADD     *            PRINT CARD BUFFER
        1248+ 1   65          + TR        PRINTCRD
        1249+10 1258 RETURN   + R ADD     PARAM        PARAM-1 IS THE RETURN ADDR      
        1250+ 5 1254          + SUB       ONE
        1251+13 1252          + STORE A   EXIT
        1252+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        1253+ 0    0 ZERO     + STOP      0000
        1254+ 0    1 ONE      + STOP      0001
        1255+ 0    2 TWO      + STOP      0002
        1256+ 0   68 D68      + STOP      0068
        1257+ 0  100 D100     + STOP      100
        1258+ 0    0 PARAM    + STOP      0000
        1259+ 0    0 DATA     + STOP      0000
        1260+ 0    0 FMT      + STOP      0000
        1261+ 0    0 COL      + STOP      0000
        1262+ 9 1276 BMPAD    + ADD       TWO
        1263+13 1265          + STORE A   EXIT
        1264+10 1266          + R ADD     BITMAPAD
        1265+ 1    0 EXIT     + TR        /   /
        1266+ 0 1268 BITMAPAD + STOP      BITMAP
        1267+     0             ORG       EVEN
        1268+     0  BITMAP     DEF       0              <blank>     0     <none>
        1269+   256             DEF       256               1        1       1        256          =  256   
        1270+   128             DEF       128               2        2       2        128          =  128   
        1271+    64             DEF       64                3        3       3         64          =   64   
        1272+    32             DEF       32                4        4       4         32          =   32   
        1273+    16             DEF       16                5        5       5         16          =   16   
        1274+     8             DEF       8                 6        6       6          8          =    8   
        1275+     4             DEF       4                 7        7       7          4          =    4   
        1276+     2  TWO        DEF       2                 8        8       8          2          =    2   
        1277+     1             DEF       1                 9        9       9          1          =    1   
        1278+   512             DEF       512               0       10       0        512          =  512   
        1279+  1024             DEF       1024              -       11       X       1024          = 1024   
        1280+  2048             DEF       2048              +       12       Y       2048          = 2048   
        1281+  2304             DEF       2304              A       13      Y-1        256+2048    = 2304   
        1282+  2176             DEF       2176              B       14      Y-2        128+2048    = 2176   
        1283+  2112             DEF       2112              C       15      Y-3         64+2048    = 2112   
        1284+  2080             DEF       2080              D       16      Y-4         32+2048    = 2080   
        1285+  2064             DEF       2064              E       17      Y-5         16+2048    = 2064   
        1286+  2056             DEF       2056              F       18      Y-6          8+2048    = 2056   
        1287+  2052             DEF       2052              G       19      Y-7          4+2048    = 2052   
        1288+  2050             DEF       2050              H       20      Y-8          2+2048    = 2050   
        1289+  2049             DEF       2049              I       21      Y-9          1+2048    = 2049   
        1290+  1280             DEF       1280              J       22      X-1        256+1024    = 1280   
        1291+  1152             DEF       1152              K       23      X-2        128+1024    = 1152   
        1292+  1088             DEF       1088              L       24      X-3         64+1024    = 1088   
        1293+  1056             DEF       1056              M       25      X-4         32+1024    = 1056   
        1294+  1040             DEF       1040              N       26      X-5         16+1024    = 1040   
        1295+  1032             DEF       1032              O       27      X-6          8+1024    = 1032   
        1296+  1028             DEF       1028              P       28      X-7          4+1024    = 1028   
        1297+  1026             DEF       1026              Q       29      X-8          2+1024    = 1026   
        1298+  1025             DEF       1025              R       30      X-9          1+1024    = 1025   
        1299+   640             DEF       640               S       31      0-2        128+512     = 640    
        1300+   576             DEF       576               T       32      0-3         64+512     = 576    
        1301+   544             DEF       544               U       33      0-4         32+512     = 544    
        1302+   528             DEF       528               V       34      0-5         16+512     = 528    
        1303+   520             DEF       520               W       35      0-6          8+512     = 520    
        1304+   516             DEF       516               X       36      0-7          4+512     = 516    
        1305+   514             DEF       514               Y       37      0-8          2+512     = 514    
        1306+   513             DEF       513               Z       38      0-9          1+512     = 513    
        1307+   578             DEF       578               ,       39      8-3-0        2+64+512  = 578    
        1308+   546             DEF       546               %       40      8-4-0        2+32+512  = 546    
        1309+  1090             DEF       1090              $       41      8-3-X        2+64+1024 = 1090   
        1310+  1058             DEF       1058              *       42      8-4-X        2+32+1024 = 1058   
        1311+  2114             DEF       2114              .       43      8-3-Y        2+64+2048 = 2114   
        1312+  2082             DEF       2082              #       44      8-4-Y        2+32+2048 = 2082   
        1313+   768             DEF       768               /       45      0-1          512+256   = 768    
        1314+    66             DEF       66                +       46      8-3          2+64      = 66     
        1315+    34             DEF       34                -       47      8-4          2+32      = 34    This is the non-minus-sign separator
        1316+15 1316 RDINT    + LOAD MQ   *
        1317+ 1 1336          + TR        RDCHRS
        1318+10 1473          + R ADD     SGN          APPLY SGN FLAG TO NUM
        1319+ 3 1324          + TR +      RDINT3
        1320- 6 1464          - R SUB     NUM
        1321-21   35          - L RIGHT   0035         MQ=ACC=-NUM
        1322+ 6 1465          + R SUB     NUM2         ACC=-NUM2
        1323+ 1 1461          + TR        EXIT
        1324+10 1465 RDINT3   + R ADD     NUM2         GET NUMBER IN LEFT HALF WORD OF ACC (17 BITS)
        1325-15 1464          - LOAD MQ   NUM          AND THE FULL 35 BIT VALUE IN MQ
        1326+ 1 1461          + TR        EXIT
        1327+15 1327 RDBMP    + LOAD MQ   *
        1328+ 1 1336          + TR        RDCHRS
        1329-15 1468          - LOAD MQ   BITMAP       SIGN IS BIT36 OF BITMAP
        1330+10 1474          + R ADD     ISNUM
        1331+ 4 1334          + TR 0      RDBMP3       TR IF CHARS READ ARE NOT AN UNSIGNED NUMBER (HAS NON 0..9 CHARS, OR DOUBLE PUNCH)
        1332+10 1465          + R ADD     NUM2         RETURN POSITIVE NUMBER 0..999 IN LEFT HALF-WORD OF ACC
        1333+ 1 1461          + TR        EXIT
        1334+ 6 1477 RDBMP3   + R SUB     ONE          ALFA CHARS READ, RETURN ACC=-1
        1335+ 1 1461          + TR        EXIT
        1336+ 9 1478 RDCHRS   + ADD       TWO          READ LEN CHARS FROM CARD BUFFER, STARTING AT COL
        1337+13 1353          + STORE A   RDIP1        STORE ADDR OF FIRST PARAM (LEN)
        1338+ 9 1477          + ADD       ONE
        1339+13 1355          + STORE A   RDIP2        STORE ADDR OF SECOND PARAM (COL)
        1340+ 9 1477          + ADD       ONE
        1341+13 1461          + STORE A   EXIT         RETURN TO MAIN PROG CALLER
        1342+14 1472          + STORE MQ  N            RDCHRS SETS THE FOLLOWING VARIABLES
        1343+10 1472          + R ADD     N               ISNUM=0 IF ANY CHAR IS NOT 0..9 OR HAS Y(12) X(11) PUNCH
        1344+ 9 1478          + ADD       TWO             NUM READ NUMBER UNTIL LEN OR '.'
        1345+13 1443          + STORE A   RET             BITMAP: 12 BITS FOR EACH ONE OF 3-LAST CHARS
        1346+ 2 1347          + TR OV     CLOV         CLEAR OV JUST IN CASE
        1347+10 1462 CLOV     + R ADD     ZERO         READ A SIGNED INT OF LEN DIGITS
        1348-12 1464          - STORE     NUM          NUM=0
        1349+12 1473          + STORE     SGN          SGN FLAG=0 (WILL BE +1 OR -1)
        1350-12 1468          - STORE     BITMAP       BITMAP (UP TO 3 CHARS, 12 BITS EACH)
        1351+10 1477          + R ADD     ONE
        1352+12 1474          + STORE     ISNUM        ISNUM=1 -> ALL READ CHARS ARE UNSIGNED 0..9 DIGITS (BLANK IS INTERPRETED AS ZERO)
        1353+10    0   RDIP1  + R ADD     /   /        GET LEN: NUMBER OF DIGITS TO READ (1..10)
        1354+12 1471          + STORE     LEN
        1355+10    0   RDIP2  + R ADD     /   /        GET COLUMN PARAM 1..72
        1356+ 3 1359          + TR +      RDIP4
        1357+13 1358          + STORE A   RDIP3        COL<0 -> INTERPRET COL AS LOC(COL) = ADDR OF COL VAR
        1358+10    0   RDIP3  + R ADD     /   /        READ VAR COL PASED AS PARAM
        1359+ 4 1461   RDIP4  + TR 0      EXIT         COL=0 -> EXIT
        1360+ 3 1362          + TR +      RDIP5
        1361+ 1 1461          + TR        EXIT         COL<0 -> EXIT
        1362+ 5 1477   RDIP5  + SUB       ONE          
        1363+12 1470          + STORE     COL          COL IS 0..71
        1364+10 1470 NXTDIG   + R ADD     COL
        1365+12 1472          + STORE     N
        1366+ 5 1482          + SUB       D36
        1367+ 3 1371          + TR +      GDIG0        IF COL >=36 CARD BUF ADDR = 0002
        1368+10 1462          + R ADD     ZERO
        1369+13 1384          + STORE A   ROWRD          
        1370+ 1 1376          + TR        GDIG1
        1371+12 1472    GDIG0 + STORE     N            NOW N=0..35 
        1372+ 5 1482          + SUB       D36
        1373+ 3 1443          + TR +      RET          IF COL >= 72 THEN RETURN TO CALLER
        1374+10 1478          + R ADD     TWO
        1375+13 1384          + STORE A   ROWRD        SET BUF BASE ADDR
        1376+10 1481    GDIG1 + R ADD     D35
        1377+ 5 1472          + SUB       N
        1378+13 1388          + STORE A   ROWSHF       SET SHIFTING
        1379+10 1480          + R ADD     D9           SCAN CARD STARTING AT ROWAD
        1380+12 1472          + STORE     N            N = 9..0 -> THE DECIMAL NUMBER IF PUNCH IN ROW
        1381+10 1477          + R ADD     ONE
        1382+12 1476          + STORE     MASK         MASK=1 -> THE MASK TO SET CHAR BITMAP
        1383+12 1475          + STORE     NOPCH        FLAG. INIT TO 1, BECOMES 0 ON READING FIRST PUNCH. ALLOWS TO IDENTIFY IS THE COLUMN HAS TWO OR MORE PUNCHES
        1384-10    0 ROWRD    - R ADD     /   /        GET ROW WORD
        1385-21    1          - L RIGHT   0001         SHIFT RIGHT TO MAKE ROOM FOR EXTRA BIT SIGN
        1386+ 3 1388          + TR +      ROWSHF
        1387+ 5 1484          + SUB       D200KOCT     REPLICATE SIGN BIT ON EXTRA BIT 
        1388-21    0 ROWSHF   - L RIGHT   /   /        SHIFT ROW WORD. SCANNED BIT IS PLACED AS MSB OF MQ
        1389-10 1462          - R ADD     ZERO
        1390-20    1          - L LEFT    0001         ACC=MSB OF MQ BIT
        1391+ 4 1412          + TR 0      NXTROW       IF =0 THEN TR AS ROW IS NOT PUNCHED
        1392+10 1475          + R ADD     NOPCH        NOPCH=1 IF NO PUNCH ON COLUMN FOUND YET    
        1393+ 4 1396          + TR 0      NOT09        NOPCH IS 0 -> COLUMN WITH DOBLE PUNCH -> NOT AN UNSIGNED NUMBER 0..9 
        1394+10 1472          + R ADD     N            IF N >= 0 THEN TR TO NUM=NUM+N
        1395+ 3 1399          + TR +      SETN         ELSE, SET ISNUM=0 AS NUM HAS SIGN OR ALFA CHARS
        1396+10 1462 NOT09    + R ADD     ZERO
        1397+12 1474          + STORE     ISNUM
        1398+ 1 1402          + TR        SETCHR
        1399+23   18 SETN     + A RIGHT   0018         NUM = NUM + N
        1400- 9 1464          - ADD       NUM
        1401-12 1464          - STORE     NUM
        1402+10 1468 SETCHR   + R ADD     BITMAP       BITMAP CAN BE NEGATIVE IF BIT36 IS SET
        1403+ 3 1406          + TR +      SETCHR1
        1404+ 6 1476          + R SUB     MASK         ADD MASK TO BITMAP
        1405+ 1 1407          + TR        SETCHR2  
        1406+10 1476 SETCHR1  + R ADD     MASK         ADD MASK TO BITMAP
        1407+23   18 SETCHR2  + A RIGHT   0018
        1408- 9 1468          - ADD       BITMAP
        1409-12 1468          - STORE     BITMAP
        1410+10 1462          + R ADD     ZERO
        1411+12 1475          + STORE     NOPCH
        1412+10 1476 NXTROW   + R ADD     MASK
        1413+ 5 1483          + SUB       D2048
        1414+ 4 1435          + TR 0      NXTCOL       ALL ROWS SCANNED. PROCEED WITH NEXT COL
        1415+10 1384          + R ADD     ROWRD        SELECT NEXT ROW
        1416+ 5 1479          + SUB       D4
        1417+13 1384          + STORE A   ROWRD 
        1418+10 1472          + R ADD     N            DECR NUM REPRESENTED BY HOLE IN ROW
        1419+ 5 1477          + SUB       ONE
        1420+12 1472          + STORE     N
        1421+10 1476          + R ADD     MASK         SHIFT LEFT ONE BIT
        1422+22    1          + A LEFT    0001          
        1423+12 1476          + STORE     MASK
        1424+ 1 1384          + TR        ROWRD        PROCEED WITH NEW ROW
        1425-10 1468 GETSGN   - R ADD     BITMAP
        1426+21   11          + L RIGHT   0011         SHR 11 SO X(11) BIT IS THE MSB OF MQ
        1427+10 1462          + R ADD     ZERO
        1428+20    1          + L LEFT    0001
        1429+ 4 1432          + TR 0      GETSGN2
        1430+ 6 1477          + R SUB     ONE          X(11) BIT SET -> SGN=-1
        1431+ 1 1433          + TR        GETSGN3
        1432+10 1477 GETSGN2  + R ADD     ONE          X(11) BIT NOT SET -> SGN=1
        1433+12 1473 GETSGN3  + STORE     SGN
        1434+ 1 1437          + TR        NXTCOL2
        1435+10 1473 NXTCOL   + R ADD     SGN          IF SGN FLAG NOT SET, TR TO GET THE SIGN ON DIGIT, IF ANY
        1436+ 4 1425          + TR 0      GETSGN       
        1437+10 1470 NXTCOL2  + R ADD     COL          DECR COL
        1438+ 9 1477          + ADD       ONE
        1439+12 1470          + STORE     COL
        1440+10 1471          + R ADD     LEN          DECR LEN
        1441+ 5 1477          + SUB       ONE
        1442+12 1471          + STORE     LEN 
        1443+ 4    0 RET      + TR 0      /   /        IF LEN=0 PROCEED TO RDINT/RDALF POST-PROCESSING
        1444-15 1464          - LOAD MQ   NUM          MULT NUM X 10
        1445-16 1466          - MPY       NUM10        
        1446-14 1464          - STORE MQ  NUM
        1447-10 1468          - R ADD     BITMAP       SHIFT LEFT BITMAP 12 BITS
        1448-22   12          - A LEFT    0012
        1449-12 1468          - STORE     BITMAP    
        1450+ 2 1452          + TR OV     NXTCOL3      IF OVERLOW, STORE BIT36 AS SIGN 
        1451+ 1 1364          + TR        NXTDIG       PROCEED WITH NEXT DIGIT ON NEXT COLUMN
        1452+10 1462 NXTCOL3  + R ADD     ZERO         MAKE BITMAP NEGATIVE -> BIT36 SET
        1453- 7 1468          - SUB AB    BITMAP
        1454-12 1468          - STORE     BITMAP    
        1455+ 4 1457          + TR 0      NXTCOL4      IF -BITMAP IS ZERO -> TR TO DEVELOP -0
        1456+ 1 1364          + TR        NXTDIG       PROCEED WITH NEXT DIGIT ON NEXT COLUMN
        1457+ 6 1477 NXTCOL4  + R SUB     ONE          TO DEVELP -0, FIRTS SET ACC=-1, THEN
        1458+22   18          + A LEFT    18           SHIFT OUT ALL BITS. SIGN IS THE ONLY BIT THAT WILL REMAIN
        1459-12 1468          - STORE     BITMAP    
        1460+ 2 1364          + TR OV     NXTDIG       TR OV CLEARS OVERFLOWS 
        1461+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER 
        1462+     0  ZERO       DEF       0            
        1463+     0             DEF       0            
        1464+     0  NUM        DEF       0            
        1465+     0  NUM2       DEF       0            
        1466+     0  NUM10      DEF       0
        1467+    10             DEF       10
        1468+     0  BITMAP     DEF       0            
        1469+     0             DEF       0            
        1470+     0  COL        DEF       0
        1471+     0  LEN        DEF       0
        1472+     0  N          DEF       0
        1473+     0  SGN        DEF       0
        1474+     0  ISNUM      DEF       0
        1475+     0  NOPCH      DEF       0
        1476+     0  MASK       DEF       0
        1477+     1  ONE        DEF       1
        1478+     2  TWO        DEF       2
        1479+     4  D4         DEF       4
        1480+     9  D9         DEF       9
        1481+    35  D35        DEF       35
        1482+    36  D36        DEF       36
        1483+  2048  D2048      DEF       2048
        1484+ 65536  D200KOCT   DEF       *200000 
        1486+ 9 1607 RDPARAM1 + ADD       TWO          GET 1 PARAMS: COL (EITHER VALUE OR VAR ADDR)
        1487+13 1497          + STORE A   RDAP2        STORE ADDR OF PARAM (COL)
        1488+ 9 1606          + ADD       ONE
        1489+13 1558          + STORE A   EXIT         RETURN TO MAIN PROG CALLER
        1490+10 1596          + R ADD     ZERO               
        1491+12 1604          + STORE     TXT
        1492+20   35          + L LEFT    0035         Acc=MQ=RETURN ADDR
        1493+ 9 1607          + ADD       TWO
        1494+13 1504          + STORE A   RDPRMEX      PARAMS PARSED, RETURN TO CALLER
        1495+10 1603          + R ADD     BITMAPAD     IF ADDR OF BASE48 BITMAP NOT COMPUTED
        1496+ 4 1505          + TR 0      GETBMP1      TR TO LOAD IT
        1497+10    0   RDAP2  + R ADD     /   /        GET COLUMN PARAM 1..72
        1498+ 3 1501          + TR +      RDAP4
        1499+13 1500          + STORE A   RDAP3        COL<0 -> INTERPRET COL AS LOC(COL) = ADDR OF COL VAR
        1500+10    0   RDAP3  + R ADD     /   /        READ VAR COL PASED AS PARAM
        1501+ 3 1503   RDAP4  + TR +      RDAP5
        1502+ 1 1558          + TR        EXIT         COL<0 -> EXIT
        1503+12 1516   RDAP5  + STORE     COL          
        1504+ 1    0 RDPRMEX  + TR        /   /        RETURN TO CALLER
        1505+10 1505 GETBMP1  + R ADD     *
        1506+ 1   85          + TR        BMPAD        GET BASE48 CHARS BITMAP ADDRESS
        1507+12 1603          + STORE     BITMAPAD     
        1508+ 1 1497          + TR        RDAP2        RETURN
        1509+15 1509 RDALF    + LOAD MQ   *
        1510+ 1 1486          + TR        RDPARAM1
        1511+10 1515          + R ADD     D3
        1512+12 1605          + STORE     LEN
        1513+10 1513          + R ADD     *            READ 3 CHARS BITMAP
        1514+ 1   83          + TR        RDBMP
        1515+ 0    3 D3       + STOP      0003         
        1516+ 0    0 COL      + STOP      0000
        1517-14 1598          - STORE MQ  BITMAP       WILL BE CM1CM2CM3, EACH CM 12 BITS LONG
        1518+12 1602          + STORE     NUM          WILL BE -1 OR 0..999 IF CHARS FORMS AN UNSIGNED NUMBER
        1519-10 1598          - R ADD     BITMAP       EXTRACT LEFTMOST (CM1) CHAR, HANDLE THE SIGN BIT 
        1520-21    1          - L RIGHT   0001         SHIFT RIGHT TO MAKE ROOM FOR EXTRA BIT SIGN
        1521+ 3 1523          + TR +      CONV1
        1522+ 5 1610          + SUB       D200KOCT     REPLICATE SIGN BIT ON EXTRA BIT 
        1523-21   23 CONV1    - L RIGHT   0023
        1524+22   18          + A LEFT    0018
        1525+12 1600          + STORE     BITS         BITS FOR LEFTMOST CHAR
        1526+10 1596          + R ADD     ZERO         REMOVE SIGN FROM MQ
        1527+21    1          + L RIGHT   0001
        1528+20   25          + L LEFT    0025
        1529-12 1598          - STORE     BITMAP       REMOVED LEFTMOST CHAR CM1. NOW BITMAP CONTAINS 2 CHARS OF 12 BITS EACH (CM1 CM3)
        1530+10 1515          + R ADD     D3
        1531+12 1605          + STORE     LEN          LEN=3 TO GENERATE 3 CHARS
        1532+10 1532 CONV2    + R ADD     *
        1533+ 1 1574          + TR        CONVB48      CONVERT BITS BITMAP. RETURN ACC=BASE48 CHAR
        1534+12 1601          + STORE     CHAR
        1535+10 1604          + R ADD     TXT  
        1536+21   53          + L RIGHT   0053         TXT=TXT*48+CHAR
        1537+16 1609          + MPY       D48
        1538+14 1604          + STORE MQ  TXT
        1539+10 1604          + R ADD     TXT
        1540+ 9 1601          + ADD       CHAR
        1541+12 1604          + STORE     TXT
        1542-10 1598          - R ADD     BITMAP       GET NEXT CHAR BITMAP 
        1543+21   12          + L RIGHT   0012
        1544+22   18          + A LEFT    0018
        1545+12 1600          + STORE     BITS
        1546+10 1596          + R ADD     ZERO
        1547+20   24          + L LEFT    0024
        1548-12 1598          - STORE     BITMAP
        1549+10 1605          + R ADD     LEN
        1550+ 5 1606          + SUB       ONE
        1551+12 1605          + STORE     LEN
        1552+ 4 1554          + TR 0      CONV3
        1553+ 1 1532          + TR        CONV2
        1554+10 1596 CONV3    + R ADD     ZERO
        1555+ 5 1604          + SUB       TXT          
        1556+21   35          + L RIGHT   0035         MQ=-TXT
        1557+10 1602          + R ADD     NUM          ACC=-1 OR 0..999
        1558+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER 
        1559+15 1559 RDCHR    + LOAD MQ   *
        1560+ 1 1486          + TR        RDPARAM1
        1561+10 1606          + R ADD     ONE
        1562+12 1605          + STORE     LEN
        1563+ 2 1564          + TR OV     CLOV         CLEAR OV JUST IN CASE
        1564+10 1564 CLOV     + R ADD     *            READ 1 CHAR BITMAP
        1565+ 1   83          + TR        RDBMP
        1566+ 0    1          + STOP      0001         
        1567- 0 1516          - STOP      COL          POINTS TO COL VARIABLE
        1568+10 1596          + R ADD     ZERO         MQ=000 000 CM1 (CM1 IS 12 BITS LONG)
        1569+20   18          + L LEFT    0018         
        1570+14 1600          + STORE MQ  BITS         BITS=CM1
        1571+10 1571          + R ADD     *
        1572+ 1 1574          + TR        CONVB48      CONVERT BITMAP TO BASE48 
        1573+ 1 1558          + TR        EXIT
        1574+ 9 1607 CONVB48  + ADD       TWO          CONVERT LEN CHARS FROM BITMAP TO BASE48. RESULT IN TXT
        1575+13 1595          + STORE A   CONVEX
        1576+10 1600          + R ADD     BITS         IF BITS=0 -> CHAR=0 -> PROCEED TO CHFOUND
        1577+ 4 1590          + TR 0      CHBLANK
        1578+10 1609          + R ADD     D48          FIND BITMAP IN TABLE. IF NOT FOUND, CHAR WILL BE ZERO
        1579+12 1601          + STORE     CHAR         
        1580+10 1601  CHLOOP  + R ADD     CHAR
        1581+ 4 1592          + TR 0      CHNOTFND
        1582+ 5 1606          + SUB       ONE
        1583+12 1601          + STORE     CHAR
        1584+ 9 1603          + ADD       BITMAPAD     
        1585+13 1586          + STORE A   CHBMPAD      
        1586+10    0  CHBMPAD + R ADD     /   /        GET BITMAP FOR SELECTED CHAR
        1587+ 7 1600          + SUB AB    BITS         COMPARE WITH BITMAP TO SEARCH FOR
        1588+ 4 1594          + TR 0      CHFOUND
        1589+ 1 1580          + TR        CHLOOP
        1590+10 1596 CHBLANK  + R ADD     ZERO
        1591+ 1 1595          + TR        CONVEX   
        1592+10 1608 CHNOTFND + R ADD     D47          IF CHAR NOT FOUND, SET BASE48 CODE = 47 (THE SPECIAL CHAR '-')
        1593+ 1 1595          + TR        CONVEX   
        1594+10 1601 CHFOUND  + R ADD     CHAR
        1595+ 1    0 CONVEX   + TR        /   / 
        1596+     0  ZERO       DEF       0            
        1597+     0             DEF       0            
        1598+     0  BITMAP     DEF       0            
        1599+     0             DEF       0            
        1600+     0  BITS       DEF       0
        1601+     0  CHAR       DEF       0
        1602+     0  NUM        DEF       0
        1603+     0  BITMAPAD   DEF       0
        1604+     0  TXT        DEF       0
        1605+     0  LEN        DEF       0
        1606+     1  ONE        DEF       1
        1607+     2  TWO        DEF       2
        1608+    47  D47        DEF       47
        1609+    48  D48        DEF       48
        1610+ 65536  D200KOCT   DEF       *200000 
        1612+ 9 1636 CLMEM    + ADD       TWO 
        1613+13 1618          + STORE A   P1           PARM: ADDR 
        1614+ 9 1635          + ADD       ONE          
        1615+13 1620          + STORE A   P2           PARM: LOCATION OF LEN=NUMBER OF HALF-WORDS TO CLEAR 
        1616+ 9 1635          + ADD       ONE          
        1617+13 1626          + STORE A   EXIT
        1618+10    0 P1       + R ADD     /   /        GET ADDR TO CLEAR
        1619+13 1629          + STORE A   MEM
        1620+10    0 P2       + R ADD     /   /        GET LEN ADDR
        1621+13 1622          + STORE A   P2A
        1622+10    0 P2A      + R ADD     /   /        GET LEN 
        1623+12 1637          + STORE     LEN
        1624+15 1634          + LOAD MQ   ZERO
        1625+10 1637 LOOP     + R ADD     LEN
        1626+ 4    0 EXIT     + TR 0      /   /
        1627+ 5 1635          + SUB       ONE
        1628+12 1637          + STORE     LEN
        1629+14    0 MEM      + STORE MQ  /   /        
        1630+10 1629          + R ADD     MEM
        1631+ 9 1635          + ADD       ONE
        1632+13 1629          + STORE A   MEM
        1633+ 1 1625          + TR        LOOP
        1634+ 0    0 ZERO     + STOP      0000
        1635+ 0    1 ONE      + STOP      0001         constant 1
        1636+ 0    2 TWO      + STOP      0002         constant 2
        1637+ 0    0 LEN      + STOP      0000
        1638+ 9 1711 RWDRUM   + ADD       TWO 
        1639+13 1648          + STORE A   PDR1         PARM1: DRUM INSTR: READ/WRITE 0128  0129  0130  0131
        1640+ 9 1710          + ADD       ONE          
        1641+13 1650          + STORE A   PDR2         PARM2: DRUM ADDRESS (0..4094)
        1642+ 9 1710          + ADD       ONE          
        1643+13 1652          + STORE A   PDR3         PARM3: BUF START ADDRESS
        1644+ 9 1710          + ADD       ONE          
        1645+13 1654          + STORE A   PDR4         PARM4: LEN: NUMBER OF HALF-WORDS (MUST BE EVEN)
        1646+ 9 1710          + ADD       ONE          
        1647+13 1708          + STORE A   EXIT               
        1648+10    0 PDR1     + R ADD     /   /        GET DRUM INSTR
        1649+12 1656          + STORE     DRIO
        1650+10    0 PDR2     + R ADD     /   /        GET DRUM ADDR
        1651+13 1657          + STORE A   DRADDR
        1652+10    0 PDR3     + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1653+13 1695          + STORE A   RWCOPY    
        1654+10    0 PDR4     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        1655+12 1712          + STORE     LEN
        1656+ 0    0 DRIO     + STOP      /   /        INSTR: READ/WRITE 0128  0129  0130  0131
        1657+29    0 DRADDR   + SET DR    /   /
        1658+ 1 1691          + TR        LOOP
        1659+ 9 1711 RDTAPE   + ADD       TWO 
        1660+13 1667          + STORE A   PR1          PARM1: TAPE ADDRESS
        1661+ 9 1710          + ADD       ONE          
        1662+13 1669          + STORE A   PR2          PARM2: BUF START ADDRESS
        1663+ 9 1710          + ADD       ONE          
        1664+13 1708          + STORE A   EXIT
        1665+ 2 1666          + TR OV     CLOV1        CLEAR OV THAT MAY HAVE BEEN SET
        1666+ 8    0    CLOV1 + NOOP      0000
        1667+10    0 PR1      + R ADD     /   /        GET TAPE ADDR
        1668+13 1671          + STORE A   RTAPAD       TAPE UNITS: 0256  0257  0258  0259
        1669+10    0 PR2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1670+13 1695          + STORE A   RWCOPY    
        1671+24    0 RTAPAD   + READ      /   /
        1672+10 1709          + R ADD     ZERO
        1673+ 1 1693          + TR        LOOP1
        1674+ 9 1711 WRTAPE   + ADD       TWO 
        1675+13 1682          + STORE A   PW1          PARM1: TAPE ADDRESS
        1676+ 9 1710          + ADD       ONE          
        1677+13 1684          + STORE A   PW2          PARM2: BUF START ADDRESS
        1678+ 9 1710          + ADD       ONE          
        1679+13 1686          + STORE A   PW3          PARM3: BUF LEN
        1680+ 9 1710          + ADD       ONE          
        1681+13 1708          + STORE A   EXIT
        1682+10    0 PW1      + R ADD     /   /        GET TAPE ADDR
        1683+13 1690          + STORE A   WTAPAD       TAPE UNITS: 0256  0257  0258  0259
        1684+10    0 PW2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1685+13 1695          + STORE A   RWCOPY    
        1686+10    0 PW3      + R ADD     /   /        GET ADDR OF LEN 
        1687+13 1688          + STORE A   PW3A
        1688+10    0 PW3A     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        1689+12 1712          + STORE     LEN
        1690+26    0 WTAPAD   + WRITE     /   /        PREPARE TO WRITE ON TAPE
        1691+10 1712 LOOP     + R ADD     LEN
        1692+ 4 1707          + TR 0      RWOK
        1693+ 5 1711 LOOP1    + SUB       TWO
        1694+12 1712          + STORE     LEN
        1695-31    0 RWCOPY   - COPY      /   /        WRITE BUFFER TO TAPE
        1696+ 1 1699          + TR        GO 
        1697+ 1 1703          + TR        EOF          END OF FILE
        1698+ 1 1705          + TR        EOR          END OF RECORD
        1699+10 1695 GO       + R ADD     RWCOPY
        1700+ 5 1711          + SUB       TWO
        1701+13 1695          + STORE A   RWCOPY
        1702+ 1 1691          + TR        LOOP
        1703+10 1710 EOF      + R ADD     ONE          SET OV FLAG TO SIGNAL END OF FILE CONDITION
        1704+22   36          + A LEFT    36
        1705+ 6 1712 EOR      + R SUB     LEN          RETURN NUMBER OF HALF-WORDS READ
        1706+ 5 1711          + SUB       TWO
        1707+26 2052 RWOK     + WRITE     2052         INSURE THAT MQ NOT IN USE            
        1708+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        1709+ 0    0 ZERO     + STOP      0000
        1710+ 0    1 ONE      + STOP      0001         
        1711+ 0    2 TWO      + STOP      0002         
        1712+     0  LEN        RES       1
        1714+ 9 1729 CHAIN    + ADD       TWO
        1715+13 1716          + STORE A   CHP1
        1716+10    0 CHP1     + R ADD     /   /        GET TAPE NUMBER
        1717+13 1724          + STORE A   TAPELOAD
        1718+30   70          + SENSE     0070         SENSE SWITCH 2                                  
        1719+ 1 1723 CONTAD   + TR        ENDSTOP      (ON POSITION MAKES SENSE OPCODE TO SKIP NEXT INSTR)
        1720+10 1719          + R ADD     CONTAD       IF SW2 IS ON, A +STOP 4095 IS EXECUTED.  
        1721+12 4095          + STORE     4095         IF THEN USER PRESS START, EXECUTION WILL BE RESUMED 
        1722+ 0 4095          + STOP      4095         AND CHAINED PROGRAM WILL BE LOADED AND EXECUTED
        1723+ 8    0 ENDSTOP  + NOOP      0000
        1724+24    0 TAPELOAD + READ      0000         
        1725-31    0 TL0      - COPY      0000         READ 1ST WORD OF SELF-LOADER FROM TAPE
        1726+ 1    0          + TR        0000         TR TO SELF-LOADER
        1727+ 0 2221          + STOP      2221         ERROR LOADING: UNEXPECTED END OF FILE
        1728+ 0 2222          + STOP      2222         ERROR LOADING: UNEXPECTED END OF RECORD 
        1729+ 0    2 TWO      + STOP      0002         ERROR LOADING: UNEXPECTED END OF FILE
          48-     0  ROUTINE INIT
          49+ 1  189 ENTRY POINT
          50-     0  ROUTINE CHAIN
          51+ 1 1714 ENTRY POINT
          52-     0  ROUTINE CLRBUF
          53+ 1  850 ENTRY POINT
          54-     0  ROUTINE READCRD
          55+ 1  854 ENTRY POINT
          56-     0  ROUTINE RDINT
          57+ 1 1316 ENTRY POINT
          58-     0  ROUTINE RDALF
          59+ 1 1509 ENTRY POINT
          60-     0  ROUTINE RDCHR
          61+ 1 1559 ENTRY POINT
          62-     0  ROUTINE PRTNLINE
          63+ 1 1180 ENTRY POINT
          64-     0  ROUTINE PRINTCRD
          65+ 1  858 ENTRY POINT
          66-     0  ROUTINE RWDRUM
          67+ 1 1638 ENTRY POINT
          68-     0  ROUTINE CLMEM
          69+ 1 1612 ENTRY POINT
          70-     0  ROUTINE WRITECRD
          71+ 1  856 ENTRY POINT
          72-     0  ROUTINE PRTALF
          73+ 1  942 ENTRY POINT
          74-     0  ROUTINE PRTSTR
          75+ 1  919 ENTRY POINT
          76-     0  ROUTINE PRTCHR
          77+ 1 1062 ENTRY POINT
          78-     0  ROUTINE PRTINT
          79+ 1 1020 ENTRY POINT
          80-     0  ROUTINE PRTOCT
          81+ 1  986 ENTRY POINT
          82-     0  ROUTINE RDBMP
          83+ 1 1327 ENTRY POINT
          84-     0  ROUTINE BMPAD
          85+ 1 1262 ENTRY POINT
          86-     0  ROUTINE RDTAPE
          87+ 1 1659 ENTRY POINT
          88-     0  ROUTINE WRTAPE
          89+ 1 1674 ENTRY POINT
        4094+    48  REGION ORIGIN TABLE LOCATION
        4095+   189  INITIAL REGION
           0+ 1  189          + TR        INIT         PROGRAM START
