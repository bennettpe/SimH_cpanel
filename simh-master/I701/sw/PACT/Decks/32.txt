        DEC
        NNNN OP ADDR COMMENTS
          82+ 9  680 SRCHVAR  + ADD       TWO          SEARCH VAR 
          83+13   90          + STORE A   SRCHP1       PARAMS: ADDR OF VAR NAME TO SEARCH
          84+ 9  679          + ADD       ONE
          85+13   95          + STORE A   SRCHP2
          86+ 9  679          + ADD       ONE
          87+13  100          + STORE A   SRCHP3
          88+ 9  679          + ADD       ONE
          89+13  155          + STORE A   SRCHVAEX     RETURN INDEX POS IN ACC
          90+10    0 SRCHP1   + R ADD     /   /        GET ADDR OF NAME     
          91+13  131          + STORE A   SRCHN0   
          92+13   93          + STORE A   SRCHP1A
          93+10    0 SRCHP1A  + R ADD     /   /
          94+12  472          + STORE     FNDVAR      
          95+10    0 SRCHP2   + R ADD     /   /        GET ADDR OF NAME1
          96+13  135          + STORE A   SRCHN1
          97+13   98          + STORE A   SRCHP2A
          98+10    0 SRCHP2A  + R ADD     /   /
          99+12  473          + STORE     FNDVAR1
         100+10    0 SRCHP3   + R ADD     /   /        GET ADDR OF NAME2
         101+13  139          + STORE A   SRCHN2
         102+13  103          + STORE A   SRCHP3A
         103+10    0 SRCHP3A  + R ADD     /   /
         104+12  474          + STORE     FNDVAR2
         105+10  105          + R ADD     *            GET THE HASH OF VAR BEING SEARCHED
         106+ 1  156          + TR        GETHASH
         107+ 9  165          + ADD       HASHAD       ADD HASH TABLE ADDR
         108+13  109          + STORE A   SRCHHA1
         109+10    0 SRCHHA1  + R ADD     /   /        GET HASH[HASH VARNAME] -> VAR NUMBER
         110+ 4  154          + TR 0      SRCHNFND     =0 -> VAR NOT IN HASH TABLE -> VAR NOT EXISTS
         111+12  453          + STORE     N
         112+ 5  679          + SUB       ONE
         113+22    3          + A LEFT    0003         ADDR IN DRUM = 8*(NVAR -1)
         114+13  127          + STORE A   SRCHDRAD
         115+10  679          + R ADD     ONE
         116+12  688          + STORE     HASHFLAG     -> USING HASH VALUE
         117+ 1  124          + TR        SRCHTEST     TEST IF VAR FOUND USING HASH 
         118+10  453 SRCHLOOP + R ADD     N
         119+ 5  471          + SUB       NVARS
         120+ 4  154          + TR 0      SRCHNFND
         121+10  453          + R ADD     N
         122+ 9  679          + ADD       ONE
         123+12  453          + STORE     N
         124+10  124 SRCHTEST + R ADD     *
         125+ 1   61          + TR        RWDRUM       READ VAR FROM DRUM
         126+24  128          + READ      0128         DRUM INSTR
         127+ 0    0 SRCHDRAD + STOP      /   /        DRUM ADDR 
         128+ 0  472          + STOP      FNDVAR
         129+ 0    4          + STOP      0004         GET 4 HALF-WORD. ONLY 3 ARE NEEDED (THE NAME), BUT NUMER OF HW WORDS READ SHOULD BE EVEN
         130+10  472          + R ADD     FNDVAR
         131+ 5    0 SRCHN0   + SUB       /   /
         132+ 4  134          + TR 0      SRCHV1
         133+ 1  141          + TR        NXTSRCH
         134+10  473 SRCHV1   + R ADD     FNDVAR1
         135+ 5    0 SRCHN1   + SUB       /   /
         136+ 4  138          + TR 0      SRCHV2
         137+ 1  141          + TR        NXTSRCH
         138+10  474 SRCHV2   + R ADD     FNDVAR2
         139+ 5    0 SRCHN2   + SUB       /   /
         140+ 4  152          + TR 0      SRCHFND      VAR FOUND
         141+10  688 NXTSRCH  + R ADD     HASHFLAG     VAR NOT FOUND, SEARCH NEXT
         142+ 4  148          + TR 0      NXTSRCH2
         143+10  677          + R ADD     ZERO
         144+12  688          + STORE     HASHFLAG     VAR NOT FOUND USING HASH, START A SEQUENTIAL SEARCH
         145+12  453          + STORE     N
         146+13  127          + STORE A   SRCHDRAD
         147+ 1  118          + TR        SRCHLOOP 
         148+10  127 NXTSRCH2 + R ADD     SRCHDRAD
         149+ 9  683          + ADD       D8
         150+13  127          + STORE A   SRCHDRAD
         151+ 1  118          + TR        SRCHLOOP
         152+10  453 SRCHFND  + R ADD     N
         153+ 1  155          + TR        SRCHVAEX
         154+10  677 SRCHNFND + R ADD     ZERO
         155+ 1    0 SRCHVAEX + TR        /   /
         156+ 9  680 GETHASH  + ADD       TWO          CALC HASH VALUE (0..198) FOR VARIABLE NAME FNDVAR, FNDVAR1, FNDVAR2
         157+13  164          + STORE A   GETHAEX      RETURN HASH IN ACC
         158+10  677          + R ADD     ZERO
         159+11  472          + ADD AB    FNDVAR
         160+11  473          + ADD AB    FNDVAR1
         161+11  474          + ADD AB    FNDVAR2
         162+21   35          + L RIGHT   0035         MQ=ABS(VARIABLE FULL NAME)
         163+18  685          + DIV       D199         DIV BY 199, ACC=REMINDER
         164+ 1    0 GETHAEX  + TR        /   /
         165+ 0  476 HASHAD   + STOP      HASH         HASH TABLE ADDRESS
         166+ 9  680 SETNVARS + ADD       TWO          COMPUTE NVARS READING TABLE
         167+13  174          + STORE A   SETNVEX      STORED IN DRUM
         168+10  168          + R ADD     *
         169+ 1   61          + TR        RWDRUM       READ  RELNUM0 AND NVARS FROM DRUM
         170+24  130          + READ      0130         DRUM INSTR
         171+ 0    0          + STOP      0000         DRUM ADDR 
         172+ 0  470          + STOP      RELNUM0      ADDR OF DATA TO SAVE
         173+ 0    2          + STOP      0002         2 HALF WORDS
         174+ 1    0 SETNVEX  + TR        /   /        RETURN TO CALLER
         175+ 9  680 LOADCC   + ADD       TWO          LOAD PACTSCR INTO CARD IMAGE SO 
         176+13  195          + STORE A   CPCCEX       CURRENT PACT SOURCE CODE CAN BE PRINTED
         177+10  677          + R ADD     ZERO         COPY TO LEFT SIDE OF SOURCE CODE CARD IMAGE
         178+13  182          + STORE A   CPCC1        AT 0..46 FROM PACTSCR
         179+10  198          + R ADD     CPCC2
         180+13  181          + STORE A   CPCC 
         181-10    0 CPCC     - R ADD     /   /
         182-12    0 CPCC1    - STORE     /   /
         183+10  182          + R ADD     CPCC1
         184+ 5  680          + SUB       TWO
         185+13  187          + STORE A   CPCC1B
         186+10  677          + R ADD     ZERO
         187-12    0 CPCC1B   - STORE     /   /
         188+10  181          + R ADD     CPCC
         189+ 5  680          + SUB       TWO
         190+13  181          + STORE A   CPCC
         191+10  182          + R ADD     CPCC1
         192+ 5  681          + SUB       D4
         193+13  182          + STORE A   CPCC1
         194+ 5  197          + SUB       CPCCE
         195+ 4    0 CPCCEX   + TR 0      /   /        RETURN TO CALLER
         196+ 1  181          + TR        CPCC
         197-12   48 CPCCE    - STORE     0048         LAST LOCATION TO COPY FROM 
         198+ 8  408 CPCC2    + NOOP      PACTSRC      PACTSRC = FIRST LOCATION TO COPY FROM
         199+10  199 INIT     + R ADD     *            
         200+ 1   53          + TR        PRTNLINE     
         201+ 0  101          + STOP      0101         STRINGZ AT COL 1
         202+ 0  711          + STOP      MSGSTART     "CHECK EQ INSTR"
         203+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         204+10  677          + R ADD     ZERO         CLEAR CC RECORD
         205+12  432          + STORE     REGION     
         206+12  433          + STORE     STEP       
         207+12  434          + STORE     OP         
         208+12  435          + STORE     FACT       
         209+12  436          + STORE     S1         
         210+12  437          + STORE     S2         
         211+12  438          + STORE     QR         
         212+12  439          + STORE     QF         
         213-12  440          - STORE     NUM        
         214+12  442          + STORE     CLUE       
         215+12  443          + STORE     STEPN      
         216+12  444          + STORE     FACTN      
         217+12  445          + STORE     FACTREG    
         218+12  446          + STORE     S1N        
         219+12  447          + STORE     S2N        
         220+12  448          + STORE     D1N        
         221+12  449          + STORE     D2N        
         222+12  450          + STORE     NINST      
         223+12  451          + STORE     NINCR 
         224+10  452          + R ADD     CCLEN        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "CCLEN" NOT REFERENCED WARNING ON ASSEMBLING             
         225+10  475          + R ADD     DUMMY        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "CCLEN" NOT REFERENCED WARNING ON ASSEMBLING             
         226+10  226          + R ADD     *            
         227+ 1   61          + TR        RWDRUM       READ VARIABLE NAMES HASH TABLE FROM DRUM
         228+24  128          + READ      0128         DRUM INSTR
         229+ 0 3800          + STOP      3800         DRUM ADDR 
         230+ 0  476          + STOP      HASH         ADDR OF DATA TO SAVE
         231+ 0  200          + STOP      0200         200 HALF WORDS
         232+10  232          + R ADD     *            COMPUTE NVARS READING TABLE
         233+ 1  166          + TR        SETNVARS     STORED IN DRUM
         234+10  677          + R ADD     ZERO
         235+12  686          + STORE     NNEWVARS     
         236+28  258          + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE)
         237+ 8    0 READREG  + NOOP      0000
         238+10  238 READSTEP + R ADD     *            READ PACT USER PROGRAM SOURCE CODE CARD
         239+ 1   59          + TR        RDTAPE
         240+ 0  258          + STOP      TAPEIN
         241+ 0  408          + STOP      CCODE        BUF TO READ IN FROM TAPE
         242+ 2  367          + TR OV     EOF          TR IF END OF FILE
         243+10  434          + R ADD     OP
         244+ 4  365          + TR 0      EOR          TR IF END OF REGION
         245+10  245          + R ADD     *            LOAD PACTSCR INTO CARD IMAGE SO 
         246+ 1  175          + TR        LOADCC       CURRENT PACT SOURCE CODE CAN BE PRINTED
         247+10  677          + R ADD     ZERO
         248+12  687          + STORE     NEWVAR       INIT NEWVAR FLAG 
         249+10  434          + R ADD     OP
         250+ 5  682          + SUB       OPEQ
         251+ 4  268          + TR 0      CHKEQ        OP="EQ VAR" -> TR TO CHECK IF VARS EXISTS
         252+ 8    0 NEXT     + NOOP      0000         CONTINUE WITH NEXT STEP RECORD
         253+30   74          + SENSE     0074         SENSE SWITCH 6
         254+ 1  261          + TR        ENDLOG1A     TR IF NO LOG SELECTED
         255+10  687          + R ADD     NEWVAR       IF NEWVAR FLAG SET 
         256+ 4  261          + TR 0      ENDLOG1A     THEN ADD NOTE TO PACT SOURCE CODE LINE
         257+10  257          + R ADD     *
         258+ 1   55          + TR        PRTSTR
         259+ 0  717          + STOP      MSGNEW       "NEW VAR DEF"
         260+ 0   40          + STOP      0040         COL 40
         261+ 8    0 ENDLOG1A + NOOP      0000
         262+30   74          + SENSE     0074         SENSE SWITCH 6
         263+ 1  266          + TR        ENDLOG1      TR IF NO LOG SELECTED
         264+10  264          + R ADD     *            PRINT STEP JUST PROCESSED
         265+ 1   57          + TR        PRINTCRD
         266+ 8    0 ENDLOG1  + NOOP      0000 
         267+ 1  238          + TR        READSTEP
         268+10  445 CHKEQ    + R ADD     FACTREG    
         269+ 5  684          + SUB       D32          'T'
         270+ 4  252          + TR 0      NEXT         IF EQ TO TEMP VAR -> NO NEW VAR -> CONTINUE TO NEXT STEP
         271+10  435          + R ADD     FACT
         272+ 3  300          + TR +      ERREQNA      ERROR IF VARIABLE IS NOT ALFA
         273+10  273          + R ADD     *
         274+ 1   82          + TR        SRCHVAR      SEARCH VAR. RETURN INDEX POS IN ACC
         275+ 0  435          + STOP      FACT
         276+ 0  436          + STOP      S1
         277+ 0  437          + STOP      S2
         278+ 4  280          + TR 0      EQ1
         279+ 1  252          + TR        NEXT         EQ VAR FOUND -> PROCEED TO NEXT INSTR
         280+10  280 EQ1      + R ADD     *
         281+ 1   82          + TR        SRCHVAR      SEARCH VAR. RETURN INDEX POS IN ACC
         282+ 0  435          + STOP      FACT
         283+ 0  436          + STOP      S1
         284+ 0  677          + STOP      ZERO
         285+ 4  287          + TR 0      EQ2
         286+ 1  252          + TR        NEXT         EQ VAR FOUND -> PROCEED TO NEXT INSTR
         287+10  287 EQ2      + R ADD     *
         288+ 1   82          + TR        SRCHVAR      SEARCH VAR. RETURN INDEX POS IN ACC
         289+ 0  435          + STOP      FACT
         290+ 0  677          + STOP      ZERO
         291+ 0  677          + STOP      ZERO
         292+ 4  303          + TR 0      VARNFND      TR EQ VAR NOT FOUND
         293+ 1  252          + TR        NEXT         EQ VAR FOUND -> PROCEED TO NEXT INSTR
         294+10  294 ADDVAROV + R ADD     *            
         295+ 1  395          + TR        ERROR
         296+ 0  689          + STOP      ERROVVAR     TOO MANY VARS DEFINED
         297+10  297 EQWNOQ   + R ADD     *            
         298+ 1  395          + TR        ERROR
         299+ 0  697          + STOP      ERRNOQ       ERROR: MISSING Q ON EQ NEW-VAR
         300+10  300 ERREQNA  + R ADD     *            
         301+ 1  395          + TR        ERROR
         302+ 0  706          + STOP      ERRVNA       ERROR IF VARIABLE IS NOT ALFA
         303+10  471 VARNFND  + R ADD     NVARS        INCR NUM OF VARS DEFINED
         304+ 9  679          + ADD       ONE
         305+12  471          + STORE     NVARS
         306+ 5  676          + SUB       MAXNVARS
         307+ 3  294          + TR +      ADDVAROV     ERROR IF > TABLE SIZE
         308+10  435          + R ADD     FACT
         309+12  454          + STORE     VARNAME    
         310+10  436          + R ADD     S1
         311+12  455          + STORE     VARNAM1
         312+10  437          + R ADD     S2
         313+12  456          + STORE     VARNAM2
         314+10  679          + R ADD     ONE
         315+12  457          + STORE     VTYPE        VAR TYPE. 1=SCALAR, 2=VECTOR, 3=MATRIX
         316+12  460          + STORE     D1           DIMENSIONS
         317+12  461          + STORE     D2         
         318+10  680          + R ADD     TWO
         319+12  458          + STORE     LEN
         320+10  677          + R ADD     ZERO
         321+12  462          + STORE     CONSTR       CONSTRAINT VAR NAME
         322+12  463          + STORE     CONSTR1      
         323+12  464          + STORE     CONSTR2      
         324+12  465          + STORE     CTYPE        CONSTRAINT VAR TYPE. 0=NONE, 1=SYN, 2=IMS, 3=SUC, 9=REL
         325+12  466          + STORE     RELADDR      RELATIVE ADDR IN VAR POOL
         326+12  467          + STORE     PHASE        
         327+12  468          + STORE     FLAG         
         328+12  469          + STORE     SIZE         NUM OF HALF-WORDS NEEDED TO ACCOMODATE LEN USED BY SUB-CHAINS VARIABLES
         329+10  438          + R ADD     QR
         330+12  459          + STORE     Q          
         331+ 4  297          + TR 0      EQWNOQ       IF QR IN EQ INSTR IS BLANK -> TR ERROR MISSING Q ON EQ NEW-VAR
         332+10  471          + R ADD     NVARS
         333+ 5  679          + SUB       ONE          ADDRESS IN DRUM = (NVARS-1)*8 
         334+22    3          + A LEFT    0003      
         335+13  340          + STORE A   DRADDR1
         336+13  346          + STORE A   DRADDR2
         337+10  337          + R ADD     *
         338+ 1   61          + TR        RWDRUM       WRITE VAR RECORD TO DRUM
         339+26  128          + WRITE     0128         DRUM INSTR
         340+ 0    0 DRADDR1  + STOP      /   /        DRUM ADDR 
         341+ 0  454          + STOP      VARNAME      ADDR OF START OF FIRST HALF OF VAR RECORD
         342+ 0    8          + STOP      0008         8 HALF WORDS
         343+10  343          + R ADD     *
         344+ 1   61          + TR        RWDRUM       WRITE VAR RECORD TO DRUM
         345+26  129          + WRITE     0129         DRUM INSTR
         346+ 0    0 DRADDR2  + STOP      /   /        DRUM ADDR 
         347+ 0  462          + STOP      CONSTR       ADDR OF START OF SECOND HALF OF VAR RECORD
         348+ 0    8          + STOP      0008         8 HALF WORDS
         349+10  677          + R ADD     ZERO         UPDATE VARNAME HASH TABLE WITH
         350+11  454          + ADD AB    VARNAME      NEW VARIABLE
         351+11  455          + ADD AB    VARNAM1
         352+11  456          + ADD AB    VARNAM2
         353+21   35          + L RIGHT   0035         MQ=ABS(VARIABLE FULL NAME)
         354+18  685          + DIV       D199         DIV BY 199, ACC=REMINDER
         355+ 9  165          + ADD       HASHAD       ADD HASH TABLE ADDR
         356+13  358          + STORE A   SETHA1
         357+10  471          + R ADD     NVARS
         358+12    0 SETHA1   + STORE     /   /        SET HASH[HASH VARNAME] = VAR NUMBER
         359+10  686          + R ADD     NNEWVARS     INCR NUM OF NEW VARS DEFINED
         360+ 9  679          + ADD       ONE
         361+12  686          + STORE     NNEWVARS
         362+10  679          + R ADD     ONE
         363+12  687          + STORE     NEWVAR       SET NEWVAR FLAG 
         364+ 1  252          + TR        NEXT         
         365+ 8    0 EOR      + NOOP      0000         END OF REGION  
         366+ 1  237          + TR        READREG      PROCEED WITH NEXT REGION
         367+ 8    0 EOF      + NOOP      0000         END OF FILE
         368+10  368          + R ADD     *            
         369+ 1   61          + TR        RWDRUM       WRITE VARIABLE NAMES HASH TABLE TO DRUM
         370+26  128          + WRITE     0128         DRUM INSTR
         371+ 0 3800          + STOP      3800         DRUM ADDR 
         372+ 0  476          + STOP      HASH         ADDR OF DATA TO SAVE
         373+ 0  200          + STOP      0200         200 HALF WORDS
         374+10  374          + R ADD     *
         375+ 1   61          + TR        RWDRUM       WRITE RELNUM0 AND NVARS TO DRUM
         376+26  130          + WRITE     0130         DRUM INSTR
         377+ 0    0          + STOP      0000         DRUM ADDR 
         378+ 0  470          + STOP      RELNUM0      ADDR OF DATA TO SAVE
         379+ 0    2          + STOP      0002         2 HALF WORDS
         380+30   74          + SENSE     0074         SENSE SWITCH 6
         381+ 1  389          + TR        ENDLOG1B     TR IF NO LOG SELECTED
         382+10  382          + R ADD     *
         383+ 1   53          + TR        PRTNLINE     
         384+ 0  101          + STOP      0101         STRINGZ AT COL 1
         385+ 0  722          + STOP      MSGNNEW      "NEW VARS DEF"
         386+ 0  213          + STOP      0213         INT AT COL 13
         387+ 0  686          + STOP      NNEWVARS     NUMBER OF NEW VARS CREATED
         388+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         389+ 8    0 ENDLOG1B + NOOP      0000
         390+28  258          + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE)
         391+10  391          + R ADD     *
         392+ 1   51          + TR        CHAIN        IF SW2 IS ON, A +STOP 4095 IS EXECUTED 
         393+ 0  256          + STOP      PACTCOMP     CHAIN TO NEXT STAGE IN PACT COMPILER TAPE
         394+ 0 4095          + STOP      4095
         395+ 9  680 ERROR    + ADD       TWO
         396+13  397          + STORE A   ERRP1
         397+10    0 ERRP1    + R ADD     /   /
         398+13  404          + STORE A   ERRSTRZ      SAVE ADDR OF ERROR TXT MESSAGE
         399+10  399          + R ADD     *            PRINT USER PROGRAM SOURCE CODE CARD JUST PROCESSED
         400+ 1   57          + TR        PRINTCRD
         401+10  401          + R ADD     *
         402+ 1   53          + TR        PRTNLINE     
         403+ 0  101          + STOP      0101         STRINGZ AT COL 1
         404+ 0    0 ERRSTRZ  + STOP      /   /        ERROR MESSAGE
         405+ 0    0          + STOP      0000         END OF LINE. PRINT ALLWAYS
         406+ 0  238          + STOP      READSTEP     IF USER PRESS STARTS, PROGRAM RESUMES PROCESSING NEXT SOURCE CODE STEP 
         407+     0             ORG       EVEN
         408+     0  PACTSRC    RES       24           CARD IMAGE OF PACT SOURCE CODE CARD (12 FULL WORDS)
         432+     0  REGION     DEF       0
         433+     0  STEP       DEF       0            REGION = ALFA (<0)
         434+     0  OP         DEF       0            STEP   = INT (>0)
         435+     0  FACT       DEF       0            OP     = 0..43    =0 MEANS END OF REGION
         436+     0  S1         DEF       0            FACT   < 0 -> FACTOR IS AN ALFA SYMBOL (VAR, REGION, ...) 
         437+     0  S2         DEF       0            FACT = 0 -> BLANK FACTOR
         438+     0  QR         DEF       0            FACT = 0..9999 -> DESTINATION STEP FOR TRANSFER/RESULT OF STEP
         439+     0  QF         DEF       0            CLUE = -, R OR N
         440+     0  NUM        DEF       0            
         441+     0             DEF       0            S1/S2 = 0 -> BLANK, >0 -> INTEGER, <0 -> ALFA 
         442+     0  CLUE       DEF       0
         443+     0  STEPN      DEF       0            QR = +/- INTEGER OR BLANK. 
         444+     0  FACTN      DEF       0            QF = SET IF THERE IS AN INTEGER FACTOR/NUMBER IN CARD
         445+     0  FACTREG    DEF       0
         446+     0  S1N        DEF       0            STEPN = SEQUENTIAL NUMBER OF STEP            
         447+     0  S2N        DEF       0            IF OP IS TRANSFER -> FACTN=DESTINATION STEPN
         448+     0  D1N        DEF       0            IF OP CALLS IN A RESULT OF STEP -> FACTN=TEMP ADDR (2, 4, ..)
         449+     0  D2N        DEF       0                                               FACTREG='T'
         450+     0  NINST      DEF       0
         451+     0  NINCR      DEF       0
         452+    44  CCLEN      DEF       0044         LENGTH OF COMPACT CODE RECORD 
         453+     0  N          DEF       0            TEMP VAR (HERE TO MAKE TABLES START AT EVEN LOCATION)
         454+     0  VARNAME    DEF       0            VARIABLE NAME
         455+     0  VARNAM1    DEF       0            
         456+     0  VARNAM2    DEF       0            
         457+     0  VTYPE      DEF       0            VAR TYPE. 1=SCALAR, 2=VECTOR, 3=MATRIX
         458+     0  LEN        DEF       0            HALF-WORD USED BY VARS
         459+     0  Q          DEF       0
         460+     0  D1         DEF       0            DIMENSIONS
         461+     0  D2         DEF       0
         462+     0  CONSTR     DEF       0            CONSTRAINT VAR NAME
         463+     0  CONSTR1    DEF       0
         464+     0  CONSTR2    DEF       0
         465+     0  CTYPE      DEF       0            CONSTRAINT VAR TYPE. 0=NONE, 1=SYN, 2=IMS, 3=SUC, 9=REL
         466+     0  RELADDR    DEF       0            RELATIVE ADDR IN VAR POOL
         467+     0  PHASE      DEF       0
         468+     0  FLAG       DEF       0
         469+     0  SIZE       DEF       0            NUM OF HALF-WORDS NEEDED TO ACCOMODATE LEN USED BY SUB-CHAINS VARIABLES
         470+     0  RELNUM0    DEF       0            REL NUM ORIGIN
         471+     0  NVARS      DEF       0            NUMBER OF VARS DEFINED
         472+     0  FNDVAR     DEF       0            TEMP ON VAR SEARCH (SHOULD BE AT EVEN ADDR)
         473+     0  FNDVAR1    DEF       0            TEMP ON VAR SEARCH
         474+     0  FNDVAR2    DEF       0            TEMP ON VAR SEARCH
         475+     0  DUMMY      DEF       0            NEEDED AS RWDRUM NEED EVEN NUMBER OF HALF-WORDS
         476+     0  HASH       RES       200          VARIABLES NAMES HASH TABLE (199 ENTRIES)
         676+   341  MAXNVARS   DEF       341          MAX VARIABLES THAT CAN DE DEFINED IN ONE PROGRAM 
         677+     0  ZERO       DEF       0
         678+     0             DEF       0
         679+     1  ONE        DEF       1
         680+     2  TWO        DEF       2
         681+     4  D4         DEF       4
         682+     7  D7         DEF       7
         683+     8  D8         DEF       8
         684+    32  D32        DEF       32
         685+   199  D199       DEF       199
         686+     0  NNEWVARS   DEF       0            NUMBER OF NEW VARS CREATED
         687+     0  NEWVAR     DEF       0            FLAG TO SIGNAL IF A NEW VAR HAS BEEN CREATED
         688+     0  HASHFLAG   DEF       0
         689- 75051  ERROVVAR   TXT       "TOO MANY VARS DEFINED",0
         690-  1213  
         691- 61680  
         692- 78990  
         693- 71440  
         694- 40053  
         695- 60736  
         696+     0  
         697- 58639  ERRNOQ     TXT       "MISSING Q ON EQ NEW-VAR",0   ERROR: WHEN EQ DEFINES A NEW VAR, SHOULD HAVE Q SET
         698- 72458  
         699- 43805  
         700-  1322  
         701-   845  
         702-  1265  
         703- 81202  
         704- 31392  
         705+     0  
         706- 42111  ERRVNA     TXT       "FACTOR NOT ALFA",'           ERROR IF VARIABLE IN FACTOR IS NOT ALFA
         707- 75054  
         708-  1275  
         709- 73741  
         710- 56173  
         711- 35537  MSGSTART   TXT       "CHECK EQ INSTR",0
         712- 35664  
         713- 40560  
         714- 49663  
         715- 75168  
         716+     0  
         717- 60755  MSGNEW     TXT       "NEW VAR DEF",0
         718-  1645  
         719- 69136  
         720- 40032  
         721+     0  
         722- 60755  MSGNNEW    TXT       "NEW VARS DEF",0
         723-  1645  
         724- 70608  
         725- 37698  
         726+     0  
         728+15  742 CLRBUF   + LOAD MQ   IOCL
         729+14  747          + STORE MQ  BUFIO
         730+15  768          + LOAD MQ   IOSTORE         
         731+ 1  739          + TR        INIT2
         732+15  764 READCRD  + LOAD MQ   IORDCRD
         733+ 1  737          + TR        INIT1
         734+15  766 WRITECRD + LOAD MQ   IOWRCRD
         735+ 1  737          + TR        INIT1
         736+15  767 PRINTCRD + LOAD MQ   IOPRCRD
         737+14  747 INIT1    + STORE MQ  BUFIO
         738+15  765          + LOAD MQ   IOCOPY         
         739+14  748 INIT2    + STORE MQ  BUFROW
         740+ 9  774          + ADD       TWO          
         741+13  763          + STORE A   EXIT
         742+10  770 IOCL     + R ADD     ZERO         RESET TO INITIAL COPY LOOP ADDRESS     
         743+13  748          + STORE A   BUFROW       FOR BUFFER
         744+10  748          + R ADD     BUFROW       X .*echo Print
         745+ 5  775          + SUB       D48          X 
         746+12  772          + STORE     ENDLP        X LOOP END VALUE
         747- 0    0   BUFIO  - STOP      /   /        READ OR WRITE
         748-31    0   BUFROW - COPY      /   /        COPY WORD TO/FROM PRINTER/CARDREADER
         749+ 1  753          + TR        BUFOK2       NORMAL PROCESSING 
         750+ 1  760          + TR        EODECK       FOR COPY READING END OF REG (=END OF DECK BEING READ)
         751+ 6  774          + R SUB     TWO          END OF FILE -> NO CARD TO READ -> STOP with Acc=-2
         752+ 0  747          + STOP      BUFIO        ON PRESSING START RETRY CARD READ
         753+10  748   BUFOK2 + R ADD     BUFROW       X
         754+ 5  774          + SUB       TWO          INCR BUF ADDR
         755+13  748          + STORE A   BUFROW       X
         756+ 5  772          + SUB       ENDLP        CHECK FOR END
         757+ 4  762          + TR 0      ENDIO
         758+10  770          + R ADD     ZERO         CLEAR ACC IN CASE WE ARE CLEANING THE BUFFER
         759+ 1  748          + TR        BUFROW
         760+10  773 EODECK   + R ADD     ONE          SET OV FLAG TO SIGNAL END OF DECK CONDITION
         761+22   36          + A LEFT    36
         762+26 2052 ENDIO    + WRITE     2052         END OF I/O: INSURE THAT MQ NOT IN USE            
         763+ 1    0 EXIT     + TR        /   /
         764+24 2048 IORDCRD  + READ      2048         PREPARE TO READ FROM CARD READER
         765-31    0 IOCOPY   - COPY      /   /   
         766+26 1024 IOWRCRD  + WRITE     1024         PREPARE TO PUNCH CARD 
         767+26  512 IOPRCRD  + WRITE     0512         PREPARE WRITE PRTBUF ON PRINTER
         768-12    0 IOSTORE  - STORE     /   /        CLEAR BUFFER
         769+     0             ORG       EVEN           
         770+     0  ZERO       DEF       0            
         771+     0             DEF       0            
         772+     0  ENDLP      DEF       0            LOOP END VALUE
         773+     1  ONE        DEF       1
         774+     2  TWO        DEF       2
         775+    48  D48        DEF       48
         776+ 9 1047 PRTPARM2 + ADD       TWO          GET 2 PARAMS: LEN AND COL (EITHER VALUE OR VAR ADDR)
         777+13  796          + STORE A   PRTPRMEX
         778+10  786          + R ADD     PRTP1
         779+ 9 1047          + ADD       TWO          PRINT PACKED TEXT FROM FULL-WORD VALUE IN MQ REGISTER 
         780+13  786          + STORE A   PRTP1        STORE ADDR OF FIRST PARAM (LEN)
         781+ 9 1046          + ADD       ONE
         782+13  788          + STORE A   PRTP2        STORE ADDR OF SECOND PARAM (COL)
         783+ 9 1046          + ADD       ONE
         784+13  863          + STORE A   EXIT
         785-14 1036          - STORE MQ  NUM          SAVE VALUE TO PRINT PARAM MQ (NUM IS ALIASED TO TXT)
         786+10    0   PRTP1  + R ADD     /   /        GET LEN: NUMBER OF CHARS TO PRINT (1..6)
         787+12 1040          + STORE     LEN
         788+10    0   PRTP2  + R ADD     /   /        GET COLUMN PARAM 1..72
         789+ 3  792          + TR +      PRTP4
         790+13  791          + STORE A   PRTP3        COL<0 -> INTERPRET COL AS LOC(COL) = ADDR OF COL VAR
         791+10    0   PRTP3  + R ADD     /   /        READ VAR COL PASED AS PARAM
         792+ 4  863   PRTP4  + TR 0      EXIT         COL=0 -> EXIT
         793+ 3  795          + TR +      PRTP5
         794+ 1  863          + TR        EXIT         COL<0 -> EXIT
         795+12  846   PRTP5  + STORE     COL
         796+ 1    0 PRTPRMEX + TR        /   /        RETURN TO CALLER
         797+13  786 PRTSTR   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
         798+10  798          + R ADD     *            FOR PRINT STRINGZ FROM MEM
         799+ 1  776          + TR        PRTPARM2
         800+12  810          + STORE     COLSZ
         801+10 1040          + R ADD     LEN          LEN IS IN FACT THE LOCATION WHERE THE STRING STARTS
         802+13  805          + STORE A   STRZAD
         803+10  863          + R ADD     EXIT
         804+13  818          + STORE A   STRZEX
         805+10    0 STRZAD   + R ADD     /   /        GET HALF-WORD WITH NEXT 3 CHARS TO PRINT
         806+ 4  818          + TR 0      STRZEX       IF +0 -> END OF STRING (-0 DOES NOT TERMINATES THE STRING)
         807+21   35          + L RIGHT   0035         MQ=3-CHARS TO PRINT
         808+10  808          + R ADD     *            
         809+ 1  820          + TR        PRTALF       PRINT 3 CHARS
         810+ 0    0 COLSZ    + STOP      0000         COL 
         811+10  805 STRZ1    + R ADD     STRZAD       INCR STRING ADDRESS
         812+ 9 1046          + ADD       ONE
         813+13  805          + STORE A   STRZAD
         814+10  810          + R ADD     COLSZ        INCR COLUMN
         815+ 9 1048          + ADD       D3
         816+13  810          + STORE A   COLSZ
         817+ 1  805          + TR        STRZAD
         818+ 3    0 STRZEX   + TR +      /   /        IF ZERO -> END OF STRING
         819+ 1  811          + TR        STRZ1
         820+ 9 1047 PRTALF   + ADD       TWO          PRINT 3-PACKED CHARS IN MQ REGISTER 
         821+14 1042          + STORE MQ  TXT          SAVE TEXT TO PRINT (IN LEFT HALF WORD)
         822+13  825          + STORE A   PRTAP2       STORE ADDR OF PARAM (COL)
         823+ 9 1046          + ADD       ONE
         824+13  863          + STORE A   EXIT
         825+10    0   PRTAP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
         826+ 3  829          + TR +      PRTAP4
         827+13  828          + STORE A   PRTAP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
         828+10    0   PRTAP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
         829+12  846   PRTAP4 + STORE     COL
         830+10 1048          + R ADD     D3
         831+12 1040          + STORE     LEN
         832+10 1030 PRT1     + R ADD     ZERO         UNPACK LEFTMOST CHAR 
         833+11 1042          + ADD AB    TXT          GET TEXT DISCARD SIGN
         834+21   35          + L RIGHT   0035         MQ=Acc
         835+10 1030          + R ADD     ZERO
         836+18 1055          + DIV       D48X48
         837+12 1042          + STORE     TXT          remainder=char to print, mq=c2 * 48 + c3 in right half-word
         838+10 1030          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
         839+20   18          + L LEFT    0018         put c2 and c3 in left half-word of MQ to be saved in CHAR half word
         840+14 1041          + STORE MQ  CHAR         CHAR TO PRINT
         841+10 1041          + R ADD     CHAR 
         842+ 4  847          + TR 0      NXTCHR       IF BLANK PROCEED TO NEXT COL
         843+21   35          + L RIGHT   0035         MQ=CHAR TO PRINT
         844+10  844          + R ADD     *            PRINT CHAR
         845+ 1  940          + TR        PRTCHR
         846+ 0    0 COL      + STOP      0000         COL: COLUMN NUMBER TO PRINT (1..72)
         847+10 1040 NXTCHR   + R ADD     LEN          DECR LEN COUNT
         848+ 5 1046          + SUB       ONE
         849+12 1040          + STORE     LEN
         850+ 4  863          + TR 0      EXIT         IF NO MORE CHARS TO PRINT EXIT
         851+10  846          + R ADD     COL          INCR COL POSITION
         852+ 9 1046          + ADD       ONE
         853+12  846          + STORE     COL
         854+ 5 1054          + SUB       D72          IF COL > 72 RETURN TO CALLER
         855+ 4  857          + TR 0      GNXTCHR      ELSE PROCEED WITH NEXT CHAR
         856+ 3  863          + TR +      EXIT
         857+10 1030 GNXTCHR  + R ADD     ZERO         GET NEXT CHAR 
         858+15 1042          + LOAD MQ   TXT
         859+16 1053          + MPY       D48
         860+22   17          + A LEFT    0017         GET RESULT IN LEFT HALF-WORD OF ACC
         861+12 1042          + STORE     TXT
         862+ 1  832          + TR        PRT1         PROCEED TO PRINT CHAR
         863+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
         864+13  786 PRTOCT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
         865+10  865          + R ADD     *            FOR PRINT OCTIONARY VALUE
         866+ 1  776          + TR        PRTPARM2
         867+10 1040          + R ADD     LEN          LEN = OCTAL DIGITS TO PRINT
         868+ 9  846          + ADD       COL
         869+ 5 1046          + SUB       ONE
         870+12  882          + STORE     COLN         COL POINTS TO LEAST SIGNIFICANT DIGIT
         871+10 1036 PRTIOCG  + R ADD     NUM          GENERATE OCTINARY DIGIT
         872+15 1030          + LOAD MQ   ZERO         CLEAR MQ
         873+21   21          + L RIGHT   0021         3 LSB BITS OF LEFT HALF-WORD OF ACC TO MQ
         874+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 3 BIT)
         875+12 1036          + STORE     NUM          SAVE BACK NUM WITH RIGHTMOST OCTIONARY DIGIY EXTRACTED (NUM'=NUM/8)
         876+10 1030          + R ADD     ZERO
         877+20   21          + L LEFT    0021         LEFT HALF-WORD OF ACC IS NOW RIGHTMOST OCTINARY DIGIT EXTRACTED FROM NUM 
         878+ 4  896          + TR 0      PRTIOZ       TR IF THIS DIGIT IS ZERO TO PRINT A '0' (BASE48 CODE = 10) INSTEAD OF A BLANK (BASE48 CODE = 0)
         879+21   35          + L RIGHT   0035         PUT DIGIT 1..9 TO PRINT IN MQ
         880+10  880 PRTOCTD  + R ADD     *            PRINT OCTINARY DIGIT
         881+ 1  940          + TR        PRTCHR
         882+ 0    0 COLN     + STOP      0000
         883+10  882          + R ADD     COLN        DECR COL NUMBER TO PRINT NEXT DIGIT
         884+ 5 1046          + SUB       ONE
         885+12  882          + STORE     COLN
         886+10 1040          + R ADD     LEN          DECR COL NUMBER TO PRINT NEXT DIGIT
         887+ 5 1046          + SUB       ONE
         888+ 4  863          + TR 0      EXIT         PRINTED LEN OCTINARY DIGITS -> EXIT
         889+12 1040          + STORE     LEN
         890+10 1036          + R ADD     NUM          IF NUM < 0, ADD SIGN BIT TO LEFTMOST DIGIT
         891+ 3  871          + TR +      PRTIOCG
         892+10 1056          + R ADD     OCT04K       
         893+ 5 1036          + SUB       NUM
         894+12 1036          + STORE     NUM
         895+ 1  871          + TR        PRTIOCG
         896+15 1049   PRTIOZ + LOAD MQ   D10          ACC=BASE48 CODE FOR '0'
         897+ 1  880          + TR        PRTOCTD      TR TO PRINT IT
         898+13  786 PRTINT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
         899+10  899          + R ADD     *            FOR PRINT OCTIONARY VALUE
         900+ 1  776          + TR        PRTPARM2
         901+10  846          + R ADD     COL          PRINT DECIMAL NUMBER. VALUE OF LEN = DIGITS TO PRINT, NOT INCLUDING SIGN
         902+ 9 1040          + ADD       LEN
         903+ 5 1046          + SUB       ONE          
         904+12  925          + STORE     COLNI        COL POINTS TO END OF NUMBER
         905+10 1030          + R ADD     ZERO
         906+12 1039          + STORE     SGN          SIGN IS POSITIVE
         907+10 1036          + R ADD     NUM
         908+ 3  913          + TR +      PRTINTG
         909+ 6 1036          + R SUB     NUM          NUM IS NEGATIVE. CONVERT TO POSITIVE
         910+12 1036          + STORE     NUM          AND SET SGN=1
         911+10 1046          + R ADD     ONE
         912+12 1039          + STORE     SGN          
         913+10 1036 PRTINTG  + R ADD     NUM          GENERATE DECIMAL DIGIT
         914+21   35          + L RIGHT   0035         MQ=Acc
         915+10 1030          + R ADD     ZERO
         916+18 1049          + DIV       D10
         917+ 4  938          + TR 0      PRTINZ
         918+12 1041 PRTINTG2 + STORE     CHAR         acc=remainder=digit to print, mq=num/10
         919+10 1030          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
         920+20   18          + L LEFT    0018         digit in left half-word of MQ to be saved in CHAR half word
         921+14 1036          + STORE MQ  NUM 
         922+15 1041          + LOAD MQ   CHAR 
         923+10  923 PRTINTD  + R ADD     *            PRINT DECIMAL DIGIT
         924+ 1  940          + TR        PRTCHR
         925+ 0    0 COLNI    + STOP      0000
         926+10  925          + R ADD     COLNI        DECR COL NUMBER TO PRINT NEXT DIGIT
         927+ 5 1046          + SUB       ONE
         928+12  925          + STORE     COLNI
         929+10 1036          + R ADD     NUM          DO NOT CARE ABOUT LEN, JUST CHECK IF NUM=0 
         930+ 4  932          + TR 0      PRTINS       (SO NO MORE DIGITS REMAINS TO BE PRINTED)
         931+ 1  913          + TR        PRTINTG      NUM NOT FINISHED, PROCEED WITH NEXT DIGIT
         932+10 1039 PRTINS   + R ADD     SGN
         933+ 4  863          + TR 0      EXIT         NO SIGN -> NUM FINISHED
         934+10 1030          + R ADD     ZERO
         935+12 1039          + STORE     SGN          CLEAR SGN FLAG
         936+15 1050          + LOAD MQ   D11          BASE48 CODE FOR '-' (MINUS) CHAR
         937+ 1  923          + TR        PRTINTD      GO TO PRINT IT
         938+10 1049   PRTINZ + R ADD     D10          ACC=BASE48 CODE FOR '0'
         939+ 1  918          + TR        PRTINTG2     TR TO PRINT IT
         940+ 9 1047 PRTCHR   + ADD       TWO          PRINT CHAR IN MQ REGISTER 
         941+14 1041          + STORE MQ  CHAR         SAVE CHAR TO PRINT (IN LEFT HALF WORD)
         942+13  946          + STORE A   PRTCP2       STORE ADDR OF PARAM (COL)
         943+ 9 1046          + ADD       ONE
         944+13 1024          + STORE A   PRTCEX
         945+ 2  946          + TR OV     PRTCP2       CLEAR OV JUST IN CASE
         946+10    0   PRTCP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
         947+ 3  950          + TR +      PRTCP4
         948+13  949          + STORE A   PRTCP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
         949+10    0   PRTCP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
         950+ 5 1046   PRTCP4 + SUB       ONE
         951+12 1044          + STORE     N            N=COL-1 -> IN RANGE 0..71
         952+ 3  954          + TR +      PRTSA        IF N >= 0 PROCEED WITH BASE BUFFER ADDR CALCULATION
         953+ 1 1024          + TR        PRTCEX       IF N<0 EXIT
         954+10 1030    PRTSA + R ADD     ZERO         CARD BUFFER USES LOCATION 0..47
         955+13 1043          + STORE A   PRTROWAD     DETERMINE ADDRESS OF LOWER ROW TO PRINT
         956+10 1044          + R ADD     N
         957+ 5 1052          + SUB       D36
         958+ 3  960          + TR +      PRTC0
         959+ 1  966          + TR        PRTC1
         960+12 1044    PRTC0 + STORE     N            COL NOW 0..35 
         961+ 5 1052          + SUB       D36
         962+ 3 1024          + TR +      PRTCEX       IF COL >= 36 (IE COL PASSED AS PARAM > 72) THEN EXIT
         963+10 1043          + R ADD     PRTROWAD
         964+ 9 1047          + ADD       TWO
         965+13 1043          + STORE A   PRTROWAD     SET BASE BUFFER ADDR 
         966+10 1046    PRTC1 + R ADD     ONE          DETERMINE MASKCOL WITH MASK TO SET IN CARD BUFFER
         967+21   53          + L RIGHT   53           SET RIGHTMOST BIT OF MQ TO 1 (SHIFT 35+18=53)
         968+10 1051          + R ADD     D35
         969+ 5 1044          + SUB       N
         970+13  972          + STORE A   PRTC2
         971+10 1030          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW
         972+20    0    PRTC2 + L LEFT    /   /        SHIFT MQ LEFT N PLACES
         973+ 4  976          + TR 0      PRTC3        IF ACC STILL ZERO -> MASKCOL VALID
         974+ 6 1046          + R SUB     ONE          ACC NOT ZERO -> SHOULD GENERATE -0 TO SET SIGN BIT ON
         975+21   72          + L RIGHT   0072         NOW MQ = -0 -> LEFTMOST BIT OF MQ SET
         976-14 1032    PRTC3 - STORE MQ  MASKCOL
         977+10 1030          + R ADD     ZERO         READ THE BITMAP OF CHAR 
         978+11 1041          + ADD AB    CHAR         DISCARD SIGN OF CHAR, IF ANY
         979+12 1041          + STORE     CHAR
         980+ 5 1053          + SUB       D48
         981+ 3 1024          + TR +      PRTCEX       IF CHAR >= 48 EXIT
         982+10 1038          + R ADD     BITMAPAD     IF ADDR OF BASE48 BITMAP NOT COMPUTED
         983+ 4 1025          + TR 0      GETBMP1      TR TO LOAD IT
         984+ 9 1041  GETBMP2 + ADD       CHAR         READ THE BITMAP OF CHAR 
         985+13  986          + STORE A   PRTC4        INDICATES THE BITS TO SET IN SELECTED 
         986+10    0    PRTC4 + R ADD     /   /        COLUMN OF CARD BUFFER 
         987+12 1045          + STORE     BITS
         988+ 6 1046          + R SUB     ONE
         989+12 1044          + STORE     N            SET TO -1
         990+10 1044    LOOP1 + R ADD     N            CURRENT ROW (STARTS AT ZERO) = OFFSET ON PRTROWAD     
         991+ 9 1046          + ADD       ONE
         992+12 1044          + STORE     N
         993+10 1045          + R ADD     BITS         EXTRACT RIGHTMOST BIT OF LEFT HALF OF ACC TO MQ
         994+ 4 1024          + TR 0      PRTCEX       NO MORE BITS -> EXIT
         995+21   19          + L RIGHT   0019         LSB BIT OF LEFT HALF-WORD OF ACC TO MQ
         996+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 1 BIT)
         997+12 1045          + STORE     BITS         SAVE BACK BITS. LSB HAS BEEN EXTACTED, CONTENTS SHIFTED RIGHT ONE PLACE
         998+10 1030          + R ADD     ZERO
         999+20    1          + L LEFT    0001         PUT EXTACTED BIT BACK INTO ACC
        1000+ 4  990          + TR 0      LOOP1        NO BIT 
        1001+10 1044          + R ADD     N            READ THE ROW N AT CARD BUFFER 
        1002+22    2          + A LEFT    0002         MULT N BY 4 AS THERE ARE 4 HALF WORDS PER ROW
        1003+ 9 1043          + ADD       PRTROWAD     
        1004+13 1006          + STORE A   PRTROWR
        1005+13 1022          + STORE A   PRTROWW
        1006-10    0  PRTROWR - R ADD     /   /        
        1007-12 1034          - STORE     ROW          CURRENT CONTENTS OF ROW
        1008-10 1032          - R ADD     MASKCOL      "OR" MASKCOL IN SELECTED ROW
        1009+ 3 1017          + TR +      PRTW2
        1010-10 1034          - R ADD     ROW 
        1011+ 4 1015          + TR 0      PRTW1         
        1012+10 1030          + R ADD     ZERO         MASKCOL IS MINUS ZERO AND ROW IS NOT-EMPTY (EITHER POSITIVE OR NEGATIVE) -> SET ROW AS NEGATIVE
        1013- 7 1034          - SUB AB    ROW 
        1014+ 1 1022          + TR        PRTROWW
        1015-10 1032    PRTW1 - R ADD     MASKCOL      MASKCOL IS MINUS ZERO AND ROW IS EMPTY -> SET ROW = MASKCOL = MINUS ZERO
        1016+ 1 1022          + TR        PRTROWW
        1017-10 1034    PRTW2 - R ADD     ROW          
        1018+ 3 1021          + TR +      PRTW3              
        1019- 5 1032          - SUB       MASKCOL      MASKCOL IS POSITIVE AND ROW IS NEGATIVE -> SUB MASKCOL FROM ROW
        1020+ 1 1022          + TR        PRTROWW
        1021- 9 1032    PRTW3 - ADD       MASKCOL      MASKCOL IS POSITIVE AND ROW IS POSITIVE OR EMPTY -> ADD MASKCOL TO ROW         
        1022-12    0  PRTROWW - STORE     /   /        ROW UPDTATE
        1023+ 1  990          + TR        LOOP1        PROCEED TO NEXT ROW
        1024+ 1    0 PRTCEX   + TR        /   /
        1025+10 1025 GETBMP1  + R ADD     *
        1026+ 1   77          + TR        BMPAD        GET BASE48 CHARS BITMAP ADDRESS
        1027+12 1038          + STORE     BITMAPAD     
        1028+ 1  984          + TR        GETBMP2      RETURN
        1029+     0             ORG       EVEN
        1030+     0  ZERO       DEF       0            
        1031+     0             DEF       0            
        1032+     0  MASKCOL    DEF       0
        1033+     0             DEF       0
        1034+     0  ROW        DEF       0
        1035+     0             DEF       0
        1036+     0  NUM        DEF       0
        1037+     0             DEF       0
        1038+     0  BITMAPAD   DEF       0
        1039+     0  SGN        DEF       0
        1040+     0  LEN        DEF       0
        1041+     0  CHAR       DEF       0
        1042+     0  TXT        DEF       0
        1043+     0  PRTROWAD   DEF       0
        1044+     0  N          DEF       0
        1045+     0  BITS       DEF       0
        1046+     1  ONE        DEF       1
        1047+     2  TWO        DEF       2
        1048+     3  D3         DEF       3
        1049+    10  D10        DEF       10
        1050+    11  D11        DEF       11
        1051+    35  D35        DEF       35
        1052+    36  D36        DEF       36
        1053+    48  D48        DEF       48
        1054+    72  D72        DEF       72
        1055+  2304  D48X48     DEF       2304
        1056+ 16384  OCT04K     DEF       *040000      BIT SIGN ON 5TH OCTINARY DIGIT
        1058+ 9 1133 PRTNLINE + ADD       TWO          PRINT A NEW LINE OF DATA
        1059+12 1136          + STORE     PARAM        SAVE PARAM LIST ADDR
        1060+10 1060          + R ADD     *            CLEAR CARD BUFFER
        1061+ 1   63          + TR        CLRBUF 
        1062+10 1136 GPARAM   + R ADD     PARAM        GET PARAM PAIR FMT/DATA
        1063+13 1068          + STORE A   P1
        1064+ 9 1132          + ADD       ONE
        1065+13 1072          + STORE A   P2
        1066+ 9 1132          + ADD       ONE
        1067+12 1136          + STORE     PARAM
        1068+10    0 P1       + R ADD     /   /
        1069+12 1138          + STORE     FMT
        1070+ 3 1072          + TR +      P2           IF FMT < 0 THEM SKIP THIS PAIR FMT/DATA
        1071+ 1 1062          + TR        GPARAM
        1072+10    0 P2       + R ADD     /   /
        1073+12 1098          + STORE     DATALOC      GET DATA ADDRESS PASED AS PARAM
        1074+13 1075          + STORE A   P2A
        1075+10    0 P2A      + R ADD     /   /
        1076+12 1137          + STORE     DATA         GET EFFECTIVE DATA
        1077+10 1131          + R ADD     ZERO
        1078+15 1138          + LOAD MQ   FMT
        1079+18 1135          + DIV       D100         ACC=REMAINDER=COL NUMBER, MQ=QUOTIEN=TYPE OF DATA
        1080+12 1139          + STORE     COL
        1081+10 1131          + R ADD     ZERO
        1082+20   18          + L LEFT    0018
        1083+14 1138          + STORE MQ  FMT
        1084+15 1137          + LOAD MQ   DATA
        1085+10 1089          + R ADD     TYPETRAD
        1086+ 9 1138          + ADD       FMT
        1087+13 1088          + STORE A   TYPETR
        1088+ 1    0 TYPETR   + TR        /   /        TR SELECTED ROUTINE
        1089+ 0 1090 TYPETRAD + STOP      TYPETRT      TYPE TRANSFER TABLE ADDRESS
        1090+ 1 1119 TYPETRT  + TR        EOL          FMT=0..6 (IE <100) -> END OF PARAM LIST -> END OF LINE 
        1091+ 1 1096          + TR        TYSTR        FMT=1 -> PRINT A STRINGZ
        1092+ 1 1101          + TR        TYINT        FMT=2 -> PRINT AN INT
        1093+ 1 1106          + TR        TYOCT        FMT=3 -> PRINT AN OCT
        1094+ 1 1111          + TR        TYCHR        FMT=4 -> PRINT A CHAR
        1095+ 1 1115          + TR        TYALF        FMT=5 -> PRINT A 3-CHR PACKED ALFA STRING
        1096+10 1096 TYSTR    + R ADD     *            PRINT STRINGZ
        1097+ 1   55          + TR        PRTSTR
        1098+ 0    0 DATALOC  + STOP      /   /
        1099- 0 1139          - STOP      COL          COLUMN WHERE TXT STARTS
        1100+ 1 1062          + TR        GPARAM
        1101+10 1101 TYINT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1102+ 1   73          + TR        PRTINT
        1103+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        1104- 0 1139          - STOP      COL          COLUMN WHERE TXT STARTS
        1105+ 1 1062          + TR        GPARAM
        1106+10 1106 TYOCT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1107+ 1   75          + TR        PRTOCT
        1108+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        1109- 0 1139          - STOP      COL          COLUMN WHERE TXT STARTS
        1110+ 1 1062          + TR        GPARAM
        1111+10 1111 TYCHR    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1112+ 1   71          + TR        PRTCHR
        1113- 0 1139          - STOP      COL          COLUMN WHERE TXT STARTS
        1114+ 1 1062          + TR        GPARAM
        1115+10 1115 TYALF    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1116+ 1   69          + TR        PRTALF
        1117- 0 1139          - STOP      COL          COLUMN WHERE TXT STARTS
        1118+ 1 1062          + TR        GPARAM
        1119+10 1139 EOL      + R ADD     COL          SEND CARD BUFFER TO PRINTER AND RETURN TO CALLER
        1120+ 4 1125          + TR 0      DOPRINT      =0 -> PRINT ALLWAYS (NO SENSE SW CHECK)
        1121+ 9 1134          + ADD       D68          =1..6 -> SENSE 69..74 = OPERATOR'S PANEL SENSE SWITCH 1..6
        1122+13 1123          + STORE A   CHKSW
        1123+30    0 CHKSW    + SENSE     /   /         
        1124+ 1 1127          + TR        RETURN       SW NOT AT ON POSITION
        1125+10 1125 DOPRINT  + R ADD     *            PRINT CARD BUFFER
        1126+ 1   57          + TR        PRINTCRD
        1127+10 1136 RETURN   + R ADD     PARAM        PARAM-1 IS THE RETURN ADDR      
        1128+ 5 1132          + SUB       ONE
        1129+13 1130          + STORE A   EXIT
        1130+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        1131+ 0    0 ZERO     + STOP      0000
        1132+ 0    1 ONE      + STOP      0001
        1133+ 0    2 TWO      + STOP      0002
        1134+ 0   68 D68      + STOP      0068
        1135+ 0  100 D100     + STOP      100
        1136+ 0    0 PARAM    + STOP      0000
        1137+ 0    0 DATA     + STOP      0000
        1138+ 0    0 FMT      + STOP      0000
        1139+ 0    0 COL      + STOP      0000
        1140+ 9 1154 BMPAD    + ADD       TWO
        1141+13 1143          + STORE A   EXIT
        1142+10 1144          + R ADD     BITMAPAD
        1143+ 1    0 EXIT     + TR        /   /
        1144+ 0 1146 BITMAPAD + STOP      BITMAP
        1145+     0             ORG       EVEN
        1146+     0  BITMAP     DEF       0              <blank>     0     <none>
        1147+   256             DEF       256               1        1       1        256          =  256   
        1148+   128             DEF       128               2        2       2        128          =  128   
        1149+    64             DEF       64                3        3       3         64          =   64   
        1150+    32             DEF       32                4        4       4         32          =   32   
        1151+    16             DEF       16                5        5       5         16          =   16   
        1152+     8             DEF       8                 6        6       6          8          =    8   
        1153+     4             DEF       4                 7        7       7          4          =    4   
        1154+     2  TWO        DEF       2                 8        8       8          2          =    2   
        1155+     1             DEF       1                 9        9       9          1          =    1   
        1156+   512             DEF       512               0       10       0        512          =  512   
        1157+  1024             DEF       1024              -       11       X       1024          = 1024   
        1158+  2048             DEF       2048              +       12       Y       2048          = 2048   
        1159+  2304             DEF       2304              A       13      Y-1        256+2048    = 2304   
        1160+  2176             DEF       2176              B       14      Y-2        128+2048    = 2176   
        1161+  2112             DEF       2112              C       15      Y-3         64+2048    = 2112   
        1162+  2080             DEF       2080              D       16      Y-4         32+2048    = 2080   
        1163+  2064             DEF       2064              E       17      Y-5         16+2048    = 2064   
        1164+  2056             DEF       2056              F       18      Y-6          8+2048    = 2056   
        1165+  2052             DEF       2052              G       19      Y-7          4+2048    = 2052   
        1166+  2050             DEF       2050              H       20      Y-8          2+2048    = 2050   
        1167+  2049             DEF       2049              I       21      Y-9          1+2048    = 2049   
        1168+  1280             DEF       1280              J       22      X-1        256+1024    = 1280   
        1169+  1152             DEF       1152              K       23      X-2        128+1024    = 1152   
        1170+  1088             DEF       1088              L       24      X-3         64+1024    = 1088   
        1171+  1056             DEF       1056              M       25      X-4         32+1024    = 1056   
        1172+  1040             DEF       1040              N       26      X-5         16+1024    = 1040   
        1173+  1032             DEF       1032              O       27      X-6          8+1024    = 1032   
        1174+  1028             DEF       1028              P       28      X-7          4+1024    = 1028   
        1175+  1026             DEF       1026              Q       29      X-8          2+1024    = 1026   
        1176+  1025             DEF       1025              R       30      X-9          1+1024    = 1025   
        1177+   640             DEF       640               S       31      0-2        128+512     = 640    
        1178+   576             DEF       576               T       32      0-3         64+512     = 576    
        1179+   544             DEF       544               U       33      0-4         32+512     = 544    
        1180+   528             DEF       528               V       34      0-5         16+512     = 528    
        1181+   520             DEF       520               W       35      0-6          8+512     = 520    
        1182+   516             DEF       516               X       36      0-7          4+512     = 516    
        1183+   514             DEF       514               Y       37      0-8          2+512     = 514    
        1184+   513             DEF       513               Z       38      0-9          1+512     = 513    
        1185+   578             DEF       578               ,       39      8-3-0        2+64+512  = 578    
        1186+   546             DEF       546               %       40      8-4-0        2+32+512  = 546    
        1187+  1090             DEF       1090              $       41      8-3-X        2+64+1024 = 1090   
        1188+  1058             DEF       1058              *       42      8-4-X        2+32+1024 = 1058   
        1189+  2114             DEF       2114              .       43      8-3-Y        2+64+2048 = 2114   
        1190+  2082             DEF       2082              #       44      8-4-Y        2+32+2048 = 2082   
        1191+   768             DEF       768               /       45      0-1          512+256   = 768    
        1192+    66             DEF       66                +       46      8-3          2+64      = 66     
        1193+    34             DEF       34                -       47      8-4          2+32      = 34    This is the non-minus-sign separator
        1194+ 9 1267 RWDRUM   + ADD       TWO 
        1195+13 1204          + STORE A   PDR1         PARM1: DRUM INSTR: READ/WRITE 0128  0129  0130  0131
        1196+ 9 1266          + ADD       ONE          
        1197+13 1206          + STORE A   PDR2         PARM2: DRUM ADDRESS (0..4094)
        1198+ 9 1266          + ADD       ONE          
        1199+13 1208          + STORE A   PDR3         PARM3: BUF START ADDRESS
        1200+ 9 1266          + ADD       ONE          
        1201+13 1210          + STORE A   PDR4         PARM4: LEN: NUMBER OF HALF-WORDS (MUST BE EVEN)
        1202+ 9 1266          + ADD       ONE          
        1203+13 1264          + STORE A   EXIT               
        1204+10    0 PDR1     + R ADD     /   /        GET DRUM INSTR
        1205+12 1212          + STORE     DRIO
        1206+10    0 PDR2     + R ADD     /   /        GET DRUM ADDR
        1207+13 1213          + STORE A   DRADDR
        1208+10    0 PDR3     + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1209+13 1251          + STORE A   RWCOPY    
        1210+10    0 PDR4     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        1211+12 1268          + STORE     LEN
        1212+ 0    0 DRIO     + STOP      /   /        INSTR: READ/WRITE 0128  0129  0130  0131
        1213+29    0 DRADDR   + SET DR    /   /
        1214+ 1 1247          + TR        LOOP
        1215+ 9 1267 RDTAPE   + ADD       TWO 
        1216+13 1223          + STORE A   PR1          PARM1: TAPE ADDRESS
        1217+ 9 1266          + ADD       ONE          
        1218+13 1225          + STORE A   PR2          PARM2: BUF START ADDRESS
        1219+ 9 1266          + ADD       ONE          
        1220+13 1264          + STORE A   EXIT
        1221+ 2 1222          + TR OV     CLOV1        CLEAR OV THAT MAY HAVE BEEN SET
        1222+ 8    0    CLOV1 + NOOP      0000
        1223+10    0 PR1      + R ADD     /   /        GET TAPE ADDR
        1224+13 1227          + STORE A   RTAPAD       TAPE UNITS: 0256  0257  0258  0259
        1225+10    0 PR2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1226+13 1251          + STORE A   RWCOPY    
        1227+24    0 RTAPAD   + READ      /   /
        1228+10 1265          + R ADD     ZERO
        1229+ 1 1249          + TR        LOOP1
        1230+ 9 1267 WRTAPE   + ADD       TWO 
        1231+13 1238          + STORE A   PW1          PARM1: TAPE ADDRESS
        1232+ 9 1266          + ADD       ONE          
        1233+13 1240          + STORE A   PW2          PARM2: BUF START ADDRESS
        1234+ 9 1266          + ADD       ONE          
        1235+13 1242          + STORE A   PW3          PARM3: BUF LEN
        1236+ 9 1266          + ADD       ONE          
        1237+13 1264          + STORE A   EXIT
        1238+10    0 PW1      + R ADD     /   /        GET TAPE ADDR
        1239+13 1246          + STORE A   WTAPAD       TAPE UNITS: 0256  0257  0258  0259
        1240+10    0 PW2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1241+13 1251          + STORE A   RWCOPY    
        1242+10    0 PW3      + R ADD     /   /        GET ADDR OF LEN 
        1243+13 1244          + STORE A   PW3A
        1244+10    0 PW3A     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        1245+12 1268          + STORE     LEN
        1246+26    0 WTAPAD   + WRITE     /   /        PREPARE TO WRITE ON TAPE
        1247+10 1268 LOOP     + R ADD     LEN
        1248+ 4 1263          + TR 0      RWOK
        1249+ 5 1267 LOOP1    + SUB       TWO
        1250+12 1268          + STORE     LEN
        1251-31    0 RWCOPY   - COPY      /   /        WRITE BUFFER TO TAPE
        1252+ 1 1255          + TR        GO 
        1253+ 1 1259          + TR        EOF          END OF FILE
        1254+ 1 1261          + TR        EOR          END OF RECORD
        1255+10 1251 GO       + R ADD     RWCOPY
        1256+ 5 1267          + SUB       TWO
        1257+13 1251          + STORE A   RWCOPY
        1258+ 1 1247          + TR        LOOP
        1259+10 1266 EOF      + R ADD     ONE          SET OV FLAG TO SIGNAL END OF FILE CONDITION
        1260+22   36          + A LEFT    36
        1261+ 6 1268 EOR      + R SUB     LEN          RETURN NUMBER OF HALF-WORDS READ
        1262+ 5 1267          + SUB       TWO
        1263+26 2052 RWOK     + WRITE     2052         INSURE THAT MQ NOT IN USE            
        1264+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        1265+ 0    0 ZERO     + STOP      0000
        1266+ 0    1 ONE      + STOP      0001         
        1267+ 0    2 TWO      + STOP      0002         
        1268+     0  LEN        RES       1
        1270+ 9 1285 CHAIN    + ADD       TWO
        1271+13 1272          + STORE A   CHP1
        1272+10    0 CHP1     + R ADD     /   /        GET TAPE NUMBER
        1273+13 1280          + STORE A   TAPELOAD
        1274+30   70          + SENSE     0070         SENSE SWITCH 2                                  
        1275+ 1 1279 CONTAD   + TR        ENDSTOP      (ON POSITION MAKES SENSE OPCODE TO SKIP NEXT INSTR)
        1276+10 1275          + R ADD     CONTAD       IF SW2 IS ON, A +STOP 4095 IS EXECUTED.  
        1277+12 4095          + STORE     4095         IF THEN USER PRESS START, EXECUTION WILL BE RESUMED 
        1278+ 0 4095          + STOP      4095         AND CHAINED PROGRAM WILL BE LOADED AND EXECUTED
        1279+ 8    0 ENDSTOP  + NOOP      0000
        1280+24    0 TAPELOAD + READ      0000         
        1281-31    0 TL0      - COPY      0000         READ 1ST WORD OF SELF-LOADER FROM TAPE
        1282+ 1    0          + TR        0000         TR TO SELF-LOADER
        1283+ 0 2221          + STOP      2221         ERROR LOADING: UNEXPECTED END OF FILE
        1284+ 0 2222          + STOP      2222         ERROR LOADING: UNEXPECTED END OF RECORD 
        1285+ 0    2 TWO      + STOP      0002         ERROR LOADING: UNEXPECTED END OF FILE
          48-     0  ROUTINE INIT
          49+ 1  199 ENTRY POINT
          50-     0  ROUTINE CHAIN
          51+ 1 1270 ENTRY POINT
          52-     0  ROUTINE PRTNLINE
          53+ 1 1058 ENTRY POINT
          54-     0  ROUTINE PRTSTR
          55+ 1  797 ENTRY POINT
          56-     0  ROUTINE PRINTCRD
          57+ 1  736 ENTRY POINT
          58-     0  ROUTINE RDTAPE
          59+ 1 1215 ENTRY POINT
          60-     0  ROUTINE RWDRUM
          61+ 1 1194 ENTRY POINT
          62-     0  ROUTINE CLRBUF
          63+ 1  728 ENTRY POINT
          64-     0  ROUTINE READCRD
          65+ 1  732 ENTRY POINT
          66-     0  ROUTINE WRITECRD
          67+ 1  734 ENTRY POINT
          68-     0  ROUTINE PRTALF
          69+ 1  820 ENTRY POINT
          70-     0  ROUTINE PRTCHR
          71+ 1  940 ENTRY POINT
          72-     0  ROUTINE PRTINT
          73+ 1  898 ENTRY POINT
          74-     0  ROUTINE PRTOCT
          75+ 1  864 ENTRY POINT
          76-     0  ROUTINE BMPAD
          77+ 1 1140 ENTRY POINT
          78-     0  ROUTINE WRTAPE
          79+ 1 1230 ENTRY POINT
        4094+    48  REGION ORIGIN TABLE LOCATION
        4095+   199  INITIAL REGION
           0+ 1  199          + TR        INIT         PROGRAM START
