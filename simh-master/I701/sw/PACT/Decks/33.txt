        DEC
        NNNN OP ADDR COMMENTS
          82+ 9 1350 SRCHVAR  + ADD       TWO          SEARCH VAR 
          83+13   90          + STORE A   SRCHP1       PARAMS: ADDR OF VAR NAME TO SEARCH
          84+ 9 1349          + ADD       ONE
          85+13   95          + STORE A   SRCHP2
          86+ 9 1349          + ADD       ONE
          87+13  100          + STORE A   SRCHP3
          88+ 9 1349          + ADD       ONE
          89+13  155          + STORE A   SRCHVAEX     RETURN INDEX POS IN ACC
          90+10    0 SRCHP1   + R ADD     /   /        GET ADDR OF NAME     
          91+13  131          + STORE A   SRCHN0   
          92+13   93          + STORE A   SRCHP1A
          93+10    0 SRCHP1A  + R ADD     /   /
          94+12 1140          + STORE     FNDVAR      
          95+10    0 SRCHP2   + R ADD     /   /        GET ADDR OF NAME1
          96+13  135          + STORE A   SRCHN1
          97+13   98          + STORE A   SRCHP2A
          98+10    0 SRCHP2A  + R ADD     /   /
          99+12 1141          + STORE     FNDVAR1
         100+10    0 SRCHP3   + R ADD     /   /        GET ADDR OF NAME2
         101+13  139          + STORE A   SRCHN2
         102+13  103          + STORE A   SRCHP3A
         103+10    0 SRCHP3A  + R ADD     /   /
         104+12 1142          + STORE     FNDVAR2
         105+10  105          + R ADD     *            GET THE HASH OF VAR BEING SEARCHED
         106+ 1  156          + TR        GETHASH
         107+ 9  165          + ADD       HASHAD       ADD HASH TABLE ADDR
         108+13  109          + STORE A   SRCHHA1
         109+10    0 SRCHHA1  + R ADD     /   /        GET HASH[HASH VARNAME] -> VAR NUMBER
         110+ 4  154          + TR 0      SRCHNFND     =0 -> VAR NOT IN HASH TABLE -> VAR NOT EXISTS
         111+12 1369          + STORE     N
         112+ 5 1349          + SUB       ONE
         113+22    3          + A LEFT    0003         ADDR IN DRUM = 8*(NVAR -1)
         114+13  127          + STORE A   SRCHDRAD
         115+10 1349          + R ADD     ONE
         116+12 1372          + STORE     HASHFLAG     -> USING HASH VALUE
         117+ 1  124          + TR        SRCHTEST     TEST IF VAR FOUND USING HASH 
         118+10 1369 SRCHLOOP + R ADD     N
         119+ 5 1137          + SUB       NVARS
         120+ 4  154          + TR 0      SRCHNFND
         121+10 1369          + R ADD     N
         122+ 9 1349          + ADD       ONE
         123+12 1369          + STORE     N
         124+10  124 SRCHTEST + R ADD     *
         125+ 1   65          + TR        RWDRUM       READ VAR FROM DRUM
         126+24  128          + READ      0128         DRUM INSTR
         127+ 0    0 SRCHDRAD + STOP      /   /        DRUM ADDR 
         128+ 0 1140          + STOP      FNDVAR
         129+ 0    4          + STOP      0004         GET 4 HALF-WORD. ONLY 3 ARE NEEDED (THE NAME), BUT NUMER OF HW WORDS READ SHOULD BE EVEN
         130+10 1140          + R ADD     FNDVAR
         131+ 5    0 SRCHN0   + SUB       /   /
         132+ 4  134          + TR 0      SRCHV1
         133+ 1  141          + TR        NXTSRCH
         134+10 1141 SRCHV1   + R ADD     FNDVAR1
         135+ 5    0 SRCHN1   + SUB       /   /
         136+ 4  138          + TR 0      SRCHV2
         137+ 1  141          + TR        NXTSRCH
         138+10 1142 SRCHV2   + R ADD     FNDVAR2
         139+ 5    0 SRCHN2   + SUB       /   /
         140+ 4  152          + TR 0      SRCHFND      VAR FOUND
         141+10 1372 NXTSRCH  + R ADD     HASHFLAG     VAR NOT FOUND, SEARCH NEXT
         142+ 4  148          + TR 0      NXTSRCH2
         143+10 1347          + R ADD     ZERO
         144+12 1372          + STORE     HASHFLAG     VAR NOT FOUND USING HASH, START A SEQUENTIAL SEARCH
         145+12 1369          + STORE     N
         146+13  127          + STORE A   SRCHDRAD
         147+ 1  118          + TR        SRCHLOOP 
         148+10  127 NXTSRCH2 + R ADD     SRCHDRAD
         149+ 9 1352          + ADD       D8
         150+13  127          + STORE A   SRCHDRAD
         151+ 1  118          + TR        SRCHLOOP
         152+10 1369 SRCHFND  + R ADD     N
         153+ 1  155          + TR        SRCHVAEX
         154+10 1347 SRCHNFND + R ADD     ZERO
         155+ 1    0 SRCHVAEX + TR        /   /
         156+ 9 1350 GETHASH  + ADD       TWO          CALC HASH VALUE (0..198) FOR VARIABLE NAME FNDVAR, FNDVAR1, FNDVAR2
         157+13  164          + STORE A   GETHAEX      RETURN HASH IN ACC
         158+10 1347          + R ADD     ZERO
         159+11 1140          + ADD AB    FNDVAR
         160+11 1141          + ADD AB    FNDVAR1
         161+11 1142          + ADD AB    FNDVAR2
         162+21   35          + L RIGHT   0035         MQ=ABS(VARIABLE FULL NAME)
         163+18 1358          + DIV       D199         DIV BY 199, ACC=REMINDER
         164+ 1    0 GETHAEX  + TR        /   /
         165+ 0 1144 HASHAD   + STOP      HASH         HASH TABLE ADDRESS
         166+ 9 1350 SRCHSUCC + ADD       TWO          SEARCH FOR SUC/IMS OF VAR 
         167+13  177          + STORE A   SCHSP1       PARAMS: ADDR OF VAR NAME TO SEARCH
         168+ 9 1349          + ADD       ONE
         169+13  179          + STORE A   SCHSP2
         170+ 9 1349          + ADD       ONE
         171+13  181          + STORE A   SCHSP3
         172+ 9 1349          + ADD       ONE
         173+13  222          + STORE A   SCHSVAEX     RETURN INDEX POS IN ACC
         174+10 1347          + R ADD     ZERO         POS IN DRUM: (POS-1)*8 ON DRUM 0128 AND 0129
         175+12 1369          + STORE     N
         176+13  189          + STORE A   SCHSDRAD     POINTS TO CONSTR NAME
         177+10    0 SCHSP1   + R ADD     /   /        GET ADDR OF NAME     
         178+13  193          + STORE A   SCHSN0   
         179+10    0 SCHSP2   + R ADD     /   /        GET ADDR OF NAME1
         180+13  197          + STORE A   SCHSN1
         181+10    0 SCHSP3   + R ADD     /   /        GET ADDR OF NAME2
         182+13  201          + STORE A   SCHSN2
         183+10 1369 SCHSLOOP + R ADD     N
         184+ 5 1137          + SUB       NVARS        
         185+ 4  221          + TR 0      SCHSNFND
         186+10  186          + R ADD     *
         187+ 1   65          + TR        RWDRUM       READ VAR RECORD FROM DRUM
         188+24  129          + READ      0129         DRUM INSTR
         189+ 0    0 SCHSDRAD + STOP      /   /        DRUM ADDR 
         190+ 0 1140          + STOP      FNDVAR       -> FNDVAR=CONSTR, FNDVAR1=CONSTR1, FNDVAR2=CONSTR2, FNDCTYPE=CTYPE
         191+ 0    4          + STOP      0004         GET 4 HALF-WORD
         192+10 1140          + R ADD     FNDVAR       IS THE CONSTAINT NAME
         193+ 5    0 SCHSN0   + SUB       /   /        CHECK IF CONSTAINT NAME (IN FNDBAR1) READ FROM DRUM
         194+ 4  196          + TR 0      SCHSV1       IS SAME AS VAR TO SEARCH PASSED AS PARAM
         195+ 1  211          + TR        NXTSCHS
         196+10 1141 SCHSV1   + R ADD     FNDVAR1
         197+ 5    0 SCHSN1   + SUB       /   /
         198+ 4  200          + TR 0      SCHSV2
         199+ 1  211          + TR        NXTSCHS
         200+10 1142 SCHSV2   + R ADD     FNDVAR2
         201+ 5    0 SCHSN2   + SUB       /   /
         202+ 4  204          + TR 0      SCHSV3
         203+ 1  211          + TR        NXTSCHS
         204+10 1143 SCHSV3   + R ADD     FNDCTYPE     IF CTYPE=3 (=SUC)
         205+ 5 1351          + SUB       D3           THEN
         206+ 4  218          + TR 0      SCHSFND      VAR FOUND
         207+10 1143          + R ADD     FNDCTYPE     IF CTYPE=2 (=IMS)
         208+ 5 1350          + SUB       TWO          THEN
         209+ 4  218          + TR 0      SCHSFND      VAR FOUND
         210+ 1  211          + TR        NXTSCHS
         211+10  189 NXTSCHS  + R ADD     SCHSDRAD
         212+ 9 1352          + ADD       D8
         213+13  189          + STORE A   SCHSDRAD
         214+10 1369          + R ADD     N
         215+ 9 1349          + ADD       ONE
         216+12 1369          + STORE     N
         217+ 1  183          + TR        SCHSLOOP
         218+10 1369 SCHSFND  + R ADD     N
         219+ 9 1349          + ADD       ONE
         220+ 1  222          + TR        SCHSVAEX
         221+10 1347 SCHSNFND + R ADD     ZERO
         222+ 1    0 SCHSVAEX + TR        /   /
         223+15  226 SETVAR   + LOAD MQ   WR128        SAVE VAR RECORD TO DRUM
         224+ 1  228          + TR        GVPARAM  
         225+24  128 RD128    + READ      0128
         226+26  128 WR128    + WRITE     0128
         227+15  225 GETVAR   + LOAD MQ   RD128        READ VAR RECORD FROM DRUM
         228+ 9 1350 GVPARAM  + ADD       TWO          RECORDS STARTS AT 1
         229+13  236          + STORE A   GVP1         
         230+ 9 1349          + ADD       ONE
         231+13  255          + STORE A   GVEXIT
         232+14  245          + STORE MQ  DROP1
         233+10  245          + R ADD     DROP1
         234+ 9 1349          + ADD       ONE
         235+12  251          + STORE     DROP2
         236+10    0 GVP1     + R ADD     /   /        GET ADDR OF INDEX VAR
         237+13  238          + STORE A   GVP1A
         238+10    0 GVP1A    + R ADD     /   /        GET INDEX VALUE 1..MAXVARS       
         239+ 5 1349          + SUB       ONE          ADDRESS IN DRUM = (IVAR-1)*8 
         240+22    3          + A LEFT    0003      
         241+13  246          + STORE A   DRADDR1
         242+13  252          + STORE A   DRADDR2
         243+10  243          + R ADD     *
         244+ 1   65          + TR        RWDRUM       WRITE VAR RECORD TO DRUM
         245+24  128 DROP1    + READ      0128         DRUM INSTR
         246+ 0    0 DRADDR1  + STOP      /   /        DRUM ADDR 
         247+ 0 1120          + STOP      VARNAME      ADDR OF START OF FIRST HALF OF VAR RECORD
         248+ 0    8          + STOP      0008         8 HALF WORDS
         249+10  249          + R ADD     *
         250+ 1   65          + TR        RWDRUM       WRITE VAR RECORD TO DRUM
         251+24  129 DROP2    + READ      0129         DRUM INSTR
         252+ 0    0 DRADDR2  + STOP      /   /        DRUM ADDR 
         253+ 0 1128          + STOP      CONSTR       ADDR OF START OF SECOND HALF OF VAR RECORD
         254+ 0    8          + STOP      0008         8 HALF WORDS
         255+ 1    0 GVEXIT   + TR        /   /
         256+10  256 INIT     + R ADD     *
         257+ 1   55          + TR        PRTNLINE     
         258+ 0  101          + STOP      0101         STRINGZ AT COL 1
         259+ 0 1409          + STOP      MSGSTART     "COMPUTE VAR LOCATION"
         260+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         261+10 1123          + R ADD     VTYPE        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         262+10 1125          + R ADD     Q            NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         263+10 1126          + R ADD     D1           NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         264+10 1127          + R ADD     D2           NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         265+10 1346          + R ADD     MAXNVARS     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         266+10 1139          + R ADD     DUMMY        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         267+10 1345          + R ADD     DATA2        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         268+10  268          + R ADD     *            
         269+ 1   65          + TR        RWDRUM       READ VARIABLE NAMES HASH TABLE FROM DRUM
         270+24  128          + READ      0128         DRUM INSTR
         271+ 0 3800          + STOP      3800         DRUM ADDR 
         272+ 0 1144          + STOP      HASH         ADDR OF DATA TO SAVE
         273+ 0  200          + STOP      0200         200 HALF WORDS
         274+10  274          + R ADD     *            COMPUTE NVARS READING TABLE
         275+ 1  326          + TR        SETNVARS     STORED IN DRUM
         276+10  276          + R ADD     *            POPULATE PHASE FIELD IN ALL VARIABLE 
         277+ 1  335          + TR        SETPHA       RECORDS, COMPUTE MAXPHASE
         278+30   74          + SENSE     0074         SENSE SWITCH 6
         279+ 1  290          + TR        ENDLOG2A     TR IF NO LOG SELECTED
         280+10  280          + R ADD     *            
         281+ 1   55          + TR        PRTNLINE     
         282+ 0  101          + STOP      0101         STRINGZ AT COL 1
         283+ 0 1417          + STOP      MSGPASS1     "VAR PASS1"
         284+ 0    6          + STOP      0006
         285+10  285          + R ADD     *
         286+ 1   55          + TR        PRTNLINE     
         287+ 0  101          + STOP      0101         STRINGZ AT COL 1
         288+ 0 1429          + STOP      MSGHDV       "...NUM NAME..... PH SIZE  LOC  LEN"
         289+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         290+ 8    0 ENDLOG2A + NOOP      0000
         291+10  291          + R ADD     *            SCAN PHASES FROM MAXPASE DOWN TO 1
         292+ 1  411          + TR        SETSIZE      ON EACH PHASE, FOLLOW CONSTRAINTS TO POPULATE SIZE FIELD
         293+30   74          + SENSE     0074         SENSE SWITCH 6
         294+ 1  305          + TR        ENDLOG2B     TR IF NO LOG SELECTED
         295+10  295          + R ADD     *            
         296+ 1   55          + TR        PRTNLINE     
         297+ 0  101          + STOP      0101         STRINGZ AT COL 1
         298+ 0 1421          + STOP      MSGPASS2     "VAR PASS2"
         299+ 0    6          + STOP      0006
         300+10  300          + R ADD     *
         301+ 1   55          + TR        PRTNLINE     
         302+ 0  101          + STOP      0101         STRINGZ AT COL 1
         303+ 0 1429          + STOP      MSGHDV       "...NUM NAME..... PH SIZE  LOC  LEN"
         304+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         305+ 8    0 ENDLOG2B + NOOP      0000
         306+10  306          + R ADD     *            SET LOC ADDR FOR VARS ON PHASE 1  
         307+ 1  571          + TR        SETLOCP1     WITHOUT OVERLAPPING
         308+30   74          + SENSE     0074         SENSE SWITCH 6
         309+ 1  320          + TR        ENDLOG2C     TR IF NO LOG SELECTED
         310+10  310          + R ADD     *            
         311+ 1   55          + TR        PRTNLINE     
         312+ 0  101          + STOP      0101         STRINGZ AT COL 1
         313+ 0 1425          + STOP      MSGPASS3     "VAR PASS3"
         314+ 0    6          + STOP      0006
         315+10  315          + R ADD     *
         316+ 1   55          + TR        PRTNLINE     
         317+ 0  101          + STOP      0101         STRINGZ AT COL 1
         318+ 0 1429          + STOP      MSGHDV       "...NUM NAME..... PH SIZE  LOC  LEN"
         319+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         320+ 8    0 ENDLOG2C + NOOP      0000
         321+10  321          + R ADD     *            SET FLAG TO RELADDR VALUE
         322+ 1  750          + TR        SETFLAG      SET V.EXT VALUE
         323+10  323          + R ADD     *            SCAN PHASES FROM PHASE 1 TO MAXPHASE 
         324+ 1  789          + TR        SETSIZE2     ON EACH PHASE, PROPAGATE RELADDR TO FOLLOWING PHASES
         325+ 1 1072          + TR        DONE
         326+ 9 1350 SETNVARS + ADD       TWO          COMPUTE NVARS READING TABLE
         327+13  334          + STORE A   SETNVEX      STORED IN DRUM
         328+10  328          + R ADD     *
         329+ 1   65          + TR        RWDRUM       READ RELNUM0 AND NVARS FROM DRUM
         330+24  130          + READ      0130         DRUM INSTR
         331+ 0    0          + STOP      0000         DRUM ADDR 
         332+ 0 1136          + STOP      RELNUM0      ADDR OF DATA TO SAVE
         333+ 0    2          + STOP      0002         2 HALF WORDS
         334+ 1    0 SETNVEX  + TR        /   /        RETURN TO CALLER
         335+ 9 1350 SETPHA   + ADD       TWO
         336+13  345          + STORE A   SETPHAEX
         337+10 1349          + R ADD     ONE
         338+12 1360          + STORE     MAXPHASE     MAX PHASE DEFINED IN VARS
         339+10 1137          + R ADD     NVARS        INIT LOOP ON VARS
         340+ 9 1349          + ADD       ONE          ADD ONE BECAUSE IVAR IS DECR ON START OF ITERATION
         341+12 1367          + STORE     IVAR
         342+10 1367 PHLOOP   + R ADD     IVAR
         343+ 5 1349          + SUB       ONE
         344+12 1367          + STORE     IVAR
         345+ 4    0 SETPHAEX + TR 0      /   /        EXIT LOOP, RETURN TO CALLER
         346+10 1367          + R ADD     IVAR         CURRENT MAIN LOOP VAR
         347+12 1368          + STORE     NVAR         INIT VAR SUB-CHAIN 
         348+10  348          + R ADD     *
         349+ 1  365          + TR        FOLLOWCO     FOLLOW SUB-CHAIN, IN: NVAR, OUT: PHA
         350+10  350          + R ADD     *            GET VAR RECORD
         351+ 1  227          + TR        GETVAR
         352+ 0 1367          + STOP      IVAR
         353+10 1365          + R ADD     PHA
         354+12 1133          + STORE     PHASE        UPDATE PHASE FIELD
         355+10  355          + R ADD     *            SAVE BACK VAR RECORD
         356+ 1  223          + TR        SETVAR
         357+ 0 1367          + STOP      IVAR
         358+10 1360          + R ADD     MAXPHASE     IF (PHA > MAXPHASE) THEN
         359+ 5 1365          + SUB       PHA             MAXPHASE=PHA
         360+ 3  363          + TR +      PHL1 
         361+10 1365          + R ADD     PHA          KEEPS TRACK OF MAX PHASE VALUE = 
         362+12 1360          + STORE     MAXPHASE     MAX VAR SUB-CHAIN LENGHT
         363+ 8    0 PHL1     + NOOP      0000
         364+ 1  342          + TR        PHLOOP
         365+ 9 1350 FOLLOWCO + ADD       TWO          FOLLOW THE VAR CONSTRAINT CHAIN TO COMPUTE PHASE LEVEL
         366+13  376          + STORE A   FOLLOWEX     IN: NVAR, OUT: PHA
         367+10 1349          + R ADD     ONE          
         368+12 1365          + STORE     PHA          
         369+10  369 FCOLOOP  + R ADD     *            GET VAR RECORD
         370+ 1  227          + TR        GETVAR
         371+ 0 1368          + STOP      NVAR
         372+10 1134          + R ADD     FLAG         IF THE VAR ALREADY VISITED IN THIS SUB-CHAIN
         373+ 5 1367          + SUB       IVAR         THEN THERE IS A CONSTARINT LOOP -> TR TO ERROR
         374+ 4  408          + TR 0      FCO5
         375+10 1128          + R ADD     CONSTR       IF CONSTRAIN NAME ID BLANK THEN 
         376+ 4    0 FOLLOWEX + TR 0      /   /        IS END OF SUB-CHAIN -> RETURN TO CALLER
         377+10 1367          + R ADD     IVAR         SET FLAG FIELD AS VISITED WITH START OF 
         378+12 1134          + STORE     FLAG         SUB-CHAIN VAR NUMBER, TO DETECT CONSTRAINT LOOPS
         379+10  379          + R ADD     *            SAVE BACK VAR RECORD
         380+ 1  223          + TR        SETVAR
         381+ 0 1368          + STOP      NVAR
         382+10 1131          + R ADD     CTYPE        CONSTRAINT VAR TYPE. 0=NONE, 1=SYN, 2=IMS, 3=SUC, 9=REL
         383+ 5 1349          + SUB       ONE          SYN CONSTRAINT INCREASES PHASE COUNT 
         384+ 4  386          + TR 0      FCO1         ERROR IF MORE THAN 10 PHASES (IE VAR SUB-CHAIN
         385+ 1  395          + TR        FCO3         IS MORE THAN 10 VARS LONG) 
         386+10 1365 FCO1     + R ADD     PHA
         387+ 9 1349          + ADD       ONE
         388+12 1365          + STORE     PHA
         389+ 5 1354          + SUB       D10
         390+ 4  392          + TR 0      FCO2
         391+ 1  395          + TR        FCO3
         392+10  392 FCO2     + R ADD     *            
         393+ 1 1094          + TR        ERROR
         394+ 0 1374          + STOP      ERRPHAOV     ERROR: MORE THAN 10 PHASES (NVAR)
         395+ 8    0 FCO3     + NOOP      0000
         396+10  396          + R ADD     *
         397+ 1   82          + TR        SRCHVAR      SEARCH VAR. RETURN INDEX POS IN ACC
         398+ 0 1128          + STOP      CONSTR       SEARCH CONSTAINT VAR       
         399+ 0 1129          + STOP      CONSTR1       
         400+ 0 1130          + STOP      CONSTR2
         401+13 1368          + STORE A   NVAR
         402+10 1368          + R ADD     NVAR
         403+ 4  405          + TR 0      FCO4         IF NOT FOUND ERROR
         404+ 1  369          + TR        FCOLOOP 
         405+10  405 FCO4     + R ADD     *            
         406+ 1 1094          + TR        ERROR
         407+ 0 1382          + STOP      ERRCONSF     ERROR: CONSTRAINT NOT FOUND (FNDVAR)
         408+10  408 FCO5     + R ADD     *            
         409+ 1 1094          + TR        ERROR
         410+ 0 1390          + STOP      ERRCONSL     ERROR: CONSTRAINT LOOP (NVAR)
         411+ 9 1350 SETSIZE  + ADD       TWO
         412+13  570          + STORE A   SETSZEX
         413+10 1360          + R ADD     MAXPHASE     PHA = MAX PHASE + 1
         414+ 9 1349          + ADD       ONE
         415+12 1365          + STORE     PHA
         416+10 1365 SCANPHA  + R ADD     PHA          DECR PHA
         417+ 5 1349          + SUB       ONE          IF PHA=0 THEN TR TO SCANDONE
         418+12 1365          + STORE     PHA
         419+ 4  569          + TR 0      SCANDONE
         420+10 1347          + R ADD     ZERO         INIT TO SCAN SUB-CHAINS THAT STARTS 
         421+12 1368          + STORE     NVAR         AT PHA PHASE
         422+10 1368 SCANVAR  + R ADD     NVAR
         423+ 5 1137          + SUB       NVARS        NVARS=NVARS+1
         424+ 4  416          + TR 0      SCANPHA      IF NVAR > NVARS THEN TR SCAN PHASE
         425+10 1368          + R ADD     NVAR         because end of var table -> all vars at this phase level scanned -> proceed with "Phase-1"
         426+ 9 1349          + ADD       ONE          
         427+12 1368          + STORE     NVAR
         428+10  428          + R ADD     *            GET VAR RECORD. WILL CHECK IF WE SHOULD
         429+ 1  227          + TR        GETVAR       COMPUTE THIS VAR
         430+ 0 1368          + STOP      NVAR
         431+10 1133          + R ADD     PHASE        IF VAR[NVAR].PHASE <> PHA THEN TR TO SCANVAR
         432+ 5 1365          + SUB       PHA          THE VAR IS NOT AT DESIRED SCANNED PHASE -> TR TO TRY WITH NEXT VAR
         433+ 4  435          + TR 0      SCV1         IF PHASE>1 WILL COMPUTE VAR WITH SYN CONSTRAINT 
         434+ 1  422          + TR        SCANVAR      IF PHASE=1 WILL COMPUTE VAR WITH NO CONSTRAINT/REL CONSTRAINT
         435+10 1365 SCV1     + R ADD     PHA          
         436+ 5 1349          + SUB       ONE
         437+ 4  442          + TR 0      SCV2
         438+10 1131          + R ADD     CTYPE        HERE SCANNED PHASE > 1         
         439+ 5 1349          + SUB       ONE          IF CTYPE=1 (SYN) CONTINUE TO COMPUTE
         440+ 4  447          + TR 0      SCV3         IF CTYPE<>1 TR TO SCANVAR TO TRY WITH NEXT VAR 
         441+ 1  422          + TR        SCANVAR
         442+10 1131 SCV2     + R ADD     CTYPE        HERE SCANNED PHASE = 1         
         443+ 4  447          + TR 0      SCV3         IF CTYPE=0 (NO CONSTRAINT) CONTINUE TO COMPUTE      
         444+ 5 1353          + SUB       D9           IF CTYPE=9 (REL CONSTRAINT) CONTINUE TO COMPUTE      
         445+ 4  447          + TR 0      SCV3         IF CTYPE<>0 AND <>9 TR TO SCANVAR TO TRY WITH NEXT VAR 
         446+ 1  422          + TR        SCANVAR
         447+ 8    0 SCV3     + NOOP      0000
         448+30   74          + SENSE     0074         SENSE SWITCH 6
         449+ 1  465          + TR        ENDLOG4A     TR IF NO LOG SELECTED
         450+10  450          + R ADD     *
         451+ 1   55          + TR        PRTNLINE     
         452+ 0  201          + STOP      0201         INT AT COL 1
         453+ 0 1368          + STOP      NVAR
         454+ 0  508          + STOP      0508         ALF AT COL 8
         455+ 0 1120          + STOP      VARNAME
         456+ 0  511          + STOP      0511         ALF AT COL 11
         457+ 0 1121          + STOP      VARNAM1
         458+ 0  514          + STOP      0514         ALF AT COL 14
         459+ 0 1122          + STOP      VARNAM2
         460+ 0  214          + STOP      0214         INT AT COL 14
         461+ 0 1133          + STOP      PHASE
         462+ 0  229          + STOP      0229         INT AT COL 29
         463+ 0 1124          + STOP      LEN
         464+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         465+ 8    0 ENDLOG4A + NOOP      0000
         466+10 1365          + R ADD     PHA
         467+ 5 1349          + SUB       ONE
         468+ 4  475          + TR 0      SCV4         TR IF PHASE=1
         469+10  469          + R ADD     *            IF PHASE > 1 LOCATE PREV VAR IN CHAIN
         470+ 1   82          + TR        SRCHVAR      SEARCH VAR. RETURN INDEX POS IN ACC
         471+ 0 1128          + STOP      CONSTR       SEARCH CONSTRAINING VAR       
         472+ 0 1129          + STOP      CONSTR1       
         473+ 0 1130          + STOP      CONSTR2
         474+ 1  476          + TR        SCV5
         475+10 1347 SCV4     + R ADD     ZERO         IF PHASE = 1 THEN THERE IS NO PREV VAR IN CHAIN, SO NPREV=0
         476+12 1366 SCV5     + STORE     NPREV
         477+10 1124          + R ADD     LEN
         478+12 1361          + STORE     LOC          first free addr after var (starting at addr zero)
         479+10 1135          + R ADD     SIZE 
         480+12 1363          + STORE     HI           LOC = VAR[NVAR].LEN 
         481+ 5 1361          + SUB       LOC          HI  = VAR[NVAR].SIZE
         482+ 3  485          + TR +      SCV4B        IF HI<LOC THEN HI=LOC
         483+10 1361          + R ADD     LOC
         484+12 1363          + STORE     HI   
         485+ 8    0 SCV4B    + NOOP      0000
         486+10  486 SCANSUC  + R ADD     *            LOCATE SUCCESSOR (SUC/IMS) VARIABLE
         487+ 1  166          + TR        SRCHSUCC
         488+ 0 1120          + STOP      VARNAME      
         489+ 0 1121          + STOP      VARNAM1
         490+ 0 1122          + STOP      VARNAM2      
         491+13 1369          + STORE A   N            if n=0 -> no SUC/IMS, >0 the successor/inmediate successor var
         492+ 4  549          + TR 0      NOSUC        TR IF NO SUCCESSOR TO FOLLOW
         493+10  493          + R ADD     *            GET SUC/IMS VAR RECORD
         494+ 1  227          + TR        GETVAR
         495+ 0 1369          + STOP      N
         496+10 1131          + R ADD     CTYPE
         497+ 5 1351          + SUB       D3
         498+ 4  521          + TR 0      SCV10        TR IF CONSTRAINT IS SUC
         499+10 1361          + R ADD     LOC          
         500+12 1132          + STORE     RELADDR      VAR[N].RELADDR = LOC
         501+10  501          + R ADD     *            SAVE VAR RECORD
         502+ 1  223          + TR        SETVAR
         503+ 0 1369          + STOP      N
         504+10 1361          + R ADD     LOC          LOC = LOC + VAR[N].LEN 
         505+ 9 1124          + ADD       LEN
         506+12 1361          + STORE     LOC
         507+10 1124          + R ADD     LEN          HI2 = LOC + MAX(LEN, SIZE) 
         508+ 5 1135          + SUB       SIZE         IF HI2 > HI THEN HI = HI2
         509+ 3  512          + TR +      SCV6
         510+10 1135          + R ADD     SIZE
         511+ 1  513          + TR        SCV7
         512+10 1124 SCV6     + R ADD     LEN
         513+ 9 1361 SCV7     + ADD       LOC
         514+12 1364          + STORE     HI2
         515+ 5 1363          + SUB       HI
         516+ 3  518          + TR +      SCV8
         517+ 1  520          + TR        SCV9
         518+10 1364 SCV8     + R ADD     HI2
         519+12 1363          + STORE     HI
         520+ 1  543 SCV9     + TR        SCV20
         521+10 1361 SCV10    + R ADD     LOC          IF LOC < HI THEN LOC = HI
         522+ 5 1363          + SUB       HI
         523+ 3  526          + TR +      SCV11
         524+10 1363          + R ADD     HI
         525+12 1361          + STORE     LOC
         526+10 1361 SCV11    + R ADD     LOC          
         527+12 1132          + STORE     RELADDR      VAR[N].RELADDR = LOC
         528+10  528          + R ADD     *            SAVE VAR RECORD
         529+ 1  223          + TR        SETVAR
         530+ 0 1369          + STOP      N
         531+10 1361          + R ADD     LOC          LOC = LOC + VAR[N].LEN 
         532+ 9 1124          + ADD       LEN
         533+12 1361          + STORE     LOC
         534+10 1124          + R ADD     LEN          HI2 = HI + MAX(LEN, SIZE) 
         535+ 5 1135          + SUB       SIZE         
         536+ 3  539          + TR +      SCV16
         537+10 1135          + R ADD     SIZE
         538+ 1  540          + TR        SCV17
         539+10 1124 SCV16    + R ADD     LEN
         540+ 9 1363 SCV17    + ADD       HI
         541+12 1363          + STORE     HI
         542+ 1  543          + TR        SCV20
         543+10 1363 SCV20    + R ADD     HI           IF HI < LOC THEN HI = LOC
         544+ 5 1361          + SUB       LOC
         545+ 3  548          + TR +      SCV21
         546+10 1361          + R ADD     LOC
         547+12 1363          + STORE     HI
         548+ 1  486 SCV21    + TR        SCANSUC  
         549+10  549 NOSUC    + R ADD     *            update Size for nVar. This size covers successors's size
         550+ 1  227          + TR        GETVAR
         551+ 0 1368          + STOP      NVAR        
         552+10 1363          + R ADD     HI           
         553+12 1135          + STORE     SIZE         VAR[NVAR].SIZE = HI
         554+10  554          + R ADD     *            SAVE VAR RECORD
         555+ 1  223          + TR        SETVAR
         556+ 0 1368          + STOP      NVAR        
         557+10 1366          + R ADD     NPREV
         558+ 4  568          + TR 0      SCV30
         559+10  559          + R ADD     *            
         560+ 1  227          + TR        GETVAR
         561+ 0 1366          + STOP      NPREV
         562+10 1363          + R ADD     HI           
         563+ 9 1135          + ADD       SIZE
         564+12 1135          + STORE     SIZE         VAR[NPREV].SIZE = VAR[NPREV].SIZE + HI      (HI=VAR[NVAR].SIZE)
         565+10  565          + R ADD     *            SAVE VAR RECORD
         566+ 1  223          + TR        SETVAR
         567+ 0 1366          + STOP      NPREV
         568+ 1  422 SCV30    + TR        SCANVAR
         569+ 8    0 SCANDONE + NOOP      0000
         570+ 1    0 SETSZEX  + TR        /   /        RETURN TO CALLER
         571+ 9 1350 SETLOCP1 + ADD       TWO
         572+13  612          + STORE A   SLP1EX
         573+10  573          + R ADD     *            INIT MEM IMAGE IN DRUM 0131 
         574+ 1  695          + TR        SMEMUSE      
         575+ 0 1347          + STOP      ZERO         LOC=0000         
         576+ 0 1359          + STOP      D4094        SIZE=4094
         577+ 0 1347          + STOP      ZERO         SET VALUE ZERO 
         578+10 1137          + R ADD     NVARS
         579+ 9 1349          + ADD       ONE
         580+12 1369          + STORE     N
         581+10 1347          + R ADD     ZERO
         582+12 1373          + STORE     LSTSIZE      INIT LAST PROCESSED VAR SIZE
         583+10 1369 SLP1LOOP + R ADD     N
         584+ 5 1349          + SUB       ONE          
         585+12 1369          + STORE     N
         586+ 4  607          + TR 0      SLP1LOEN
         587+10  587          + R ADD     *            
         588+ 1  227          + TR        GETVAR
         589+ 0 1369          + STOP      N
         590+10 1131          + R ADD     CTYPE                           ELSE FLAG = 0   SIGNALS SHOULD COMPUTE RELADDR VALUE 
         591+ 5 1353          + SUB       D9
         592+ 4  596          + TR 0      SLP1A        TR AS RELADDR VALUE ALREADY ASSIGNED
         593+10 1347          + R ADD     ZERO         SET SHOULD COMPUTE RELADDR VALUE 
         594+12 1134          + STORE     FLAG
         595+ 1  603          + TR        SLP1Z
         596+10 1349 SLP1A    + R ADD     ONE          RELADDR VALUE ALREADY ASSIGNED -> SIGNAL ITS MEM USAGE
         597+12 1134          + STORE     FLAG
         598+10  598          + R ADD     *            SET IN MEM IMAGE LOCATIONS USED BY VAR
         599+ 1  695          + TR        SMEMUSE      
         600+ 0 1132          + STOP      RELADDR      LOC=CURRENT RELADDR LOCATION
         601+ 0 1135          + STOP      SIZE         SIZE=CURRENT VAR SIZE
         602+ 0 1369          + STOP      N            SET VALUE = THE VARIABLE NUMBER
         603+10  603 SLP1Z    + R ADD     *            SAVE BACK THE FLAG FIELD VALUE    
         604+ 1  223          + TR        SETVAR
         605+ 0 1369          + STOP      N
         606+ 1  583          + TR        SLP1LOOP 
         607+ 8    0 SLP1LOEN + NOOP      0000
         608+10 1347          + R ADD     ZERO
         609+12 1368          + STORE     NVAR
         610+10 1368 SLP1SCAN + R ADD     NVAR
         611+ 5 1137          + SUB       NVARS
         612+ 4    0 SLP1EX   + TR 0      /   /        RETURN TO CALLER
         613+10 1368          + R ADD     NVAR
         614+ 9 1349          + ADD       ONE
         615+12 1368          + STORE     NVAR         
         616+10  616          + R ADD     *            
         617+ 1  227          + TR        GETVAR
         618+ 0 1368          + STOP      NVAR
         619+10 1133          + R ADD     PHASE        IF PHASE <> 1 THEN PROCEED WITH NEXT VAR
         620+ 5 1349          + SUB       ONE          WE WILL ONLY HANDLE PHASE 1 VARS
         621+ 4  623          + TR 0      SLP1B
         622+ 1  610          + TR        SLP1SCAN
         623+10 1134 SLP1B    + R ADD     FLAG
         624+ 5 1349          + SUB       ONE
         625+ 4  610          + TR 0      SLP1SCAN     IF FLAG = 1 -> RELADDR VALUE ALREADY ASSIGNED -> PROCEED WITH NEXT VAR
         626+10 1131          + R ADD     CTYPE
         627+ 5 1350          + SUB       TWO
         628+ 4  610          + TR 0      SLP1SCAN     IF CTYPE = 2 (IMS) -> VAR IS A SUCCESSOR OF ANOTHER PHASE 1 VAR -> SKIP THIS VAR -> PROCEED WITH NEXT VAR
         629+10 1131          + R ADD     CTYPE
         630+ 5 1351          + SUB       D3
         631+ 4  610          + TR 0      SLP1SCAN     IF CTYPE = 3 (SUC) -> VAR IS A SUCCESSOR OF ANOTHER PHASE 1 VAR -> SKIP THIS VAR -> PROCEED WITH NEXT VAR
         632+30   74          + SENSE     0074         SENSE SWITCH 6
         633+ 1  651          + TR        ENDLOG4B     TR IF NO LOG SELECTED
         634+10  634          + R ADD     *
         635+ 1   55          + TR        PRTNLINE     
         636+ 0  201          + STOP      0201         INT AT COL 1
         637+ 0 1368          + STOP      NVAR
         638+ 0  508          + STOP      0508         ALF AT COL 8
         639+ 0 1120          + STOP      VARNAME
         640+ 0  511          + STOP      0511         ALF AT COL 11
         641+ 0 1121          + STOP      VARNAM1
         642+ 0  514          + STOP      0514         ALF AT COL 14
         643+ 0 1122          + STOP      VARNAM2
         644+ 0  214          + STOP      0214         INT AT COL 14
         645+ 0 1133          + STOP      PHASE
         646+ 0  219          + STOP      0219         INT AT COL 19
         647+ 0 1135          + STOP      SIZE
         648+ 0  229          + STOP      0229         INT AT COL 29
         649+ 0 1124          + STOP      LEN
         650+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         651+ 8    0 ENDLOG4B + NOOP      0000
         652+10 1135          + R ADD     SIZE
         653+12 1363          + STORE     HI           HI  = VAR[NVAR].SIZE
         654+ 5 1373          + SUB       LSTSIZE      IF CURRENT NVAR HAS SAME SIZE AS LAST VAR PROCESSED
         655+ 4  658          + TR 0      SLP1SCOV     TR TO KEEP LOC VALUE TO START OVERLAPPING SCAN JUST AFTER LAST VAR 
         656+10 1347          + R ADD     ZERO         IF CURRENT NVAR HAS NOT SAME SIZE AS LAST VAR PROCESSED
         657+12 1361          + STORE     LOC          THEN SET LOC=0 TO START SCAN FOR OVERLAPPING FROM START OF VAR REGION 
         658+10  658 SLP1SCOV + R ADD     *            SCAN MEM IMAGE IN DRUM 0131 TO GET MEMORY USAGE IN LOCATIONS LOC (SIZE)
         659+ 1  725          + TR        GMEMUSE      RETURN FIRST VALUE NON-ZERO (=NVAR STORED AT THIS LOCATION) 
         660+ 0 1361          + STOP      LOC          ZERO IF MEM IS UN-USED
         661+ 0 1363          + STOP      HI
         662+ 4  675          + TR 0      SLP1NOV      VAR NOT OVERLAPS ANY OTHER -> TR TO END OF OVERLAP CHECK 
         663+12 1369          + STORE     N            N IS THE ALREADY EXISTING OVERLAPPED VAR
         664+10  664          + R ADD     *            YES, VAR[NVAR] OVERLAPS WITH VAR[N]
         665+ 1  227          + TR        GETVAR       
         666+ 0 1369          + STOP      N
         667+10 1132          + R ADD     RELADDR      = VAR[N].RELADDR
         668+ 9 1135          + ADD       SIZE         = VAR[N].SIZE
         669+12 1361          + STORE     LOC          LOC = NEW POSSIBLE VAR[NVAR].RELADDR VAR[N].RELADDR + VAR[N].SIZE
         670+10 1361          + R ADD     LOC          IF NEW LOC DOES NOT FIT IN MEM
         671+ 9 1363          + ADD       HI           THEN TR TO ERROR
         672+ 5 1359          + SUB       D4094
         673+ 3  782          + TR +      EVNOMEM  
         674+ 1  658          + TR        SLP1SCOV     SCAN FOR OVERLAP AGAIN
         675+10  675 SLP1NOV  + R ADD     *            VAR[NVAR] DOES NOT OVERLAPS ANY OTHER DEFINED VAR -> KEEP ADDR, MARK AS DEFINED
         676+ 1  227          + TR        GETVAR       
         677+ 0 1368          + STOP      NVAR
         678+10 1349          + R ADD     ONE
         679+12 1134          + STORE     FLAG         VAR[NVAR].FLAG = 1
         680+10 1361          + R ADD     LOC
         681+12 1132          + STORE     RELADDR      VAR[NVAR].RELADDR = LOC = 1ST FREE LOCATION NOT OVERLAPPING ANYONE
         682+10 1135          + R ADD     SIZE
         683+12 1373          + STORE     LSTSIZE      SAVE VAR SIZE AS LAST PROCESSED VAR SIZE
         684+ 9 1361          + ADD       LOC
         685+12 1361          + STORE     LOC          LOC NOW POINT TO 1ST LOC AFTER NVAR
         686+10  686          + R ADD     *
         687+ 1  223          + TR        SETVAR
         688+ 0 1368          + STOP      NVAR
         689+10  689          + R ADD     *            SET MEM IMAGE IN DRUM 0131 TO SIGNAL VAR PLACED AT RELADDR
         690+ 1  695          + TR        SMEMUSE      
         691+ 0 1132          + STOP      RELADDR      LOCATION OF VAR
         692+ 0 1135          + STOP      SIZE         
         693+ 0 1368          + STOP      NVAR         NUMBER OF VAR AT THIS LOCATION
         694+ 1  610          + TR        SLP1SCAN 
         695+ 9 1350 SMEMUSE  + ADD       TWO         USE DRUM 0131 AS MEMORY MAP. EACH WORD HAS THE VARS NUMBER THAT USES IT
         696+13  703          + STORE A   SMEMP1      SMEMUSE -> SETS THE GIVE VALUE IN LOCATION/SIZE GIVEN AS PARAM 
         697+ 9 1349          + ADD       ONE         PARAMS: SMLOC -> LOCATION (SHOULD BE EVEN)
         698+13  707          + STORE A   SMEMP2              SMSIZE -> NUMBER OF HALF-WORDS (SHOULD BE EVEN)
         699+ 9 1349          + ADD       ONE                 SMVAL -> VALUE TO STORE
         700+13  711          + STORE A   SMEMP3
         701+ 9 1349          + ADD       ONE
         702+13  724          + STORE A   SMEMEX      
         703+10    0 SMEMP1   + R ADD     /   /       GET VAR LOCATION
         704+13  705          + STORE A   SMEMP1A
         705+10    0 SMEMP1A  + R ADD     /   /
         706+13  716          + STORE A   SMLOC
         707+10    0 SMEMP2   + R ADD     /   /       GET ADDR THAT CONTAINS VAR SIZE
         708+13  709          + STORE A   SMEMP2A     
         709+10    0 SMEMP2A  + R ADD     /   /       DERREFERENCE
         710+12 1370          + STORE     NVARSIZE    VAR SIZE
         711+10    0 SMEMP3   + R ADD     /   /       GET ADDR THAT CONTAINS VALUE TO STORE IN DRUM
         712+13  713          + STORE A   SMEMP3A
         713+10    0 SMEMP3A  + R ADD     /   /
         714-12 1344          - STORE     DATA
         715+26  131          + WRITE     0131
         716+29    0 SMLOC    + SET DR    /   /
         717+10 1370 SMLOOP   + R ADD     NVARSIZE   
         718+ 4  723          + TR 0      SMLOOPE
         719+ 5 1350          + SUB       TWO
         720+12 1370          + STORE     NVARSIZE   
         721-31 1344          - COPY      DATA
         722+ 1  717          + TR        SMLOOP
         723+26 2052 SMLOOPE  + WRITE     2052         INSURE THAT MQ NOT IN USE                  
         724+ 1    0 SMEMEX   + TR        /   /
         725+ 9 1350 GMEMUSE  + ADD       TWO         USE DRUM 0131 AS MEMORY MAP. EACH WORD HAS THE VARS NUMBER THAt USES IT
         726+13  731          + STORE A   GMEMP1      GMEMUSE -> GETS NVAR THAT USES LOCATION/SIZE GIVEN AS PARAM 
         727+ 9 1349          + ADD       ONE         PARAMS: SMLOC -> LOCATION (SHOULD BE EVEN)
         728+13  735          + STORE A   GMEMP2              SMSIZE -> NUMBER OF HALF-WORDS (SHOULD BE EVEN)
         729+ 9 1349          + ADD       ONE                 RETURN FIRST VALUE NON-ZERO (=NVAR STORED AT THIS LOCATION) 
         730+13  749          + STORE A   GMEMEX                     ZERO IF MEM IS UN-USED
         731+10    0 GMEMP1   + R ADD     /   /       GET VAR LOCATION
         732+13  733          + STORE A   GMEMP1A
         733+10    0 GMEMP1A  + R ADD     /   /
         734+13  740          + STORE A   GMLOC
         735+10    0 GMEMP2   + R ADD     /   /       GET ADDR THAT CONTAINS VAR SIZE
         736+13  737          + STORE A   GMEMP2A     
         737+10    0 GMEMP2A  + R ADD     /   /       DERREFERENCE
         738+12 1370          + STORE     NVARSIZE    VAR SIZE
         739+24  131          + READ      0131
         740+29    0 GMLOC    + SET DR    /   /
         741+10 1370 GMLOOP   + R ADD     NVARSIZE   
         742+ 4  748          + TR 0      GMLOOPE
         743+ 5 1350          + SUB       TWO
         744+12 1370          + STORE     NVARSIZE   
         745-31 1344          - COPY      DATA
         746+10 1344          + R ADD     DATA
         747+ 4  741          + TR 0      GMLOOP       IF ACC <> 0 -> ACC=NVAR THAT USES THIS LOCATION -> EXIT
         748+26 2052 GMLOOPE  + WRITE     2052         INSURE THAT MQ NOT IN USE                  
         749+ 1    0 GMEMEX   + TR        /   /
         750+ 9 1350 SETFLAG  + ADD       TWO
         751+13  760          + STORE A   SETFLGEX
         752+10 1347          + R ADD     ZERO
         753+12 1138          + STORE     V.EXT        INIT VAR REGION SIZE
         754+10 1137          + R ADD     NVARS
         755+ 9 1349          + ADD       ONE
         756+12 1368          + STORE     NVAR
         757+10 1368 SFLGLOOP + R ADD     NVAR
         758+ 5 1349          + SUB       ONE
         759+12 1368          + STORE     NVAR
         760+ 4    0 SETFLGEX + TR 0      /   /        RETURN TO CALLER
         761+10  761          + R ADD     *            
         762+ 1  227          + TR        GETVAR
         763+ 0 1368          + STOP      NVAR
         764+10 1347          + R ADD     ZERO
         765+12 1134          + STORE     FLAG         VARS[N].FLAG=0
         766+10 1133          + R ADD     PHASE        IF VARS[N].PHASE = 1 THEN 
         767+ 5 1349          + SUB       ONE
         768+ 4  770          + TR 0      SFLG1
         769+ 1  785          + TR        SFLG9
         770+10 1132 SFLG1    + R ADD     RELADDR      VARS[N].FLAG = VARS[N].RELADDR
         771+12 1134          + STORE     FLAG
         772+ 9 1135          + ADD       SIZE
         773+12 1363          + STORE     HI           HI = VARS[N].RELADDR + VARS[N].SIZE = NEXT FREE ADDRESS
         774+10 1138          + R ADD     V.EXT        IF HI > V.EXT THEN V.EXT = HI
         775+ 5 1363          + SUB       HI           THIS IS THE SZIE FOR VARS REGION
         776+ 3  785          + TR +      SFLG9
         777+10 1363          + R ADD     HI
         778+12 1138          + STORE     V.EXT
         779+10 1359          + R ADD     D4094        IF V.EXT > 4094 THEN ERROR VARIABLES OVERFLOWS HI-SPEED STORAGE
         780+ 5 1138          + SUB       V.EXT
         781+ 3  785          + TR +      SFLG9
         782+10  782 EVNOMEM  + R ADD     *            
         783+ 1 1094          + TR        ERROR
         784+ 0 1396          + STOP      ERRSTOOV     ERROR: VARIABLES OVERFLOWS HI-SPEED STORAGE
         785+10  785 SFLG9    + R ADD     *            
         786+ 1  223          + TR        SETVAR
         787+ 0 1368          + STOP      NVAR
         788+ 1  757          + TR        SFLGLOOP 
         789+ 9 1350 SETSIZE2 + ADD       TWO
         790+13  911          + STORE A   SETSZ2EX
         791+10 1347          + R ADD     ZERO         PHA = 0
         792+12 1365          + STORE     PHA
         793+10 1365 SCANPHA2 + R ADD     PHA          INCR PHA
         794+ 5 1360          + SUB       MAXPHASE
         795+ 4  910          + TR 0      SCANDON2
         796+10 1365          + R ADD     PHA
         797+ 9 1349          + ADD       ONE          IF PHA=0 THEN TR TO SCANDON2
         798+12 1365          + STORE     PHA
         799+10 1347          + R ADD     ZERO         INIT TO SCAN SUB-CHAINS THAT STARTS 
         800+12 1368          + STORE     NVAR         AT PHA PHASE
         801+10 1368 SCANVAR2 + R ADD     NVAR
         802+ 5 1137          + SUB       NVARS        NVARS=NVARS+1
         803+ 4  793          + TR 0      SCANPHA2     IF NVAR > NVARS THEN TR SCAN PHASE
         804+10 1368          + R ADD     NVAR         because end of var table -> all vars at this phase level scanned -> proceed with "Phase-1"
         805+ 9 1349          + ADD       ONE          
         806+12 1368          + STORE     NVAR
         807+10  807          + R ADD     *            GET VAR RECORD. WILL CHECK IF WE SHOULD
         808+ 1  227          + TR        GETVAR       COMPUTE THIS VAR
         809+ 0 1368          + STOP      NVAR
         810+10 1133          + R ADD     PHASE        CHECK IF VAR SHOULD BE COMPUTED
         811+ 5 1365          + SUB       PHA          IF VAR[NVAR].PHASE <> PHA THEN TR TO SCANVAR2
         812+ 4  814          + TR 0      SCVB1        THE VAR IS NOT AT DESIRED SCANNED PHASE -> TR TO TRY WITH NEXT VAR
         813+ 1  801          + TR        SCANVAR2
         814+10 1133 SCVB1    + R ADD     PHASE        IF PHASE=1 WILL COMPUTE VAR WITH NO CONSTRAINT/SYN/REL CONSTRAINT
         815+ 5 1349          + SUB       ONE          IF PHASE>1 WILL COMPUTE VAR WITH SYN CONSTRAINT 
         816+ 4  821          + TR 0      SCVB2        
         817+10 1131          + R ADD     CTYPE        HERE SCANNED PHASE > 1         
         818+ 5 1349          + SUB       ONE          IF CTYPE=1 (SYN) CONTINUE TO COMPUTE
         819+ 4  826          + TR 0      SCVB3        IF CTYPE<>1 TR TO SCANVAR2 TO TRY WITH NEXT VAR 
         820+ 1  801          + TR        SCANVAR2
         821+10 1131 SCVB2    + R ADD     CTYPE        HERE SCANNED PHASE = 1         
         822+ 4  826          + TR 0      SCVB3        IF CTYPE=0 (NO CONSTRAINT) CONTINUE TO COMPUTE      
         823+ 5 1353          + SUB       D9           IF CTYPE=9 (REL CONSTRAINT) CONTINUE TO COMPUTE      
         824+ 4  826          + TR 0      SCVB3        IF CTYPE<>0 AND <>9 TR TO SCANVAR2 TO TRY WITH NEXT VAR 
         825+ 1  801          + TR        SCANVAR2
         826+ 8    0 SCVB3    + NOOP      0000
         827+30   74          + SENSE     0074         SENSE SWITCH 6
         828+ 1  848          + TR        ENDLOG4C     TR IF NO LOG SELECTED
         829+10  829          + R ADD     *
         830+ 1   55          + TR        PRTNLINE     
         831+ 0  201          + STOP      0201         INT AT COL 1
         832+ 0 1368          + STOP      NVAR
         833+ 0  508          + STOP      0508         ALF AT COL 8
         834+ 0 1120          + STOP      VARNAME
         835+ 0  511          + STOP      0511         ALF AT COL 11
         836+ 0 1121          + STOP      VARNAM1
         837+ 0  514          + STOP      0514         ALF AT COL 14
         838+ 0 1122          + STOP      VARNAM2
         839+ 0  214          + STOP      0214         INT AT COL 14
         840+ 0 1133          + STOP      PHASE
         841+ 0  219          + STOP      0219         INT AT COL 19
         842+ 0 1135          + STOP      SIZE
         843+ 0  224          + STOP      0224         INT AT COL 24
         844+ 0 1132          + STOP      RELADDR
         845+ 0  229          + STOP      0229         INT AT COL 29
         846+ 0 1124          + STOP      LEN
         847+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         848+ 8    0 ENDLOG4C + NOOP      0000
         849+10 1365          + R ADD     PHA
         850+ 5 1349          + SUB       ONE
         851+ 4  887          + TR 0      SCVB4        TR IF PHASE=1
         852+10  852          + R ADD     *            IF PHASE > 1 LOCATE PREV VAR IN CHAIN
         853+ 1   82          + TR        SRCHVAR      SEARCH VAR. RETURN INDEX POS IN ACC
         854+ 0 1128          + STOP      CONSTR       SEARCH CONSTRAINING VAR       
         855+ 0 1129          + STOP      CONSTR1       
         856+ 0 1130          + STOP      CONSTR2
         857+13 1366          + STORE A   NPREV
         858+10  858          + R ADD     *            
         859+ 1  227          + TR        GETVAR
         860+ 0 1366          + STOP      NPREV
         861+10 1134          + R ADD     FLAG         LOC = VAR[NPREV].FLAG   current RelAddr taken from constraint
         862+12 1361          + STORE     LOC
         863+10  863          + R ADD     *            
         864+ 1  227          + TR        GETVAR
         865+ 0 1368          + STOP      NVAR
         866+10 1361          + R ADD     LOC          VAR[NVAR].RELADDR = LOC
         867+12 1132          + STORE     RELADDR      VAR[NVAR].FLAG = VAR[NVAR].RELADDR
         868+12 1134          + STORE     FLAG
         869+10 1135          + R ADD     SIZE
         870+12 1370          + STORE     NVARSIZE     NVARSIZE = VAR[NVAR].SIZE
         871+10  871          + R ADD     *            
         872+ 1  223          + TR        SETVAR
         873+ 0 1368          + STOP      NVAR
         874+10  874          + R ADD     *            
         875+ 1  227          + TR        GETVAR
         876+ 0 1366          + STOP      NPREV
         877+10 1361          + R ADD     LOC          VAR[NPREV].FLAG = LOC + VAR[NVAR].SIZE
         878+ 9 1370          + ADD       NVARSIZE
         879+12 1134          + STORE     FLAG
         880+10  880          + R ADD     *            
         881+ 1  223          + TR        SETVAR
         882+ 0 1366          + STOP      NPREV
         883+10  883          + R ADD     *            RESTORE NVAR         
         884+ 1  227          + TR        GETVAR
         885+ 0 1368          + STOP      NVAR
         886+ 1  891          + TR        SCANSUC2
         887+10 1347 SCVB4    + R ADD     ZERO         IF PHASE = 1 THEN THERE IS NO PREV VAR IN CHAIN, SO NPREV=0
         888+13 1366          + STORE A   NPREV
         889+10 1134          + R ADD     FLAG         LOC = VAR[NVAR].FLAG 
         890+12 1361          + STORE     LOC
         891+10  891 SCANSUC2 + R ADD     *            scan for SUC/IMS of name (successors of current var nVar)
         892+ 1  166          + TR        SRCHSUCC
         893+ 0 1120          + STOP      VARNAME      
         894+ 0 1121          + STOP      VARNAM1
         895+ 0 1122          + STOP      VARNAM2      
         896+13 1369          + STORE A   N            if n=0 -> no SUC/IMS, >0 the successor/inmediate successor var
         897+ 4  909          + TR 0      NOSUC2       TR IF NO SUCCESSOR TO FOLLOW
         898+10  898          + R ADD     *            GET SUC/IMS VAR RECORD
         899+ 1  227          + TR        GETVAR
         900+ 0 1369          + STOP      N
         901+10 1132          + R ADD     RELADDR      VAR[N].RELADDR = LOC + VAR[N].RELADDR
         902+ 9 1361          + ADD       LOC
         903+12 1132          + STORE     RELADDR
         904+12 1134          + STORE     FLAG         VAR[N].FLAG = VAR[N].RELADDR
         905+10  905          + R ADD     *            
         906+ 1  223          + TR        SETVAR
         907+ 0 1369          + STOP      N
         908+ 1  891          + TR        SCANSUC2
         909+ 1  801 NOSUC2   + TR        SCANVAR2
         910+ 8    0 SCANDON2 + NOOP      0000
         911+ 1    0 SETSZ2EX + TR        /   /        RETURN TO CALLER
         912+ 9 1350 LISTVARS + ADD       TWO
         913+13 1071          + STORE A   LISTEX
         914+30  521          + SENSE     0521         SHEET EJECTION -> NEW PAGE FOR VARIABLES LISTING
         915+10  915          + R ADD     *
         916+ 1   55          + TR        PRTNLINE
         917+ 0    0          + STOP      0000         PRINT BLANK LINE
         918+10  918          + R ADD     *
         919+ 1   55          + TR        PRTNLINE
         920+ 0  101          + STOP      0101         STRINGZ AT COL 1
         921+ 0 1448          + STOP      MSGHDLV1     "TAG  REL.LOC. VARIABLE              CONSTRAINT"
         922+ 0    0          + STOP      0000         END OF LINE. 
         923+10  923          + R ADD     *
         924+ 1   55          + TR        PRTNLINE     
         925+ 0  101          + STOP      0101         STRINGZ AT COL 1
         926+ 0 1465          + STOP      MSGHDLV2     "    1ST  LAST FACT.  S1    S2   Q   FACT.  S1    S2  TYPE LOC."
         927+ 0    0          + STOP      0000         END OF LINE. 
         928+10 1347          + R ADD     ZERO
         929+12 1369          + STORE     N
         930+10 1369 LVLOOP   + R ADD     N
         931+ 5 1137          + SUB       NVARS
         932+ 4 1062          + TR 0      LVLOEND      TR TO LOOP END
         933+10 1369          + R ADD     N
         934+ 9 1349          + ADD       ONE
         935+12 1369          + STORE     N
         936+10  936          + R ADD     *            
         937+ 1  227          + TR        GETVAR
         938+ 0 1369          + STOP      N
         939+15 1356          + LOAD MQ   D31          'S'
         940+10 1123          + R ADD     VTYPE
         941+ 5 1349          + SUB       ONE
         942+ 4  947          + TR 0      LV0
         943+15 1357          + LOAD MQ   D34          'V'
         944+ 5 1349          + SUB       ONE
         945+ 4  947          + TR 0      LV0
         946+15 1355          + LOAD MQ   D25          'M'
         947+14 1371 LV0      + STORE MQ  CHAR         TAG CHAR
         948+10  948          + R ADD     *            CLEAR CARD BUFFER
         949+ 1   53          + TR        CLRBUF 
         950+15 1371          + LOAD MQ   CHAR
         951+10  951          + R ADD     *            PRINT TAG (CHAR)
         952+ 1   63          + TR        PRTCHR
         953+ 0    3          + STOP      0003         COLUMN 
         954+15 1132          + LOAD MQ   RELADDR
         955+10  955          + R ADD     *            PRINT REL 1ST (INTEGER)
         956+ 1   61          + TR        PRTINT
         957+ 0    4          + STOP      0004         LEN
         958+ 0    5          + STOP      0005         COLUMN 
         959+10 1124          + R ADD     LEN
         960+ 5 1350          + SUB       TWO
         961+ 4  971          + TR 0      LVPR1        TR IS SCALAR (NO NEED TO PRINT LOC LAST)
         962+10 1132          + R ADD     RELADDR
         963+ 9 1124          + ADD       LEN
         964+ 5 1350          + SUB       TWO
         965+12 1362          + STORE     LOC2
         966+15 1362          + LOAD MQ   LOC2
         967+10  967          + R ADD     *            PRINT LOC LAST (INTEGER)
         968+ 1   61          + TR        PRTINT
         969+ 0    4          + STOP      0004         LEN
         970+ 0   10          + STOP      0010         COLUMN 
         971+ 8    0 LVPR1    + NOOP      0000
         972+10 1123          + R ADD     VTYPE        VAR TYPE. 1=SCALAR, 2=VECTOR, 3=MATRIX
         973+ 5 1349          + SUB       ONE
         974+ 4  994          + TR 0      LVPRSC       TR TO PRINT SCALAR VAR NAME
         975+ 5 1349          + SUB       ONE
         976+ 4 1007          + TR 0      LVPRVE       TR TO PRINT VECTOR
         977+15 1120          + LOAD MQ   VARNAME      PRINT MATRIX VAR NAME
         978+10  978          + R ADD     *            CANNOT HAVE DEFINITIVE SUBSCRIPTS
         979+ 1   59          + TR        PRTALF
         980+ 0   15          + STOP      0015         COLUMN 
         981+10 1127          + R ADD     D2
         982+22    1          + A LEFT    0001
         983+21   35          + L RIGHT   0035         UNDER "S1" LABEL, THE PRINTED VALUE FOR MATRIX IS IN FACT D1=2*dimension 2
         984+10  984          + R ADD     *            THIS IS THE VALUE THAT WILL BE USED ON "ID" STATEMENTS WHEN SENDING THE DIMENSION 
         985+ 1   61          + TR        PRTINT
         986+ 0    4          + STOP      0004         LEN
         987+ 0   20          + STOP      0020         COLUMN 
         988+15 1350          + LOAD MQ   TWO          UNDER "S2" LABEL, THE PRINTED VALUE IS IN FACT D2. ON A MATRIX, THIS IS ALLWAYS 2
         989+10  989          + R ADD     *            THIS IS THE VALUE THAT WILL BE USED ON "ID" STATEMENTS WHEN SENDING THE DIMENSION 
         990+ 1   61          + TR        PRTINT
         991+ 0    2          + STOP      0002         LEN
         992+ 0   28          + STOP      0028         COLUMN 
         993+ 1 1020          + TR        LVPRQ
         994+15 1120 LVPRSC   + LOAD MQ   VARNAME      PRINT SCALAR VAR NAME
         995+10  995          + R ADD     *            CAN HAVE 2 DEFINITIVE SUBSCRIPTS
         996+ 1   59          + TR        PRTALF
         997+ 0   15          + STOP      0015         COLUMN 
         998+15 1121          + LOAD MQ   VARNAM1
         999+10  999          + R ADD     *     
        1000+ 1   59          + TR        PRTALF
        1001+ 0   21          + STOP      0021         COLUMN 
        1002+15 1122          + LOAD MQ   VARNAM2
        1003+10 1003          + R ADD     *     
        1004+ 1   59          + TR        PRTALF
        1005+ 0   27          + STOP      0027         COLUMN 
        1006+ 1 1020          + TR        LVPRQ
        1007+15 1120 LVPRVE   + LOAD MQ   VARNAME      PRINT VECTOR VAR NAME
        1008+10 1008          + R ADD     *            CAN HAVE 1 DEFINITIVE SUBSCRIPT
        1009+ 1   59          + TR        PRTALF
        1010+ 0   15          + STOP      0015         COLUMN 
        1011+15 1121          + LOAD MQ   VARNAM1
        1012+10 1012          + R ADD     *     
        1013+ 1   59          + TR        PRTALF
        1014+ 0   21          + STOP      0021         COLUMN 
        1015+15 1350          + LOAD MQ   TWO          UNDER "S2" LABEL, THE PRINTED VALUE IS IN FACT D1. ON A VECTOR, THIS IS ALLWAYS 2
        1016+10 1016          + R ADD     *            THIS IS THE VALUE THAT WILL BE USED ON "ID" STATEMENTS WHEN SENDING THE DIMENSION 
        1017+ 1   61          + TR        PRTINT
        1018+ 0    2          + STOP      0002         LEN
        1019+ 0   28          + STOP      0028         COLUMN 
        1020+15 1125 LVPRQ    + LOAD MQ   Q
        1021+10 1021          + R ADD     *     
        1022+ 1   61          + TR        PRTINT
        1023+ 0    2          + STOP      0002         LEN
        1024+ 0   32          + STOP      0032         COLUMN 
        1025+10 1131          + R ADD     CTYPE        CONSTRAINT VAR TYPE. 0=NONE, 1=SYN, 2=IMS, 3=SUC, 9=REL
        1026+ 4 1059          + TR 0      LVPREND
        1027+15 1128          + LOAD MQ   CONSTR       PRINT SCALAR VAR NAME
        1028+10 1028          + R ADD     *            CAN HAVE 2 DEFINITIVE SUBSCRIPTS
        1029+ 1   59          + TR        PRTALF
        1030+ 0   37          + STOP      0037         COLUMN 
        1031+15 1129          + LOAD MQ   CONSTR1
        1032+10 1032          + R ADD     *     
        1033+ 1   59          + TR        PRTALF
        1034+ 0   43          + STOP      0043         COLUMN 
        1035+15 1130          + LOAD MQ   CONSTR2
        1036+10 1036          + R ADD     *     
        1037+ 1   59          + TR        PRTALF
        1038+ 0   49          + STOP      0049         COLUMN 
        1039+10 1131          + R ADD     CTYPE        CONSTRAINT VAR TYPE. 0=NONE, 1=SYN, 2=IMS, 3=SUC, 9=REL
        1040+ 5 1353          + SUB       D9
        1041+ 4 1052          + TR 0      LVREL        TR IF CONSTRAINT IS REL
        1042+10 1131          + R ADD     CTYPE
        1043+ 5 1349          + SUB       ONE
        1044+ 9 1051          + ADD       CTYTXTAD
        1045+13 1046          + STORE A   LVCONS
        1046+15    0 LVCONS   + LOAD MQ   /   /
        1047+10 1047 LVCONS2  + R ADD     *            PRINT CONSTRAINT TYPE 
        1048+ 1   59          + TR        PRTALF
        1049+ 0   54          + STOP      0054         COLUMN 
        1050+ 1 1059          + TR        LVPREND
        1051+ 0 1489 CTYTXTAD + STOP      ALFSYN
        1052+15 1132 LVREL    + LOAD MQ   RELADDR
        1053+10 1053          + R ADD     *            PRINT LOC (INTEGER)
        1054+ 1   61          + TR        PRTINT
        1055+ 0    4          + STOP      0004         LEN
        1056+ 0   58          + STOP      0058         COLUMN 
        1057+15 1492          + LOAD MQ   ALFREL
        1058+ 1 1047          + TR        LVCONS2
        1059+10 1059 LVPREND  + R ADD     *            PRINT CARD BUFFER
        1060+ 1   57          + TR        PRINTCRD
        1061+ 1  930          + TR        LVLOOP
        1062+10 1136 LVLOEND  + R ADD     RELNUM0
        1063+ 4 1071          + TR 0      LISTEX       NO "NUM nnnn" CONSTRAINT SET -> VAR LISTING TERMINATED
        1064+10 1064          + R ADD     *            IF "NUM nnnn" CONSTRAINT SET -> PRINT IT AT END OF VAR LIST
        1065+ 1   55          + TR        PRTNLINE     
        1066+ 0  154          + STOP      0154         STRINGZ AT COL 54
        1067+ 0 1487          + STOP      MSGNUM       'NUM'
        1068+ 0  256          + STOP      0256         INT AT COL 56
        1069+ 0 1136          + STOP      RELNUM0      REL LOCATION OF START OF NUMBERS
        1070+ 0    0          + STOP      0000         END OF LINE. 
        1071+ 1    0 LISTEX   + TR        /   /        RETURN TO CALLER
        1072+30   74 DONE     + SENSE     0074         SENSE SWITCH 6
        1073+ 1 1081          + TR        ENDLOG1B     TR IF NO LOG SELECTED
        1074+10 1074          + R ADD     *            
        1075+ 1   55          + TR        PRTNLINE     
        1076+ 0  101          + STOP      0101         STRINGZ AT COL 1
        1077+ 0 1442          + STOP      MSGVEXT      "VAR EXT"
        1078+ 0  215          + STOP      0215         INT AT COL 15
        1079+ 0 1138          + STOP      V.EXT        HI REL ADDR OF VARS
        1080+ 0    6          + STOP      0006
        1081+ 8    0 ENDLOG1B + NOOP      0000
        1082+10 1082          + R ADD     *
        1083+ 1  912          + TR        LISTVARS     LIST PACT PROGRAM VARIABLES
        1084+10 1084          + R ADD     *
        1085+ 1   65          + TR        RWDRUM       WRITE RELNUM0, NVARS AND V.EXT TO DRUM
        1086+26  130          + WRITE     0130         DRUM INSTR
        1087+ 0    0          + STOP      0000         DRUM ADDR 
        1088+ 0 1136          + STOP      RELNUM0      ADDR OF DATA TO SAVE
        1089+ 0    4          + STOP      0004         4 HALF WORDS
        1090+10 1090          + R ADD     *
        1091+ 1   51          + TR        CHAIN        IF SW2 IS ON, A +STOP 4095 IS EXECUTED 
        1092+ 0  256          + STOP      PACTCOMP     CHAIN TO NEXT STAGE IN PACT COMPILER TAPE
        1093+ 0 4095          + STOP      4095
        1094+ 9 1350 ERROR    + ADD       TWO
        1095+13 1096          + STORE A   ERRP1
        1096+10    0 ERRP1    + R ADD     /   /
        1097+13 1117          + STORE A   ERRSTRZ      SAVE ADDR OF ERROR TXT MESSAGE
        1098+10 1098          + R ADD     *            PRINT CURRENT VAR POINTED BY NVAR
        1099+ 1  227          + TR        GETVAR
        1100+ 0 1368          + STOP      NVAR
        1101+10 1101          + R ADD     *
        1102+ 1   55          + TR        PRTNLINE     
        1103+ 0  101          + STOP      0101         STRINGZ AT COL 1
        1104+ 0 1446          + STOP      MSGVAR       "VAR "
        1105+ 0  201          + STOP      0201         INT AT COL 1
        1106+ 0 1368          + STOP      NVAR
        1107+ 0  508          + STOP      0508         ALF AT COL 8
        1108+ 0 1120          + STOP      VARNAME
        1109+ 0  511          + STOP      0511         ALF AT COL 11
        1110+ 0 1121          + STOP      VARNAM1
        1111+ 0  514          + STOP      0514         ALF AT COL 14
        1112+ 0 1122          + STOP      VARNAM2
        1113+ 0    0          + STOP      0000
        1114+10 1114          + R ADD     *
        1115+ 1   55          + TR        PRTNLINE     
        1116+ 0  101          + STOP      0101         STRINGZ AT COL 1
        1117+ 0    0 ERRSTRZ  + STOP      /   /        ERROR MESSAGE
        1118+ 0    0          + STOP      0000         END OF LINE. PRINT ALLWAYS
        1119+ 0 1119 ERRLOOP  + STOP      ERRLOOP      VARIABLE ERROR ARE NT RESTARTABLE
        1120+     0  VARNAME    DEF       0            VARIABLE NAME
        1121+     0  VARNAM1    DEF       0            
        1122+     0  VARNAM2    DEF       0            
        1123+     0  VTYPE      DEF       0            VAR TYPE. 1=SCALAR, 2=VECTOR, 3=MATRIX
        1124+     0  LEN        DEF       0            HALF-WORD USED BY VARS
        1125+     0  Q          DEF       0
        1126+     0  D1         DEF       0            DIMENSIONS
        1127+     0  D2         DEF       0
        1128+     0  CONSTR     DEF       0            CONSTRAINT VAR NAME
        1129+     0  CONSTR1    DEF       0
        1130+     0  CONSTR2    DEF       0
        1131+     0  CTYPE      DEF       0            CONSTRAINT VAR TYPE. 0=NONE, 1=SYN, 2=IMS, 3=SUC, 9=REL
        1132+     0  RELADDR    DEF       0            RELATIVE ADDR IN VAR POOL
        1133+     0  PHASE      DEF       0
        1134+     0  FLAG       DEF       0
        1135+     0  SIZE       DEF       0            NUM OF HALF-WORDS NEEDED TO ACCOMODATE LEN USED BY SUB-CHAINS VARIABLES
        1136+     0  RELNUM0    DEF       0            REL NUM ORIGIN
        1137+     0  NVARS      DEF       0            NUMBER OF VARS DEFINED
        1138+     0  V.EXT      DEF       0            EXTENSION (=SIZE IN HALF WORDS) OF VARIABLE REGION (IS EVEN)
        1139+     0  DUMMY      DEF       0            DUMMY VAR TO KEEP FNDVAR AT EVEN LOCATION
        1140+     0  FNDVAR     DEF       0            TEMP ON VAR SEARCH (SHOULD BE AT EVEN ADDR)
        1141+     0  FNDVAR1    DEF       0            TEMP ON VAR SEARCH
        1142+     0  FNDVAR2    DEF       0            TEMP ON VAR SEARCH
        1143+     0  FNDCTYPE   DEF       0            TEMP ON VAR SEARCH
        1144+     0  HASH       RES       200          VARIABLES NAMES HASH TABLE (199 ENTRIES)
        1344+     0  DATA       DEF       0
        1345+     0  DATA2      DEF       0
        1346+   341  MAXNVARS   DEF       341          MAX VARIABLES THAT CAN DE DEFINED IN ONE PROGRAM 
        1347+     0  ZERO       DEF       0
        1348+     0             DEF       0
        1349+     1  ONE        DEF       1
        1350+     2  TWO        DEF       2
        1351+     3  D3         DEF       3
        1352+     8  D8         DEF       8
        1353+     9  D9         DEF       9
        1354+    10  D10        DEF       10
        1355+    25  D25        DEF       25
        1356+    31  D31        DEF       31
        1357+    34  D34        DEF       34
        1358+   199  D199       DEF       199
        1359+  4094  D4094      DEF       4094
        1360+     0  MAXPHASE   DEF       0            MAX NUMBER OF PHASES DEFINED
        1361+     0  LOC        DEF       0
        1362+     0  LOC2       DEF       0
        1363+     0  HI         DEF       0
        1364+     0  HI2        DEF       0
        1365+     0  PHA        DEF       0            CURRENT PHASE BEING SCANNED
        1366+     0  NPREV      DEF       0            
        1367+     0  IVAR       DEF       0            INDEX ON VARS NUMBER
        1368+     0  NVAR       DEF       0            INDEX ON VARS NUMBER
        1369+     0  N          DEF       0            TEMP
        1370+     0  NVARSIZE   DEF       0            TEMP
        1371+     0  CHAR       DEF       0            TEMP
        1372+     0  HASHFLAG   DEF       0
        1373+     0  LSTSIZE    DEF       0            LAST PROCESSED VAR SIZE
        1374- 58926  ERRPHAOV   TXT       "MORE THAN 10 PHASES",0       NVAR IS THE OFFENDING VAR
        1375- 39200  
        1376- 46730  
        1377-    58  
        1378-  1364  
        1379- 31457  
        1380- 71424  
        1381+     0  
        1382- 35882  ERRCONSF   TXT       "CONSTRAINT NOT FOUND",0
        1383- 72990  
        1384- 30986  
        1385- 73754  
        1386- 63744  
        1387- 42801  
        1388- 60672  
        1389+     0  
        1390- 35882  ERRCONSL   TXT       "CONSTRAINT LOOP",0 
        1391- 72990  
        1392- 30986  
        1393- 73752  
        1394- 63532  
        1395+     0  
        1396- 78990  ERRSTOOV   TXT       "VARIABLES OVERFLOWS HI-SPEED STORAGE",0
        1397- 49022  
        1398- 56143  
        1399-  1330  
        1400- 40626  
        1401- 56627  
        1402- 71444  
        1403- 48943  
        1404- 65345  
        1405- 36895  
        1406- 75054  
        1407- 30881  
        1408+     0  
        1409- 35881  MSGSTART   TXT       "COMPUTE VARS LOCATION",0
        1410- 66128  
        1411- 39202  
        1412- 31423  
        1413-  1179  
        1414- 35216  
        1415- 49706  
        1416+     0  
        1417- 78990  MSGPASS1   TXT       "VAR PASS1",0
        1418-  1357  
        1419- 72913  
        1420+     0  
        1421- 78990  MSGPASS2   TXT       "VAR PASS2",0
        1422-  1357  
        1423- 72914  
        1424+     0  
        1425- 78990  MSGPASS3   TXT       "VAR PASS3",0
        1426-  1357  
        1427- 72915  
        1428+     0  
        1429-     0  MSGHDV     TXT       "   NUM NAME      PH SIZE  LOC  LEN",0
        1430- 61513  
        1431-  1261  
        1432- 58416  
        1433-     0  
        1434-    28  
        1435- 46111  
        1436- 50225  
        1437-    24  
        1438- 62928  
        1439-  1169  
        1440- 59904  
        1441+     0  
        1442- 78990  MSGVEXT    TXT       "VAR EXT",0
        1443-   852  
        1444- 73728  
        1445+     0  
        1446- 78990  MSGVAR     TXT       "VAR",0
        1447+     0  
        1448- 74371  MSGHDLV1   TXT       "TAG  REL.LOC. VARIABLE              CONSTRAINT",0                                                         
        1449-    30  
        1450- 40363  
        1451- 56607  
        1452- 99106  
        1453- 31413  
        1454- 30648  
        1455- 39168  
        1456-     0  
        1457-     0  
        1458-     0  
        1459-     0  
        1460- 35882  
        1461- 72990  
        1462- 30986  
        1463- 73728  
        1464+     0  
        1465-     0  MSGHDLV2   TXT       "    1ST  LAST FACT.  S1    S2   Q   FACT.  S1    S2  TYPE LOC.",0
        1466-    79  
        1467- 73728  
        1468- 55951  
        1469- 73746  
        1470- 30704  
        1471- 99072  
        1472- 71472  
        1473-     0  
        1474- 71520  
        1475-    29  
        1476-     0  
        1477- 42111  
        1478- 75792  
        1479-  1489  
        1480-     0  
        1481-  1490  
        1482-    32  
        1483- 86609  
        1484-  1179  
        1485- 36624  
        1486+     0  
        1487- 61513  MSGNUM     TXT       "NUM",0
        1488+     0  
        1489- 73226  ALFSYN     TXT       'SYN'
        1490- 49615             TXT       'IMS'
        1491- 73023             TXT       'SUC'
        1492- 69960  ALFREL     TXT       'REL'
        1494+15 1508 CLRBUF   + LOAD MQ   IOCL
        1495+14 1513          + STORE MQ  BUFIO
        1496+15 1534          + LOAD MQ   IOSTORE         
        1497+ 1 1505          + TR        INIT2
        1498+15 1530 READCRD  + LOAD MQ   IORDCRD
        1499+ 1 1503          + TR        INIT1
        1500+15 1532 WRITECRD + LOAD MQ   IOWRCRD
        1501+ 1 1503          + TR        INIT1
        1502+15 1533 PRINTCRD + LOAD MQ   IOPRCRD
        1503+14 1513 INIT1    + STORE MQ  BUFIO
        1504+15 1531          + LOAD MQ   IOCOPY         
        1505+14 1514 INIT2    + STORE MQ  BUFROW
        1506+ 9 1540          + ADD       TWO          
        1507+13 1529          + STORE A   EXIT
        1508+10 1536 IOCL     + R ADD     ZERO         RESET TO INITIAL COPY LOOP ADDRESS     
        1509+13 1514          + STORE A   BUFROW       FOR BUFFER
        1510+10 1514          + R ADD     BUFROW       X .*echo Print
        1511+ 5 1541          + SUB       D48          X 
        1512+12 1538          + STORE     ENDLP        X LOOP END VALUE
        1513- 0    0   BUFIO  - STOP      /   /        READ OR WRITE
        1514-31    0   BUFROW - COPY      /   /        COPY WORD TO/FROM PRINTER/CARDREADER
        1515+ 1 1519          + TR        BUFOK2       NORMAL PROCESSING 
        1516+ 1 1526          + TR        EODECK       FOR COPY READING END OF REG (=END OF DECK BEING READ)
        1517+ 6 1540          + R SUB     TWO          END OF FILE -> NO CARD TO READ -> STOP with Acc=-2
        1518+ 0 1513          + STOP      BUFIO        ON PRESSING START RETRY CARD READ
        1519+10 1514   BUFOK2 + R ADD     BUFROW       X
        1520+ 5 1540          + SUB       TWO          INCR BUF ADDR
        1521+13 1514          + STORE A   BUFROW       X
        1522+ 5 1538          + SUB       ENDLP        CHECK FOR END
        1523+ 4 1528          + TR 0      ENDIO
        1524+10 1536          + R ADD     ZERO         CLEAR ACC IN CASE WE ARE CLEANING THE BUFFER
        1525+ 1 1514          + TR        BUFROW
        1526+10 1539 EODECK   + R ADD     ONE          SET OV FLAG TO SIGNAL END OF DECK CONDITION
        1527+22   36          + A LEFT    36
        1528+26 2052 ENDIO    + WRITE     2052         END OF I/O: INSURE THAT MQ NOT IN USE            
        1529+ 1    0 EXIT     + TR        /   /
        1530+24 2048 IORDCRD  + READ      2048         PREPARE TO READ FROM CARD READER
        1531-31    0 IOCOPY   - COPY      /   /   
        1532+26 1024 IOWRCRD  + WRITE     1024         PREPARE TO PUNCH CARD 
        1533+26  512 IOPRCRD  + WRITE     0512         PREPARE WRITE PRTBUF ON PRINTER
        1534-12    0 IOSTORE  - STORE     /   /        CLEAR BUFFER
        1535+     0             ORG       EVEN           
        1536+     0  ZERO       DEF       0            
        1537+     0             DEF       0            
        1538+     0  ENDLP      DEF       0            LOOP END VALUE
        1539+     1  ONE        DEF       1
        1540+     2  TWO        DEF       2
        1541+    48  D48        DEF       48
        1542+ 9 1813 PRTPARM2 + ADD       TWO          GET 2 PARAMS: LEN AND COL (EITHER VALUE OR VAR ADDR)
        1543+13 1562          + STORE A   PRTPRMEX
        1544+10 1552          + R ADD     PRTP1
        1545+ 9 1813          + ADD       TWO          PRINT PACKED TEXT FROM FULL-WORD VALUE IN MQ REGISTER 
        1546+13 1552          + STORE A   PRTP1        STORE ADDR OF FIRST PARAM (LEN)
        1547+ 9 1812          + ADD       ONE
        1548+13 1554          + STORE A   PRTP2        STORE ADDR OF SECOND PARAM (COL)
        1549+ 9 1812          + ADD       ONE
        1550+13 1629          + STORE A   EXIT
        1551-14 1802          - STORE MQ  NUM          SAVE VALUE TO PRINT PARAM MQ (NUM IS ALIASED TO TXT)
        1552+10    0   PRTP1  + R ADD     /   /        GET LEN: NUMBER OF CHARS TO PRINT (1..6)
        1553+12 1806          + STORE     LEN
        1554+10    0   PRTP2  + R ADD     /   /        GET COLUMN PARAM 1..72
        1555+ 3 1558          + TR +      PRTP4
        1556+13 1557          + STORE A   PRTP3        COL<0 -> INTERPRET COL AS LOC(COL) = ADDR OF COL VAR
        1557+10    0   PRTP3  + R ADD     /   /        READ VAR COL PASED AS PARAM
        1558+ 4 1629   PRTP4  + TR 0      EXIT         COL=0 -> EXIT
        1559+ 3 1561          + TR +      PRTP5
        1560+ 1 1629          + TR        EXIT         COL<0 -> EXIT
        1561+12 1612   PRTP5  + STORE     COL
        1562+ 1    0 PRTPRMEX + TR        /   /        RETURN TO CALLER
        1563+13 1552 PRTSTR   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        1564+10 1564          + R ADD     *            FOR PRINT STRINGZ FROM MEM
        1565+ 1 1542          + TR        PRTPARM2
        1566+12 1576          + STORE     COLSZ
        1567+10 1806          + R ADD     LEN          LEN IS IN FACT THE LOCATION WHERE THE STRING STARTS
        1568+13 1571          + STORE A   STRZAD
        1569+10 1629          + R ADD     EXIT
        1570+13 1584          + STORE A   STRZEX
        1571+10    0 STRZAD   + R ADD     /   /        GET HALF-WORD WITH NEXT 3 CHARS TO PRINT
        1572+ 4 1584          + TR 0      STRZEX       IF +0 -> END OF STRING (-0 DOES NOT TERMINATES THE STRING)
        1573+21   35          + L RIGHT   0035         MQ=3-CHARS TO PRINT
        1574+10 1574          + R ADD     *            
        1575+ 1 1586          + TR        PRTALF       PRINT 3 CHARS
        1576+ 0    0 COLSZ    + STOP      0000         COL 
        1577+10 1571 STRZ1    + R ADD     STRZAD       INCR STRING ADDRESS
        1578+ 9 1812          + ADD       ONE
        1579+13 1571          + STORE A   STRZAD
        1580+10 1576          + R ADD     COLSZ        INCR COLUMN
        1581+ 9 1814          + ADD       D3
        1582+13 1576          + STORE A   COLSZ
        1583+ 1 1571          + TR        STRZAD
        1584+ 3    0 STRZEX   + TR +      /   /        IF ZERO -> END OF STRING
        1585+ 1 1577          + TR        STRZ1
        1586+ 9 1813 PRTALF   + ADD       TWO          PRINT 3-PACKED CHARS IN MQ REGISTER 
        1587+14 1808          + STORE MQ  TXT          SAVE TEXT TO PRINT (IN LEFT HALF WORD)
        1588+13 1591          + STORE A   PRTAP2       STORE ADDR OF PARAM (COL)
        1589+ 9 1812          + ADD       ONE
        1590+13 1629          + STORE A   EXIT
        1591+10    0   PRTAP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        1592+ 3 1595          + TR +      PRTAP4
        1593+13 1594          + STORE A   PRTAP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        1594+10    0   PRTAP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        1595+12 1612   PRTAP4 + STORE     COL
        1596+10 1814          + R ADD     D3
        1597+12 1806          + STORE     LEN
        1598+10 1796 PRT1     + R ADD     ZERO         UNPACK LEFTMOST CHAR 
        1599+11 1808          + ADD AB    TXT          GET TEXT DISCARD SIGN
        1600+21   35          + L RIGHT   0035         MQ=Acc
        1601+10 1796          + R ADD     ZERO
        1602+18 1821          + DIV       D48X48
        1603+12 1808          + STORE     TXT          remainder=char to print, mq=c2 * 48 + c3 in right half-word
        1604+10 1796          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        1605+20   18          + L LEFT    0018         put c2 and c3 in left half-word of MQ to be saved in CHAR half word
        1606+14 1807          + STORE MQ  CHAR         CHAR TO PRINT
        1607+10 1807          + R ADD     CHAR 
        1608+ 4 1613          + TR 0      NXTCHR       IF BLANK PROCEED TO NEXT COL
        1609+21   35          + L RIGHT   0035         MQ=CHAR TO PRINT
        1610+10 1610          + R ADD     *            PRINT CHAR
        1611+ 1 1706          + TR        PRTCHR
        1612+ 0    0 COL      + STOP      0000         COL: COLUMN NUMBER TO PRINT (1..72)
        1613+10 1806 NXTCHR   + R ADD     LEN          DECR LEN COUNT
        1614+ 5 1812          + SUB       ONE
        1615+12 1806          + STORE     LEN
        1616+ 4 1629          + TR 0      EXIT         IF NO MORE CHARS TO PRINT EXIT
        1617+10 1612          + R ADD     COL          INCR COL POSITION
        1618+ 9 1812          + ADD       ONE
        1619+12 1612          + STORE     COL
        1620+ 5 1820          + SUB       D72          IF COL > 72 RETURN TO CALLER
        1621+ 4 1623          + TR 0      GNXTCHR      ELSE PROCEED WITH NEXT CHAR
        1622+ 3 1629          + TR +      EXIT
        1623+10 1796 GNXTCHR  + R ADD     ZERO         GET NEXT CHAR 
        1624+15 1808          + LOAD MQ   TXT
        1625+16 1819          + MPY       D48
        1626+22   17          + A LEFT    0017         GET RESULT IN LEFT HALF-WORD OF ACC
        1627+12 1808          + STORE     TXT
        1628+ 1 1598          + TR        PRT1         PROCEED TO PRINT CHAR
        1629+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        1630+13 1552 PRTOCT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        1631+10 1631          + R ADD     *            FOR PRINT OCTIONARY VALUE
        1632+ 1 1542          + TR        PRTPARM2
        1633+10 1806          + R ADD     LEN          LEN = OCTAL DIGITS TO PRINT
        1634+ 9 1612          + ADD       COL
        1635+ 5 1812          + SUB       ONE
        1636+12 1648          + STORE     COLN         COL POINTS TO LEAST SIGNIFICANT DIGIT
        1637+10 1802 PRTIOCG  + R ADD     NUM          GENERATE OCTINARY DIGIT
        1638+15 1796          + LOAD MQ   ZERO         CLEAR MQ
        1639+21   21          + L RIGHT   0021         3 LSB BITS OF LEFT HALF-WORD OF ACC TO MQ
        1640+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 3 BIT)
        1641+12 1802          + STORE     NUM          SAVE BACK NUM WITH RIGHTMOST OCTIONARY DIGIY EXTRACTED (NUM'=NUM/8)
        1642+10 1796          + R ADD     ZERO
        1643+20   21          + L LEFT    0021         LEFT HALF-WORD OF ACC IS NOW RIGHTMOST OCTINARY DIGIT EXTRACTED FROM NUM 
        1644+ 4 1662          + TR 0      PRTIOZ       TR IF THIS DIGIT IS ZERO TO PRINT A '0' (BASE48 CODE = 10) INSTEAD OF A BLANK (BASE48 CODE = 0)
        1645+21   35          + L RIGHT   0035         PUT DIGIT 1..9 TO PRINT IN MQ
        1646+10 1646 PRTOCTD  + R ADD     *            PRINT OCTINARY DIGIT
        1647+ 1 1706          + TR        PRTCHR
        1648+ 0    0 COLN     + STOP      0000
        1649+10 1648          + R ADD     COLN        DECR COL NUMBER TO PRINT NEXT DIGIT
        1650+ 5 1812          + SUB       ONE
        1651+12 1648          + STORE     COLN
        1652+10 1806          + R ADD     LEN          DECR COL NUMBER TO PRINT NEXT DIGIT
        1653+ 5 1812          + SUB       ONE
        1654+ 4 1629          + TR 0      EXIT         PRINTED LEN OCTINARY DIGITS -> EXIT
        1655+12 1806          + STORE     LEN
        1656+10 1802          + R ADD     NUM          IF NUM < 0, ADD SIGN BIT TO LEFTMOST DIGIT
        1657+ 3 1637          + TR +      PRTIOCG
        1658+10 1822          + R ADD     OCT04K       
        1659+ 5 1802          + SUB       NUM
        1660+12 1802          + STORE     NUM
        1661+ 1 1637          + TR        PRTIOCG
        1662+15 1815   PRTIOZ + LOAD MQ   D10          ACC=BASE48 CODE FOR '0'
        1663+ 1 1646          + TR        PRTOCTD      TR TO PRINT IT
        1664+13 1552 PRTINT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        1665+10 1665          + R ADD     *            FOR PRINT OCTIONARY VALUE
        1666+ 1 1542          + TR        PRTPARM2
        1667+10 1612          + R ADD     COL          PRINT DECIMAL NUMBER. VALUE OF LEN = DIGITS TO PRINT, NOT INCLUDING SIGN
        1668+ 9 1806          + ADD       LEN
        1669+ 5 1812          + SUB       ONE          
        1670+12 1691          + STORE     COLNI        COL POINTS TO END OF NUMBER
        1671+10 1796          + R ADD     ZERO
        1672+12 1805          + STORE     SGN          SIGN IS POSITIVE
        1673+10 1802          + R ADD     NUM
        1674+ 3 1679          + TR +      PRTINTG
        1675+ 6 1802          + R SUB     NUM          NUM IS NEGATIVE. CONVERT TO POSITIVE
        1676+12 1802          + STORE     NUM          AND SET SGN=1
        1677+10 1812          + R ADD     ONE
        1678+12 1805          + STORE     SGN          
        1679+10 1802 PRTINTG  + R ADD     NUM          GENERATE DECIMAL DIGIT
        1680+21   35          + L RIGHT   0035         MQ=Acc
        1681+10 1796          + R ADD     ZERO
        1682+18 1815          + DIV       D10
        1683+ 4 1704          + TR 0      PRTINZ
        1684+12 1807 PRTINTG2 + STORE     CHAR         acc=remainder=digit to print, mq=num/10
        1685+10 1796          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        1686+20   18          + L LEFT    0018         digit in left half-word of MQ to be saved in CHAR half word
        1687+14 1802          + STORE MQ  NUM 
        1688+15 1807          + LOAD MQ   CHAR 
        1689+10 1689 PRTINTD  + R ADD     *            PRINT DECIMAL DIGIT
        1690+ 1 1706          + TR        PRTCHR
        1691+ 0    0 COLNI    + STOP      0000
        1692+10 1691          + R ADD     COLNI        DECR COL NUMBER TO PRINT NEXT DIGIT
        1693+ 5 1812          + SUB       ONE
        1694+12 1691          + STORE     COLNI
        1695+10 1802          + R ADD     NUM          DO NOT CARE ABOUT LEN, JUST CHECK IF NUM=0 
        1696+ 4 1698          + TR 0      PRTINS       (SO NO MORE DIGITS REMAINS TO BE PRINTED)
        1697+ 1 1679          + TR        PRTINTG      NUM NOT FINISHED, PROCEED WITH NEXT DIGIT
        1698+10 1805 PRTINS   + R ADD     SGN
        1699+ 4 1629          + TR 0      EXIT         NO SIGN -> NUM FINISHED
        1700+10 1796          + R ADD     ZERO
        1701+12 1805          + STORE     SGN          CLEAR SGN FLAG
        1702+15 1816          + LOAD MQ   D11          BASE48 CODE FOR '-' (MINUS) CHAR
        1703+ 1 1689          + TR        PRTINTD      GO TO PRINT IT
        1704+10 1815   PRTINZ + R ADD     D10          ACC=BASE48 CODE FOR '0'
        1705+ 1 1684          + TR        PRTINTG2     TR TO PRINT IT
        1706+ 9 1813 PRTCHR   + ADD       TWO          PRINT CHAR IN MQ REGISTER 
        1707+14 1807          + STORE MQ  CHAR         SAVE CHAR TO PRINT (IN LEFT HALF WORD)
        1708+13 1712          + STORE A   PRTCP2       STORE ADDR OF PARAM (COL)
        1709+ 9 1812          + ADD       ONE
        1710+13 1790          + STORE A   PRTCEX
        1711+ 2 1712          + TR OV     PRTCP2       CLEAR OV JUST IN CASE
        1712+10    0   PRTCP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        1713+ 3 1716          + TR +      PRTCP4
        1714+13 1715          + STORE A   PRTCP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        1715+10    0   PRTCP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        1716+ 5 1812   PRTCP4 + SUB       ONE
        1717+12 1810          + STORE     N            N=COL-1 -> IN RANGE 0..71
        1718+ 3 1720          + TR +      PRTSA        IF N >= 0 PROCEED WITH BASE BUFFER ADDR CALCULATION
        1719+ 1 1790          + TR        PRTCEX       IF N<0 EXIT
        1720+10 1796    PRTSA + R ADD     ZERO         CARD BUFFER USES LOCATION 0..47
        1721+13 1809          + STORE A   PRTROWAD     DETERMINE ADDRESS OF LOWER ROW TO PRINT
        1722+10 1810          + R ADD     N
        1723+ 5 1818          + SUB       D36
        1724+ 3 1726          + TR +      PRTC0
        1725+ 1 1732          + TR        PRTC1
        1726+12 1810    PRTC0 + STORE     N            COL NOW 0..35 
        1727+ 5 1818          + SUB       D36
        1728+ 3 1790          + TR +      PRTCEX       IF COL >= 36 (IE COL PASSED AS PARAM > 72) THEN EXIT
        1729+10 1809          + R ADD     PRTROWAD
        1730+ 9 1813          + ADD       TWO
        1731+13 1809          + STORE A   PRTROWAD     SET BASE BUFFER ADDR 
        1732+10 1812    PRTC1 + R ADD     ONE          DETERMINE MASKCOL WITH MASK TO SET IN CARD BUFFER
        1733+21   53          + L RIGHT   53           SET RIGHTMOST BIT OF MQ TO 1 (SHIFT 35+18=53)
        1734+10 1817          + R ADD     D35
        1735+ 5 1810          + SUB       N
        1736+13 1738          + STORE A   PRTC2
        1737+10 1796          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW
        1738+20    0    PRTC2 + L LEFT    /   /        SHIFT MQ LEFT N PLACES
        1739+ 4 1742          + TR 0      PRTC3        IF ACC STILL ZERO -> MASKCOL VALID
        1740+ 6 1812          + R SUB     ONE          ACC NOT ZERO -> SHOULD GENERATE -0 TO SET SIGN BIT ON
        1741+21   72          + L RIGHT   0072         NOW MQ = -0 -> LEFTMOST BIT OF MQ SET
        1742-14 1798    PRTC3 - STORE MQ  MASKCOL
        1743+10 1796          + R ADD     ZERO         READ THE BITMAP OF CHAR 
        1744+11 1807          + ADD AB    CHAR         DISCARD SIGN OF CHAR, IF ANY
        1745+12 1807          + STORE     CHAR
        1746+ 5 1819          + SUB       D48
        1747+ 3 1790          + TR +      PRTCEX       IF CHAR >= 48 EXIT
        1748+10 1804          + R ADD     BITMAPAD     IF ADDR OF BASE48 BITMAP NOT COMPUTED
        1749+ 4 1791          + TR 0      GETBMP1      TR TO LOAD IT
        1750+ 9 1807  GETBMP2 + ADD       CHAR         READ THE BITMAP OF CHAR 
        1751+13 1752          + STORE A   PRTC4        INDICATES THE BITS TO SET IN SELECTED 
        1752+10    0    PRTC4 + R ADD     /   /        COLUMN OF CARD BUFFER 
        1753+12 1811          + STORE     BITS
        1754+ 6 1812          + R SUB     ONE
        1755+12 1810          + STORE     N            SET TO -1
        1756+10 1810    LOOP1 + R ADD     N            CURRENT ROW (STARTS AT ZERO) = OFFSET ON PRTROWAD     
        1757+ 9 1812          + ADD       ONE
        1758+12 1810          + STORE     N
        1759+10 1811          + R ADD     BITS         EXTRACT RIGHTMOST BIT OF LEFT HALF OF ACC TO MQ
        1760+ 4 1790          + TR 0      PRTCEX       NO MORE BITS -> EXIT
        1761+21   19          + L RIGHT   0019         LSB BIT OF LEFT HALF-WORD OF ACC TO MQ
        1762+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 1 BIT)
        1763+12 1811          + STORE     BITS         SAVE BACK BITS. LSB HAS BEEN EXTACTED, CONTENTS SHIFTED RIGHT ONE PLACE
        1764+10 1796          + R ADD     ZERO
        1765+20    1          + L LEFT    0001         PUT EXTACTED BIT BACK INTO ACC
        1766+ 4 1756          + TR 0      LOOP1        NO BIT 
        1767+10 1810          + R ADD     N            READ THE ROW N AT CARD BUFFER 
        1768+22    2          + A LEFT    0002         MULT N BY 4 AS THERE ARE 4 HALF WORDS PER ROW
        1769+ 9 1809          + ADD       PRTROWAD     
        1770+13 1772          + STORE A   PRTROWR
        1771+13 1788          + STORE A   PRTROWW
        1772-10    0  PRTROWR - R ADD     /   /        
        1773-12 1800          - STORE     ROW          CURRENT CONTENTS OF ROW
        1774-10 1798          - R ADD     MASKCOL      "OR" MASKCOL IN SELECTED ROW
        1775+ 3 1783          + TR +      PRTW2
        1776-10 1800          - R ADD     ROW 
        1777+ 4 1781          + TR 0      PRTW1         
        1778+10 1796          + R ADD     ZERO         MASKCOL IS MINUS ZERO AND ROW IS NOT-EMPTY (EITHER POSITIVE OR NEGATIVE) -> SET ROW AS NEGATIVE
        1779- 7 1800          - SUB AB    ROW 
        1780+ 1 1788          + TR        PRTROWW
        1781-10 1798    PRTW1 - R ADD     MASKCOL      MASKCOL IS MINUS ZERO AND ROW IS EMPTY -> SET ROW = MASKCOL = MINUS ZERO
        1782+ 1 1788          + TR        PRTROWW
        1783-10 1800    PRTW2 - R ADD     ROW          
        1784+ 3 1787          + TR +      PRTW3              
        1785- 5 1798          - SUB       MASKCOL      MASKCOL IS POSITIVE AND ROW IS NEGATIVE -> SUB MASKCOL FROM ROW
        1786+ 1 1788          + TR        PRTROWW
        1787- 9 1798    PRTW3 - ADD       MASKCOL      MASKCOL IS POSITIVE AND ROW IS POSITIVE OR EMPTY -> ADD MASKCOL TO ROW         
        1788-12    0  PRTROWW - STORE     /   /        ROW UPDTATE
        1789+ 1 1756          + TR        LOOP1        PROCEED TO NEXT ROW
        1790+ 1    0 PRTCEX   + TR        /   /
        1791+10 1791 GETBMP1  + R ADD     *
        1792+ 1   75          + TR        BMPAD        GET BASE48 CHARS BITMAP ADDRESS
        1793+12 1804          + STORE     BITMAPAD     
        1794+ 1 1750          + TR        GETBMP2      RETURN
        1795+     0             ORG       EVEN
        1796+     0  ZERO       DEF       0            
        1797+     0             DEF       0            
        1798+     0  MASKCOL    DEF       0
        1799+     0             DEF       0
        1800+     0  ROW        DEF       0
        1801+     0             DEF       0
        1802+     0  NUM        DEF       0
        1803+     0             DEF       0
        1804+     0  BITMAPAD   DEF       0
        1805+     0  SGN        DEF       0
        1806+     0  LEN        DEF       0
        1807+     0  CHAR       DEF       0
        1808+     0  TXT        DEF       0
        1809+     0  PRTROWAD   DEF       0
        1810+     0  N          DEF       0
        1811+     0  BITS       DEF       0
        1812+     1  ONE        DEF       1
        1813+     2  TWO        DEF       2
        1814+     3  D3         DEF       3
        1815+    10  D10        DEF       10
        1816+    11  D11        DEF       11
        1817+    35  D35        DEF       35
        1818+    36  D36        DEF       36
        1819+    48  D48        DEF       48
        1820+    72  D72        DEF       72
        1821+  2304  D48X48     DEF       2304
        1822+ 16384  OCT04K     DEF       *040000      BIT SIGN ON 5TH OCTINARY DIGIT
        1824+ 9 1899 PRTNLINE + ADD       TWO          PRINT A NEW LINE OF DATA
        1825+12 1902          + STORE     PARAM        SAVE PARAM LIST ADDR
        1826+10 1826          + R ADD     *            CLEAR CARD BUFFER
        1827+ 1   53          + TR        CLRBUF 
        1828+10 1902 GPARAM   + R ADD     PARAM        GET PARAM PAIR FMT/DATA
        1829+13 1834          + STORE A   P1
        1830+ 9 1898          + ADD       ONE
        1831+13 1838          + STORE A   P2
        1832+ 9 1898          + ADD       ONE
        1833+12 1902          + STORE     PARAM
        1834+10    0 P1       + R ADD     /   /
        1835+12 1904          + STORE     FMT
        1836+ 3 1838          + TR +      P2           IF FMT < 0 THEM SKIP THIS PAIR FMT/DATA
        1837+ 1 1828          + TR        GPARAM
        1838+10    0 P2       + R ADD     /   /
        1839+12 1864          + STORE     DATALOC      GET DATA ADDRESS PASED AS PARAM
        1840+13 1841          + STORE A   P2A
        1841+10    0 P2A      + R ADD     /   /
        1842+12 1903          + STORE     DATA         GET EFFECTIVE DATA
        1843+10 1897          + R ADD     ZERO
        1844+15 1904          + LOAD MQ   FMT
        1845+18 1901          + DIV       D100         ACC=REMAINDER=COL NUMBER, MQ=QUOTIEN=TYPE OF DATA
        1846+12 1905          + STORE     COL
        1847+10 1897          + R ADD     ZERO
        1848+20   18          + L LEFT    0018
        1849+14 1904          + STORE MQ  FMT
        1850+15 1903          + LOAD MQ   DATA
        1851+10 1855          + R ADD     TYPETRAD
        1852+ 9 1904          + ADD       FMT
        1853+13 1854          + STORE A   TYPETR
        1854+ 1    0 TYPETR   + TR        /   /        TR SELECTED ROUTINE
        1855+ 0 1856 TYPETRAD + STOP      TYPETRT      TYPE TRANSFER TABLE ADDRESS
        1856+ 1 1885 TYPETRT  + TR        EOL          FMT=0..6 (IE <100) -> END OF PARAM LIST -> END OF LINE 
        1857+ 1 1862          + TR        TYSTR        FMT=1 -> PRINT A STRINGZ
        1858+ 1 1867          + TR        TYINT        FMT=2 -> PRINT AN INT
        1859+ 1 1872          + TR        TYOCT        FMT=3 -> PRINT AN OCT
        1860+ 1 1877          + TR        TYCHR        FMT=4 -> PRINT A CHAR
        1861+ 1 1881          + TR        TYALF        FMT=5 -> PRINT A 3-CHR PACKED ALFA STRING
        1862+10 1862 TYSTR    + R ADD     *            PRINT STRINGZ
        1863+ 1   71          + TR        PRTSTR
        1864+ 0    0 DATALOC  + STOP      /   /
        1865- 0 1905          - STOP      COL          COLUMN WHERE TXT STARTS
        1866+ 1 1828          + TR        GPARAM
        1867+10 1867 TYINT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1868+ 1   61          + TR        PRTINT
        1869+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        1870- 0 1905          - STOP      COL          COLUMN WHERE TXT STARTS
        1871+ 1 1828          + TR        GPARAM
        1872+10 1872 TYOCT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1873+ 1   73          + TR        PRTOCT
        1874+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        1875- 0 1905          - STOP      COL          COLUMN WHERE TXT STARTS
        1876+ 1 1828          + TR        GPARAM
        1877+10 1877 TYCHR    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1878+ 1   63          + TR        PRTCHR
        1879- 0 1905          - STOP      COL          COLUMN WHERE TXT STARTS
        1880+ 1 1828          + TR        GPARAM
        1881+10 1881 TYALF    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1882+ 1   59          + TR        PRTALF
        1883- 0 1905          - STOP      COL          COLUMN WHERE TXT STARTS
        1884+ 1 1828          + TR        GPARAM
        1885+10 1905 EOL      + R ADD     COL          SEND CARD BUFFER TO PRINTER AND RETURN TO CALLER
        1886+ 4 1891          + TR 0      DOPRINT      =0 -> PRINT ALLWAYS (NO SENSE SW CHECK)
        1887+ 9 1900          + ADD       D68          =1..6 -> SENSE 69..74 = OPERATOR'S PANEL SENSE SWITCH 1..6
        1888+13 1889          + STORE A   CHKSW
        1889+30    0 CHKSW    + SENSE     /   /         
        1890+ 1 1893          + TR        RETURN       SW NOT AT ON POSITION
        1891+10 1891 DOPRINT  + R ADD     *            PRINT CARD BUFFER
        1892+ 1   57          + TR        PRINTCRD
        1893+10 1902 RETURN   + R ADD     PARAM        PARAM-1 IS THE RETURN ADDR      
        1894+ 5 1898          + SUB       ONE
        1895+13 1896          + STORE A   EXIT
        1896+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        1897+ 0    0 ZERO     + STOP      0000
        1898+ 0    1 ONE      + STOP      0001
        1899+ 0    2 TWO      + STOP      0002
        1900+ 0   68 D68      + STOP      0068
        1901+ 0  100 D100     + STOP      100
        1902+ 0    0 PARAM    + STOP      0000
        1903+ 0    0 DATA     + STOP      0000
        1904+ 0    0 FMT      + STOP      0000
        1905+ 0    0 COL      + STOP      0000
        1906+ 9 1920 BMPAD    + ADD       TWO
        1907+13 1909          + STORE A   EXIT
        1908+10 1910          + R ADD     BITMAPAD
        1909+ 1    0 EXIT     + TR        /   /
        1910+ 0 1912 BITMAPAD + STOP      BITMAP
        1911+     0             ORG       EVEN
        1912+     0  BITMAP     DEF       0              <blank>     0     <none>
        1913+   256             DEF       256               1        1       1        256          =  256   
        1914+   128             DEF       128               2        2       2        128          =  128   
        1915+    64             DEF       64                3        3       3         64          =   64   
        1916+    32             DEF       32                4        4       4         32          =   32   
        1917+    16             DEF       16                5        5       5         16          =   16   
        1918+     8             DEF       8                 6        6       6          8          =    8   
        1919+     4             DEF       4                 7        7       7          4          =    4   
        1920+     2  TWO        DEF       2                 8        8       8          2          =    2   
        1921+     1             DEF       1                 9        9       9          1          =    1   
        1922+   512             DEF       512               0       10       0        512          =  512   
        1923+  1024             DEF       1024              -       11       X       1024          = 1024   
        1924+  2048             DEF       2048              +       12       Y       2048          = 2048   
        1925+  2304             DEF       2304              A       13      Y-1        256+2048    = 2304   
        1926+  2176             DEF       2176              B       14      Y-2        128+2048    = 2176   
        1927+  2112             DEF       2112              C       15      Y-3         64+2048    = 2112   
        1928+  2080             DEF       2080              D       16      Y-4         32+2048    = 2080   
        1929+  2064             DEF       2064              E       17      Y-5         16+2048    = 2064   
        1930+  2056             DEF       2056              F       18      Y-6          8+2048    = 2056   
        1931+  2052             DEF       2052              G       19      Y-7          4+2048    = 2052   
        1932+  2050             DEF       2050              H       20      Y-8          2+2048    = 2050   
        1933+  2049             DEF       2049              I       21      Y-9          1+2048    = 2049   
        1934+  1280             DEF       1280              J       22      X-1        256+1024    = 1280   
        1935+  1152             DEF       1152              K       23      X-2        128+1024    = 1152   
        1936+  1088             DEF       1088              L       24      X-3         64+1024    = 1088   
        1937+  1056             DEF       1056              M       25      X-4         32+1024    = 1056   
        1938+  1040             DEF       1040              N       26      X-5         16+1024    = 1040   
        1939+  1032             DEF       1032              O       27      X-6          8+1024    = 1032   
        1940+  1028             DEF       1028              P       28      X-7          4+1024    = 1028   
        1941+  1026             DEF       1026              Q       29      X-8          2+1024    = 1026   
        1942+  1025             DEF       1025              R       30      X-9          1+1024    = 1025   
        1943+   640             DEF       640               S       31      0-2        128+512     = 640    
        1944+   576             DEF       576               T       32      0-3         64+512     = 576    
        1945+   544             DEF       544               U       33      0-4         32+512     = 544    
        1946+   528             DEF       528               V       34      0-5         16+512     = 528    
        1947+   520             DEF       520               W       35      0-6          8+512     = 520    
        1948+   516             DEF       516               X       36      0-7          4+512     = 516    
        1949+   514             DEF       514               Y       37      0-8          2+512     = 514    
        1950+   513             DEF       513               Z       38      0-9          1+512     = 513    
        1951+   578             DEF       578               ,       39      8-3-0        2+64+512  = 578    
        1952+   546             DEF       546               %       40      8-4-0        2+32+512  = 546    
        1953+  1090             DEF       1090              $       41      8-3-X        2+64+1024 = 1090   
        1954+  1058             DEF       1058              *       42      8-4-X        2+32+1024 = 1058   
        1955+  2114             DEF       2114              .       43      8-3-Y        2+64+2048 = 2114   
        1956+  2082             DEF       2082              #       44      8-4-Y        2+32+2048 = 2082   
        1957+   768             DEF       768               /       45      0-1          512+256   = 768    
        1958+    66             DEF       66                +       46      8-3          2+64      = 66     
        1959+    34             DEF       34                -       47      8-4          2+32      = 34    This is the non-minus-sign separator
        1960+ 9 2033 RWDRUM   + ADD       TWO 
        1961+13 1970          + STORE A   PDR1         PARM1: DRUM INSTR: READ/WRITE 0128  0129  0130  0131
        1962+ 9 2032          + ADD       ONE          
        1963+13 1972          + STORE A   PDR2         PARM2: DRUM ADDRESS (0..4094)
        1964+ 9 2032          + ADD       ONE          
        1965+13 1974          + STORE A   PDR3         PARM3: BUF START ADDRESS
        1966+ 9 2032          + ADD       ONE          
        1967+13 1976          + STORE A   PDR4         PARM4: LEN: NUMBER OF HALF-WORDS (MUST BE EVEN)
        1968+ 9 2032          + ADD       ONE          
        1969+13 2030          + STORE A   EXIT               
        1970+10    0 PDR1     + R ADD     /   /        GET DRUM INSTR
        1971+12 1978          + STORE     DRIO
        1972+10    0 PDR2     + R ADD     /   /        GET DRUM ADDR
        1973+13 1979          + STORE A   DRADDR
        1974+10    0 PDR3     + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1975+13 2017          + STORE A   RWCOPY    
        1976+10    0 PDR4     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        1977+12 2034          + STORE     LEN
        1978+ 0    0 DRIO     + STOP      /   /        INSTR: READ/WRITE 0128  0129  0130  0131
        1979+29    0 DRADDR   + SET DR    /   /
        1980+ 1 2013          + TR        LOOP
        1981+ 9 2033 RDTAPE   + ADD       TWO 
        1982+13 1989          + STORE A   PR1          PARM1: TAPE ADDRESS
        1983+ 9 2032          + ADD       ONE          
        1984+13 1991          + STORE A   PR2          PARM2: BUF START ADDRESS
        1985+ 9 2032          + ADD       ONE          
        1986+13 2030          + STORE A   EXIT
        1987+ 2 1988          + TR OV     CLOV1        CLEAR OV THAT MAY HAVE BEEN SET
        1988+ 8    0    CLOV1 + NOOP      0000
        1989+10    0 PR1      + R ADD     /   /        GET TAPE ADDR
        1990+13 1993          + STORE A   RTAPAD       TAPE UNITS: 0256  0257  0258  0259
        1991+10    0 PR2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1992+13 2017          + STORE A   RWCOPY    
        1993+24    0 RTAPAD   + READ      /   /
        1994+10 2031          + R ADD     ZERO
        1995+ 1 2015          + TR        LOOP1
        1996+ 9 2033 WRTAPE   + ADD       TWO 
        1997+13 2004          + STORE A   PW1          PARM1: TAPE ADDRESS
        1998+ 9 2032          + ADD       ONE          
        1999+13 2006          + STORE A   PW2          PARM2: BUF START ADDRESS
        2000+ 9 2032          + ADD       ONE          
        2001+13 2008          + STORE A   PW3          PARM3: BUF LEN
        2002+ 9 2032          + ADD       ONE          
        2003+13 2030          + STORE A   EXIT
        2004+10    0 PW1      + R ADD     /   /        GET TAPE ADDR
        2005+13 2012          + STORE A   WTAPAD       TAPE UNITS: 0256  0257  0258  0259
        2006+10    0 PW2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        2007+13 2017          + STORE A   RWCOPY    
        2008+10    0 PW3      + R ADD     /   /        GET ADDR OF LEN 
        2009+13 2010          + STORE A   PW3A
        2010+10    0 PW3A     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        2011+12 2034          + STORE     LEN
        2012+26    0 WTAPAD   + WRITE     /   /        PREPARE TO WRITE ON TAPE
        2013+10 2034 LOOP     + R ADD     LEN
        2014+ 4 2029          + TR 0      RWOK
        2015+ 5 2033 LOOP1    + SUB       TWO
        2016+12 2034          + STORE     LEN
        2017-31    0 RWCOPY   - COPY      /   /        WRITE BUFFER TO TAPE
        2018+ 1 2021          + TR        GO 
        2019+ 1 2025          + TR        EOF          END OF FILE
        2020+ 1 2027          + TR        EOR          END OF RECORD
        2021+10 2017 GO       + R ADD     RWCOPY
        2022+ 5 2033          + SUB       TWO
        2023+13 2017          + STORE A   RWCOPY
        2024+ 1 2013          + TR        LOOP
        2025+10 2032 EOF      + R ADD     ONE          SET OV FLAG TO SIGNAL END OF FILE CONDITION
        2026+22   36          + A LEFT    36
        2027+ 6 2034 EOR      + R SUB     LEN          RETURN NUMBER OF HALF-WORDS READ
        2028+ 5 2033          + SUB       TWO
        2029+26 2052 RWOK     + WRITE     2052         INSURE THAT MQ NOT IN USE            
        2030+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        2031+ 0    0 ZERO     + STOP      0000
        2032+ 0    1 ONE      + STOP      0001         
        2033+ 0    2 TWO      + STOP      0002         
        2034+     0  LEN        RES       1
        2036+ 9 2051 CHAIN    + ADD       TWO
        2037+13 2038          + STORE A   CHP1
        2038+10    0 CHP1     + R ADD     /   /        GET TAPE NUMBER
        2039+13 2046          + STORE A   TAPELOAD
        2040+30   70          + SENSE     0070         SENSE SWITCH 2                                  
        2041+ 1 2045 CONTAD   + TR        ENDSTOP      (ON POSITION MAKES SENSE OPCODE TO SKIP NEXT INSTR)
        2042+10 2041          + R ADD     CONTAD       IF SW2 IS ON, A +STOP 4095 IS EXECUTED.  
        2043+12 4095          + STORE     4095         IF THEN USER PRESS START, EXECUTION WILL BE RESUMED 
        2044+ 0 4095          + STOP      4095         AND CHAINED PROGRAM WILL BE LOADED AND EXECUTED
        2045+ 8    0 ENDSTOP  + NOOP      0000
        2046+24    0 TAPELOAD + READ      0000         
        2047-31    0 TL0      - COPY      0000         READ 1ST WORD OF SELF-LOADER FROM TAPE
        2048+ 1    0          + TR        0000         TR TO SELF-LOADER
        2049+ 0 2221          + STOP      2221         ERROR LOADING: UNEXPECTED END OF FILE
        2050+ 0 2222          + STOP      2222         ERROR LOADING: UNEXPECTED END OF RECORD 
        2051+ 0    2 TWO      + STOP      0002         ERROR LOADING: UNEXPECTED END OF FILE
          48-     0  ROUTINE INIT
          49+ 1  256 ENTRY POINT
          50-     0  ROUTINE CHAIN
          51+ 1 2036 ENTRY POINT
          52-     0  ROUTINE CLRBUF
          53+ 1 1494 ENTRY POINT
          54-     0  ROUTINE PRTNLINE
          55+ 1 1824 ENTRY POINT
          56-     0  ROUTINE PRINTCRD
          57+ 1 1502 ENTRY POINT
          58-     0  ROUTINE PRTALF
          59+ 1 1586 ENTRY POINT
          60-     0  ROUTINE PRTINT
          61+ 1 1664 ENTRY POINT
          62-     0  ROUTINE PRTCHR
          63+ 1 1706 ENTRY POINT
          64-     0  ROUTINE RWDRUM
          65+ 1 1960 ENTRY POINT
          66-     0  ROUTINE READCRD
          67+ 1 1498 ENTRY POINT
          68-     0  ROUTINE WRITECRD
          69+ 1 1500 ENTRY POINT
          70-     0  ROUTINE PRTSTR
          71+ 1 1563 ENTRY POINT
          72-     0  ROUTINE PRTOCT
          73+ 1 1630 ENTRY POINT
          74-     0  ROUTINE BMPAD
          75+ 1 1906 ENTRY POINT
          76-     0  ROUTINE RDTAPE
          77+ 1 1981 ENTRY POINT
          78-     0  ROUTINE WRTAPE
          79+ 1 1996 ENTRY POINT
        4094+    48  REGION ORIGIN TABLE LOCATION
        4095+   256  INITIAL REGION
           0+ 1  256          + TR        INIT         PROGRAM START
