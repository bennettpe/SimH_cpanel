        DEC
        NNNN OP ADDR COMMENTS
          84+ 9 2144 SRCHVAR  + ADD       TWO          SEARCH VAR 
          85+13   92          + STORE A   SRCHP1       PARAMS: ADDR OF VAR NAME TO SEARCH
          86+ 9 2143          + ADD       ONE
          87+13   97          + STORE A   SRCHP2
          88+ 9 2143          + ADD       ONE
          89+13  102          + STORE A   SRCHP3
          90+ 9 2143          + ADD       ONE
          91+13  157          + STORE A   SRCHVAEX     RETURN INDEX POS IN ACC
          92+10    0 SRCHP1   + R ADD     /   /        GET ADDR OF NAME     
          93+13  133          + STORE A   SRCHN0   
          94+13   95          + STORE A   SRCHP1A
          95+10    0 SRCHP1A  + R ADD     /   /
          96+12  910          + STORE     FNDVAR      
          97+10    0 SRCHP2   + R ADD     /   /        GET ADDR OF NAME1
          98+13  137          + STORE A   SRCHN1
          99+13  100          + STORE A   SRCHP2A
         100+10    0 SRCHP2A  + R ADD     /   /
         101+12  911          + STORE     FNDVAR1
         102+10    0 SRCHP3   + R ADD     /   /        GET ADDR OF NAME2
         103+13  141          + STORE A   SRCHN2
         104+13  105          + STORE A   SRCHP3A
         105+10    0 SRCHP3A  + R ADD     /   /
         106+12  912          + STORE     FNDVAR2
         107+10  107          + R ADD     *            GET THE HASH OF VAR BEING SEARCHED
         108+ 1  158          + TR        GETHASH
         109+ 9  167          + ADD       HASHAD       ADD HASH TABLE ADDR
         110+13  111          + STORE A   SRCHHA1
         111+10    0 SRCHHA1  + R ADD     /   /        GET HASH[HASH VARNAME] -> VAR NUMBER
         112+ 4  156          + TR 0      SRCHNFND     =0 -> VAR NOT IN HASH TABLE -> VAR NOT EXISTS
         113+12  889          + STORE     N
         114+ 5 2143          + SUB       ONE
         115+22    3          + A LEFT    0003         ADDR IN DRUM = 8*(NVAR -1)
         116+13  129          + STORE A   SRCHDRAD
         117+10 2143          + R ADD     ONE
         118+12 2156          + STORE     HASHFLAG     -> USING HASH VALUE
         119+ 1  126          + TR        SRCHTEST     TEST IF VAR FOUND USING HASH 
         120+10  889 SRCHLOOP + R ADD     N
         121+ 5  907          + SUB       NVARS
         122+ 4  156          + TR 0      SRCHNFND
         123+10  889          + R ADD     N
         124+ 9 2143          + ADD       ONE
         125+12  889          + STORE     N
         126+10  126 SRCHTEST + R ADD     *
         127+ 1   65          + TR        RWDRUM       READ VAR FROM DRUM
         128+24  128          + READ      0128         DRUM INSTR
         129+ 0    0 SRCHDRAD + STOP      /   /        DRUM ADDR 
         130+ 0  910          + STOP      FNDVAR
         131+ 0    4          + STOP      0004         GET 4 HALF-WORD. ONLY 3 ARE NEEDED (THE NAME), BUT NUMER OF HW WORDS READ SHOULD BE EVEN
         132+10  910          + R ADD     FNDVAR
         133+ 5    0 SRCHN0   + SUB       /   /
         134+ 4  136          + TR 0      SRCHV1
         135+ 1  143          + TR        NXTSRCH
         136+10  911 SRCHV1   + R ADD     FNDVAR1
         137+ 5    0 SRCHN1   + SUB       /   /
         138+ 4  140          + TR 0      SRCHV2
         139+ 1  143          + TR        NXTSRCH
         140+10  912 SRCHV2   + R ADD     FNDVAR2
         141+ 5    0 SRCHN2   + SUB       /   /
         142+ 4  154          + TR 0      SRCHFND      VAR FOUND
         143+10 2156 NXTSRCH  + R ADD     HASHFLAG     VAR NOT FOUND, SEARCH NEXT
         144+ 4  150          + TR 0      NXTSRCH2
         145+10 2141          + R ADD     ZERO
         146+12 2156          + STORE     HASHFLAG     VAR NOT FOUND USING HASH, START A SEQUENTIAL SEARCH
         147+12  889          + STORE     N
         148+13  129          + STORE A   SRCHDRAD
         149+ 1  120          + TR        SRCHLOOP 
         150+10  129 NXTSRCH2 + R ADD     SRCHDRAD
         151+ 9 2147          + ADD       D8
         152+13  129          + STORE A   SRCHDRAD
         153+ 1  120          + TR        SRCHLOOP
         154+10  889 SRCHFND  + R ADD     N
         155+ 1  157          + TR        SRCHVAEX
         156+10 2141 SRCHNFND + R ADD     ZERO
         157+ 1    0 SRCHVAEX + TR        /   /
         158+ 9 2144 GETHASH  + ADD       TWO          CALC HASH VALUE (0..198) FOR VARIABLE NAME FNDVAR, FNDVAR1, FNDVAR2
         159+13  166          + STORE A   GETHAEX      RETURN HASH IN ACC
         160+10 2141          + R ADD     ZERO
         161+11  910          + ADD AB    FNDVAR
         162+11  911          + ADD AB    FNDVAR1
         163+11  912          + ADD AB    FNDVAR2
         164+21   35          + L RIGHT   0035         MQ=ABS(VARIABLE FULL NAME)
         165+18 2152          + DIV       D199         DIV BY 199, ACC=REMINDER
         166+ 1    0 GETHAEX  + TR        /   /
         167+ 0  914 HASHAD   + STOP      HASH         HASH TABLE ADDRESS
         168+ 9 2144 SETNVARS + ADD       TWO          COMPUTE NVARS READING TABLE
         169+13  176          + STORE A   SETNVEX      STORED IN DRUM
         170+10  170          + R ADD     *
         171+ 1   65          + TR        RWDRUM       READ RELNUM0, NVARS AND V.EXT FROM DRUM
         172+24  130          + READ      0130         DRUM INSTR
         173+ 0    0          + STOP      0000         DRUM ADDR 
         174+ 0  906          + STOP      RELNUM0      ADDR OF DATA TO SAVE
         175+ 0    4          + STOP      0004         4 HALF WORDS
         176+ 1    0 SETNVEX  + TR        /   /        RETURN TO CALLER
         177+ 9 2144 GETVAR   + ADD       TWO          READ VAR RECORD FROM DRUM
         178+13  181          + STORE A   GVP1         RECORDS STARTS AT 1
         179+ 9 2143          + ADD       ONE
         180+13  200          + STORE A   GVEXIT
         181+10    0 GVP1     + R ADD     /   /        GET ADDR OF INDEX VAR
         182+13  183          + STORE A   GVP1A
         183+10    0 GVP1A    + R ADD     /   /        GET INDEX VALUE 1..MAXVARS       
         184+ 5 2143          + SUB       ONE          ADDRESS IN DRUM = (IVAR-1)*8 
         185+22    3          + A LEFT    0003      
         186+13  191          + STORE A   DRADDR1
         187+13  197          + STORE A   DRADDR2
         188+10  188          + R ADD     *
         189+ 1   65          + TR        RWDRUM       WRITE VAR RECORD TO DRUM
         190+24  128          + READ      0128         DRUM INSTR
         191+ 0    0 DRADDR1  + STOP      /   /        DRUM ADDR 
         192+ 0  890          + STOP      VARNAME      ADDR OF START OF FIRST HALF OF VAR RECORD
         193+ 0    8          + STOP      0008         8 HALF WORDS
         194+10  194          + R ADD     *
         195+ 1   65          + TR        RWDRUM       WRITE VAR RECORD TO DRUM
         196+24  129          + READ      0129         DRUM INSTR
         197+ 0    0 DRADDR2  + STOP      /   /        DRUM ADDR 
         198+ 0  898          + STOP      CONSTR       ADDR OF START OF SECOND HALF OF VAR RECORD
         199+ 0    8          + STOP      0008         8 HALF WORDS
         200+ 1    0 GVEXIT   + TR        /   /
         201+ 9 2144 LOADCC   + ADD       TWO          LOAD PACTSCR INTO CARD IMAGE SO 
         202+13  221          + STORE A   CPCCEX       CURRENT PACT SOURCE CODE CAN BE PRINTED
         203+10 2141          + R ADD     ZERO         COPY TO LEFT SIDE OF SOURCE CODE CARD IMAGE
         204+13  208          + STORE A   CPCC1        AT 0..46 FROM PACTSCR
         205+10  224          + R ADD     CPCC2
         206+13  207          + STORE A   CPCC 
         207-10    0 CPCC     - R ADD     /   /
         208-12    0 CPCC1    - STORE     /   /
         209+10  208          + R ADD     CPCC1
         210+ 5 2144          + SUB       TWO
         211+13  213          + STORE A   CPCC1B
         212+10 2141          + R ADD     ZERO
         213-12    0 CPCC1B   - STORE     /   /
         214+10  207          + R ADD     CPCC
         215+ 5 2144          + SUB       TWO
         216+13  207          + STORE A   CPCC
         217+10  208          + R ADD     CPCC1
         218+ 5 2145          + SUB       D4
         219+13  208          + STORE A   CPCC1
         220+ 5  223          + SUB       CPCCE
         221+ 4    0 CPCCEX   + TR 0      /   /        RETURN TO CALLER
         222+ 1  207          + TR        CPCC
         223-12   48 CPCCE    - STORE     0048         LAST LOCATION TO COPY FROM 
         224+ 8  844 CPCC2    + NOOP      PACTSRC      PACTSRC = FIRST LOCATION TO COPY FROM
         225+10  225 INIT     + R ADD     *            
         226+ 1   53          + TR        PRTNLINE     
         227+ 0  101          + STOP      0101         STRINGZ AT COL 1
         228+ 0 2313          + STOP      MSGSTART     "STORAGE ASSIGNEMENT"
         229+ 0  139          + STOP      0139         STRINGZ AT COL 39
         230+ 0 2322          + STOP      MSGSTAR2     "REL LOC.  Q"
         231+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         232+10  232          + R ADD     *            CLEAR TABLES
         233+ 1   67          + TR        CLMEM        TNUMPOOL
         234+ 0 1116          + STOP      TNUMPOOL
         235+ 0 2153          + STOP      D1024        = MAXNNUMS * 2
         236+10 2141          + R ADD     ZERO         CLEAR CC RECORD
         237+12  868          + STORE     REGION     
         238+12  869          + STORE     STEP       
         239+12  870          + STORE     OP         
         240+12  871          + STORE     FACT       
         241+12  872          + STORE     S1         
         242+12  873          + STORE     S2         
         243+12  874          + STORE     QR         
         244+12  875          + STORE     QF         
         245-12  876          - STORE     NUM        
         246+12  878          + STORE     CLUE       
         247+12  879          + STORE     STEPN      
         248+12  880          + STORE     FACTN      
         249+12  881          + STORE     FACTREG    
         250+12  882          + STORE     S1N        
         251+12  883          + STORE     S2N        
         252+12  884          + STORE     D1N        
         253+12  885          + STORE     D2N        
         254+12  886          + STORE     NINST      
         255+12  887          + STORE     NINCR 
         256+10  888          + R ADD     CCLEN        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         257+10 2141          + R ADD     ZERO         CLEAR VAR RECORD
         258+12  890          + STORE     VARNAME    
         259+12  891          + STORE     VARNAM1      NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         260+12  892          + STORE     VARNAM2      NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         261+12  893          + STORE     VTYPE        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         262+12  894          + STORE     LEN          NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         263+12  895          + STORE     Q          
         264+12  896          + STORE     D1         
         265+12  897          + STORE     D2         
         266+12  898          + STORE     CONSTR       NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         267+12  899          + STORE     CONSTR1      NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         268+12  900          + STORE     CONSTR2      NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         269+12  901          + STORE     CTYPE        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         270+12  902          + STORE     RELADDR    
         271+12  903          + STORE     PHASE        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         272+12  904          + STORE     FLAG         NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         273+12  905          + STORE     SIZE         NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         274+10  908          + R ADD     V.EXT        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         275+10 2140          + R ADD     MAXNVARS     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         276+10  913          + R ADD     DUMMY        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         277+10  277          + R ADD     *            
         278+ 1   65          + TR        RWDRUM       READ VARIABLE NAMES HASH TABLE FROM DRUM
         279+24  128          + READ      0128         DRUM INSTR
         280+ 0 3800          + STOP      3800         DRUM ADDR 
         281+ 0  914          + STOP      HASH         ADDR OF DATA TO SAVE
         282+ 0  200          + STOP      0200         200 HALF WORDS
         283+10  283          + R ADD     *            COMPUTE NVARS READING TABLE
         284+ 1  168          + TR        SETNVARS     STORED IN DRUM
         285+10 2141          + R ADD     ZERO
         286+12 1115          + STORE     NNUMS        INIT NUMBER POOL
         287+12  909          + STORE     N.EXT        SIZE OF NUMBER REGION
         288+28  258          + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE)
         289+28  257          + REWIND    TAPEOUT      REWIND TAPE OUT WITH UPDATED PACT COMPACT CODE
         290+ 8    0 READREG  + NOOP      0000
         291+10  291 READSTEP + R ADD     *            READ PACT USER PROGRAM SOURCE CODE FROM TAPE IN
         292+ 1   61          + TR        RDTAPE
         293+ 0  258          + STOP      TAPEIN
         294+ 0  844          + STOP      CCODE        BUF TO READ IN FROM TAPE
         295+ 2  768          + TR OV     EOF          TR IF END OF FILE
         296+10  870          + R ADD     OP
         297+ 4  761          + TR 0      EOR          TR IF END OF REGION
         298+10  298          + R ADD     *            LOAD PACTSCR INTO CARD IMAGE SO 
         299+ 1  201          + TR        LOADCC       CURRENT PACT SOURCE CODE CAN BE PRINTED
         300+10  881          + R ADD     FACTREG    
         301+ 5 2150          + SUB       D32          'T'
         302+ 4  353          + TR 0      NEXT         IF TEMP VAR -> NO VAR ASSIGNMENT NEEDED -> CONTINUE TO NEXT STEP
         303+10  870          + R ADD     OP           JUMP TABLE TO HANDLE THE FACTOR OF EACH TYPE OF PACT OPERATION
         304+ 9  307          + ADD       OPTBLE
         305+13  306          + STORE A   OPTBLETR
         306+ 1    0 OPTBLETR + TR        /   /
         307+ 0  307 OPTBLE   + STOP      *
         308+ 1  677          + TR        FACTVAR3     OP=1   TAKE   FACTOR CANNOT BE BLANK 
         309+ 1  493          + TR        FACTVAR      OP=2   ADD    ALLOWS BLANK FACTOR -> RSV: BEHAVES AS ACC=ACC+ACC
         310+ 1  493          + TR        FACTVAR      OP=3   SUB    ALLOWS BLANK FACTOR -> RSV: BEHAVES AS ACC=-ACC
         311+ 1  493          + TR        FACTVAR      OP=4   MUL    ALLOWS BLANK FACTOR -> RSV: BEHAVES AS ACC=ACC * ACC
         312+ 1  677          + TR        FACTVAR3     OP=5   DIV    FACTOR CANNOT BE BLANK -> RSV: DIV UNIARY IS A NON-SENSE, EVEN IF STATED AS ALLOWED ON MANUAL
         313+ 1  384          + TR        NOFACT       OP=6   RES    NO FACTOR ALLOWED
         314+ 1  670          + TR        FACTVAR2     OP=7   EQ     NEEDS VARIABLE AS FACTOR
         315+ 1  493          + TR        FACTVAR      OP=8   +ABS   ALLOWS BLANK FACTOR
         316+ 1  493          + TR        FACTVAR      OP=9   -ABS   ALLOWS BLANK FACTOR
         317+ 1  677          + TR        FACTVAR3     OP=10  ABS    FACTOR CANNOT BE BLANK 
         318+ 1  353          + TR        NEXT         OP=11  T      FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         319+ 1  353          + TR        NEXT         OP=12  TZ     FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         320+ 1  353          + TR        NEXT         OP=13  TP     FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         321+ 1  353          + TR        NEXT         OP=14  TN     FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         322+ 1  353          + TR        NEXT         OP=15  TF     FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         323+ 1  353          + TR        NEXT         OP=16  HALT   FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         324+ 1  401          + TR        INDEXVAR     OP=17  TEST   ALLOWS BLANK FACTOR
         325+ 1  401          + TR        INDEXVAR     OP=18  SET
         326+ 1  401          + TR        INDEXVAR     OP=19  USE
         327+ 1  353          + TR        NEXT         OP=20  DO     FACTOR=REGION -> NO VARIABLE FACTOR TO PROCESS    
         328+ 1  384          + TR        NOFACT       OP=21  EXIT   NO FACTOR ALLOWED
         329+ 1  352          + TR        BADOP2       OP=22  DUP    SHOULD NOT BE PRESENT. IT IS ALREADY PROCESSED
         330+ 1  353          + TR        NEXT         OP=23  LIB    FACTOR=REGION -> NO VARIABLE FACTOR TO PROCESS    
         331+ 1  351          + TR        BADOP        OP=24  ID     SHOULD NOT BE PRESENT. IT IS DESAMBIGUATED
         332+ 1  351          + TR        BADOP        OP=25  FOR    SHOULD NOT BE PRESENT. IT IS DESAMBIGUATED
         333+ 1  353          + TR        NEXT         OP=26  CALL   IGNORE FACTOR
         334+ 1  493          + TR        FACTVAR      OP=27  SIN    ALLOWS BLANK FACTOR
         335+ 1  493          + TR        FACTVAR      OP=28  COS    ALLOWS BLANK FACTOR
         336+ 1  493          + TR        FACTVAR      OP=29  ARCT   ALLOWS BLANK FACTOR
         337+ 1  493          + TR        FACTVAR      OP=30  SQRT   ALLOWS BLANK FACTOR
         338+ 1  493          + TR        FACTVAR      OP=31  LOG    ALLOWS BLANK FACTOR
         339+ 1  493          + TR        FACTVAR      OP=32  EXP    ALLOWS BLANK FACTOR
         340+ 1  392          + TR        S1INT        OP=33  SE     FACTOR IS BLANK, S1 IS INTEGER VALUE
         341+ 1  670          + TR        FACTVAR2     OP=34  CL     NEEDS VARIABLE AS FACTOR
         342+ 1  384          + TR        NOFACT       OP=35  READ   NO FACTOR ALLOWED
         343+ 1  384          + TR        NOFACT       OP=36  LIST   NO FACTOR ALLOWED
         344+ 1  384          + TR        NOFACT       OP=37  RES for MULT, NO FACTOR ALLOWED
         345+ 1  384          + TR        NOFACT       OP=38  RES for DIV, NO FACTOR ALLOWED
         346+ 1  493          + TR        FACTVAR      OP=39  ID for LIST         ALLOWS BLANK FACTOR
         347+ 1  687          + TR        FACTVAR4     OP=40  ID for DO/LIB       FACTOR CAN BE INTEGER OR VAR, CAN BE BLANK, IF IS INTEGER DO NOT ADD IT TO NUMBER POOL
         348+ 1  687          + TR        FACTVAR4     OP=41  ID for CALL         FACTOR CAN BE INTEGER OR VAR, CAN BE BLANK, IF IS INTEGER DO NOT ADD IT TO NUMBER POOL
         349+ 1  434          + TR        FORFACT      OP=42  FOR for DO/LIB
         350+ 1  434          + TR        FORFACT      OP=43  FOR for CALL
         351+ 0 1111 BADOP    + STOP      1111         INTERNAL COMPILER ERROR: SHOULD NOT BE PRESENT. IT SHOULD HAVE BEEN DESAMBIGUATED
         352+ 0 1111 BADOP2   + STOP      1111         INTERNAL COMPILER ERROR: SHOULD NOT BE PRESENT. IT IS ALREADY PROCESSED
         353+ 8    0 NEXT     + NOOP      0000         CONTINUE 
         354+30   74          + SENSE     0074         SENSE SWITCH 6
         355+ 1  372          + TR        ENDLOG1A     TR IF NO LOG SELECTED
         356+10  881          + R ADD     FACTREG
         357+ 4  372          + TR 0      ENDLOG1A     NO STORAGE ASSIGNED TO FACT
         358+15  881          + LOAD MQ   FACTREG
         359+10  359          + R ADD     *
         360+ 1   57          + TR        PRTCHR       PRINT FACTREG AT COL 40
         361+ 0   40          + STOP      0040
         362+15  880          + LOAD MQ   FACTN
         363+10  363          + R ADD     *
         364+ 1   55          + TR        PRTINT       PRINT FACTN AT COL 40
         365+ 0    6          + STOP      0006         LEN=6
         366+ 0   40          + STOP      0040
         367+15  875          + LOAD MQ   QF
         368+10  368          + R ADD     *
         369+ 1   55          + TR        PRTINT       PRINT FACTN AT COL 45
         370+ 0    3          + STOP      0003         LEN=6
         371+ 0   48          + STOP      0048
         372+ 8    0 ENDLOG1A + NOOP      0000
         373+10  373          + R ADD     *
         374+ 1   63          + TR        WRTAPE       WRITE MAGNETIC TAPE TAPEOUT (PACT COMPACT CODE)
         375+ 0  257          + STOP      TAPEOUT
         376+ 0  844          + STOP      CCODE        BUF TO WRITE TO TAPE
         377+ 0  888          + STOP      CCLEN        LEN
         378+30   74          + SENSE     0074         SENSE SWITCH 6
         379+ 1  382          + TR        ENDLOG1      TR IF NO LOG SELECTED
         380+10  380          + R ADD     *            PRINT STEP JUST PROCESSED
         381+ 1   59          + TR        PRINTCRD
         382+ 8    0 ENDLOG1  + NOOP      0000 
         383+ 1  291          + TR        READSTEP
         384+10  871 NOFACT   + R ADD     FACT         CHECK THERE IS NO FACTOR IN RES, LIST, READ, CALL, EXIT INSTRUCTIONS
         385+ 4  389          + TR 0      NF2          
         386+10  386 NF1      + R ADD     *            
         387+ 1  832          + TR        ERROR
         388+ 0 2157          + STOP      ERRNOFAC     ERROR: NO FACTOR ALLOWED ON THIS PACT INSTR
         389-10  876 NF2      - R ADD     NUM
         390+ 4  353          + TR 0      NEXT         PROCEED TO NEXT STEP AS FACTOR IS BLANK ANS NUMBER IS ALSO BLANK
         391+ 1  386          + TR        NF1
         392+10  871 S1INT    + R ADD     FACT         CHECK FACTOR IS BLANK, S1 IS INTEGER
         393+ 4  395          + TR 0      S1A
         394+ 1  386          + TR        NF1          TR TO ERROR NO FACTOR ALLOWED ON THIS PACT INSTR
         395+10  872 S1A      + R ADD     S1           CHECK THERE IS A >0 INTEGER NUMBER AS FACTOR IN SE (SENSE) INSTRUCTION
         396+ 4  398          + TR 0      S1C          TR IF S1=0 (IE BLANK)
         397+ 3  353          + TR +      NEXT         PROCEED TO NEXT STEP IF S1 IS INT NUMBER 
         398+10  398 S1C      + R ADD     *            
         399+ 1  832          + TR        ERROR
         400+ 0 2170          + STOP      ERRNOINT     ERROR: S1 MUST BE INTEGER
         401+10  871 INDEXVAR + R ADD     FACT         CHECK IF FACTOR HAS A VARIABLE (IE <0)
         402+ 3  406          + TR +      IDX1         NO -> PROCEED        
         403+10  403 IDXERR   + R ADD     *            YES -> ERROR
         404+ 1  832          + TR        ERROR
         405+ 0 2183          + STOP      ERRNOIDX     ERROR: USE/SET/TEST SYNTAX ERROR. SHOULD BE    [DESTINATION STEP]  ALFAINDEX  ALFAINDEX|ALFAVAR|NUM
         406-10  876 IDX1     - R ADD     NUM          CHECK IF THERE IS A NUMBER IN THE STEP
         407+ 4  409          + TR 0      IDX2         NO -> PROCEED
         408+ 1  403          + TR        IDXERR       YES -> TR TO ERROR
         409+10  872 IDX2     + R ADD     S1           CHECK IF S1 IS AN INDEX (SHOULD BE ALFA, IE <0)
         410+ 3  403          + TR +      IDXERR       S1 NOT ALFA -> TR TO ERROR
         411+10  873          + R ADD     S2           CHECK IF S2 IS NOT BLANK (SHOULD BE <>0)
         412+ 4  403          + TR 0      IDXERR       S2 IS BLANK -> TR TO ERROR
         413+10  873          + R ADD     S2
         414+ 3  429          + TR +      IDX3         S2>0 -> S2 IS A NUMBER, PROCEED
         415+10  415          + R ADD     *            
         416+ 1   84          + TR        SRCHVAR      S2<0 -> S2 IS A VAR OR INDEX -> SEARCH THE VAR. RETURN INDEX POS IN ACC
         417+ 0  873          + STOP      S2
         418+ 0 2141          + STOP      ZERO
         419+ 0 2141          + STOP      ZERO
         420+12 2154          + STORE     NVAR
         421+ 4  429          + TR 0      IDX3         IF S2 NOT FOUND AS A VAR -> S2 IS AN INDEX -> PROCEED LEAVING FACTN=0
         422+10  422          + R ADD     *            
         423+ 1  177          + TR        GETVAR
         424+ 0 2154          + STOP      NVAR
         425+10  902          + R ADD     RELADDR      S2 IS A VAR -> FACTN=VAR ADDRESS, FACTREG='V'
         426+12  880          + STORE     FACTN
         427+10 2151          + R ADD     D34          'V'
         428+12  881          + STORE     FACTREG
         429+10  872 IDX3     + R ADD     S1           PROPAGATE
         430+12  882          + STORE     S1N
         431+10  873          + R ADD     S2
         432+12  883          + STORE     S2N
         433+ 1  353          + TR        NEXT         
         434+10  871 FORFACT  + R ADD     FACT
         435+ 3  460          + TR +      FOR3
         436+ 1  446          + TR        FOR2         FACTOR IS ALFA -> FACTOR IS VAR OR INDEX
         437+10  437 S1NOVAR  + R ADD     *            
         438+ 1  832          + TR        ERROR
         439+ 0 2193          + STOP      ERRS1NOV     ERROR: S1 VARIABLE NOT FOUND
         440+10  440 S2NOVAR  + R ADD     *            
         441+ 1  832          + TR        ERROR
         442+ 0 2201          + STOP      ERRS2NOV     ERROR: S2 VARIABLE NOT FOUND
         443+10  443 S12NONUM + R ADD     *            
         444+ 1  832          + TR        ERROR
         445+ 0 2209          + STOP      ERRS12NN     ERROR: FOR INDEX USED: S1/S2 SHOULD BE A NUMBER
         446+10  446 FOR2     + R ADD     *            
         447+ 1   84          + TR        SRCHVAR      SEARCH FACT AS VARIABLE (WITHOUT DEFINITIVE SUBSCRIPTS)
         448+ 0  871          + STOP      FACT
         449+ 0 2141          + STOP      ZERO
         450+ 0 2141          + STOP      ZERO
         451+12 2154          + STORE     NVAR
         452+ 4  460          + TR 0      FOR3         IF FACT NOT FOUND AS A VAR -> FACT IS AN INDEX -> PROCEED LEAVING FACTN=0
         453+10  453          + R ADD     *            
         454+ 1  177          + TR        GETVAR
         455+ 0 2154          + STOP      NVAR
         456+10  902          + R ADD     RELADDR      FACT IS A VAR -> FACTN=VAR ADDRESS, FACTREG='V'
         457+12  880          + STORE     FACTN
         458+10 2151          + R ADD     D34          'V'
         459+12  881          + STORE     FACTREG
         460+10  872 FOR3     + R ADD     S1           IF S1 IS BLANK/NUM (IE >0) -> PROCEED
         461+ 3  476          + TR +      FOR4         
         462+10  881          + R ADD     FACTREG      HERE, S1 IS A VAR. IF INSTR IS
         463+ 4  443          + TR 0      S12NONUM     FOR INDEX -> S1 SHOULD BE A VAR
         464+10  464          + R ADD     *            
         465+ 1   84          + TR        SRCHVAR      SEARCH S1 AS VARIABLE 
         466+ 0  872          + STOP      S1
         467+ 0 2141          + STOP      ZERO
         468+ 0 2141          + STOP      ZERO
         469+12 2154          + STORE     NVAR
         470+ 4  437          + TR 0      S1NOVAR      IF S1 NOT FOUND AS A VAR -> ERROR
         471+10  471          + R ADD     *            
         472+ 1  177          + TR        GETVAR
         473+ 0 2154          + STOP      NVAR
         474+10  902          + R ADD     RELADDR      S1 IS A VAR -> S1N=VAR ADDRESS
         475+12  882          + STORE     S1N
         476+10  873 FOR4     + R ADD     S2           IF S2 IS BLANK/NUM (IE >0) -> PROCEED
         477+ 3  353          + TR +      NEXT
         478+10  881          + R ADD     FACTREG      HERE, S1 IS A VAR. IF INSTR IS
         479+ 4  443          + TR 0      S12NONUM     FOR INDEX -> S1 SHOULD BE A VAR
         480+10  480          + R ADD     *            
         481+ 1   84          + TR        SRCHVAR      SEARCH S1 AS VARIABLE 
         482+ 0  873          + STOP      S2
         483+ 0 2141          + STOP      ZERO
         484+ 0 2141          + STOP      ZERO
         485+12 2154          + STORE     NVAR
         486+ 4  440          + TR 0      S2NOVAR      IF S2 NOT FOUND AS A VAR -> ERROR
         487+10  487          + R ADD     *            
         488+ 1  177          + TR        GETVAR
         489+ 0 2154          + STOP      NVAR
         490+10  902          + R ADD     RELADDR      S2 IS A VAR -> S1N=VAR ADDRESS
         491+12  883          + STORE     S2N
         492+ 4  353          + TR 0      NEXT         
         493+ 8    0 FACTVAR  + NOOP      0000
         494+10  871          + R ADD     FACT
         495+ 3  713          + TR +      FACTNUM      TR IF FACT IS NOT A VARIABLE
         496+ 5 2340          + SUB       ALFTMP       '  $'
         497+ 4  695          + TR 0      FACTTMP      ACCESSING A TEMP VAR
         498+10  498          + R ADD     *
         499+ 1   84          + TR        SRCHVAR      SEARCH VAR. RETURN INDEX POS IN ACC
         500+ 0  871          + STOP      FACT
         501+ 0  872          + STOP      S1
         502+ 0  873          + STOP      S2
         503+ 4  529          + TR 0      EQ1          TR IF VAR "FACT S1 S2" NOT FOUND -> WILL TRY WITH "FACT S1"
         504+12 2154          + STORE     NVAR
         505+10  505          + R ADD     *            
         506+ 1  177          + TR        GETVAR
         507+ 0 2154          + STOP      NVAR
         508+10 2141          + R ADD     ZERO         CLEAR S1 AND S2 AS THEY ARE DEFINITIVE INDEXES.
         509+12  872          + STORE     S1           AS INDUCTIVE INDEXES THEY ARE NOT SET -> SET TO ZERO
         510+12  882          + STORE     S1N
         511+12  873          + STORE     S2
         512+12  883          + STORE     S2N
         513+ 1  560          + TR        EQ3          VAR FOUND. both indexes are definitive -> no inductive index possible
         514+10  514 VARNFND  + R ADD     *            
         515+ 1  832          + TR        ERROR
         516+ 0 2218          + STOP      ERRFANOV     ERROR: FACTOR VARIABLE NOT FOUND
         517+10  517 NOS1     + R ADD     *            
         518+ 1  832          + TR        ERROR
         519+ 0 2267          + STOP      ERRNOS1      ERROR: MISSING S1 INDEX
         520+10  520 NOS2     + R ADD     *            
         521+ 1  832          + TR        ERROR
         522+ 0 2274          + STOP      ERRNOS2      ERROR: MISSING S2 INDEX
         523+10  523 NAS1     + R ADD     *            
         524+ 1  832          + TR        ERROR
         525+ 0 2281          + STOP      ERRNAS1      ERROR: S1 INDEX NOT ALLOWED
         526+10  526 NAS2     + R ADD     *            
         527+ 1  832          + TR        ERROR
         528+ 0 2289          + STOP      ERRNAS2      ERROR: S2 INDEX NOT ALLOWED
         529+10  529 EQ1      + R ADD     *
         530+ 1   84          + TR        SRCHVAR      SEARCH VAR. RETURN INDEX POS IN ACC
         531+ 0  871          + STOP      FACT
         532+ 0  872          + STOP      S1
         533+ 0 2141          + STOP      ZERO
         534+ 4  550          + TR 0      EQ2          TR IF "FACT S1" NOT FOUND
         535+12 2154          + STORE     NVAR
         536+10  536          + R ADD     *            
         537+ 1  177          + TR        GETVAR
         538+ 0 2154          + STOP      NVAR
         539+10 2141          + R ADD     ZERO         CLEAR S1 AS IT IS DEFINITIVE INDEX.
         540+12  872          + STORE     S1           AS INDUCTIVE INDEX IT IS ARE NOT SET -> SET TO ZERO
         541+12  882          + STORE     S1N
         542+10  873          + R ADD     S2
         543+ 4  560          + TR 0      EQ3          TR IF VAR FOUND, NO INDEX
         544+12  882          + STORE     S1N          MOVE S2 TO S1 INDEX 
         545+12  872          + STORE     S1
         546+10 2141          + R ADD     ZERO         AND CLEAR S2
         547+12  873          + STORE     S2
         548+12  883          + STORE     S2N
         549+ 1  560          + TR        EQ3          VAR FOUND
         550+10  550 EQ2      + R ADD     *
         551+ 1   84          + TR        SRCHVAR      SEARCH VAR. RETURN INDEX POS IN ACC
         552+ 0  871          + STOP      FACT
         553+ 0 2141          + STOP      ZERO
         554+ 0 2141          + STOP      ZERO
         555+ 4  514          + TR 0      VARNFND      TR IF VAR NOT FOUND
         556+12 2154          + STORE     NVAR
         557+10  557          + R ADD     *            
         558+ 1  177          + TR        GETVAR
         559+ 0 2154          + STOP      NVAR
         560+10 2141 EQ3      + R ADD     ZERO
         561+12  884          + STORE     D1N          INIT D1N AND D2N
         562+12  885          + STORE     D2N
         563+10  872          + R ADD     S1
         564+ 4  566          + TR 0      EQ3A
         565+ 1  575          + TR        EQ3B
         566+10  873 EQ3A     + R ADD     S2
         567+ 4  592          + TR 0      EQ4          TR AS S1=0 AND S2=0 -> NO INDEXES
         568+10  873          + R ADD     S2           HERE S1=0 AND S2<>0 -> MOVE S2 TO S1 INDEX
         569+12  882          + STORE     S1N         
         570+12  872          + STORE     S1
         571+10 2141          + R ADD     ZERO         AND CLEAR S2
         572+12  873          + STORE     S2
         573+12  883          + STORE     S2N
         574+ 4  587          + TR 0      EQ3C         TR AS S1<>0 AND S2=0 -> S1 INDEX SET
         575+10  873 EQ3B     + R ADD     S2           
         576+ 4  587          + TR 0      EQ3C         TR AS S1<>0 AND S2=0 -> S1 INDEX SET
         577+10  872          + R ADD     S1           HERE S1<>0 AND S2<>0 
         578+12  882          + STORE     S1N          BOTH S1 AND S2 INDEXS SET
         579+10  873          + R ADD     S2
         580+12  883          + STORE     S2N
         581+10  897          + R ADD     D2
         582+22    1          + A LEFT    0001
         583+12  884          + STORE     D1N          D1N= (D2 * 2)
         584+10 2144          + R ADD     TWO
         585+12  885          + STORE     D2N          D2N=2
         586+ 1  592          + TR        EQ4
         587+10  872 EQ3C     + R ADD     S1           HERE S1<>0 AND S2=0 
         588+12  882          + STORE     S1N          S1 INDEX SET
         589+10 2144          + R ADD     TWO
         590+12  884          + STORE     D1N          D1N=2
         591+ 1  592          + TR        EQ4
         592+10  870 EQ4      + R ADD     OP           IF OP=EQ AND QR SET -> CHECK QF=QR 
         593+ 5 2146          + SUB       OPEQ         
         594+ 4  596          + TR 0      EQ4A
         595+ 1  603          + TR        EQ4C
         596+10  874 EQ4A     + R ADD     QR
         597+ 4  603          + TR 0      EQ4C         OP=EQ BUT QR NOT SET -> PROCEED
         598+ 5  895          + SUB       Q
         599+ 4  603          + TR 0      EQ4C         OP=EQ AND QR=Q OR VAR -> PROCEED
         600+10  600          + R ADD     *            
         601+ 1  832          + TR        ERROR
         602+ 0 2297          + STOP      ERREQBQ      ERROR: IF QR SET ON "EQ FACT" INSTR, THE QR MUST MATCH THE Q OF VARIABLE
         603+10  897 EQ4C     + R ADD     D2           CHECK IF NUMBER OF SUBSCRITS MATCHES THE TYPE OF VAR
         604+ 5 2143          + SUB       ONE          SCALAR -> NO INDEX, VECTOR -> ONE INDEX, MATRIX -> 2 INDEXS
         605+ 4  611          + TR 0      EQ5
         606+10  882          + R ADD     S1N          D2>1 -> IS A MATRIX -> NEEDS S1 AND S2 INDEX
         607+ 4  517          + TR 0      NOS1         TR TO ERROR IF MISSING INDEX S1 (S1N=0)
         608+10  883          + R ADD     S2N          
         609+ 4  520          + TR 0      NOS2         TR TO ERROR IF MISSING INDEX S2 (S2N=0)
         610+ 1  625          + TR        EQ10
         611+10  896 EQ5      + R ADD     D1
         612+ 5 2143          + SUB       ONE
         613+ 4  619          + TR 0      EQ6
         614+10  882          + R ADD     S1N          D1>1 -> IS A VECTOR -> NEEDS S1 INDEX
         615+ 4  517          + TR 0      NOS1         TR TO ERROR IF MISSING INDEX S1 (S1N=0)
         616+10  883          + R ADD     S2N          
         617+ 4  625          + TR 0      EQ10 
         618+ 1  526          + TR        NAS2         TR TO ERROR: INDEX S2 NOT ALLOWED
         619+10  882 EQ6      + R ADD     S1N          D1=D2=1 -> IS A SCALAR -> NO INDEX ALLOWED
         620+ 4  622          + TR 0      EQ7 
         621+ 1  523          + TR        NAS1         TR TO ERROR: INDEX S1 NOT ALLOWED
         622+10  883 EQ7      + R ADD     S2N          
         623+ 4  625          + TR 0      EQ10
         624+ 1  526          + TR        NAS2         TR TO ERROR: INDEX S2 NOT ALLOWED
         625+10  902 EQ10     + R ADD     RELADDR      FACTN=VAR RELATIVE ADDR
         626+12  880          + STORE     FACTN        
         627+10 2151          + R ADD     D34          'V'
         628+12  881          + STORE     FACTREG
         629+10  895          + R ADD     Q            QF (Q OF FACTOR)=Q (Q OF VARIABLE)
         630+12  875          + STORE     QF
         631+10  883          + R ADD     S2N          
         632+ 4  635          + TR 0      EQ11         TR IF NO INDEX S2
         633+ 3  649          + TR +      EQ13         TR AS S2=NUMBER -> S2 IS CONSTANT
         634+ 1  669          + TR        EQ20         TR AS S2=INDEX -> S2 NOT A CONSTANT
         635+10  882 EQ11     + R ADD     S1N          HERE, NO S2 INDEX (S2=0)
         636+ 4  669          + TR 0      EQ20         TR IF NO INDEX S1
         637+ 3  639          + TR +      EQ12         TR AS S1=NUMBER -> S1 IS CONSTANT
         638+ 1  669          + TR        EQ20         TR AS S1=INDEX -> S1 NOT A CONSTANT
         639+10  882 EQ12     + R ADD     S1N          HERE S1 IS CONSTANT (S1>0) AND NO S2 INDEX (S2=0)
         640+ 5 2143          + SUB       ONE          FactorN = FactorN + (S1N-1) * 2
         641+22    1          + A LEFT    0001         is effetive address of Vector[constant]
         642+ 9  880          + ADD       FACTN
         643+12  880          + STORE     FACTN        
         644+10 2141          + R ADD     ZERO         REMOVE S1N INDEX
         645+12  882          + STORE     S1N
         646+ 6 2143          + R SUB     ONE          SET D1N=-1 TO SIGNAL IT IS A VECTOR WITH CONSTANT SUBSCRIPTS
         647+12  884          + STORE     D1N
         648+ 1  669          + TR        EQ20
         649+10  882 EQ13     + R ADD     S1N          HERE, CONSTANT S2 INDEX (S2>0)
         650+ 4  669          + TR 0      EQ20         TR IF NO INDEX S1
         651+ 3  653          + TR +      EQ14         TR AS S1=NUMBER -> S1 IS CONSTANT
         652+ 1  669          + TR        EQ20         TR AS S1=INDEX -> S1 NOT A CONSTANT
         653+10  882 EQ14     + R ADD     S1N          HERE S1 IS CONSTANT (S1>0) AND S2 IS CONSTANT (S2>0)
         654+ 5 2143          + SUB       ONE          FactorN = FactorN + (S1N-1) * D2 * 2 + (S2N-1) * 2
         655+21   35          + L RIGHT   0035         ACC -> MQ
         656+16  897          + MPY       D2           is effetive address of Matrix[constant, constant]
         657+22   17          + A LEFT    0017         NOW ACC=MQ*D2*2 = (S1N-1) * D2 * 2
         658+22    1          + A LEFT    0001
         659+ 9  883          + ADD       S2N
         660+ 9  883          + ADD       S2N
         661+ 5 2144          + SUB       TWO
         662+ 9  880          + ADD       FACTN
         663+12  880          + STORE     FACTN        
         664+10 2141          + R ADD     ZERO         REMOVE S1N AND S2N INDEX 
         665+12  882          + STORE     S1N          
         666+12  883          + STORE     S2N
         667+ 6 2143          + R SUB     ONE          SET D1N=-1 TO SIGNAL IT IS A MATRIX WITH CONSTANT SUBSCRIPTS
         668+12  884          + STORE     D1N
         669+ 1  353 EQ20     + TR        NEXT
         670+10  871 FACTVAR2 + R ADD     FACT         AS FACTVAR, CHECKING FACTOR IS A VARIABLE
         671+ 4  674          + TR 0      FV2E
         672+ 3  674          + TR +      FV2E
         673+ 1  493          + TR        FACTVAR      HERE FACTOR IS <0 -> IS ALFA -> IS A VARIABLE -> PROCEED         
         674+10  674 FV2E     + R ADD     *            
         675+ 1  832          + TR        ERROR
         676+ 0 2228          + STOP      ERRNOFV      ERROR: NEEDS VARIABLE AS FACTOR (CANNOT BE BLANK OR NUMBER)
         677+10  871 FACTVAR3 + R ADD     FACT         AS FACTVAR, CHECKING FACTOR IS NOT BLANK (SHOULD BE VAR OR NUMBER)
         678+ 4  681          + TR 0      FV3
         679+ 3  681          + TR +      FV3
         680+ 1  493          + TR        FACTVAR      HERE FACTOR IS <0 -> IS ALFA -> IS A VARIABLE -> TR TO PROCESS IT
         681-10  876 FV3      - R ADD     NUM
         682+ 4  684          + TR 0      FV3E
         683+ 1  493          + TR        FACTVAR      HERE FACTOR IS NOT A VARIABLE AND NUMBER IS NOT BLANK -> TR TO PROCESS IT
         684+10  684 FV3E     + R ADD     *            
         685+ 1  832          + TR        ERROR
         686+ 0 2237          + STOP      ERRNOFBL     ERROR: FACTOR CANNOT BE BLANK (CAN BE VARIABLE OR NUMBER)
         687-10  876 FACTVAR4 - R ADD     NUM          AS FACTVAR3, CHECKING IF FACT IS INTEGER (TO NOT ADD IT TO NUMBER POOL)
         688+ 4  493          + TR 0      FACTVAR      TR IF FACTOR IS NOT A NUMBER
         689+10  875          + R ADD     QF           IF INTEGER NUM, JUST PROCEED TO NEXT STEP WITHOUT SETTING FACTN, FACTREG
         690+ 5 2148          + SUB       D17          AS IF FACTOR IS BLANK
         691+ 4  353          + TR 0      NEXT
         692+10  692          + R ADD     *            
         693+ 1  832          + TR        ERROR
         694+ 0 2177          + STOP      ERRNOIN2     ERROR: FACT/NUMBER MUST BE INTEGER
         695+ 8    0 FACTTMP  + NOOP      0000         ACCESSING A TEMP VAR
         696+10  872          + R ADD     S1  
         697+22    1          + A LEFT    0001         
         698+ 3  702          + TR +      FTMP1
         699+10  699          + R ADD     *            
         700+ 1  832          + TR        ERROR
         701+ 0 2246          + STOP      ERRS1NUM     ERROR: S1 SHOULD BE A NUMBER (OR BLANK)
         702+12  880 FTMP1    + STORE     FACTN        FACTN=S1 * 2, FACTREG='T'
         703+10 2150          + R ADD     D32          'T'
         704+12  881          + STORE     FACTREG
         705+10  874          + R ADD     QR           QF (Q OF FACTOR)=QR (Q OF STEP RESULT)
         706+12  875          + STORE     QF
         707+ 1  353          + TR        NEXT
         708+10  878 FACTBLA  + R ADD     CLUE
         709+ 4  353          + TR 0      NEXT         NO CLUE -> FACT IS BLANK -> LEAVE ALL BLANK
         710+10  710          + R ADD     *            
         711+ 1  832          + TR        ERROR
         712+ 0 2309          + STOP      ERRCLUBL     ERROR: CANNOT HAVE A NON BLANK CLUE WITH BLANK FACTOR
         713-10  876 FACTNUM  - R ADD     NUM
         714+ 4  708          + TR 0      FACTBLA      NUM IS BLANK -> FACTOR IS BLANK
         715+10 2141          + R ADD     ZERO         
         716+12  889          + STORE     N
         717+10  719          + R ADD     TNPOOLAD
         718+13  726          + STORE A   TNPOOL1
         719+ 8 1116 TNPOOLAD + NOOP      TNUMPOOL
         720+10  889 SRNULOOP + R ADD     N
         721+ 5 1115          + SUB       NNUMS
         722+ 4  733          + TR 0      SRNUNFND
         723+10  889          + R ADD     N
         724+ 9 2143          + ADD       ONE
         725+12  889          + STORE     N
         726-10    0 TNPOOL1  - R ADD     /   /
         727- 5  876          - SUB       NUM
         728+ 4  751          + TR 0      SRNUFND      NUM FOUND IN NUMBER POOL
         729+10  726          + R ADD     TNPOOL1  
         730+ 5 2144          + SUB       TWO
         731+13  726          + STORE A   TNPOOL1  
         732+ 1  720          + TR        SRNULOOP
         733+10 1115 SRNUNFND + R ADD     NNUMS        INCR NUM OF NUMS DEFINED
         734+ 9 2143          + ADD       ONE
         735+12 1115          + STORE     NNUMS
         736+12  889          + STORE     N
         737+ 5 1114          + SUB       MAXNNUMS
         738+ 3  758          + TR +      ADDNUMOV     ERROR IF > TABLE SIZE
         739+10  889          + R ADD     N            POS IN TABLE: (POS-1)*2 
         740+ 5 2143          + SUB       ONE
         741+22    1          + A LEFT    0001      
         742+ 9  719          + ADD       TNPOOLAD   
         743+13  750          + STORE A   TNPOOL2
         744+10  889          + R ADD     N            N.EXT=RELNUM0 + (NUM+1) * 2
         745+ 9 2143          + ADD       ONE
         746+22    1          + A LEFT    0001
         747+ 9  906          + ADD       RELNUM0
         748+12  909          + STORE     N.EXT
         749-10  876          - R ADD     NUM       
         750-12    0 TNPOOL2  - STORE     /   /        SAVE NUM IN TNUMPOOL
         751+10  889 SRNUFND  + R ADD     N            FACTN=RELNUM0 + NUM * 2, FACTREG='N'
         752+22    1          + A LEFT    0001
         753+ 9  906          + ADD       RELNUM0
         754+12  880          + STORE     FACTN
         755+10 2149          + R ADD     D26          'N'
         756+12  881          + STORE     FACTREG
         757+ 1  353          + TR        NEXT         PROCEED WITH NEXT STEP
         758+10  758 ADDNUMOV + R ADD     *            
         759+ 1  832          + TR        ERROR
         760+ 0 2258          + STOP      ERROVNUM     TOO MANY NUMBERS DEFINED
         761+ 8    0 EOR      + NOOP      0000         END OF REGION  
         762+10  762          + R ADD     *
         763+ 1   63          + TR        WRTAPE       WRITE MAGNETIC TAPE TAPEOUT (PACT COMPACT CODE)
         764+ 0  257          + STOP      TAPEOUT
         765+ 0  844          + STOP      CCODE        BUF TO WRITE TO TAPE
         766+ 0  888          + STOP      CCLEN        LEN
         767+ 1  290          + TR        READREG      PROCEED WITH NEXT REGION
         768+ 8    0 EOF      + NOOP      0000         END OF FILE
         769+10  769          + R ADD     *
         770+ 1   65          + TR        RWDRUM       WRITE RELNUM0, NVARS, V.EXT AND N.EXT TO DRUM
         771+26  130          + WRITE     0130         DRUM INSTR
         772+ 0    0          + STOP      0000         DRUM ADDR 
         773+ 0  906          + STOP      RELNUM0      ADDR OF DATA TO SAVE
         774+ 0    4          + STOP      0004         4 HALF WORDS
         775+10  775          + R ADD     *
         776+ 1   65          + TR        RWDRUM       SAVE NUMBER POOL TO DRUM (WITHOUT OVERWRITTING RELNUM0, ... DRUM ADDR 0)
         777+26  130          + WRITE     0130         DRUM INSTR
         778+ 0   16          + STOP      0016         DRUM ADDR 
         779+ 0 1114          + STOP      MAXNNUMS     ADDR OF START OF TABLES
         780+ 0 1026          + STOP      1026         MAXNNUMS (1 HALF-WORD) + NNUMS (1 HW) + TNUMPOOL (1024 HW)
         781+27  257          + WRITE EF  TAPEOUT      WRITE EOF IN TAPE OUT (COMPACT CODE)
         782+30   74          + SENSE     0074         SENSE SWITCH 6
         783+ 1  825          + TR        ENDLOG1B     TR IF NO LOG SELECTED
         784+10  784          + R ADD     *
         785+ 1   53          + TR        PRTNLINE     
         786+ 0  101          + STOP      0101         STRINGZ AT COL 1
         787+ 0 2331          + STOP      MSGNPOOL     "   NUM POOL CONTENTS"
         788+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         789+10 2141          + R ADD     ZERO         PRINT THE NUMBER POOL
         790+12  889          + STORE     N
         791+10  719          + R ADD     TNPOOLAD
         792+13  799          + STORE A   TNPOOL9
         793+10  889 TNPOOL9A + R ADD     N
         794+ 5 1115          + SUB       NNUMS
         795+ 4  818          + TR 0      TNPOOL9B
         796+10  889          + R ADD     N
         797+ 9 2143          + ADD       ONE
         798+12  889          + STORE     N
         799-10    0 TNPOOL9  - R ADD     /   /
         800-12  876          - STORE     NUM
         801+10  799          + R ADD     TNPOOL9
         802+ 5 2144          + SUB       TWO
         803+13  799          + STORE A   TNPOOL9
         804+10  889          + R ADD     N
         805+ 9  889          + ADD       N
         806+ 9  906          + ADD       RELNUM0
         807+12 2155          + STORE     NNUM
         808+10  808          + R ADD     *
         809+ 1   53          + TR        PRTNLINE     
         810+ 0  201          + STOP      0201         INT AT COL 1
         811+ 0 2155          + STOP      NNUM
         812+ 0  308          + STOP      0308         OCT AT COL 8
         813+ 0  876          + STOP      NUM
         814+ 0  315          + STOP      0315         OCT AT COL 15
         815+ 0  877          + STOP      NUM2
         816+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         817+ 1  793          + TR        TNPOOL9A
         818+10  818 TNPOOL9B + R ADD     *
         819+ 1   53          + TR        PRTNLINE     
         820+ 0  101          + STOP      0101         STRINGZ AT COL 1
         821+ 0 2327          + STOP      MSGNEXT      "NUM EXT"
         822+ 0  215          + STOP      0215         INT AT COL 15
         823+ 0  909          + STOP      N.EXT        EXTENSION (=SIZE IN HALF WORDS) OF NUMBERS REGION (IS EVEN)
         824+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         825+ 8    0 ENDLOG1B + NOOP      0000
         826+28  258          + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE)
         827+28  257          + REWIND    TAPEOUT      REWIND TAPE OUT WITH UPDATED PACT COMPACT CODE
         828+10  828          + R ADD     *
         829+ 1   51          + TR        CHAIN        IF SW2 IS ON, A +STOP 4095 IS EXECUTED 
         830+ 0  256          + STOP      PACTCOMP     CHAIN TO NEXT STAGE IN PACT COMPILER TAPE
         831+ 0 4095          + STOP      4095
         832+ 9 2144 ERROR    + ADD       TWO
         833+13  834          + STORE A   ERRP1
         834+10    0 ERRP1    + R ADD     /   /
         835+13  841          + STORE A   ERRSTRZ      SAVE ADDR OF ERROR TXT MESSAGE
         836+10  836          + R ADD     *            PRINT USER PROGRAM SOURCE CODE CARD JUST PROCESSED
         837+ 1   59          + TR        PRINTCRD
         838+10  838          + R ADD     *
         839+ 1   53          + TR        PRTNLINE     
         840+ 0  101          + STOP      0101         STRINGZ AT COL 1
         841+ 0    0 ERRSTRZ  + STOP      /   /        ERROR MESSAGE
         842+ 0    0          + STOP      0000         END OF LINE
         843+ 0  291          + STOP      READSTEP     IF USER PRESS STARTS, PROGRAM RESUMES PROCESSING NEXT SOURCE CODE STEP 
         844+     0  PACTSRC    RES       24           CARD IMAGE OF PACT SOURCE CODE CARD (12 FULL WORDS)
         868+     0  REGION     DEF       0
         869+     0  STEP       DEF       0            REGION = ALFA (<0)
         870+     0  OP         DEF       0            STEP   = INT (>0)
         871+     0  FACT       DEF       0            OP     = 0..43    =0 MEANS END OF REGION
         872+     0  S1         DEF       0            FACT   < 0 -> FACTOR IS AN ALFA SYMBOL (VAR, REGION, ...) 
         873+     0  S2         DEF       0            FACT = 0 -> BLANK FACTOR
         874+     0  QR         DEF       0            FACT = 0..9999 -> DESTINATION STEP FOR TRANSFER/RESULT OF STEP
         875+     0  QF         DEF       0            CLUE = -, R OR N
         876+     0  NUM        DEF       0            
         877+     0  NUM2       DEF       0            S1/S2 = 0 -> BLANK, >0 -> INTEGER, <0 -> ALFA 
         878+     0  CLUE       DEF       0
         879+     0  STEPN      DEF       0            QR = +/- INTEGER OR BLANK. 
         880+     0  FACTN      DEF       0            QF = SET IF THERE IS AN INTEGER FACTOR/NUMBER IN CARD
         881+     0  FACTREG    DEF       0
         882+     0  S1N        DEF       0            STEPN = SEQUENTIAL NUMBER OF STEP            
         883+     0  S2N        DEF       0            IF OP IS TRANSFER -> FACTN=DESTINATION STEPN
         884+     0  D1N        DEF       0            FACTN=ADDR (0, 2, 4, ..) FACTREG=' ', 'T', 'V', 'N'
         885+     0  D2N        DEF       0            S1N/S2N=INDEX (IF <0), BLANK (IF =0), CONST (IF >0)
         886+     0  NINST      DEF       0            D1N/D2N=HALF-WORD SIZE OF EACH DIMENSION
         887+     0  NINCR      DEF       0                    D1N=-1 IF MATRIX/VECTOR WITH CONSTANT SUBSCRIPTS
         888+    44  CCLEN      DEF       0044         LENGTH OF COMPACT CODE RECORD 
         889+     0  N          DEF       0            TEMP VAR (HERE TO MAKE TABLES START AT EVEN LOCATION)
         890+     0  VARNAME    DEF       0            VARIABLE NAME
         891+     0  VARNAM1    DEF       0            
         892+     0  VARNAM2    DEF       0            
         893+     0  VTYPE      DEF       0            VAR TYPE. 1=SCALAR, 2=VECTOR, 3=MATRIX
         894+     0  LEN        DEF       0            HALF-WORD USED BY VARS
         895+     0  Q          DEF       0
         896+     0  D1         DEF       0            DIMENSIONS
         897+     0  D2         DEF       0
         898+     0  CONSTR     DEF       0            CONSTRAINT VAR NAME
         899+     0  CONSTR1    DEF       0
         900+     0  CONSTR2    DEF       0
         901+     0  CTYPE      DEF       0            CONSTRAINT VAR TYPE. 0=NONE, 1=SYN, 2=IMS, 3=SUC, 9=REL
         902+     0  RELADDR    DEF       0            RELATIVE ADDR IN VAR POOL
         903+     0  PHASE      DEF       0
         904+     0  FLAG       DEF       0
         905+     0  SIZE       DEF       0            NUM OF HALF-WORDS NEEDED TO ACCOMODATE LEN USED BY SUB-CHAINS VARIABLES
         906+     0  RELNUM0    DEF       0            REL NUM ORIGIN
         907+     0  NVARS      DEF       0            NUMBER OF VARS DEFINED
         908+     0  V.EXT      DEF       0            EXTENSION (=SIZE IN HALF WORDS) OF VARIABLE REGION (IS EVEN)
         909+     0  N.EXT      DEF       0            EXTENSION (=SIZE IN HALF WORDS) OF NUMBERS REGION (IS EVEN)
         910+     0  FNDVAR     DEF       0            TEMP ON VAR SEARCH (SHOULD BE AT EVEN ADDR)
         911+     0  FNDVAR1    DEF       0            TEMP ON VAR SEARCH
         912+     0  FNDVAR2    DEF       0            TEMP ON VAR SEARCH
         913+     0  DUMMY      DEF       0            NEEDED AS RWDRUM NEED EVEN NUMBER OF HALF-WORDS
         914+     0  HASH       RES       200          VARIABLES NAMES HASH TABLE (199 ENTRIES)
        1114+   512  MAXNNUMS   DEF       512          MAX NUMBER OF NUMBERS THAT CAN BE DEFINED
        1115+     0  NNUMS      DEF       0            NUMBER OF NUMBERS IN NUMBER POOL
        1116+     0  TNUMPOOL   RES       1024         EACH ENTRY IN TABLE IS 2 HALF-WORDS
        2140+   341  MAXNVARS   DEF       341          MAX VARIABLES THAT CAN DE DEFINED IN ONE PROGRAM 
        2141+     0  ZERO       DEF       0
        2142+     0             DEF       0
        2143+     1  ONE        DEF       1
        2144+     2  TWO        DEF       2
        2145+     4  D4         DEF       4
        2146+     7  D7         DEF       7
        2147+     8  D8         DEF       8
        2148+    17  D17        DEF       17
        2149+    26  D26        DEF       26
        2150+    32  D32        DEF       32
        2151+    34  D34        DEF       34
        2152+   199  D199       DEF       199
        2153+  1024  D1024      DEF       1024
        2154+     0  NVAR       DEF       0            TEMP
        2155+     0  NNUM       DEF       0
        2156+     0  HASHFLAG   DEF       0
        2157- 61200  ERRNOFAC   TXT       "NO FACTOR ALLOWED ON THIS PACT INSTR",0
        2158- 42111  
        2159- 75054  
        2160-   648  
        2161- 56627  
        2162- 39936  
        2163- 63456  
        2164- 74709  
        2165- 71452  
        2166- 30704  
        2167-  1034  
        2168- 72990  
        2169+     0  
        2170- 71472  ERRNOINT   TXT       "S1 MUST BE INTEGER",0
        2171- 59215  
        2172- 73742  
        2173- 39189  
        2174- 61457  
        2175- 44622  
        2176+     0  
        2177- 59215  ERRNOIN2   TXT       "MUST BE INTEGER",0
        2178- 73742  
        2179- 39189  
        2180- 61457  
        2181- 44622  
        2182+     0  
        2183- 77537  ERRNOIDX   TXT       "USE/SET/TEST SYNTAX ERROR",0            SHOULD BE    [DESTINATION STEP]  ALFAINDEX  ALFAINDEX|ALFAVAR|NUM
        2184-105185  
        2185- 75920  
        2186- 40688  
        2187-  1525  
        2188- 61453  
        2189- 82961  
        2190- 70587  
        2191- 69120  
        2192+     0  
        2193- 71472  ERRS1NOV   TXT       "S1 VARIABLE NOT FOUND",0
        2194- 78990  
        2195- 49022  
        2196- 56112  
        2197- 61232  
        2198-   891  
        2199- 77296  
        2200+     0  
        2201- 71520  ERRS2NOV   TXT       "S2 VARIABLE NOT FOUND",0
        2202- 78990  
        2203- 49022  
        2204- 56112  
        2205- 61232  
        2206-   891  
        2207- 77296  
        2208+     0  
        2209- 71517  ERRS12NN   TXT       "S1/S2 SHOULD BE NUMBER",0               ERROR: FOR INDEX USED: S1/S2 SHOULD BE A NUMBER
        2210- 71520  
        2211- 72411  
        2212- 77200  
        2213-   689  
        2214-  1281  
        2215- 58289  
        2216- 69120  
        2217+     0  
        2218- 42111  ERRFANOV   TXT       "FACTOR VARIABLE NOT FOUND",0
        2219- 75054  
        2220-  1645  
        2221- 70141  
        2222- 33425  
        2223-  1275  
        2224- 73746  
        2225- 63818  
        2226- 36864  
        2227+     0  
        2228- 60737  ERRNOFV    TXT       "NEEDS VARIABLE AS FACTOR",0             (CANNOT BE BLANK OR NUMBER)
        2229- 38352  
        2230- 78990  
        2231- 49022  
        2232- 56112  
        2233- 31440  
        2234- 42111  
        2235- 75054  
        2236+     0  
        2237- 42111  ERRNOFBL   TXT       "FACTOR CANNOT BE BLANK",0               (CAN BE VARIABLE OR NUMBER)
        2238- 75054  
        2239-   733  
        2240- 61179  
        2241- 73742  
        2242- 39182  
        2243- 55946  
        2244- 52992  
        2245+     0  
        2246- 71472  ERRS1NUM   TXT       "S1 SHOULD BE A NUMBER (OR BLANK)",0
        2247- 72411  
        2248- 77200  
        2249-   689  
        2250-   624  
        2251- 61513  
        2252- 33102  
        2253-  2283  
        2254- 69134  
        2255- 55946  
        2256- 55248  
        2257+     0  
        2258- 75051  ERROVNUM   TXT       "TOO MANY NUMBERS DEFINED",0
        2259-  1213  
        2260- 61680  
        2261- 61513  
        2262- 33102  
        2263- 71440  
        2264- 40053  
        2265- 60736  
        2266+     0  
        2267- 58639  ERRNOS1    TXT       "MISSING S1 INDEX",0                     BECAUSE VAR IS A VECTOR/MATRIX
        2268- 72458  
        2269- 43807  
        2270-  2325  
        2271- 60689  
        2272- 82944  
        2273+     0  
        2274- 58639  ERRNOS2    TXT       "MISSING S2 INDEX",0                     BECAUSE VAR IS A MATRIX
        2275- 72458  
        2276- 43807  
        2277-  4629  
        2278- 60689  
        2279- 82944  
        2280+     0  
        2281- 71472  ERRNAS1    TXT       "S1 INDEX NOT ALLOWED",0
        2282- 49648  
        2283- 40896  
        2284- 61232  
        2285-   648  
        2286- 56627  
        2287- 39936  
        2288+     0  
        2289- 71520  ERRNAS2    TXT       "S2 INDEX NOT ALLOWED",0
        2290- 49648  
        2291- 40896  
        2292- 61232  
        2293-   648  
        2294- 56627  
        2295- 39936  
        2296+     0  
        2297- 68256  ERREQBQ    TXT       "QR DOES NOT MATCH Q OF VARIABLE",0      IF QR SET ON "EQ FACT" INSTR, THE QR MUST MATCH THE Q OF VARIABLE
        2298- 38177  
        2299- 71450  
        2300- 63744  
        2301- 58256  
        2302- 35520  
        2303- 66843  
        2304- 41506  
        2305- 31413  
        2306- 30648  
        2307- 39168  
        2308+     0  
        2309- 32896  ERRCLUBL   TXT       "BAD CLUE",0                             CANNOT HAVE A NON BLANK CLUE WITH BLANK FACTOR
        2310-   744  
        2311- 76848  
        2312+     0  
        2313- 72987  MSGSTART   TXT       "STORAGE ASSIGNEMENT   QR",0
        2314- 69763  
        2315- 39181  
        2316- 72933  
        2317- 45041  
        2318- 58442  
        2319- 73728  
        2320-  1422  
        2321+     0  
        2322- 69955  MSGSTAR2   TXT       "REG REL   QF",0
        2323-  1457  
        2324- 55296  
        2325-  1410  
        2326+     0  
        2327- 61513  MSGNEXT    TXT       "NUM EXT",0
        2328-   852  
        2329- 73728  
        2330+     0  
        2331-     0  MSGNPOOL   TXT       "   NUM POOL CONTENTS OCT",0
        2332- 61513  
        2333-  1371  
        2334- 63360  
        2335- 35882  
        2336- 74570  
        2337- 75216  
        2338- 62960  
        2339+     0  
        2340-    41  ALFTMP     TXT       '  $'
        2342+15 2356 CLRBUF   + LOAD MQ   IOCL
        2343+14 2361          + STORE MQ  BUFIO
        2344+15 2382          + LOAD MQ   IOSTORE         
        2345+ 1 2353          + TR        INIT2
        2346+15 2378 READCRD  + LOAD MQ   IORDCRD
        2347+ 1 2351          + TR        INIT1
        2348+15 2380 WRITECRD + LOAD MQ   IOWRCRD
        2349+ 1 2351          + TR        INIT1
        2350+15 2381 PRINTCRD + LOAD MQ   IOPRCRD
        2351+14 2361 INIT1    + STORE MQ  BUFIO
        2352+15 2379          + LOAD MQ   IOCOPY         
        2353+14 2362 INIT2    + STORE MQ  BUFROW
        2354+ 9 2388          + ADD       TWO          
        2355+13 2377          + STORE A   EXIT
        2356+10 2384 IOCL     + R ADD     ZERO         RESET TO INITIAL COPY LOOP ADDRESS     
        2357+13 2362          + STORE A   BUFROW       FOR BUFFER
        2358+10 2362          + R ADD     BUFROW       X .*echo Print
        2359+ 5 2389          + SUB       D48          X 
        2360+12 2386          + STORE     ENDLP        X LOOP END VALUE
        2361- 0    0   BUFIO  - STOP      /   /        READ OR WRITE
        2362-31    0   BUFROW - COPY      /   /        COPY WORD TO/FROM PRINTER/CARDREADER
        2363+ 1 2367          + TR        BUFOK2       NORMAL PROCESSING 
        2364+ 1 2374          + TR        EODECK       FOR COPY READING END OF REG (=END OF DECK BEING READ)
        2365+ 6 2388          + R SUB     TWO          END OF FILE -> NO CARD TO READ -> STOP with Acc=-2
        2366+ 0 2361          + STOP      BUFIO        ON PRESSING START RETRY CARD READ
        2367+10 2362   BUFOK2 + R ADD     BUFROW       X
        2368+ 5 2388          + SUB       TWO          INCR BUF ADDR
        2369+13 2362          + STORE A   BUFROW       X
        2370+ 5 2386          + SUB       ENDLP        CHECK FOR END
        2371+ 4 2376          + TR 0      ENDIO
        2372+10 2384          + R ADD     ZERO         CLEAR ACC IN CASE WE ARE CLEANING THE BUFFER
        2373+ 1 2362          + TR        BUFROW
        2374+10 2387 EODECK   + R ADD     ONE          SET OV FLAG TO SIGNAL END OF DECK CONDITION
        2375+22   36          + A LEFT    36
        2376+26 2052 ENDIO    + WRITE     2052         END OF I/O: INSURE THAT MQ NOT IN USE            
        2377+ 1    0 EXIT     + TR        /   /
        2378+24 2048 IORDCRD  + READ      2048         PREPARE TO READ FROM CARD READER
        2379-31    0 IOCOPY   - COPY      /   /   
        2380+26 1024 IOWRCRD  + WRITE     1024         PREPARE TO PUNCH CARD 
        2381+26  512 IOPRCRD  + WRITE     0512         PREPARE WRITE PRTBUF ON PRINTER
        2382-12    0 IOSTORE  - STORE     /   /        CLEAR BUFFER
        2383+     0             ORG       EVEN           
        2384+     0  ZERO       DEF       0            
        2385+     0             DEF       0            
        2386+     0  ENDLP      DEF       0            LOOP END VALUE
        2387+     1  ONE        DEF       1
        2388+     2  TWO        DEF       2
        2389+    48  D48        DEF       48
        2390+ 9 2661 PRTPARM2 + ADD       TWO          GET 2 PARAMS: LEN AND COL (EITHER VALUE OR VAR ADDR)
        2391+13 2410          + STORE A   PRTPRMEX
        2392+10 2400          + R ADD     PRTP1
        2393+ 9 2661          + ADD       TWO          PRINT PACKED TEXT FROM FULL-WORD VALUE IN MQ REGISTER 
        2394+13 2400          + STORE A   PRTP1        STORE ADDR OF FIRST PARAM (LEN)
        2395+ 9 2660          + ADD       ONE
        2396+13 2402          + STORE A   PRTP2        STORE ADDR OF SECOND PARAM (COL)
        2397+ 9 2660          + ADD       ONE
        2398+13 2477          + STORE A   EXIT
        2399-14 2650          - STORE MQ  NUM          SAVE VALUE TO PRINT PARAM MQ (NUM IS ALIASED TO TXT)
        2400+10    0   PRTP1  + R ADD     /   /        GET LEN: NUMBER OF CHARS TO PRINT (1..6)
        2401+12 2654          + STORE     LEN
        2402+10    0   PRTP2  + R ADD     /   /        GET COLUMN PARAM 1..72
        2403+ 3 2406          + TR +      PRTP4
        2404+13 2405          + STORE A   PRTP3        COL<0 -> INTERPRET COL AS LOC(COL) = ADDR OF COL VAR
        2405+10    0   PRTP3  + R ADD     /   /        READ VAR COL PASED AS PARAM
        2406+ 4 2477   PRTP4  + TR 0      EXIT         COL=0 -> EXIT
        2407+ 3 2409          + TR +      PRTP5
        2408+ 1 2477          + TR        EXIT         COL<0 -> EXIT
        2409+12 2460   PRTP5  + STORE     COL
        2410+ 1    0 PRTPRMEX + TR        /   /        RETURN TO CALLER
        2411+13 2400 PRTSTR   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2412+10 2412          + R ADD     *            FOR PRINT STRINGZ FROM MEM
        2413+ 1 2390          + TR        PRTPARM2
        2414+12 2424          + STORE     COLSZ
        2415+10 2654          + R ADD     LEN          LEN IS IN FACT THE LOCATION WHERE THE STRING STARTS
        2416+13 2419          + STORE A   STRZAD
        2417+10 2477          + R ADD     EXIT
        2418+13 2432          + STORE A   STRZEX
        2419+10    0 STRZAD   + R ADD     /   /        GET HALF-WORD WITH NEXT 3 CHARS TO PRINT
        2420+ 4 2432          + TR 0      STRZEX       IF +0 -> END OF STRING (-0 DOES NOT TERMINATES THE STRING)
        2421+21   35          + L RIGHT   0035         MQ=3-CHARS TO PRINT
        2422+10 2422          + R ADD     *            
        2423+ 1 2434          + TR        PRTALF       PRINT 3 CHARS
        2424+ 0    0 COLSZ    + STOP      0000         COL 
        2425+10 2419 STRZ1    + R ADD     STRZAD       INCR STRING ADDRESS
        2426+ 9 2660          + ADD       ONE
        2427+13 2419          + STORE A   STRZAD
        2428+10 2424          + R ADD     COLSZ        INCR COLUMN
        2429+ 9 2662          + ADD       D3
        2430+13 2424          + STORE A   COLSZ
        2431+ 1 2419          + TR        STRZAD
        2432+ 3    0 STRZEX   + TR +      /   /        IF ZERO -> END OF STRING
        2433+ 1 2425          + TR        STRZ1
        2434+ 9 2661 PRTALF   + ADD       TWO          PRINT 3-PACKED CHARS IN MQ REGISTER 
        2435+14 2656          + STORE MQ  TXT          SAVE TEXT TO PRINT (IN LEFT HALF WORD)
        2436+13 2439          + STORE A   PRTAP2       STORE ADDR OF PARAM (COL)
        2437+ 9 2660          + ADD       ONE
        2438+13 2477          + STORE A   EXIT
        2439+10    0   PRTAP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        2440+ 3 2443          + TR +      PRTAP4
        2441+13 2442          + STORE A   PRTAP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        2442+10    0   PRTAP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        2443+12 2460   PRTAP4 + STORE     COL
        2444+10 2662          + R ADD     D3
        2445+12 2654          + STORE     LEN
        2446+10 2644 PRT1     + R ADD     ZERO         UNPACK LEFTMOST CHAR 
        2447+11 2656          + ADD AB    TXT          GET TEXT DISCARD SIGN
        2448+21   35          + L RIGHT   0035         MQ=Acc
        2449+10 2644          + R ADD     ZERO
        2450+18 2669          + DIV       D48X48
        2451+12 2656          + STORE     TXT          remainder=char to print, mq=c2 * 48 + c3 in right half-word
        2452+10 2644          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        2453+20   18          + L LEFT    0018         put c2 and c3 in left half-word of MQ to be saved in CHAR half word
        2454+14 2655          + STORE MQ  CHAR         CHAR TO PRINT
        2455+10 2655          + R ADD     CHAR 
        2456+ 4 2461          + TR 0      NXTCHR       IF BLANK PROCEED TO NEXT COL
        2457+21   35          + L RIGHT   0035         MQ=CHAR TO PRINT
        2458+10 2458          + R ADD     *            PRINT CHAR
        2459+ 1 2554          + TR        PRTCHR
        2460+ 0    0 COL      + STOP      0000         COL: COLUMN NUMBER TO PRINT (1..72)
        2461+10 2654 NXTCHR   + R ADD     LEN          DECR LEN COUNT
        2462+ 5 2660          + SUB       ONE
        2463+12 2654          + STORE     LEN
        2464+ 4 2477          + TR 0      EXIT         IF NO MORE CHARS TO PRINT EXIT
        2465+10 2460          + R ADD     COL          INCR COL POSITION
        2466+ 9 2660          + ADD       ONE
        2467+12 2460          + STORE     COL
        2468+ 5 2668          + SUB       D72          IF COL > 72 RETURN TO CALLER
        2469+ 4 2471          + TR 0      GNXTCHR      ELSE PROCEED WITH NEXT CHAR
        2470+ 3 2477          + TR +      EXIT
        2471+10 2644 GNXTCHR  + R ADD     ZERO         GET NEXT CHAR 
        2472+15 2656          + LOAD MQ   TXT
        2473+16 2667          + MPY       D48
        2474+22   17          + A LEFT    0017         GET RESULT IN LEFT HALF-WORD OF ACC
        2475+12 2656          + STORE     TXT
        2476+ 1 2446          + TR        PRT1         PROCEED TO PRINT CHAR
        2477+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        2478+13 2400 PRTOCT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2479+10 2479          + R ADD     *            FOR PRINT OCTIONARY VALUE
        2480+ 1 2390          + TR        PRTPARM2
        2481+10 2654          + R ADD     LEN          LEN = OCTAL DIGITS TO PRINT
        2482+ 9 2460          + ADD       COL
        2483+ 5 2660          + SUB       ONE
        2484+12 2496          + STORE     COLN         COL POINTS TO LEAST SIGNIFICANT DIGIT
        2485+10 2650 PRTIOCG  + R ADD     NUM          GENERATE OCTINARY DIGIT
        2486+15 2644          + LOAD MQ   ZERO         CLEAR MQ
        2487+21   21          + L RIGHT   0021         3 LSB BITS OF LEFT HALF-WORD OF ACC TO MQ
        2488+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 3 BIT)
        2489+12 2650          + STORE     NUM          SAVE BACK NUM WITH RIGHTMOST OCTIONARY DIGIY EXTRACTED (NUM'=NUM/8)
        2490+10 2644          + R ADD     ZERO
        2491+20   21          + L LEFT    0021         LEFT HALF-WORD OF ACC IS NOW RIGHTMOST OCTINARY DIGIT EXTRACTED FROM NUM 
        2492+ 4 2510          + TR 0      PRTIOZ       TR IF THIS DIGIT IS ZERO TO PRINT A '0' (BASE48 CODE = 10) INSTEAD OF A BLANK (BASE48 CODE = 0)
        2493+21   35          + L RIGHT   0035         PUT DIGIT 1..9 TO PRINT IN MQ
        2494+10 2494 PRTOCTD  + R ADD     *            PRINT OCTINARY DIGIT
        2495+ 1 2554          + TR        PRTCHR
        2496+ 0    0 COLN     + STOP      0000
        2497+10 2496          + R ADD     COLN        DECR COL NUMBER TO PRINT NEXT DIGIT
        2498+ 5 2660          + SUB       ONE
        2499+12 2496          + STORE     COLN
        2500+10 2654          + R ADD     LEN          DECR COL NUMBER TO PRINT NEXT DIGIT
        2501+ 5 2660          + SUB       ONE
        2502+ 4 2477          + TR 0      EXIT         PRINTED LEN OCTINARY DIGITS -> EXIT
        2503+12 2654          + STORE     LEN
        2504+10 2650          + R ADD     NUM          IF NUM < 0, ADD SIGN BIT TO LEFTMOST DIGIT
        2505+ 3 2485          + TR +      PRTIOCG
        2506+10 2670          + R ADD     OCT04K       
        2507+ 5 2650          + SUB       NUM
        2508+12 2650          + STORE     NUM
        2509+ 1 2485          + TR        PRTIOCG
        2510+15 2663   PRTIOZ + LOAD MQ   D10          ACC=BASE48 CODE FOR '0'
        2511+ 1 2494          + TR        PRTOCTD      TR TO PRINT IT
        2512+13 2400 PRTINT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2513+10 2513          + R ADD     *            FOR PRINT OCTIONARY VALUE
        2514+ 1 2390          + TR        PRTPARM2
        2515+10 2460          + R ADD     COL          PRINT DECIMAL NUMBER. VALUE OF LEN = DIGITS TO PRINT, NOT INCLUDING SIGN
        2516+ 9 2654          + ADD       LEN
        2517+ 5 2660          + SUB       ONE          
        2518+12 2539          + STORE     COLNI        COL POINTS TO END OF NUMBER
        2519+10 2644          + R ADD     ZERO
        2520+12 2653          + STORE     SGN          SIGN IS POSITIVE
        2521+10 2650          + R ADD     NUM
        2522+ 3 2527          + TR +      PRTINTG
        2523+ 6 2650          + R SUB     NUM          NUM IS NEGATIVE. CONVERT TO POSITIVE
        2524+12 2650          + STORE     NUM          AND SET SGN=1
        2525+10 2660          + R ADD     ONE
        2526+12 2653          + STORE     SGN          
        2527+10 2650 PRTINTG  + R ADD     NUM          GENERATE DECIMAL DIGIT
        2528+21   35          + L RIGHT   0035         MQ=Acc
        2529+10 2644          + R ADD     ZERO
        2530+18 2663          + DIV       D10
        2531+ 4 2552          + TR 0      PRTINZ
        2532+12 2655 PRTINTG2 + STORE     CHAR         acc=remainder=digit to print, mq=num/10
        2533+10 2644          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        2534+20   18          + L LEFT    0018         digit in left half-word of MQ to be saved in CHAR half word
        2535+14 2650          + STORE MQ  NUM 
        2536+15 2655          + LOAD MQ   CHAR 
        2537+10 2537 PRTINTD  + R ADD     *            PRINT DECIMAL DIGIT
        2538+ 1 2554          + TR        PRTCHR
        2539+ 0    0 COLNI    + STOP      0000
        2540+10 2539          + R ADD     COLNI        DECR COL NUMBER TO PRINT NEXT DIGIT
        2541+ 5 2660          + SUB       ONE
        2542+12 2539          + STORE     COLNI
        2543+10 2650          + R ADD     NUM          DO NOT CARE ABOUT LEN, JUST CHECK IF NUM=0 
        2544+ 4 2546          + TR 0      PRTINS       (SO NO MORE DIGITS REMAINS TO BE PRINTED)
        2545+ 1 2527          + TR        PRTINTG      NUM NOT FINISHED, PROCEED WITH NEXT DIGIT
        2546+10 2653 PRTINS   + R ADD     SGN
        2547+ 4 2477          + TR 0      EXIT         NO SIGN -> NUM FINISHED
        2548+10 2644          + R ADD     ZERO
        2549+12 2653          + STORE     SGN          CLEAR SGN FLAG
        2550+15 2664          + LOAD MQ   D11          BASE48 CODE FOR '-' (MINUS) CHAR
        2551+ 1 2537          + TR        PRTINTD      GO TO PRINT IT
        2552+10 2663   PRTINZ + R ADD     D10          ACC=BASE48 CODE FOR '0'
        2553+ 1 2532          + TR        PRTINTG2     TR TO PRINT IT
        2554+ 9 2661 PRTCHR   + ADD       TWO          PRINT CHAR IN MQ REGISTER 
        2555+14 2655          + STORE MQ  CHAR         SAVE CHAR TO PRINT (IN LEFT HALF WORD)
        2556+13 2560          + STORE A   PRTCP2       STORE ADDR OF PARAM (COL)
        2557+ 9 2660          + ADD       ONE
        2558+13 2638          + STORE A   PRTCEX
        2559+ 2 2560          + TR OV     PRTCP2       CLEAR OV JUST IN CASE
        2560+10    0   PRTCP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        2561+ 3 2564          + TR +      PRTCP4
        2562+13 2563          + STORE A   PRTCP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        2563+10    0   PRTCP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        2564+ 5 2660   PRTCP4 + SUB       ONE
        2565+12 2658          + STORE     N            N=COL-1 -> IN RANGE 0..71
        2566+ 3 2568          + TR +      PRTSA        IF N >= 0 PROCEED WITH BASE BUFFER ADDR CALCULATION
        2567+ 1 2638          + TR        PRTCEX       IF N<0 EXIT
        2568+10 2644    PRTSA + R ADD     ZERO         CARD BUFFER USES LOCATION 0..47
        2569+13 2657          + STORE A   PRTROWAD     DETERMINE ADDRESS OF LOWER ROW TO PRINT
        2570+10 2658          + R ADD     N
        2571+ 5 2666          + SUB       D36
        2572+ 3 2574          + TR +      PRTC0
        2573+ 1 2580          + TR        PRTC1
        2574+12 2658    PRTC0 + STORE     N            COL NOW 0..35 
        2575+ 5 2666          + SUB       D36
        2576+ 3 2638          + TR +      PRTCEX       IF COL >= 36 (IE COL PASSED AS PARAM > 72) THEN EXIT
        2577+10 2657          + R ADD     PRTROWAD
        2578+ 9 2661          + ADD       TWO
        2579+13 2657          + STORE A   PRTROWAD     SET BASE BUFFER ADDR 
        2580+10 2660    PRTC1 + R ADD     ONE          DETERMINE MASKCOL WITH MASK TO SET IN CARD BUFFER
        2581+21   53          + L RIGHT   53           SET RIGHTMOST BIT OF MQ TO 1 (SHIFT 35+18=53)
        2582+10 2665          + R ADD     D35
        2583+ 5 2658          + SUB       N
        2584+13 2586          + STORE A   PRTC2
        2585+10 2644          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW
        2586+20    0    PRTC2 + L LEFT    /   /        SHIFT MQ LEFT N PLACES
        2587+ 4 2590          + TR 0      PRTC3        IF ACC STILL ZERO -> MASKCOL VALID
        2588+ 6 2660          + R SUB     ONE          ACC NOT ZERO -> SHOULD GENERATE -0 TO SET SIGN BIT ON
        2589+21   72          + L RIGHT   0072         NOW MQ = -0 -> LEFTMOST BIT OF MQ SET
        2590-14 2646    PRTC3 - STORE MQ  MASKCOL
        2591+10 2644          + R ADD     ZERO         READ THE BITMAP OF CHAR 
        2592+11 2655          + ADD AB    CHAR         DISCARD SIGN OF CHAR, IF ANY
        2593+12 2655          + STORE     CHAR
        2594+ 5 2667          + SUB       D48
        2595+ 3 2638          + TR +      PRTCEX       IF CHAR >= 48 EXIT
        2596+10 2652          + R ADD     BITMAPAD     IF ADDR OF BASE48 BITMAP NOT COMPUTED
        2597+ 4 2639          + TR 0      GETBMP1      TR TO LOAD IT
        2598+ 9 2655  GETBMP2 + ADD       CHAR         READ THE BITMAP OF CHAR 
        2599+13 2600          + STORE A   PRTC4        INDICATES THE BITS TO SET IN SELECTED 
        2600+10    0    PRTC4 + R ADD     /   /        COLUMN OF CARD BUFFER 
        2601+12 2659          + STORE     BITS
        2602+ 6 2660          + R SUB     ONE
        2603+12 2658          + STORE     N            SET TO -1
        2604+10 2658    LOOP1 + R ADD     N            CURRENT ROW (STARTS AT ZERO) = OFFSET ON PRTROWAD     
        2605+ 9 2660          + ADD       ONE
        2606+12 2658          + STORE     N
        2607+10 2659          + R ADD     BITS         EXTRACT RIGHTMOST BIT OF LEFT HALF OF ACC TO MQ
        2608+ 4 2638          + TR 0      PRTCEX       NO MORE BITS -> EXIT
        2609+21   19          + L RIGHT   0019         LSB BIT OF LEFT HALF-WORD OF ACC TO MQ
        2610+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 1 BIT)
        2611+12 2659          + STORE     BITS         SAVE BACK BITS. LSB HAS BEEN EXTACTED, CONTENTS SHIFTED RIGHT ONE PLACE
        2612+10 2644          + R ADD     ZERO
        2613+20    1          + L LEFT    0001         PUT EXTACTED BIT BACK INTO ACC
        2614+ 4 2604          + TR 0      LOOP1        NO BIT 
        2615+10 2658          + R ADD     N            READ THE ROW N AT CARD BUFFER 
        2616+22    2          + A LEFT    0002         MULT N BY 4 AS THERE ARE 4 HALF WORDS PER ROW
        2617+ 9 2657          + ADD       PRTROWAD     
        2618+13 2620          + STORE A   PRTROWR
        2619+13 2636          + STORE A   PRTROWW
        2620-10    0  PRTROWR - R ADD     /   /        
        2621-12 2648          - STORE     ROW          CURRENT CONTENTS OF ROW
        2622-10 2646          - R ADD     MASKCOL      "OR" MASKCOL IN SELECTED ROW
        2623+ 3 2631          + TR +      PRTW2
        2624-10 2648          - R ADD     ROW 
        2625+ 4 2629          + TR 0      PRTW1         
        2626+10 2644          + R ADD     ZERO         MASKCOL IS MINUS ZERO AND ROW IS NOT-EMPTY (EITHER POSITIVE OR NEGATIVE) -> SET ROW AS NEGATIVE
        2627- 7 2648          - SUB AB    ROW 
        2628+ 1 2636          + TR        PRTROWW
        2629-10 2646    PRTW1 - R ADD     MASKCOL      MASKCOL IS MINUS ZERO AND ROW IS EMPTY -> SET ROW = MASKCOL = MINUS ZERO
        2630+ 1 2636          + TR        PRTROWW
        2631-10 2648    PRTW2 - R ADD     ROW          
        2632+ 3 2635          + TR +      PRTW3              
        2633- 5 2646          - SUB       MASKCOL      MASKCOL IS POSITIVE AND ROW IS NEGATIVE -> SUB MASKCOL FROM ROW
        2634+ 1 2636          + TR        PRTROWW
        2635- 9 2646    PRTW3 - ADD       MASKCOL      MASKCOL IS POSITIVE AND ROW IS POSITIVE OR EMPTY -> ADD MASKCOL TO ROW         
        2636-12    0  PRTROWW - STORE     /   /        ROW UPDTATE
        2637+ 1 2604          + TR        LOOP1        PROCEED TO NEXT ROW
        2638+ 1    0 PRTCEX   + TR        /   /
        2639+10 2639 GETBMP1  + R ADD     *
        2640+ 1   81          + TR        BMPAD        GET BASE48 CHARS BITMAP ADDRESS
        2641+12 2652          + STORE     BITMAPAD     
        2642+ 1 2598          + TR        GETBMP2      RETURN
        2643+     0             ORG       EVEN
        2644+     0  ZERO       DEF       0            
        2645+     0             DEF       0            
        2646+     0  MASKCOL    DEF       0
        2647+     0             DEF       0
        2648+     0  ROW        DEF       0
        2649+     0             DEF       0
        2650+     0  NUM        DEF       0
        2651+     0             DEF       0
        2652+     0  BITMAPAD   DEF       0
        2653+     0  SGN        DEF       0
        2654+     0  LEN        DEF       0
        2655+     0  CHAR       DEF       0
        2656+     0  TXT        DEF       0
        2657+     0  PRTROWAD   DEF       0
        2658+     0  N          DEF       0
        2659+     0  BITS       DEF       0
        2660+     1  ONE        DEF       1
        2661+     2  TWO        DEF       2
        2662+     3  D3         DEF       3
        2663+    10  D10        DEF       10
        2664+    11  D11        DEF       11
        2665+    35  D35        DEF       35
        2666+    36  D36        DEF       36
        2667+    48  D48        DEF       48
        2668+    72  D72        DEF       72
        2669+  2304  D48X48     DEF       2304
        2670+ 16384  OCT04K     DEF       *040000      BIT SIGN ON 5TH OCTINARY DIGIT
        2672+ 9 2747 PRTNLINE + ADD       TWO          PRINT A NEW LINE OF DATA
        2673+12 2750          + STORE     PARAM        SAVE PARAM LIST ADDR
        2674+10 2674          + R ADD     *            CLEAR CARD BUFFER
        2675+ 1   69          + TR        CLRBUF 
        2676+10 2750 GPARAM   + R ADD     PARAM        GET PARAM PAIR FMT/DATA
        2677+13 2682          + STORE A   P1
        2678+ 9 2746          + ADD       ONE
        2679+13 2686          + STORE A   P2
        2680+ 9 2746          + ADD       ONE
        2681+12 2750          + STORE     PARAM
        2682+10    0 P1       + R ADD     /   /
        2683+12 2752          + STORE     FMT
        2684+ 3 2686          + TR +      P2           IF FMT < 0 THEM SKIP THIS PAIR FMT/DATA
        2685+ 1 2676          + TR        GPARAM
        2686+10    0 P2       + R ADD     /   /
        2687+12 2712          + STORE     DATALOC      GET DATA ADDRESS PASED AS PARAM
        2688+13 2689          + STORE A   P2A
        2689+10    0 P2A      + R ADD     /   /
        2690+12 2751          + STORE     DATA         GET EFFECTIVE DATA
        2691+10 2745          + R ADD     ZERO
        2692+15 2752          + LOAD MQ   FMT
        2693+18 2749          + DIV       D100         ACC=REMAINDER=COL NUMBER, MQ=QUOTIEN=TYPE OF DATA
        2694+12 2753          + STORE     COL
        2695+10 2745          + R ADD     ZERO
        2696+20   18          + L LEFT    0018
        2697+14 2752          + STORE MQ  FMT
        2698+15 2751          + LOAD MQ   DATA
        2699+10 2703          + R ADD     TYPETRAD
        2700+ 9 2752          + ADD       FMT
        2701+13 2702          + STORE A   TYPETR
        2702+ 1    0 TYPETR   + TR        /   /        TR SELECTED ROUTINE
        2703+ 0 2704 TYPETRAD + STOP      TYPETRT      TYPE TRANSFER TABLE ADDRESS
        2704+ 1 2733 TYPETRT  + TR        EOL          FMT=0..6 (IE <100) -> END OF PARAM LIST -> END OF LINE 
        2705+ 1 2710          + TR        TYSTR        FMT=1 -> PRINT A STRINGZ
        2706+ 1 2715          + TR        TYINT        FMT=2 -> PRINT AN INT
        2707+ 1 2720          + TR        TYOCT        FMT=3 -> PRINT AN OCT
        2708+ 1 2725          + TR        TYCHR        FMT=4 -> PRINT A CHAR
        2709+ 1 2729          + TR        TYALF        FMT=5 -> PRINT A 3-CHR PACKED ALFA STRING
        2710+10 2710 TYSTR    + R ADD     *            PRINT STRINGZ
        2711+ 1   77          + TR        PRTSTR
        2712+ 0    0 DATALOC  + STOP      /   /
        2713- 0 2753          - STOP      COL          COLUMN WHERE TXT STARTS
        2714+ 1 2676          + TR        GPARAM
        2715+10 2715 TYINT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2716+ 1   55          + TR        PRTINT
        2717+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        2718- 0 2753          - STOP      COL          COLUMN WHERE TXT STARTS
        2719+ 1 2676          + TR        GPARAM
        2720+10 2720 TYOCT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2721+ 1   79          + TR        PRTOCT
        2722+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        2723- 0 2753          - STOP      COL          COLUMN WHERE TXT STARTS
        2724+ 1 2676          + TR        GPARAM
        2725+10 2725 TYCHR    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2726+ 1   57          + TR        PRTCHR
        2727- 0 2753          - STOP      COL          COLUMN WHERE TXT STARTS
        2728+ 1 2676          + TR        GPARAM
        2729+10 2729 TYALF    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2730+ 1   75          + TR        PRTALF
        2731- 0 2753          - STOP      COL          COLUMN WHERE TXT STARTS
        2732+ 1 2676          + TR        GPARAM
        2733+10 2753 EOL      + R ADD     COL          SEND CARD BUFFER TO PRINTER AND RETURN TO CALLER
        2734+ 4 2739          + TR 0      DOPRINT      =0 -> PRINT ALLWAYS (NO SENSE SW CHECK)
        2735+ 9 2748          + ADD       D68          =1..6 -> SENSE 69..74 = OPERATOR'S PANEL SENSE SWITCH 1..6
        2736+13 2737          + STORE A   CHKSW
        2737+30    0 CHKSW    + SENSE     /   /         
        2738+ 1 2741          + TR        RETURN       SW NOT AT ON POSITION
        2739+10 2739 DOPRINT  + R ADD     *            PRINT CARD BUFFER
        2740+ 1   59          + TR        PRINTCRD
        2741+10 2750 RETURN   + R ADD     PARAM        PARAM-1 IS THE RETURN ADDR      
        2742+ 5 2746          + SUB       ONE
        2743+13 2744          + STORE A   EXIT
        2744+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        2745+ 0    0 ZERO     + STOP      0000
        2746+ 0    1 ONE      + STOP      0001
        2747+ 0    2 TWO      + STOP      0002
        2748+ 0   68 D68      + STOP      0068
        2749+ 0  100 D100     + STOP      100
        2750+ 0    0 PARAM    + STOP      0000
        2751+ 0    0 DATA     + STOP      0000
        2752+ 0    0 FMT      + STOP      0000
        2753+ 0    0 COL      + STOP      0000
        2754+ 9 2768 BMPAD    + ADD       TWO
        2755+13 2757          + STORE A   EXIT
        2756+10 2758          + R ADD     BITMAPAD
        2757+ 1    0 EXIT     + TR        /   /
        2758+ 0 2760 BITMAPAD + STOP      BITMAP
        2759+     0             ORG       EVEN
        2760+     0  BITMAP     DEF       0              <blank>     0     <none>
        2761+   256             DEF       256               1        1       1        256          =  256   
        2762+   128             DEF       128               2        2       2        128          =  128   
        2763+    64             DEF       64                3        3       3         64          =   64   
        2764+    32             DEF       32                4        4       4         32          =   32   
        2765+    16             DEF       16                5        5       5         16          =   16   
        2766+     8             DEF       8                 6        6       6          8          =    8   
        2767+     4             DEF       4                 7        7       7          4          =    4   
        2768+     2  TWO        DEF       2                 8        8       8          2          =    2   
        2769+     1             DEF       1                 9        9       9          1          =    1   
        2770+   512             DEF       512               0       10       0        512          =  512   
        2771+  1024             DEF       1024              -       11       X       1024          = 1024   
        2772+  2048             DEF       2048              +       12       Y       2048          = 2048   
        2773+  2304             DEF       2304              A       13      Y-1        256+2048    = 2304   
        2774+  2176             DEF       2176              B       14      Y-2        128+2048    = 2176   
        2775+  2112             DEF       2112              C       15      Y-3         64+2048    = 2112   
        2776+  2080             DEF       2080              D       16      Y-4         32+2048    = 2080   
        2777+  2064             DEF       2064              E       17      Y-5         16+2048    = 2064   
        2778+  2056             DEF       2056              F       18      Y-6          8+2048    = 2056   
        2779+  2052             DEF       2052              G       19      Y-7          4+2048    = 2052   
        2780+  2050             DEF       2050              H       20      Y-8          2+2048    = 2050   
        2781+  2049             DEF       2049              I       21      Y-9          1+2048    = 2049   
        2782+  1280             DEF       1280              J       22      X-1        256+1024    = 1280   
        2783+  1152             DEF       1152              K       23      X-2        128+1024    = 1152   
        2784+  1088             DEF       1088              L       24      X-3         64+1024    = 1088   
        2785+  1056             DEF       1056              M       25      X-4         32+1024    = 1056   
        2786+  1040             DEF       1040              N       26      X-5         16+1024    = 1040   
        2787+  1032             DEF       1032              O       27      X-6          8+1024    = 1032   
        2788+  1028             DEF       1028              P       28      X-7          4+1024    = 1028   
        2789+  1026             DEF       1026              Q       29      X-8          2+1024    = 1026   
        2790+  1025             DEF       1025              R       30      X-9          1+1024    = 1025   
        2791+   640             DEF       640               S       31      0-2        128+512     = 640    
        2792+   576             DEF       576               T       32      0-3         64+512     = 576    
        2793+   544             DEF       544               U       33      0-4         32+512     = 544    
        2794+   528             DEF       528               V       34      0-5         16+512     = 528    
        2795+   520             DEF       520               W       35      0-6          8+512     = 520    
        2796+   516             DEF       516               X       36      0-7          4+512     = 516    
        2797+   514             DEF       514               Y       37      0-8          2+512     = 514    
        2798+   513             DEF       513               Z       38      0-9          1+512     = 513    
        2799+   578             DEF       578               ,       39      8-3-0        2+64+512  = 578    
        2800+   546             DEF       546               %       40      8-4-0        2+32+512  = 546    
        2801+  1090             DEF       1090              $       41      8-3-X        2+64+1024 = 1090   
        2802+  1058             DEF       1058              *       42      8-4-X        2+32+1024 = 1058   
        2803+  2114             DEF       2114              .       43      8-3-Y        2+64+2048 = 2114   
        2804+  2082             DEF       2082              #       44      8-4-Y        2+32+2048 = 2082   
        2805+   768             DEF       768               /       45      0-1          512+256   = 768    
        2806+    66             DEF       66                +       46      8-3          2+64      = 66     
        2807+    34             DEF       34                -       47      8-4          2+32      = 34    This is the non-minus-sign separator
        2808+ 9 2832 CLMEM    + ADD       TWO 
        2809+13 2814          + STORE A   P1           PARM: ADDR 
        2810+ 9 2831          + ADD       ONE          
        2811+13 2816          + STORE A   P2           PARM: LOCATION OF LEN=NUMBER OF HALF-WORDS TO CLEAR 
        2812+ 9 2831          + ADD       ONE          
        2813+13 2822          + STORE A   EXIT
        2814+10    0 P1       + R ADD     /   /        GET ADDR TO CLEAR
        2815+13 2825          + STORE A   MEM
        2816+10    0 P2       + R ADD     /   /        GET LEN ADDR
        2817+13 2818          + STORE A   P2A
        2818+10    0 P2A      + R ADD     /   /        GET LEN 
        2819+12 2833          + STORE     LEN
        2820+15 2830          + LOAD MQ   ZERO
        2821+10 2833 LOOP     + R ADD     LEN
        2822+ 4    0 EXIT     + TR 0      /   /
        2823+ 5 2831          + SUB       ONE
        2824+12 2833          + STORE     LEN
        2825+14    0 MEM      + STORE MQ  /   /        
        2826+10 2825          + R ADD     MEM
        2827+ 9 2831          + ADD       ONE
        2828+13 2825          + STORE A   MEM
        2829+ 1 2821          + TR        LOOP
        2830+ 0    0 ZERO     + STOP      0000
        2831+ 0    1 ONE      + STOP      0001         constant 1
        2832+ 0    2 TWO      + STOP      0002         constant 2
        2833+ 0    0 LEN      + STOP      0000
        2834+ 9 2907 RWDRUM   + ADD       TWO 
        2835+13 2844          + STORE A   PDR1         PARM1: DRUM INSTR: READ/WRITE 0128  0129  0130  0131
        2836+ 9 2906          + ADD       ONE          
        2837+13 2846          + STORE A   PDR2         PARM2: DRUM ADDRESS (0..4094)
        2838+ 9 2906          + ADD       ONE          
        2839+13 2848          + STORE A   PDR3         PARM3: BUF START ADDRESS
        2840+ 9 2906          + ADD       ONE          
        2841+13 2850          + STORE A   PDR4         PARM4: LEN: NUMBER OF HALF-WORDS (MUST BE EVEN)
        2842+ 9 2906          + ADD       ONE          
        2843+13 2904          + STORE A   EXIT               
        2844+10    0 PDR1     + R ADD     /   /        GET DRUM INSTR
        2845+12 2852          + STORE     DRIO
        2846+10    0 PDR2     + R ADD     /   /        GET DRUM ADDR
        2847+13 2853          + STORE A   DRADDR
        2848+10    0 PDR3     + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        2849+13 2891          + STORE A   RWCOPY    
        2850+10    0 PDR4     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        2851+12 2908          + STORE     LEN
        2852+ 0    0 DRIO     + STOP      /   /        INSTR: READ/WRITE 0128  0129  0130  0131
        2853+29    0 DRADDR   + SET DR    /   /
        2854+ 1 2887          + TR        LOOP
        2855+ 9 2907 RDTAPE   + ADD       TWO 
        2856+13 2863          + STORE A   PR1          PARM1: TAPE ADDRESS
        2857+ 9 2906          + ADD       ONE          
        2858+13 2865          + STORE A   PR2          PARM2: BUF START ADDRESS
        2859+ 9 2906          + ADD       ONE          
        2860+13 2904          + STORE A   EXIT
        2861+ 2 2862          + TR OV     CLOV1        CLEAR OV THAT MAY HAVE BEEN SET
        2862+ 8    0    CLOV1 + NOOP      0000
        2863+10    0 PR1      + R ADD     /   /        GET TAPE ADDR
        2864+13 2867          + STORE A   RTAPAD       TAPE UNITS: 0256  0257  0258  0259
        2865+10    0 PR2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        2866+13 2891          + STORE A   RWCOPY    
        2867+24    0 RTAPAD   + READ      /   /
        2868+10 2905          + R ADD     ZERO
        2869+ 1 2889          + TR        LOOP1
        2870+ 9 2907 WRTAPE   + ADD       TWO 
        2871+13 2878          + STORE A   PW1          PARM1: TAPE ADDRESS
        2872+ 9 2906          + ADD       ONE          
        2873+13 2880          + STORE A   PW2          PARM2: BUF START ADDRESS
        2874+ 9 2906          + ADD       ONE          
        2875+13 2882          + STORE A   PW3          PARM3: BUF LEN
        2876+ 9 2906          + ADD       ONE          
        2877+13 2904          + STORE A   EXIT
        2878+10    0 PW1      + R ADD     /   /        GET TAPE ADDR
        2879+13 2886          + STORE A   WTAPAD       TAPE UNITS: 0256  0257  0258  0259
        2880+10    0 PW2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        2881+13 2891          + STORE A   RWCOPY    
        2882+10    0 PW3      + R ADD     /   /        GET ADDR OF LEN 
        2883+13 2884          + STORE A   PW3A
        2884+10    0 PW3A     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        2885+12 2908          + STORE     LEN
        2886+26    0 WTAPAD   + WRITE     /   /        PREPARE TO WRITE ON TAPE
        2887+10 2908 LOOP     + R ADD     LEN
        2888+ 4 2903          + TR 0      RWOK
        2889+ 5 2907 LOOP1    + SUB       TWO
        2890+12 2908          + STORE     LEN
        2891-31    0 RWCOPY   - COPY      /   /        WRITE BUFFER TO TAPE
        2892+ 1 2895          + TR        GO 
        2893+ 1 2899          + TR        EOF          END OF FILE
        2894+ 1 2901          + TR        EOR          END OF RECORD
        2895+10 2891 GO       + R ADD     RWCOPY
        2896+ 5 2907          + SUB       TWO
        2897+13 2891          + STORE A   RWCOPY
        2898+ 1 2887          + TR        LOOP
        2899+10 2906 EOF      + R ADD     ONE          SET OV FLAG TO SIGNAL END OF FILE CONDITION
        2900+22   36          + A LEFT    36
        2901+ 6 2908 EOR      + R SUB     LEN          RETURN NUMBER OF HALF-WORDS READ
        2902+ 5 2907          + SUB       TWO
        2903+26 2052 RWOK     + WRITE     2052         INSURE THAT MQ NOT IN USE            
        2904+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        2905+ 0    0 ZERO     + STOP      0000
        2906+ 0    1 ONE      + STOP      0001         
        2907+ 0    2 TWO      + STOP      0002         
        2908+     0  LEN        RES       1
        2910+ 9 2925 CHAIN    + ADD       TWO
        2911+13 2912          + STORE A   CHP1
        2912+10    0 CHP1     + R ADD     /   /        GET TAPE NUMBER
        2913+13 2920          + STORE A   TAPELOAD
        2914+30   70          + SENSE     0070         SENSE SWITCH 2                                  
        2915+ 1 2919 CONTAD   + TR        ENDSTOP      (ON POSITION MAKES SENSE OPCODE TO SKIP NEXT INSTR)
        2916+10 2915          + R ADD     CONTAD       IF SW2 IS ON, A +STOP 4095 IS EXECUTED.  
        2917+12 4095          + STORE     4095         IF THEN USER PRESS START, EXECUTION WILL BE RESUMED 
        2918+ 0 4095          + STOP      4095         AND CHAINED PROGRAM WILL BE LOADED AND EXECUTED
        2919+ 8    0 ENDSTOP  + NOOP      0000
        2920+24    0 TAPELOAD + READ      0000         
        2921-31    0 TL0      - COPY      0000         READ 1ST WORD OF SELF-LOADER FROM TAPE
        2922+ 1    0          + TR        0000         TR TO SELF-LOADER
        2923+ 0 2221          + STOP      2221         ERROR LOADING: UNEXPECTED END OF FILE
        2924+ 0 2222          + STOP      2222         ERROR LOADING: UNEXPECTED END OF RECORD 
        2925+ 0    2 TWO      + STOP      0002         ERROR LOADING: UNEXPECTED END OF FILE
          48-     0  ROUTINE INIT
          49+ 1  225 ENTRY POINT
          50-     0  ROUTINE CHAIN
          51+ 1 2910 ENTRY POINT
          52-     0  ROUTINE PRTNLINE
          53+ 1 2672 ENTRY POINT
          54-     0  ROUTINE PRTINT
          55+ 1 2512 ENTRY POINT
          56-     0  ROUTINE PRTCHR
          57+ 1 2554 ENTRY POINT
          58-     0  ROUTINE PRINTCRD
          59+ 1 2350 ENTRY POINT
          60-     0  ROUTINE RDTAPE
          61+ 1 2855 ENTRY POINT
          62-     0  ROUTINE WRTAPE
          63+ 1 2870 ENTRY POINT
          64-     0  ROUTINE RWDRUM
          65+ 1 2834 ENTRY POINT
          66-     0  ROUTINE CLMEM
          67+ 1 2808 ENTRY POINT
          68-     0  ROUTINE CLRBUF
          69+ 1 2342 ENTRY POINT
          70-     0  ROUTINE READCRD
          71+ 1 2346 ENTRY POINT
          72-     0  ROUTINE WRITECRD
          73+ 1 2348 ENTRY POINT
          74-     0  ROUTINE PRTALF
          75+ 1 2434 ENTRY POINT
          76-     0  ROUTINE PRTSTR
          77+ 1 2411 ENTRY POINT
          78-     0  ROUTINE PRTOCT
          79+ 1 2478 ENTRY POINT
          80-     0  ROUTINE BMPAD
          81+ 1 2754 ENTRY POINT
        4094+    48  REGION ORIGIN TABLE LOCATION
        4095+   225  INITIAL REGION
           0+ 1  225          + TR        INIT         PROGRAM START
