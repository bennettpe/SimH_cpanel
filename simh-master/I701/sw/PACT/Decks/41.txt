        DEC
        NNNN OP ADDR COMMENTS
          88+ 9 1342 LOADCC   + ADD       TWO          LOAD PACTSCR INTO CARD IMAGE SO 
          89+13  108          + STORE A   CPCCEX       CURRENT PACT SOURCE CODE CAN BE PRINTED
          90+10 1339          + R ADD     ZERO         COPY TO LEFT SIDE OF SOURCE CODE CARD IMAGE
          91+13   95          + STORE A   CPCC1        AT 0..46 FROM PACTSCR
          92+10  111          + R ADD     CPCC2
          93+13   94          + STORE A   CPCC 
          94-10    0 CPCC     - R ADD     /   /
          95-12    0 CPCC1    - STORE     /   /
          96+10   95          + R ADD     CPCC1
          97+ 5 1342          + SUB       TWO
          98+13  100          + STORE A   CPCC1B
          99+10 1339          + R ADD     ZERO
         100-12    0 CPCC1B   - STORE     /   /
         101+10   94          + R ADD     CPCC
         102+ 5 1342          + SUB       TWO
         103+13   94          + STORE A   CPCC
         104+10   95          + R ADD     CPCC1
         105+ 5 1344          + SUB       D4
         106+13   95          + STORE A   CPCC1
         107+ 5  110          + SUB       CPCCE
         108+ 4    0 CPCCEX   + TR 0      /   /        RETURN TO CALLER
         109+ 1   94          + TR        CPCC
         110-12   48 CPCCE    - STORE     0048         LAST LOCATION TO COPY FROM 
         111+ 8 1090 CPCC2    + NOOP      PACTSRC      PACTSRC = FIRST LOCATION TO COPY FROM
         112+10  112 INIT     + R ADD     *            
         113+ 1   55          + TR        PRTNLINE     
         114+ 0  101          + STOP      0101         STRINGZ AT COL 1
         115+ 0 1400          + STOP      MSGSTART     "OPERATION EXPANSION"
         116+ 0  159          + STOP      0159         STRINGZ AT COL 59
         117+ 0 1408          + STOP      MSGSTAR2     "QPV QF QOP QR"
         118+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         119+10 1339          + R ADD     ZERO         CLEAR CC RECORD
         120+12 1114          + STORE     REGION     
         121+12 1115          + STORE     STEP       
         122+12 1116          + STORE     OP         
         123+12 1117          + STORE     FACT       
         124+12 1118          + STORE     S1         
         125+12 1119          + STORE     S2         
         126+12 1120          + STORE     QR         
         127+12 1121          + STORE     QF         
         128-12 1122          - STORE     NUM        
         129+12 1124          + STORE     CLUE       
         130+12 1125          + STORE     STEPN      
         131+12 1126          + STORE     FACTN      
         132+12 1127          + STORE     FACTREG    
         133+12 1128          + STORE     S1N        
         134+12 1129          + STORE     S2N        
         135+12 1130          + STORE     D1N        
         136+12 1131          + STORE     D2N        
         137+12 1132          + STORE     NINST      
         138+12 1133          + STORE     NINCR 
         139+10 1334          + R ADD     CCLEN        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         140+10 1337          + R ADD     DUMMY        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         141+10  141          + R ADD     *            CLEAR GENERATED MACHINE CODE INSTR ON CC RECORD
         142+ 1   75          + TR        CLMEM        
         143+ 0 1134 TINSTAD  + STOP      TINST      
         144+ 0 1359          + STOP      D200         TINST (200 HALF-WORDS) = 2 * MAXNINST (MAX NUMBER OF MACHINE CODE INSTRUTIONS PER STEP)
         145+10 1339          + R ADD     ZERO
         146+12 1335          + STORE     N
         147+10  147          + R ADD     *            
         148+ 1   73          + TR        RWDRUM       READ RELNUM0
         149+24  130          + READ      0130         DRUM INSTR
         150+ 0    0          + STOP      0000         DRUM ADDR 
         151+ 0 1336          + STOP      RELNUM0      REL NUM ORIGIN
         152+ 0    2          + STOP      0002         2 HALF WORDS
         153+28  257          + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE)
         154+28  258          + REWIND    TAPEOUT      REWIND TAPE OUT WITH UPDATED PACT COMPACT CODE
         155+10 1339 READREG  + R ADD     ZERO
         156+12 1361          + STORE     QRPREV       QR VALUE OF PREVIOUS STEP
         157+10  157 READSTEP + R ADD     *            READ PACT USER PROGRAM SOURCE CODE FROM TAPE IN
         158+ 1   69          + TR        RDTAPE
         159+ 0  257          + STOP      TAPEIN
         160+ 0 1090          + STOP      CCODE        BUF TO READ IN FROM TAPE
         161+ 2  279          + TR OV     EOF          TR IF END OF FILE
         162+10 1116          + R ADD     OP
         163+ 4  272          + TR 0      EOR          TR IF END OF REGION
         164+10  164          + R ADD     *            LOAD PACTSCR INTO CARD IMAGE SO 
         165+ 1   88          + TR        LOADCC       CURRENT PACT SOURCE CODE CAN BE PRINTED
         166+10 1361          + R ADD     QRPREV
         167+12 1362          + STORE     QRPREV0      SAVE INITAL VALUE OF QRPREV
         168+10 1360          + R ADD     D1000
         169+12 1363          + STORE     QROP         INIT QOP=1000 AS NOT USED
         170+10 1124          + R ADD     CLUE         
         171+ 5 1348          + SUB       D11          '-'
         172+ 4  178          + TR 0      FACTMI       CLUE IS MINUS
         173+10 1124          + R ADD     CLUE         
         174+ 5 1350          + SUB       D26          'N'
         175+ 4  178          + TR 0      FACTMI       CLUE IS MINUS
         176+15 1339          + LOAD MQ   ZERO
         177+ 1  179          + TR        FACTSGN
         178+15 1341 FACTMI   + LOAD MQ   ONE
         179+14 1376 FACTSGN  + STORE MQ  FACTNEG      IF =1 THEN FACT SHOULD BE USED WITH MINUS SIGN
         180+10 1116          + R ADD     OP           JUMP TABLE TO HANDLE THE FACTOR OF EACH TYPE OF PACT OPERATION
         181+ 9  184          + ADD       OPTBL
         182+13  183          + STORE A   OPTBLTR
         183+ 1    0 OPTBLTR  + TR        /   /
         184+ 0  184 OPTBL    + STOP      *
         185+ 1  381          + TR        TAKEFACT     OP=1   TAKE   FACTOR CANNOT BE BLANK 
         186+ 1  303          + TR        ADDSUB       OP=2   ADD    ALLOWS BLANK FACTOR -> BEHAVES AS ACC=ACC+ACC=ACC*2
         187+ 1  303          + TR        ADDSUB       OP=3   SUB    ALLOWS BLANK FACTOR ->            ACC=ACC-ACC -> ACC=0
         188+ 1  389          + TR        MULT         OP=4   MUL    ALLOWS BLANK FACTOR ->            ACC=ACC*ACC -> ACC=ACC^2
         189+ 1  414          + TR        DIV          OP=5   DIV    FACTOR CANNOT BE BLANK -> RSV: DIV UNARY IS A NON-SENSE, EVEN IF STATED AS ALLOWED ON MANUAL
         190+ 1  456          + TR        RESMQ        OP=6   RES    RSV: JUST RETRIEVES MQ, AT GIVEN QR
         191+ 1  373          + TR        EQVAR        OP=7   EQ     NEEDS VARIABLE AS FACTOR
         192+ 1  299          + TR        ADDABS       OP=8   +ABS   ALLOWS BLANK FACTOR
         193+ 1  301          + TR        SUBABS       OP=9   -ABS   ALLOWS BLANK FACTOR
         194+ 1  461          + TR        TAKEABS      OP=10  ABS    FACTOR CANNOT BE BLANK 
         195+ 1  546          + TR        TROP         OP=11  T      FACTOR=DESTINATION STEP, QR IGNORED
         196+ 1  552          + TR        TROP2        OP=12  TZ     FACTOR=DESTINATION STEP, SHIFT TO MATCH QR BEFORE CONDITIONAL TEST
         197+ 1  552          + TR        TROP2        OP=13  TP     FACTOR=DESTINATION STEP, SHIFT TO MATCH QR BEFORE CONDITIONAL TEST
         198+ 1  552          + TR        TROP2        OP=14  TN     FACTOR=DESTINATION STEP, SHIFT TO MATCH QR BEFORE CONDITIONAL TEST
         199+ 1  552          + TR        TROP2        OP=15  TF     FACTOR=DESTINATION STEP, SHIFT TO MATCH QR BEFORE CONDITIONAL TEST
         200+ 1  552          + TR        TROP2        OP=16  HALT   FACTOR=DESTINATION STEP, SHIFT TO MATCH QR BEFORE CONDITIONAL TEST
         201+ 1  230          + TR        NEXT         OP=17  TEST   WILL BE PROCESSED ON INDEX EXPANSION STAGE
         202+ 1  230          + TR        NEXT         OP=18  SET    WILL BE PROCESSED ON INDEX EXPANSION STAGE
         203+ 1  230          + TR        NEXT         OP=19  USE    WILL BE PROCESSED ON INDEX EXPANSION STAGE
         204+ 1  533          + TR        DO           OP=20  DO     FACTOR=REGION -> NO VARIABLE FACTOR TO PROCESS    
         205+ 1  580          + TR        EXIT         OP=21  EXIT
         206+ 1  229          + TR        BADOP2       OP=22  DUP    SHOULD NOT BE PRESENT. IT IS ALREADY PROCESSED
         207+ 1  529          + TR        LIB          OP=23  LIB    FACTOR=REGION -> NO VARIABLE FACTOR TO PROCESS    
         208+ 1  228          + TR        BADOP        OP=24  ID     SHOULD NOT BE PRESENT. IT IS DESAMBIGUATED
         209+ 1  228          + TR        BADOP        OP=25  FOR    SHOULD NOT BE PRESENT. IT IS DESAMBIGUATED
         210+ 1  230          + TR        NEXT         OP=26  CALL   WILL BE PROCESSED ON CALL EXPANSION STAGE
         211+ 1  466          + TR        SIN          OP=27  SIN    ALLOWS BLANK FACTOR
         212+ 1  469          + TR        COS          OP=28  COS    ALLOWS BLANK FACTOR
         213+ 1  472          + TR        ARCT         OP=29  ARCT   ALLOWS BLANK FACTOR
         214+ 1  475          + TR        SQRT         OP=30  SQRT   ALLOWS BLANK FACTOR
         215+ 1  478          + TR        LOG          OP=31  LOG    ALLOWS BLANK FACTOR
         216+ 1  481          + TR        EXP          OP=32  EXP    ALLOWS BLANK FACTOR
         217+ 1  586          + TR        SENSE        OP=33  SE
         218+ 1  590          + TR        CL           OP=34  CL     NEEDS VARIABLE AS FACTOR
         219+ 1  535          + TR        READ         OP=35  READ
         220+ 1  537          + TR        LIST         OP=36  LIST
         221+ 1  450          + TR        MULTRES      OP=37  RES for MULT        RETRIEVES RESIDUE AFTER MULT (FROM MQ)       
         222+ 1  230          + TR        NEXT         OP=38  RES for DIV         RES OP HANDLED WITHIN DIV PROCEESING
         223+ 1  592          + TR        IDLIST       OP=39  ID for LIST         FACTOR CAN BE BLANK 
         224+ 1  605          + TR        IDDO         OP=40  ID for DO/LIB       WILL BE PROCESSED HERE, AND IN CALL EXPANSION STAGE
         225+ 1  230          + TR        NEXT         OP=41  ID for CALL         WILL BE PROCESSED ON CALL EXPANSION STAGE
         226+ 1  230          + TR        NEXT         OP=42  FOR for DO/LIB      WILL BE PROCESSED ON CALL EXPANSION STAGE
         227+ 1  230          + TR        NEXT         OP=43  FOR for CALL        WILL BE PROCESSED ON CALL EXPANSION STAGE
         228+ 0 1111 BADOP    + STOP      1111         INTERNAL COMPILER ERROR: SHOULD NOT BE PRESENT. IT SHOULD HAVE BEEN DESAMBIGUATED
         229+ 0 1111 BADOP2   + STOP      1111         INTERNAL COMPILER ERROR: SHOULD NOT BE PRESENT. IT IS ALREADY PROCESSED
         230+ 8    0 NEXT     + NOOP      0000         CONTINUE 
         231+10 1334          + R ADD     CCLEN        SAVE MC INSTRUCTIONS GENERATED SO FAR
         232+ 9 1132          + ADD       NINST        ADD NINST TWICE AS EACH MC INSTR USES TWO HALF-WORDS
         233+ 9 1132          + ADD       NINST
         234+12 1335          + STORE     N
         235+10  235          + R ADD     *
         236+ 1   71          + TR        WRTAPE       WRITE MAGNETIC TAPE TAPEOUT (PACT COMPACT CODE)
         237+ 0  258          + STOP      TAPEOUT
         238+ 0 1090          + STOP      CCODE        BUF TO WRITE TO TAPE
         239+ 0 1335          + STOP      N            LEN
         240+30   74          + SENSE     0074         SENSE SWITCH 6
         241+ 1  270          + TR        ENDLOG1      TR IF NO LOG SELECTED
         242+10 1363          + R ADD     QROP
         243+ 5 1360          + SUB       D1000
         244+ 4  265          + TR 0      PRTQ2
         245+15 1362          + LOAD MQ   QRPREV0      PRINT VALUE OF QR AT ENTRY OF STEP 
         246+10  246          + R ADD     *                                    
         247+ 1   61          + TR        PRTINT
         248+ 0   60          + STOP      0060         AT COL 59
         249+ 0    2          + STOP      0002         LEN=2
         250+15 1121          + LOAD MQ   QF           PRINT VALUE OF QF OF STEP 
         251+10  251          + R ADD     *
         252+ 1   61          + TR        PRTINT
         253+ 0   63          + STOP      0063         AT COL 63
         254+ 0    2          + STOP      0002         LEN=2
         255+15 1363          + LOAD MQ   QROP         PRINT VALUE OF QOP 
         256+10  256          + R ADD     *
         257+ 1   61          + TR        PRTINT
         258+ 0   67          + STOP      0067         AT COL 67
         259+ 0    2          + STOP      0002         LEN=2
         260+15 1361          + LOAD MQ   QRPREV       PRINT VALUE OF QR AT END OF STEP
         261+10  261          + R ADD     *
         262+ 1   61          + TR        PRTINT
         263+ 0   71          + STOP      0071         AT COL 71
         264+ 0    2          + STOP      0002         LEN=2
         265+ 8    0 PRTQ2    + NOOP      0000
         266+10  266          + R ADD     *            PRINT STEP JUST PROCESSED
         267+ 1   57          + TR        PRINTCRD
         268+10  268          + R ADD     *
         269+ 1  961          + TR        PRTMC        PRINT TINST TABLE WITH MC INSTRUCTIONS GENERATED FOR THIS STEP
         270+ 8    0 ENDLOG1  + NOOP      0000 
         271+ 1  157          + TR        READSTEP
         272+ 8    0 EOR      + NOOP      0000         END OF REGION  
         273+10  273          + R ADD     *
         274+ 1   71          + TR        WRTAPE       WRITE MAGNETIC TAPE TAPEOUT (PACT COMPACT CODE)
         275+ 0  258          + STOP      TAPEOUT
         276+ 0 1090          + STOP      CCODE        BUF TO WRITE TO TAPE
         277+ 0 1334          + STOP      CCLEN        LEN
         278+ 1  155          + TR        READREG      PROCEED WITH NEXT REGION
         279+ 8    0 EOF      + NOOP      0000         END OF FILE
         280+27  258          + WRITE EF  TAPEOUT      WRITE EOF IN TAPE OUT (COMPACT CODE)
         281+28  257          + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE)
         282+28  258          + REWIND    TAPEOUT      REWIND TAPE OUT WITH UPDATED PACT COMPACT CODE
         283+10  283          + R ADD     *
         284+ 1   51          + TR        CHAIN        IF SW2 IS ON, A +STOP 4095 IS EXECUTED 
         285+ 0  256          + STOP      PACTCOMP     CHAIN TO NEXT STAGE IN PACT COMPILER TAPE
         286+ 0 4095          + STOP      4095
         287+ 9 1342 ERROR    + ADD       TWO
         288+13  289          + STORE A   ERRP1
         289+10    0 ERRP1    + R ADD     /   /
         290+13  296          + STORE A   ERRSTRZ      SAVE ADDR OF ERROR TXT MESSAGE
         291+10  291          + R ADD     *            PRINT USER PROGRAM SOURCE CODE CARD JUST PROCESSED
         292+ 1   57          + TR        PRINTCRD
         293+10  293          + R ADD     *
         294+ 1   55          + TR        PRTNLINE     
         295+ 0  101          + STOP      0101         STRINGZ AT COL 1
         296+ 0    0 ERRSTRZ  + STOP      /   /        ERROR MESSAGE
         297+ 0    0          + STOP      0000         END OF LINE
         298+ 0  157          + STOP      READSTEP     IF USER PRESS STARTS, PROGRAM RESUMES PROCESSING NEXT SOURCE CODE STEP 
         299+15  650 ADDABS   + LOAD MQ   MC.AABS
         300+ 1  314          + TR        AS5
         301+15  670 SUBABS   + LOAD MQ   MC.SABS
         302+ 1  314          + TR        AS5
         303+10 1376 ADDSUB   + R ADD     FACTNEG
         304+ 4  308          + TR 0      ASPLUS
         305+10 1345          + R ADD     D5           IF - FACT -> OP=2 ADD BECOMES OP=3 SUB, OP=3 BECOMES OP=2
         306+ 5 1116          + SUB       OP  
         307+ 1  309          + TR        AS3
         308+10 1116 ASPLUS   + R ADD     OP
         309+ 5 1342 AS3      + SUB       TWO          HERE ACC=0 FOR OP=ADD, =1 FOR SUB
         310+ 4  313          + TR 0      AS4
         311+15  632          + LOAD MQ   MC.SUB       MACHINE CODE TABLE FOR OP=SUB
         312+ 1  314          + TR        AS5
         313+15  614 AS4      + LOAD MQ   MC.ADD       MACHINE CODE TABLE FOR OP=ADD
         314+14 1364 AS5      + STORE MQ  MC.TABLE     HERE MQ=MACHINE CODE TABLE FOR OP
         315+10 1361          + R ADD     QRPREV       DETERMINE THE Q OF ARITH OPERATION RESULT
         316+ 5 1121          + SUB       QF
         317+ 3  320          + TR +      AQROP1       QROP = MAX(QRPREV, QF)
         318+10 1121          + R ADD     QF
         319+ 1  321          + TR        AQROP2
         320+10 1361 AQROP1   + R ADD     QRPREV
         321+12 1363 AQROP2   + STORE     QROP
         322+10 1127 GENARITH + R ADD     FACTREG      IF FACTREG=0 -> IS AN UNARY OPERATION 
         323+ 4  335          + TR 0      SHUNARY
         324+10 1361          + R ADD     QRPREV       // calc shift needed before arith instr to align Q of both operands (align to higher one)
         325+ 5 1121          + SUB       QF           // nShift = Qr_prev - Qf;
         326+12 1365          + STORE     SHIFT1       // if =0 -> no need to shift
         327+ 4  331          + TR 0      NOSH         // if >0 -> shift right n bits Fact before performing arithmetic instruction
         328+ 3  333          + TR +      SHFACT       // if <0 -> shift right abs(n) bits acc before using it in arithmetic instruction
         329+10 1342          + R ADD     TWO          MUST SHIFT ACC
         330+ 1  338          + TR        GENMCTBL
         331+10 1341 NOSH     + R ADD     ONE          NO NEED TO SHIFT FACT
         332+ 1  338          + TR        GENMCTBL
         333+10 1343 SHFACT   + R ADD     D3           MUST SHIFT FACT
         334+ 1  338          + TR        GENMCTBL
         335+10 1361 SHUNARY  + R ADD     QRPREV       ON UNARY ADD/SUB, THE QR OF OPERATION = QR OF ACC = QR PREV OPEARTION
         336+12 1363          + STORE     QROP
         337+10 1344          + R ADD     D4
         338+ 9 1364 GENMCTBL + ADD       MC.TABLE     DERREFRENENCE TABLE  MC.TABLE +STOP *
         339+13  340          + STORE A   GENMCRD                                    +STOP ADDR FOR NO SHIFT  
         340+10    0 GENMCRD  + R ADD     /   /                                      +STOP ADDR FOR SHIFT ACC 
         341+12 1364          + STORE     MC.TABLE                                   +STOP ADDR FOR SHIFT FACT
         342+10  342 GENARIT2 + R ADD     *            
         343+ 1  828          + TR        GENTABLE
         344+10 1120          + R ADD     QR
         345+ 4  367          + TR 0      SH2          IF =0 TR AS NO QR SET IN PACT INSTR. NO SHIFT On RESULT DONE, ASSUME THE QR OF OPERATION AS QR FOR NEXT OPERATION 
         346+ 5 1363          + SUB       QROP
         347+12 1365          + STORE     SHIFT1       IF QR=QROP TR AS NO SHIFT ON RESULT NEEDED
         348+ 4  367          + TR 0      SH2          IF QR < QROP TR TO SHIFT RESULT TO THE LEFT
         349+ 3  363          + TR +      SH1B         IF QR > QROP TR TO SHIFT RESULT TO THE RIGHT
         350+10 1116          + R ADD     OP           MUST SHIFT LEFT. IF OP=MULT, USE LONG SHIFH, AS MQ=LOWER 36 BITS OF MULT
         351+ 5 1344          + SUB       OPMULT       IF OP<>MULT, USE ACC SHIFT AS CONTENTS OF MQ IS UNKNOWN
         352+ 4  358          + TR 0      SH1A         
         353+10  353          + R ADD     *            SHIFT RESULT AFTER OP <> MULT
         354+ 1  817          + TR        GENINST      HERE ADD INSTR TO SHIFT RESULT TO LEFT USING "A LEFT"
         355+22 1002          + A LEFT    ANN          SO Q OF OPERATION RESULT (QROP) MATCHES QR DESIRED BY THE USER
         356+ 0    0          + STOP      0000
         357+ 1  367          + TR        SH2
         358+10  358 SH1A     + R ADD     *            SHIFT RESULT AFTER MULT
         359+ 1  817          + TR        GENINST      HERE ADD INSTR TO SHIFT RESULT TO LEFT USING "L LEFT"
         360+20 1002          + L LEFT    ANN          SO Q OF OPERATION RESULT (QROP) MATCHES QR DESIRED BY THE USER
         361+ 0    0          + STOP      0000
         362+ 1  367          + TR        SH2
         363+10  363 SH1B     + R ADD     *
         364+ 1  817          + TR        GENINST      HERE ADD INSTR TO SHIFT RESULT TO RIGHT
         365+21 1002          + L RIGHT   ANN          SO Q OF OPERATION RESULT (QROP) MATCHES QR DESIRED BY THE USER
         366+ 0    0          + STOP      0000
         367+10 1120 SH2      + R ADD     QR           IF QR=0 THEN USE QROP INSTEAD
         368+ 4  370          + TR 0      SH3          SET QRPREV=QR  (OR QRPREV=QROP IF QR IS ZERO)
         369+ 1  371          + TR        SH4
         370+10 1363 SH3      + R ADD     QROP
         371+12 1361 SH4      + STORE     QRPREV
         372+ 1  230          + TR        NEXT
         373+15  690 EQVAR    + LOAD MQ   MC.EQ        MACHINE CODE TABLE FOR OP=EQ  FACT
         374+10 1376          + R ADD     FACTNEG      =1 IF -FACT
         375+ 4  377          + TR 0      EQMC
         376+15  702          + LOAD MQ   MC.EQSUB     MACHINE CODE TABLE FOR OP=EQ -FACT
         377+14 1364 EQMC     + STORE MQ  MC.TABLE     HERE MQ=MACHINE CODE TABLE FOR OP
         378+10 1121          + R ADD     QF           DETERMINE THE Q OF OPERATION RESULT
         379+12 1363          + STORE     QROP
         380+ 1  322          + TR        GENARITH     TR TO SHIFT ACC TO QF BEFORE STORING IT. HERE QR=QF, SO NO SHIFT WILL BE DONE AFTER STORING
         381+15  720 TAKEFACT + LOAD MQ   MC.TAKE      MACHINE CODE TABLE FOR OP=TAKE  FACT
         382+10 1376          + R ADD     FACTNEG      =1 IF -FACT
         383+ 4  385          + TR 0      TAKMC
         384+15  721          + LOAD MQ   MC.TAKSB     MACHINE CODE TABLE FOR OP=TAKE -FACT
         385+14 1364 TAKMC    + STORE MQ  MC.TABLE     HERE MQ=MACHINE CODE TABLE FOR OP
         386+10 1121          + R ADD     QF           DETERMINE THE Q OF OPERATION RESULT: QROP=QF
         387+12 1363          + STORE     QROP
         388+ 1  342          + TR        GENARIT2     TR AS NO SHIFT NEED TO BE DONE BEFORE READING FACT. SHIFT WILL BE DONE AFTER READING FACT TO MATCH DESIRED QR
         389+10 1127 MULT     + R ADD     FACTREG      IF FACTOR IS BLANK, THEN 
         390+ 4  404          + TR 0      SQUARE       MULT SQUARES THE ACC 
         391+10 1376          + R ADD     FACTNEG      =1 IF -FACT
         392+ 4  395          + TR 0      MULT1
         393+15  727          + LOAD MQ   MC.MULTS
         394+ 1  399          + TR        MULTMC
         395-10 1122 MULT1    - R ADD     NUM
         396+ 5 1342          + SUB       TWO
         397+ 4  409          + TR 0      MULTX2 
         398+15  726          + LOAD MQ   MC.MULT
         399+10 1361 MULTMC   + R ADD     QRPREV       DETERMINE THE Q OF OPERATION RESULT: QROP=QRPREV + QF
         400+ 9 1121          + ADD       QF
         401+12 1363          + STORE     QROP
         402+14 1364 GENMULT  + STORE MQ  MC.TABLE
         403+ 1  342          + TR        GENARIT2     TR AS NO SHIFT NEED TO BE DONE BEFORE READING FACT. 
         404+15  729 SQUARE   + LOAD MQ   MC.SQURE     GENERATE ACC = ACC X ACC    
         405+10 1361          + R ADD     QRPREV       DETERMINE THE Q OF OPERATION RESULT: QROP=QRPREV X 2
         406+ 9 1361          + ADD       QRPREV
         407+12 1363          + STORE     QROP
         408+ 1  402          + TR        GENMULT
         409+15  728 MULTX2   + LOAD MQ   MC.MULT2     GENERATE ACC=ACC X 2 (INTEGER)
         410+10 1361          + R ADD     QRPREV       DETERMINE THE Q OF OPERATION RESULT: QROP=QRPREV + 1
         411+ 9 1341          + ADD       ONE
         412+12 1363          + STORE     QROP
         413+ 1  402          + TR        GENMULT      TR AS NO SHIFT NEED TO BE DONE BEFORE READING FACT. 
         414+10  414 DIV      + R ADD     *            READ START OF NEXT COMPACT CODE RECORD 
         415+ 1   65          + TR        RDFTAPE      READ FORWARD FROM MAGNETIC TAPE A GIVEN LEN 
         416+ 0  257          + STOP      TAPEIN
         417+ 0 1134          + STOP      TINST        BUF TO READ IN FROM TAPE
         418+ 0 1351          + STOP      D28         
         419+10  419          + R ADD     *            READ BACK TO POSITION TAPE AT START OF NEXT COMPACT CODE RECORD 
         420+ 1   67          + TR        RDBTAPE      READ BACKWARDS FROM MAGNETIC TAPE A GIVEN LEN 
         421+ 0  257          + STOP      TAPEIN
         422+ 0 1134          + STOP      TINST        BUF TO READ IN FROM TAPE
         423+ 0 1342          + STOP      TWO         
         424+10 1350          + R ADD     D26
         425+ 9  143          + ADD       TINSTAD
         426+13  427          + STORE A   DIV1
         427+10    0 DIV1     + R ADD     /   /        ACC=OP OF STEPN JUST FOLLOWING CURRENT DIV
         428+12 1377          + STORE     OP2          SAVE IT 
         429+10 1376          + R ADD     FACTNEG      =1 IF -FACT
         430+ 4  433          + TR 0      DIVP
         431+15  742          + LOAD MQ   MC.DIVS
         432+ 1  434          + TR        DIVMC
         433+15  741 DIVP     + LOAD MQ   MC.DIV
         434+14 1364 DIVMC    + STORE MQ  MC.TABLE
         435+10 1377          + R ADD     OP2
         436+ 5 1356          + SUB       OPDIVRES
         437+ 4  446          + TR 0      DIVRES       TR IF A RES FOLLOWS THE DIV OPERATION
         438+10 1361          + R ADD     QRPREV       DETERMINE THE Q OF OPERATION RESULT: QROP=QRPREV - QF
         439+ 5 1121          + SUB       QF
         440+12 1363          + STORE     QROP
         441+10  441          + R ADD     *            GENERATE DIV MC INSTR        
         442+ 1  828          + TR        GENTABLE
         443+15  743          + LOAD MQ   MC.GETMQ     MC INSTR TO GET QUOTIENT FROM MQ
         444+14 1364          + STORE MQ  MC.TABLE
         445+ 1  342          + TR        GENARIT2     TR AS NO SHIFT NEED TO BE DONE BEFORE READING FACT. SHIFT WILL BE DONE AFTER OPERATION TO MATCH DESIRED QR
         446+10 1361 DIVRES   + R ADD     QRPREV       DETERMINE THE Q OF OPERATION RESULT: QROP=QRPREV - 35
         447+ 5 1355          + SUB       D35
         448+12 1363          + STORE     QROP
         449+ 1  342          + TR        GENARIT2     TR AS NO SHIFT NEED TO BE DONE BEFORE READING FACT. SHIFT WILL BE DONE AFTER OPERATION TO MATCH DESIRED QR
         450+15  743 MULTRES  + LOAD MQ   MC.GETMQ     RETRIEVES RESIDUE IN MQ 
         451+14 1364          + STORE MQ  MC.TABLE    
         452+10 1361          + R ADD     QRPREV       DETERMINE THE Q OF OPERATION RESULT: QROP=QRPREV - 35 
         453+ 5 1355          + SUB       D35
         454+12 1363          + STORE     QROP
         455+ 1  342          + TR        GENARIT2     TR AS NO SHIFT NEED TO BE DONE BEFORE READING FACT. SHIFT WILL BE DONE AFTER OPERATION TO MATCH DESIRED QR
         456+15  743 RESMQ    + LOAD MQ   MC.GETMQ     RES NOT TIED TO DIV/MULT. JUST RETRIEVES MQ 
         457+14 1364          + STORE MQ  MC.TABLE
         458+10 1120          + R ADD     QR           RSV: Even it not stated in manual, seems logical that QR sets the Q to
         459+12 1363          + STORE     QROP         use on retrieved value of MQ
         460+ 1  342          + TR        GENARIT2     TR AS NO SHIFT NEED TO BE DONE BEFORE READING FACT. SHIFT WILL BE DONE AFTER OPERATION TO MATCH DESIRED QR
         461+15  752 TAKEABS  + LOAD MQ   MC.ABS       MACHINE CODE TABLE FOR OP=ABS  FACT
         462+14 1364          + STORE MQ  MC.TABLE     HERE MQ=MACHINE CODE TABLE FOR OP
         463+10 1121          + R ADD     QF           DETERMINE THE Q OF OPERATION RESULT: QROP=QF
         464+12 1363          + STORE     QROP
         465+ 1  342          + TR        GENARIT2     TR AS NO SHIFT NEED TO BE DONE BEFORE READING FACT. SHIFT WILL BE DONE AFTER READING FACT TO MATCH DESIRED QR
         466+15 1460 SIN      + LOAD MQ   FNSIN        'SI$'
         467+10 1341          + R ADD     ONE
         468+ 1  490          + TR        FNCALL
         469+15 1461 COS      + LOAD MQ   FNCOS        'CO$'
         470+10 1341          + R ADD     ONE
         471+ 1  490          + TR        FNCALL
         472+15 1462 ARCT     + LOAD MQ   FNARCT       'AT$'
         473+10 1341          + R ADD     ONE
         474+ 1  490          + TR        FNCALL
         475+15 1463 SQRT     + LOAD MQ   FNSQRT       'SQ$'
         476+10 1339          + R ADD     ZERO
         477+ 1  490          + TR        FNCALL
         478+15 1464 LOG      + LOAD MQ   FNLOG        'LO$'
         479+10 1346          + R ADD     D6
         480+ 1  490          + TR        FNCALL
         481+10 1120 EXP      + R ADD     QR           CHECK QR ON EXP STEP
         482+ 5 1341          + SUB       ONE          MUST BE >= ONE (ELSE, EXP ROUTINE OVERFLOWS)
         483+ 3  487          + TR +      EXP2
         484+10  484          + R ADD     *
         485+ 1  287          + TR        ERROR
         486+ 0 1388          + STOP      ERREQR0S     ERROR: QR OF EXP CANNOT BE LESS THAT ONE
         487+15 1465 EXP2     + LOAD MQ   FNEXP        'EX$'
         488+10 1120          + R ADD     QR
         489+ 1  490          + TR        FNCALL
         490+14 1366 FNCALL   + STORE MQ  TRANSFER     SYMBOL TO TRANSFER TO    
         491+12 1363          + STORE     QROP         Q OF FUNC RESULT 
         492+10 1127          + R ADD     FACTREG      IF FACTOR IS BLANK, THEN 
         493+ 4  499          + TR 0      FN1          FUNC ARGUMENT IS ACC
         494+10 1376          + R ADD     FACTNEG      =1 IF -FACT
         495+ 4  502          + TR 0      FN2
         496+15  757          + LOAD MQ   MC.FN-FA     FUNC ARG IS -FACT
         497+10 1121          + R ADD     QF
         498+ 1  505          + TR        FN3
         499+15  758 FN1      + LOAD MQ   MC.FNACC     FUNC ARG IS ACC
         500+10 1361          + R ADD     QRPREV
         501+ 1  505          + TR        FN3
         502+15  756 FN2      + LOAD MQ   MC.FNFAC     FUNC ARG IS +FACT
         503+10 1121          + R ADD     QF
         504+ 1  505          + TR        FN3
         505+12 1369 FN3      + STORE     PARAM1       PASS Q OF ARGUMENT TO CALLED ROUTINE
         506+14 1364          + STORE MQ  MC.TABLE
         507+10 1116          + R ADD     OP           OP=SQRT?
         508+ 5 1352          + SUB       D30
         509+ 4  514          + TR 0      FN4SQRT      TR IF YES, 
         510+10 1116          + R ADD     OP           OP=EXP?
         511+ 5 1353          + SUB       D32
         512+ 4  519          + TR 0      FN4EXP       TR IF YES, 
         513+ 1  342          + TR        GENARIT2     TR AS NO SHIFT NEED TO BE DONE BEFORE READING FACT. SHIFT WILL BE DONE AFTER OPERATION TO MATCH DESIRED QR
         514+10 1369 FN4SQRT  + R ADD     PARAM1       SPECIAL CASE: QROP OF SQRT = (PARAM1+1) DIV 2
         515+ 9 1341          + ADD       ONE
         516+23    1          + A RIGHT   0001
         517+12 1363          + STORE     QROP
         518+ 1  342          + TR        GENARIT2
         519+10 1354 FN4EXP   + R ADD     D34          SPECIAL CASE: 2ND PARAM: QR ARG FOR EXP = 34-PARAM1
         520+ 5 1369          + SUB       PARAM1
         521+12 1369          + STORE     PARAM1
         522+10  522          + R ADD     *            
         523+ 1  828          + TR        GENTABLE
         524+15  759          + LOAD MQ   MC.FN2
         525+14 1364          + STORE MQ  MC.TABLE
         526+10 1120          + R ADD     QR
         527+12 1370          + STORE     PARAM2       PARAM2=PASS TO FUNC Q OF RESULT SELECTED BY USER
         528+ 1  342          + TR        GENARIT2
         529+15 1117 LIB      + LOAD MQ   FACT
         530+14 1366          + STORE MQ  TRANSFER     SYMBOL TO TRANSFER TO 
         531+15  774          + LOAD MQ   MC.LIB        
         532+ 1  540          + TR        GENMC
         533+15 1117 DO       + LOAD MQ   FACT
         534+ 1  538          + TR        DOCALL
         535+15 1466 READ     + LOAD MQ   FNREAD       'RD$'
         536+ 1  538          + TR        DOCALL
         537+15 1467 LIST     + LOAD MQ   FNLIST       'LS$'
         538+14 1366 DOCALL   + STORE MQ  TRANSFER     SYMBOL TO TRANSFER TO 
         539+15  775          + LOAD MQ   MC.DO        LIBRARY ROUTINE CALL
         540+14 1364 GENMC    + STORE MQ  MC.TABLE     
         541+10  541          + R ADD     *            
         542+ 1  828          + TR        GENTABLE     GENERATE INSTR
         543+10 1120          + R ADD     QR           
         544+12 1361          + STORE     QRPREV       PROPAGATE QR TO NEXT INSTR
         545+ 1  230          + TR        NEXT
         546+15  781 TROP     + LOAD MQ   MC.TR        INST TABLE FOR TRANSFER OP
         547+10 1126          + R ADD     FACTN        DESTINATION STEPN
         548+12 1366          + STORE     TRANSFER
         549+10 1341          + R ADD     ONE          DESTIMATION IS LOCATION 1 OF STEPN
         550+12 1367          + STORE     TRSTLOC 
         551+ 1  540          + TR        GENMC
         552+10 1120 TROP2    + R ADD     QR           SHIFT TO MATCH QR BEFORE CONDITIONAL TEST
         553+ 4  568          + TR 0      TRNOSH
         554+ 5 1361          + SUB       QRPREV       // nShift = Qr - Qr_prev ;
         555+12 1365          + STORE     SHIFT1       // if =0 -> no need to shift
         556+ 4  570          + TR 0      TRSHOK       // if <0 -> shift left acc before performing conditional test
         557+ 3  563          + TR +      TRSHRI       // if >0 -> shift right acc before performing conditional test
         558+10  558          + R ADD     *            MUST SHIFT ACC LEFT 
         559+ 1  817          + TR        GENINST      HERE ADD INSTR TO SHIFT ACC TO LEFT
         560+22 1002          + A LEFT    ANN          CANNOT USE "L LEFT" BECAUSE "L LEFT" SET SIGN OF ACC TO MATCH MQ SIGN, THUS OVERWRITTING CURRENT ACC SIGN
         561+ 0    0          + STOP      0000
         562+ 1  570          + TR        TRSHOK
         563+10  563 TRSHRI   + R ADD     *            MUST SHIFT ACC RIGHT 
         564+ 1  817          + TR        GENINST      HERE ADD INSTR TO SHIFT ACC TO LEFT
         565+21 1002          + L RIGHT   ANN          
         566+ 0    0          + STOP      0000
         567+ 1  570          + TR        TRSHOK
         568+10 1361 TRNOSH   + R ADD     QRPREV       IF QR NOT SET, PROPAGATE QR OF PREVIOUS STEP
         569+12 1120          + STORE     QR
         570+10 1116 TRSHOK   + R ADD     OP           
         571+ 5 1347          + SUB       D10
         572+ 9  780          + ADD       MC.TRTAD 
         573+13  574          + STORE A   TR1
         574+15    0 TR1      + LOAD MQ   /   /        INST TABLE FOR TRANSFER OP
         575+10 1126          + R ADD     FACTN        DESTINATION STEPN
         576+12 1366          + STORE     TRANSFER
         577+10 1341          + R ADD     ONE          DESTIMATION IS LOCATION 1 OF STEPN
         578+12 1367          + STORE     TRSTLOC 
         579+ 1  540          + TR        GENMC
         580+15  781 EXIT     + LOAD MQ   MC.TR
         581+10 1341          + R ADD     ONE          // transfer to second inst of first step (the call's return addr)
         582+12 1366          + STORE     TRANSFER
         583+10 1342          + R ADD     TWO          DESTIMATION IS LOCATION 2 OF FIRST STEPN
         584+12 1367          + STORE     TRSTLOC 
         585+ 1  540          + TR        GENMC
         586+15  802 SENSE    + LOAD MQ   MC.SENSE
         587+10 1118          + R ADD     S1
         588+12 1369          + STORE     PARAM1
         589+ 1  540          + TR        GENMC
         590+15  805 CL       + LOAD MQ   MC.CL
         591+ 1  540          + TR        GENMC
         592+10 1127 IDLIST   + R ADD     FACTREG
         593+ 4  601          + TR 0      IDLI0        TR IF NO FACT
         594+10 1120          + R ADD     QR           IF QR IS SET, USE IT TO OVERRIDE THE QF OF VARIABLE/NUMBER
         595+ 4  597          + TR 0      IDLI1        THIS ALLOWS TO PRINT ANY VAR AT ANY Q
         596+ 1  598          + TR        IDLI2
         597+10 1121 IDLI1    + R ADD     QF
         598+12 1369 IDLI2    + STORE     PARAM1       THE Q TO USE WHEN PRINTING THE FACTOR
         599+15  809          + LOAD MQ   MC.IDLST     ID FOR LIST WITH FACTOR=VAR OR NUM
         600+ 1  540          + TR        GENMC
         601+10 1339 IDLI0    + R ADD     ZERO
         602+12 1369          + STORE     PARAM1
         603+15  810          + LOAD MQ   MC.IDLS0     ID FOR LIST WITH NO VAR 
         604+ 1  540          + TR        GENMC
         605+10 1127 IDDO     + R ADD     FACTREG                  ID with DO INSTR
         606+ 5 1354          + SUB       D34          'V'         IF INST IS "ID VAR" -> VAR CAN BE A VECTOR OR A MATRIX, TO BE 
         607+ 4  609          + TR 0      IDDOADDR                 PROCESSED IN LOOP EXPANSION STAGE -> GENERATE INST NOW 
         608+ 1  230          + TR        NEXT                     ELSE DO NOT GENERATE INSTR AND PROCEES WITH NEXT INSTR
         609+10  609 IDDOADDR + R ADD     *            GENERATE THE INSTRUCTIONS FOR CALLER'S PARAMETERS
         610+ 1  817          + TR        GENINST     
         611- 0 1004          - STOP      CC.FACT      '-H  V nnnn'  OR '-H  T nnnn'
         612+ 0    0          + STOP      0000         END OF INSTR TABLE
         613+ 1  230          + TR        NEXT
         614+ 0  614 MC.ADD   + STOP      *
         615+ 0  619          + STOP      MC.ADD0      mc table addr for no shift
         616+ 0  621          + STOP      MC.ADDSA                       acc shift
         617+ 0  624          + STOP      MC.ADDFA                       factor shift
         618+ 0  629          + STOP      MC.ADDU                        unary operation
         619- 9 1004 MC.ADD0  - ADD       CC.FACT      no shift needed
         620+ 0    0          + STOP      0000
         621+21 1002 MC.ADDSA + L RIGHT   ANN          acc shift right needed
         622- 9 1004          - ADD       CC.FACT      
         623+ 0    0          + STOP      0000
         624-12 1001 MC.ADDFA - STORE     T0           fact shift right needed
         625-10 1004          - R ADD     CC.FACT
         626+21 1002          + L RIGHT   ANN 
         627- 9 1001          - ADD       T0      
         628+ 0    0          + STOP      0000
         629-12 1001 MC.ADDU  - STORE     T0           unary add -> Acc=acc + acc
         630- 9 1001          - ADD       T0
         631+ 0    0          + STOP      0000
         632+ 0  632 MC.SUB   + STOP      *
         633+ 0  637          + STOP      MC.SUB0      mc table addr for no shift
         634+ 0  639          + STOP      MC.SUBSA                       acc shift
         635+ 0  642          + STOP      MC.SUBFA                       factor shift
         636+ 0  647          + STOP      MC.SUBU                        unary operation
         637- 5 1004 MC.SUB0  - SUB       CC.FACT      no shift needed
         638+ 0    0          + STOP      0000
         639+21 1002 MC.SUBSA + L RIGHT   ANN          acc shift right needed
         640- 5 1004          - SUB       CC.FACT      
         641+ 0    0          + STOP      0000
         642-12 1001 MC.SUBFA - STORE     T0           fact shift right needed
         643- 6 1004          - R SUB     CC.FACT
         644+21 1002          + L RIGHT   ANN
         645- 9 1001          - ADD       T0      
         646+ 0    0          + STOP      0000
         647-12 1001 MC.SUBU  - STORE     T0           unary sub -> Acc=Acc-Acc
         648- 5 1001          - SUB       T0
         649+ 0    0          + STOP      0000
         650+ 0  650 MC.AABS  + STOP      *
         651+ 0  655          + STOP      MC.AABS0     mc table addr for no shift
         652+ 0  657          + STOP      MC.AABSA                       acc shift
         653+ 0  660          + STOP      MC.AABSF                       factor shift
         654+ 0  666          + STOP      MC.AABSU                       unary operation
         655-11 1004 MC.AABS0 - ADD AB    CC.FACT      no shift needed
         656+ 0    0          + STOP      0000
         657+21 1002 MC.AABSA + L RIGHT   ANN          acc shift right needed
         658-11 1004          - ADD AB    CC.FACT      
         659+ 0    0          + STOP      0000
         660-12 1001 MC.AABSF - STORE     T0           fact shift right needed
         661-10 1005          - R ADD     N0
         662-11 1004          - ADD AB    CC.FACT
         663+21 1002          + L RIGHT   ANN 
         664- 9 1001          - ADD       T0      
         665+ 0    0          + STOP      0000
         666-12 1001 MC.AABSU - STORE     T0           unary +abs -> Acc=abs(acc)
         667-10 1005          - R ADD     N0
         668-11 1001          - ADD AB    T0
         669+ 0    0          + STOP      0000
         670+ 0  670 MC.SABS  + STOP      *
         671+ 0  675          + STOP      MC.SABS0     mc table addr for no shift
         672+ 0  677          + STOP      MC.SABSA                       acc shift
         673+ 0  680          + STOP      MC.SABSF                       factor shift
         674+ 0  686          + STOP      MC.SABSU                       unary operation
         675- 7 1004 MC.SABS0 - SUB AB    CC.FACT      no shift needed
         676+ 0    0          + STOP      0000
         677+21 1002 MC.SABSA + L RIGHT   ANN          acc shift right needed
         678- 7 1004          - SUB AB    CC.FACT      
         679+ 0    0          + STOP      0000
         680-12 1001 MC.SABSF - STORE     T0           fact shift right needed
         681-10 1005          - R ADD     N0
         682- 7 1004          - SUB AB    CC.FACT
         683+21 1002          + L RIGHT   ANN 
         684- 9 1001          - ADD       T0      
         685+ 0    0          + STOP      0000
         686-12 1001 MC.SABSU - STORE     T0           unary +abs -> Acc=abs(acc)
         687-10 1005          - R ADD     N0
         688- 7 1001          - SUB AB    T0
         689+ 0    0          + STOP      0000
         690+ 0  690 MC.EQ    + STOP      *
         691+ 0  694          + STOP      MC.EQ0       mc table addr for no shift
         692+ 0  696          + STOP      MC.EQSR                        acc shift right
         693+ 0  699          + STOP      MC.EQSL                        acc shift left
         694-12 1004 MC.EQ0   - STORE     CC.FACT      no shift needed
         695+ 0    0          + STOP      0000
         696+21 1002 MC.EQSR  + L RIGHT   ANN          acc shift right needed
         697-12 1004          - STORE     CC.FACT      
         698+ 0    0          + STOP      0000
         699+22 1002 MC.EQSL  + A LEFT    ANN          acc shift left needed
         700-12 1004          - STORE     CC.FACT      
         701+ 0    0          + STOP      0000
         702+ 0  702 MC.EQSUB + STOP      *
         703+ 0  706          + STOP      MC.EQS0      mc table addr for no shift
         704+ 0  710          + STOP      MC.EQSSR                       acc shift right
         705+ 0  715          + STOP      MC.EQSSL                       acc shift left
         706-12 1001 MC.EQS0  - STORE     T0
         707- 6 1001          - R SUB     T0
         708-12 1004          - STORE     CC.FACT      no shift needed
         709+ 0    0          + STOP      0000
         710-12 1001 MC.EQSSR - STORE     T0
         711- 6 1001          - R SUB     T0
         712+21 1002          + L RIGHT   ANN          acc shift right needed
         713-12 1004          - STORE     CC.FACT      
         714+ 0    0          + STOP      0000
         715-12 1001 MC.EQSSL - STORE     T0
         716- 6 1001          - R SUB     T0
         717+22 1002          + A LEFT    ANN          acc shift left needed
         718-12 1004          - STORE     CC.FACT      
         719+ 0    0          + STOP      0000
         720+ 0  722 MC.TAKE  + STOP      MC.TAK       mc table addr for no shift, clue=+
         721+ 0  724 MC.TAKSB + STOP      MC.TAKS                                  clue=-
         722-10 1004 MC.TAK   - R ADD     CC.FACT      no shift needed
         723+ 0    0          + STOP      0000
         724- 6 1004 MC.TAKS  - R SUB     CC.FACT      no shift needed, clue=-
         725+ 0    0          + STOP      0000
         726+ 0  732 MC.MULT  + STOP      MC.MLT
         727+ 0  730 MC.MULTS + STOP      MC.MLTS
         728+ 0  735 MC.MULT2 + STOP      MC.MLT2
         729+ 0  737 MC.SQURE + STOP      MC.SQRE
         730-12 1001 MC.MLTS  - STORE     T0
         731- 6 1001          - R SUB     T0
         732+21 1003 MC.MLT   + L RIGHT   A35          ACC TO MQ
         733-16 1004          - MPY       CC.FACT      ACC = ACC X FACT
         734+ 0    0          + STOP      0000
         735-15 1005 MC.MLT2  - LOAD MQ   N0           MULT x 2 -> JUST CLEARS MQ AS THERE IS NO RESIDUE. 
         736+ 0    0          + STOP      0000         MULT WILL BE PERFORMED ON SHIFTING THE RESULT FOR DESIRED QR
         737-12 1001 MC.SQRE  - STORE     T0           ACC TO TEMP 0
         738+21 1003          + L RIGHT   A35          ACC TO MQ
         739-16 1001          - MPY       T0           ACC = ACC X ACC
         740+ 0    0          + STOP      0000
         741+ 0  746 MC.DIV   + STOP      MC.DIVI
         742+ 0  744 MC.DIVS  + STOP      MC.DIVIS
         743+ 0  749 MC.GETMQ + STOP      MC.GQ
         744-12 1001 MC.DIVIS - STORE     T0
         745- 6 1001          - R SUB     T0
         746+15 1005 MC.DIVI  + LOAD MQ   N0
         747-18 1004          - DIV       CC.FACT      MQ=RESULT OF DIVISION, ACC=REMAINDER
         748+ 0    0          + STOP      0000
         749-14 1001 MC.GQ    - STORE MQ  T0           ACC=MQ=RESULT OF DIVISION / RESIDUE OF MULT
         750-10 1001          - R ADD     T0           DO NOT USE "L LEFT" TO TRANSFER MQ TO ACC TO 
         751+ 0    0          + STOP      0000         AVOID OVERFLOW IF ACC WAS NOT ZERO
         752+ 0  753 MC.ABS   + STOP      MC.TKABS
         753-10 1005 MC.TKABS - R ADD     N0
         754-11 1004          - ADD AB    CC.FACT
         755+ 0    0          + STOP      0000
         756+ 0  760 MC.FNFAC + STOP      MC.FNPL      FUNC ARG IS +FACT, 1 PARAM IN CALL
         757+ 0  766 MC.FN-FA + STOP      MC.FNMI      FUNC ARG IS -FACT
         758+ 0  761 MC.FNACC + STOP      MC.FNU       UNIARY OPERATION. FUNC ARG IS ACC
         759+ 0  772 MC.FN2   + STOP      MC.FN2PA     FUNC 2ND PARAM IN CALL
         760-10 1004 MC.FNPL  - R ADD     CC.FACT
         761+21 1003 MC.FNU   + L RIGHT   A35          MQ=ACC
         762+10 1008          + R ADD     STAR         RA *
         763+ 1 1011          + TR        SYMB         CALL FUNCTION ROUTINE
         764+ 0 1006          + STOP      P1           Q OF ARGUMENT SENT TO ROUTINE
         765+ 0    0          + STOP      0000
         766- 6 1004 MC.FNMI  - R SUB     CC.FACT
         767+21 1003          + L RIGHT   A35          MQ=ACC
         768+10 1008          + R ADD     STAR         RA *
         769+ 1 1011          + TR        SYMB         CALL FUNCTION ROUTINE
         770+ 0 1006          + STOP      P1           Q OF ARGUMENT SENT TO ROUTINE
         771+ 0    0          + STOP      0000
         772+ 0 1007 MC.FN2PA + STOP      P2           Q OF RESULT SENT TO ROUTINE
         773+ 0    0          + STOP      0000
         774+ 0  776 MC.LIB   + STOP      MC.LIBCA
         775+ 0  777 MC.DO    + STOP      MC.DOCAL
         776+21 1003 MC.LIBCA + L RIGHT   A35          MQ=ACC
         777+10 1008 MC.DOCAL + R ADD     STAR         RA *
         778+ 1 1011          + TR        SYMB         CALL FUNCTION ROUTINE
         779+ 0    0          + STOP      0000
         780+ 0  780 MC.TRTAD + STOP      *
         781+ 0  787 MC.TR    + STOP      MC.TRA
         782+ 0  789          + STOP      MC.TRZ
         783+ 0  791          + STOP      MC.TRP
         784+ 0  794          + STOP      MC.TRN
         785+ 0  798          + STOP      MC.TROV
         786+ 0  800          + STOP      MC.HALT
         787+ 1 1012 MC.TRA   + TR        INN          transfer to stepN given in var TRANSFER = stepN, TRSTLOC = location in step machine code
         788+ 0    0          + STOP      0000
         789+ 4 1012 MC.TRZ   + TR 0      INN          Transfer if acc=0
         790+ 0    0          + STOP      0000
         791+ 4 1009 MC.TRP   + TR 0      STAR+2
         792+ 3 1012          + TR +      INN          Transfer if acc>0
         793+ 0    0          + STOP      0000
         794+ 4 1010 MC.TRN   + TR 0      STAR+3
         795+ 3 1009          + TR +      STAR+2
         796+ 1 1012          + TR        INN          Transfer if acc<0
         797+ 0    0          + STOP      0000
         798+ 2 1012 MC.TROV  + TR OV     INN          Transfer if Overflow
         799+ 0    0          + STOP      0000
         800+ 0 1012 MC.HALT  + STOP      INN          Halt and tranfer on restart
         801+ 0    0          + STOP      0000
         802+ 0  803 MC.SENSE + STOP      MC.SE
         803+30 1006 MC.SE    + SENSE     P1
         804+ 0    0          + STOP      0000
         805+ 0  806 MC.CL    + STOP      MC.CLR
         806-10 1005 MC.CLR   - R ADD     N0
         807-12 1004          - STORE     CC.FACT
         808+ 0    0          + STOP      0000
         809+ 0  811 MC.IDLST + STOP      MC.IDL       ID FOR LIST WITH VAR AS PARAM
         810+ 0  814 MC.IDLS0 + STOP      MC.IDL0      ID FOR LIST WITH NO VAR 
         811- 0 1004 MC.IDL   - STOP      CC.FACT      // factor to print via LIST op
         812+ 0 1006          + STOP      P1           // Q of factor 
         813+ 0    0          + STOP      0000
         814+ 0 1006 MC.IDL0  + STOP      P1           // blank factor (p1=0)
         815+ 0 1006          + STOP      P1           // Q of factor
         816+ 0    0          + STOP      0000
         817+ 9 1342 GENINST  + ADD       TWO          GENERATE MACHINE CODE (MC) INSTRUCTIONS
         818+13 1364          + STORE A   MC.TABLE     MC TABLE FOLLOWS CALL AS PARAMTERS (UNTIL -STOP 0000 INSTR)
         819+10  819          + R ADD     *
         820+ 1  828          + TR        GENTABLE
         821+10  832          + R ADD     GEN1
         822+ 9 1341          + ADD       ONE
         823+13  824          + STORE A   GENEXIT2      
         824+ 1    0 GENEXIT2 + TR        /   /
         825+10  825 GENTBOV  + R ADD     *
         826+ 1  287          + TR        ERROR
         827+ 0 1378          + STOP      ERROVINS     ERROR: TOO MANY INSTR IN THIS STEP
         828+ 9 1342 GENTABLE + ADD       TWO          GENERATE MACHINE CODE (MC) INSTRUCTIONS
         829+13  833          + STORE A   GENEXIT      MC TABLE AT LOCATION IN MC.TABLE VAR
         830+10 1364          + R ADD     MC.TABLE
         831+13  832          + STORE A   GEN1
         832+10    0 GEN1     + R ADD     /   /        READ MACHINE CODE TABLE
         833+ 4    0 GENEXIT  + TR 0      /   /        =0 -> END OF MC.TABLE-> RETURN TO CALLER
         834+12 1371          + STORE     MC
         835+23   30          + A RIGHT   0030         SAVE OPCODE ONLY
         836+22   30          + A LEFT    0030         (WITH SIGN)
         837+12 1372          + STORE     MC.OP        IN MC.OP
         838+10 1132          + R ADD     NINST        INCR NUMBER OF MC INSTRUCTIONS IN CC TABLE
         839+ 9 1341          + ADD       ONE          ERROR IF > MAXIMUN ALLOWED
         840+12 1132          + STORE     NINST
         841+ 5 1338          + SUB       MAXNINST
         842+ 4  825          + TR 0      GENTBOV      ERROR: TOO MANY INSTR IN THIS STEP
         843+10 1339          + R ADD     ZERO
         844+11 1371          + ADD AB    MC           EXTRACT ADDR PART OF MC 
         845+ 7 1372          + SUB AB    MC.OP        
         846+ 5 1360          + SUB       D1000
         847+ 3  849          + TR +      GEN2
         848+ 0 1111          + STOP      1111         INVALID MC.TABLE
         849+ 9  854 GEN2     + ADD       ADTBL        USE THE TRANSFER TABLE TO PROCESS IT
         850+13  853          + STORE A   ADTBLTR
         851+10 1339          + R ADD     ZERO
         852+11 1372          + ADD AB    MC.OP        ON ENTRY TO ROUTINE, ACC=ABS(MC.OP). SIGN IS IN MC VARIABLE
         853+ 1    0 ADTBLTR  + TR        /   /
         854+ 0  854 ADTBL    + STOP      *
         855+ 1  904          + TR        GEN.T0       T 0000  temporal location 0 
         856+ 1  909          + TR        GEN.ANN      A nnnn  where nnnn is the value of SHIFT1 var
         857+ 1  915          + TR        GEN.A35      A 0035  
         858+ 1  920          + TR        GEN.FACT     factor to be replaced by V 0005 (variable), T 0010 (result of a step) or N 0012 (a number)
         859+ 1  942          + TR        GEN.N0       N 0000  will point to contant zero
         860+ 1  949          + TR        GEN.P1       A nnnn  where nnnn is the value of PARAM1 var
         861+ 1  947          + TR        GEN.P2       A nnnn  where nnnn is the value of PARAM2 var
         862+ 1  893          + TR        GEN.STAR     * will be filled with final own instruction location 
         863+ 1  892          + TR        GEN.ST+2     *+2 will be filled with final own instruction location + 2
         864+ 1  891          + TR        GEN.ST+3     *+3 will be filled with final own instruction location + 3
         865+ 1  898          + TR        GEN.SYMB     transfer to symbol given in TRANSFER var
         866+ 1  886          + TR        GEN.INN      transfer to location n (1..199) into stepN given in var TRANSFER = stepN, TRSTLOC = location in step machine code
         867+10 1371 GENADD   + R ADD     MC           ADD A GENERATED MC INSTR TO TINST TABLE
         868+ 3  871          + TR +      GENADD1      TAKE THE SIGN OF MC AND PLACE IT IN MC.OP
         869+ 6 1372          + R SUB     MC.OP
         870+12 1372          + STORE     MC.OP
         871+10 1132 GENADD1  + R ADD     NINST        ADD NINST TWICE AS EACH MC INSTR USES TWO HALF-WORDS
         872+ 9 1132          + ADD       NINST
         873+ 5 1342          + SUB       TWO          
         874+ 9  143          + ADD       TINSTAD      TINSTAD=LOCATION OF TABLE WITH MC INSTRUCTIONS GENERATED FOR THE CURRENT STEP
         875+13  879          + STORE A   GENADD2      TINST[ (INST- 1)*2 ] =MC instr op and region
         876+ 9 1341          + ADD       ONE
         877+13  881          + STORE A   GENADD3      TINST[ (INST- 1)*2 ] =MC instr addr
         878+10 1372          + R ADD     MC.OP        
         879+12    0 GENADD2  + STORE     /   /        STORE GENERATED MC INSTRUCTION MC.OP (MC.OP CAN BE >0 OR <0)
         880+10 1374          + R ADD     MC.ADDR
         881+12    0 GENADD3  + STORE     /   /                                       MC.ADDR (CAN BE >0 OR <0 IF HOLDS A STEPN/LOCATION PAIR)
         882+10  832          + R ADD     GEN1         PROCEED WITH NEXT MC INST N LIST
         883+ 9 1341          + ADD       ONE
         884+13  832          + STORE A   GEN1
         885+ 1  832          + TR        GEN1
         886+ 9 1367 GEN.INN  + ADD       TRSTLOC      TRSTLOC=LOCATION INTO STEPN NUMBER THE MC INSTR HAS TO TRANSFER TO 
         887+12 1372          + STORE     MC.OP        MC.OP   = OPCODE + LOCATION INTO STEPN
         888+ 6 1366          + R SUB     TRANSFER     TRANSFER=STEPN NUMBER THE MC INSTR HAS TO TRANSFER TO 
         889+12 1374          + STORE     MC.ADDR      MC.ADDR = STEPN (WITH MINUS SIGN, TO SIGNAL ADDR POINTS TO STEPN/LOCATION IN THIS STEP PAIR)
         890+ 1  867          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
         891+ 9 1341 GEN.ST+3 + ADD       ONE
         892+ 9 1342 GEN.ST+2 + ADD       TWO
         893+ 9 1132 GEN.STAR + ADD       NINST      
         894+12 1372          + STORE     MC.OP        MC.OP   = OPCODE + CURRENT OWN LOCATION INTO STEPN
         895+ 6 1125          + R SUB     STEPN
         896+12 1374          + STORE     MC.ADDR      MC.ADDR = STEPN (WITH MINUS SIGN, TO SIGNAL ADDR POINTS TO STEPN/LOCATION IN THIS STEP PAIR)
         897+ 1  867          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
         898+ 9 1419 GEN.SYMB + ADD       REG.S
         899+12 1372          + STORE     MC.OP        MC.OP   = OPCODE + REGION S
         900+10 1339          + R ADD     ZERO
         901+11 1366          + ADD AB    TRANSFER     REMOVE MINUS SIGN FROM VALUE
         902+12 1374          + STORE     MC.ADDR      MC.ADDR = SYMBOL ALFA VALUE/NUMBER TO TRANSFER TO
         903+ 1  867          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
         904+ 9 1417 GEN.T0   + ADD       REG.T
         905+12 1372          + STORE     MC.OP        MC.OP   = OPCODE + REGION T
         906+10 1339          + R ADD     ZERO
         907+12 1374          + STORE     MC.ADDR      MC.ADDR = 0
         908+ 1  867          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
         909+ 9 1414 GEN.ANN  + ADD       REG.A
         910+12 1372          + STORE     MC.OP        MC.OP   = OPCODE + REGION A
         911+10 1339          + R ADD     ZERO
         912+11 1365          + ADD AB    SHIFT1
         913+12 1374          + STORE     MC.ADDR      MC.ADDR = ABS(SHIFT1) VARIABLE
         914+ 1  867          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
         915+ 9 1414 GEN.A35  + ADD       REG.A
         916+12 1372          + STORE     MC.OP        MC.OP   = OPCODE + REGION A
         917+10 1355          + R ADD     D35
         918+12 1374          + STORE     MC.ADDR      MC.ADDR = 0035
         919+ 1  867          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
         920+15 1416 GEN.FACT + LOAD MQ   REG.V
         921+10 1127          + R ADD     FACTREG
         922+ 5 1354          + SUB       D34          'V'
         923+ 4  933          + TR 0      GEN.FA1
         924+15 1418          + LOAD MQ   REG.N
         925+10 1127          + R ADD     FACTREG
         926+ 5 1350          + SUB       D26          'N'
         927+ 4  933          + TR 0      GEN.FA1
         928+15 1417          + LOAD MQ   REG.T
         929+10 1127          + R ADD     FACTREG
         930+ 5 1353          + SUB       D32          'T'
         931+ 4  933          + TR 0      GEN.FA1
         932+ 0 1111          + STOP      1111         INTERNAL COMPILER ERROR: INVALID FACT REGION
         933+10 1339 GEN.FA1  + R ADD     ZERO
         934+20   35          + L LEFT    0035         A=MQ
         935+11 1372          + ADD AB    MC.OP
         936+12 1372          + STORE     MC.OP        MC.OP   = OPCODE + REGION OF FACTOR (CAN BE V, N OR T)
         937+10 1126          + R ADD     FACTN
         938+12 1374          + STORE     MC.ADDR      MC.ADDR = FACTN
         939+10 1132          + R ADD     NINST   
         940+12 1133          + STORE     NINCR        NINCR= THE LOCATION OF FACTOR MC INSTRUCTION INTO THE STEP 
         941+ 1  867          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
         942+ 9 1418 GEN.N0   + ADD       REG.N
         943+12 1372          + STORE     MC.OP        MC.OP   = OPCODE + REGION N
         944+10 1336          + R ADD     RELNUM0      ORIGIN OF NUMBERS (USUALLY = 0)
         945+12 1374          + STORE     MC.ADDR      MC.ADDR = 0000
         946+ 1  867          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
         947+15 1370 GEN.P2   + LOAD MQ   PARAM2
         948+ 1  950          + TR        GEN.P0
         949+15 1369 GEN.P1   + LOAD MQ   PARAM1
         950+ 9 1414 GEN.P0   + ADD       REG.A
         951+12 1372          + STORE     MC.OP        MC.OP   = OPCODE + REGION A
         952+10 1339          + R ADD     ZERO
         953+20   35          + L LEFT    0035         ACC=MQ 
         954+12 1368          + STORE     PARAM0
         955+ 3  959          + TR +      GEN.P1PL     TR IF PARAM > 0 -> KEEP OP SIGN
         956+ 6 1371          + R SUB     MC           IF PARAM IS NEGATIVE, STORE IT AS POSITIVE VALUE IN MC.ADDR
         957+12 1371          + STORE     MC           AND REVERSET THE MC INSTRUCTIOn SIGN 
         958+ 6 1368          + R SUB     PARAM0
         959+12 1374 GEN.P1PL + STORE     MC.ADDR      MC.ADDR = PARAM1/2/3 
         960+ 1  867          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
         961+ 9 1342 PRTMC    + ADD       TWO          PRINT TINST TABLE WITH MC INSTRUCTIONS GENERATED FOR THIS STEP
         962+13 1088          + STORE A   PRTMCEX
         963+10 1339          + R ADD     ZERO
         964+12 1375          + STORE     PRTMCNUM
         965+10 1375 PMCLOOP  + R ADD     PRTMCNUM
         966+ 5 1132          + SUB       NINST
         967+ 4 1088          + TR 0      PRTMCEX      EXIT IF ALL NINST INSTRUCTIONS PRINTED
         968+10 1375          + R ADD     PRTMCNUM     INCR COUNT
         969+ 9 1341          + ADD       ONE
         970+12 1375          + STORE     PRTMCNUM     GET MC INSTR FROM TINST[ (PRTMCNUM-1)*2 ]
         971+ 9 1375          + ADD       PRTMCNUM
         972+ 5 1342          + SUB       TWO
         973+ 9  143          + ADD       TINSTAD
         974+13  979          + STORE A   PMCAD1
         975+ 9 1341          + ADD       ONE
         976+13  983          + STORE A   PMCAD2
         977+10 1339          + R ADD     ZERO
         978+12 1373          + STORE     MC.REG       INIT REGION REFERENCED BY MC
         979+10    0 PMCAD1   + R ADD     /   /
         980+13 1373          + STORE A   MC.REG
         981+23   12          + A RIGHT   0012
         982+12 1372          + STORE     MC.OP        MC.OP HAS NOW THE SIGNED OPCODE -31..31 
         983+10    0 PMCAD2   + R ADD     /   /
         984+12 1374          + STORE     MC.ADDR
         985+ 3  992          + TR +      PMC3         IF MC.ADDR >=0 THEN MC.REG HOLDS THE REGION FOR MC.ADDR 
         986+10 1373          + R ADD     MC.REG       IF MC.ADDR <0 THEN MC.REG VAR HOLDS THE LOCATION INTO STEPN REFERENCED BY MC.ADDR
         987+12 1367          + STORE     TRSTLOC      LOCATION IN STEP GIVEN BY MC.ADDR
         988+ 6 1374          + R SUB     MC.ADDR      MAKES MC.ADDR POSITIVE. IT IS THE DESTINATION STEP
         989+12 1374          + STORE     MC.ADDR
         990+10 1415          + R ADD     REG.I
         991+12 1373          + STORE     MC.REG       SET REGION I -> MC.ADDR=THE STEPN, TRSTLOC=THE NINST REFERENCED IN THIS STEPN
         992+10  992 PMC3     + R ADD     *            START NEW LINE TO PRINT
         993+ 1   53          + TR        CLRBUF
         994+15 1125          + LOAD MQ   STEPN        PRINT STEPN
         995+10  995          + R ADD     *
         996+ 1   61          + TR        PRTINT
         997+ 0   40          + STOP      0040         AT COL 40 
         998+ 0    4          + STOP      0004         LEN=4
         999+15 1357          + LOAD MQ   D43          PRINT '.'
        1000+10 1000          + R ADD     *
        1001+ 1   63          + TR        PRTCHR
        1002+ 0   44          + STOP      0044         AT COL 44 
        1003+15 1342          + LOAD MQ   TWO
        1004+10 1375          + R ADD     PRTMCNUM     IF INST NUMBER < 10 PRINT IT
        1005+ 5 1347          + SUB       D10          WITH LEN=1, IF >= 10 USE LEN=2
        1006+ 3 1008          + TR +      PMC4
        1007+15 1341          + LOAD MQ   ONE
        1008+14 1013 PMC4     + STORE MQ  PMC5
        1009+15 1375          + LOAD MQ   PRTMCNUM
        1010+10 1010          + R ADD     *
        1011+ 1   61          + TR        PRTINT
        1012+ 0   45          + STOP      0045         AT COL 45 
        1013+ 0    2 PMC5     + STOP      0002         LEN=1 OR 2
        1014+15 1349          + LOAD MQ   D12          '+'
        1015+10 1372          + R ADD     MC.OP
        1016+ 3 1018          + TR +      PMC6
        1017+15 1348          + LOAD MQ   D11          '-'
        1018+10 1018 PMC6     + R ADD     *            PRINT OP SIGN
        1019+ 1   63          + TR        PRTCHR
        1020+ 0   48          + STOP      0048         AT COL 48
        1021+10 1339          + R ADD     ZERO
        1022+11 1372          + ADD AB    MC.OP
        1023+ 9 1062          + ADD       TMNEAD
        1024+13 1025          + STORE A   PMC7
        1025+15    0 PMC7     + LOAD MQ   /   /
        1026+10 1026          + R ADD     *            PRINT OP MNEMONIC
        1027+ 1   59          + TR        PRTALF
        1028+ 0   49          + STOP      0049         AT COL 49
        1029+10 1373          + R ADD     MC.REG
        1030+ 9 1063          + ADD       TREGMNEA     CHARS IN TREGMNE ARE TXT ALFA VALUES  
        1031+13 1032          + STORE A   PMC8         THUS ARE NEGATIVE
        1032+ 6    0 PMC8     + R SUB     /   /        CHANGE SIGN BEFORE STORING IT IN MQ
        1033+21   35          + L RIGHT   0035
        1034+10 1034          + R ADD     *            PRINT REGION LETTER V I S T A N
        1035+ 1   63          + TR        PRTCHR
        1036+ 0   52          + STOP      0052         AT COL 52
        1037+10 1373          + R ADD     MC.REG       IF MC.REG='I' THEN ...
        1038+ 5 1415          + SUB       REG.I        
        1039+ 4 1064          + TR 0      PMC9         TR TO PRINT STEPN.LOCATION
        1040+10 1373          + R ADD     MC.REG       IF MC.REG='S' THEN ...
        1041+ 5 1419          + SUB       REG.S
        1042+ 4 1049          + TR 0      PMC8B        TR TO PRINT ALFA SYMBOL TO TRANSFER TO
        1043+15 1374          + LOAD MQ   MC.ADDR      MC.REG IS 'V', 'T', 'A' OR 'N'
        1044+10 1044          + R ADD     *            JUST PRINT THE INST ADDRESS
        1045+ 1   61          + TR        PRTINT
        1046+ 0   53          + STOP      0053         AT COL 53 
        1047+ 0    4          + STOP      0004         LEN=4
        1048+ 1 1084          + TR        PMC12
        1049+15 1358 PMC8B    + LOAD MQ   D45          PRINT ALFA SYMBOL TO TRANSFER TO
        1050+10 1050          + R ADD     *            '/'
        1051+ 1   63          + TR        PRTCHR
        1052+ 0   54          + STOP      0054         AT COL 54
        1053+15 1358          + LOAD MQ   D45          '/'
        1054+10 1054          + R ADD     *
        1055+ 1   63          + TR        PRTCHR
        1056+ 0   58          + STOP      0058         AT COL 58
        1057+15 1374          + LOAD MQ   MC.ADDR      GET SYMBOL ALFA
        1058+10 1058          + R ADD     *            
        1059+ 1   59          + TR        PRTALF
        1060+ 0   55          + STOP      0055         AT COL 55
        1061+ 1 1084          + TR        PMC12
        1062+ 0 1428 TMNEAD   + STOP      TMNE
        1063+ 0 1420 TREGMNEA + STOP      TREGMNE
        1064+15 1374 PMC9     + LOAD MQ   MC.ADDR      PRINT STEPN.TRSTLOC 
        1065+10 1065          + R ADD     *
        1066+ 1   61          + TR        PRTINT
        1067+ 0   53          + STOP      0053         AT COL 53 
        1068+ 0    4          + STOP      0004         LEN=4
        1069+15 1357          + LOAD MQ   D43          PRINT '.'
        1070+10 1070          + R ADD     *
        1071+ 1   63          + TR        PRTCHR
        1072+ 0   57          + STOP      0057         AT COL 57 
        1073+15 1342          + LOAD MQ   TWO
        1074+10 1367          + R ADD     TRSTLOC      IF INST NUMBER < 10 PRINT IT
        1075+ 5 1347          + SUB       D10          WITH LEN=1, IF >= 10 USE LEN=2
        1076+ 3 1078          + TR +      PMC10
        1077+15 1341          + LOAD MQ   ONE
        1078+14 1083 PMC10    + STORE MQ  PMC11
        1079+15 1367          + LOAD MQ   TRSTLOC
        1080+10 1080          + R ADD     *
        1081+ 1   61          + TR        PRTINT
        1082+ 0   58          + STOP      0058         AT COL 58 
        1083+ 0    2 PMC11    + STOP      0002         LEN=1 OR 2
        1084+ 8    0 PMC12    + NOOP      0000
        1085+10 1085          + R ADD     *
        1086+ 1   57          + TR        PRINTCRD
        1087+ 1  965          + TR        PMCLOOP    
        1088+ 1    0 PRTMCEX  + TR        /   /        RETURN TO CALLER
        1089+     0             ORG       EVEN
        1090+     0  PACTSRC    RES       24           CARD IMAGE OF PACT SOURCE CODE CARD (12 FULL WORDS)
        1114+     0  REGION     DEF       0
        1115+     0  STEP       DEF       0            REGION = ALFA (<0)
        1116+     0  OP         DEF       0            STEP   = INT (>0)
        1117+     0  FACT       DEF       0            OP     = 0..43    =0 MEANS END OF REGION
        1118+     0  S1         DEF       0            FACT   < 0 -> FACTOR IS AN ALFA SYMBOL (VAR, REGION, ...) 
        1119+     0  S2         DEF       0            FACT = 0 -> BLANK FACTOR
        1120+     0  QR         DEF       0            FACT = 0..9999 -> DESTINATION STEP FOR TRANSFER/RESULT OF STEP
        1121+     0  QF         DEF       0            CLUE = -, R OR N
        1122+     0  NUM        DEF       0            
        1123+     0             DEF       0            S1/S2 = 0 -> BLANK, >0 -> INTEGER, <0 -> ALFA 
        1124+     0  CLUE       DEF       0
        1125+     0  STEPN      DEF       0            QR = +/- INTEGER OR BLANK. 
        1126+     0  FACTN      DEF       0            QF = SET IF THERE IS AN INTEGER FACTOR/NUMBER IN CARD
        1127+     0  FACTREG    DEF       0
        1128+     0  S1N        DEF       0            STEPN = SEQUENTIAL NUMBER OF STEP            
        1129+     0  S2N        DEF       0            IF OP IS TRANSFER -> FACTN=DESTINATION STEPN
        1130+     0  D1N        DEF       0            FACTN=ADDR (0, 2, 4, ..) FACTREG=' ', 'T', 'V', 'N'
        1131+     0  D2N        DEF       0            S1N/S2N=INDEX (IF <0), BLANK (IF =0), CONST (IF >0)
        1132+     0  NINST      DEF       0            D1N/D2N=HALF-WORD SIZE OF EACH DIMENSION
        1133+     0  NINCR      DEF       0                D1N=-1 IF MATRIX/VECTOR WITH CONSTANT SUBSCRIPTS
        1134+     0  TINST      RES       200          MACHINE CODE: 1ST HALF-WORD OPCODE + REGION/LOCATION INTO STEP (FOR TRANSFERS)
        1334+    44  CCLEN      DEF       0044         LENGTH OF COMPACT CODE RECORD 
        1335+     0  N          DEF       0            TEMP VAR (HERE TO MAKE TABLES START AT EVEN LOCATION)
        1336+     0  RELNUM0    DEF       0            REL NUM ORIGIN
        1337+     0  DUMMY      DEF       0            
        1338+   100  MAXNINST   DEF       100          MAX NUMBER OF MACHINE CODE INSTRUTIONS PER STEP
        1339+     0  ZERO       DEF       0
        1340+     0             DEF       0
        1341+     1  ONE        DEF       1
        1342+     2  TWO        DEF       2
        1343+     3  D3         DEF       3
        1344+     4  D4         DEF       4
        1345+     5  D5         DEF       5
        1346+     6  D6         DEF       6
        1347+    10  D10        DEF       10
        1348+    11  D11        DEF       11
        1349+    12  D12        DEF       12
        1350+    26  D26        DEF       26
        1351+    28  D28        DEF       28
        1352+    30  D30        DEF       30
        1353+    32  D32        DEF       32
        1354+    34  D34        DEF       34
        1355+    35  D35        DEF       35
        1356+    38  D38        DEF       38
        1357+    43  D43        DEF       43
        1358+    45  D45        DEF       45
        1359+   200  D200       DEF       200
        1360+  1000  D1000      DEF       1000
        1361+     0  QRPREV     DEF       0            VALUE OF QR (Q OF RESULT) OF PREVIOUS STEP
        1362+     0  QRPREV0    DEF       0            SAVED VALUE OF QRPREV
        1363+     0  QROP       DEF       0            Q RESULTING OF STEP OPERATION, PRIOR TO APPLY SHIFT TO MATCH DESIRED QR ON THIS STEP
        1364+     0  MC.TABLE   DEF       0            ADDRESS TO MACHINE CODE GENERATION TABLE TO USE 
        1365+     0  SHIFT1     DEF       0            SHIFT NEEDED BEFOR OPERATION TO ALIGN OPERANDS ACC AND FACTOR
        1366+     0  TRANSFER   DEF       0            STEPN NUMBER THE MC INSTR HAS TO TRANSFER TO 
        1367+     0  TRSTLOC    DEF       0            LOCATION INTO STEPN NUMBER THE MC INSTR HAS TO TRANSFER TO 
        1368+     0  PARAM0     DEF       0            PARAMETER FOR MC GENERATION
        1369+     0  PARAM1     DEF       0            PARAMETER FOR MC GENERATION
        1370+     0  PARAM2     DEF       0            PARAMETER FOR MC GENERATION
        1371+     0  MC         DEF       0            MACHINE CODE INSTR TO GENERATE FROM MC TABLE
        1372+     0  MC.OP      DEF       0            MC OPCODE GENERATED
        1373+     0  MC.REG     DEF       0            REGION REFERENCED BY MC OPCODE GENERATED
        1374+     0  MC.ADDR    DEF       0            MC ADDR GENERATED. BOTH WILL BE STORED IN TINST TABLE IN COMPCAT CODE RECORD
        1375+     0  PRTMCNUM   DEF       0            NEXT INSTR TO PRINT WITH PRTMC
        1376+     0  FACTNEG    DEF       0            =1 IF FACTOR HAS CLUE=- OR CLUE=N   
        1377+     0  OP2        DEF       0            TEMP
        1378- 75051  ERROVINS   TXT       "TOO MANY INSTR IN THIS STEP",0
        1379-  1213  
        1380- 61680  
        1381- 49663  
        1382- 75168  
        1383- 49632  
        1384- 74709  
        1385- 71455  
        1386- 74572  
        1387+     0  
        1388- 68256  ERREQR0S   TXT       "QR OF EXP CANNOT BE LESS THAT ONE",0    QR ON EXP STEP MIST BE >= 1
        1389- 63072  
        1390- 40924  
        1391-   733  
        1392- 61179  
        1393- 73742  
        1394- 39192  
        1395- 40687  
        1396-  1556  
        1397- 31488  
        1398- 63473  
        1399+     0  
        1400- 63569  MSGSTART   TXT       "OPERATION EXPANSION",0
        1401- 69776  
        1402- 49706  
        1403-   852  
        1404- 65162  
        1405- 72459  
        1406- 59904  
        1407+     0  
        1408- 68194  MSGSTAR2   TXT       "QPV QF  QOP QR",0
        1409-  1410  
        1410-    29  
        1411- 63552  
        1412- 68256  
        1413+     0  
        1414+     0  REG.A      DEF       0            ABSOLUTE A 0000
        1415+     1  REG.I      DEF       1            INSTRUCTIONS CODE I 0000
        1416+     2  REG.V      DEF       2            VARIABLES V 0000
        1417+     3  REG.T      DEF       3            TEMPORARY T 0000
        1418+     4  REG.N      DEF       4            NUMBER N 0000
        1419+     7  REG.S      DEF       7            SYMBOL S 0000
        1420-    13  TREGMNE    TXT       '  A'
        1421-    21             TXT       '  I'
        1422-    34             TXT       '  V'
        1423-    32             TXT       '  T'
        1424-    26             TXT       '  N'
        1425-    28             TXT       '  P'        PERISHABLE STORAGE (=LIB LOCAL VARS/CONSTANTS)
        1426-    44             TXT       '  #'        UNUSED
        1427-    31             TXT       '  S'
        1428- 46080  TMNE       TXT       'H  '        STOP/HALT
        1429- 73728             TXT       'T  '        TRANSFER
        1430- 74592             TXT       'TF '        TRANSFER ON OVERLOF
        1431- 75072             TXT       'TP '        TRANSFER ON PLUS
        1432- 75552             TXT       'TZ '        TRANSFER ON ZERO
        1433- 71424             TXT       'S  '        SUBTRACT
        1434- 70608             TXT       'RS '        RESET AND SUBTRACT
        1435- 73056             TXT       'SV '        SUBTRACT ABSOLUTE VALUE
        1436- 59904             TXT       'N  '        NO OPERATION
        1437- 29952             TXT       'A  '        ADD
        1438- 69744             TXT       'RA '        RESET AND ADD
        1439- 31584             TXT       'AV '        ADD ABSOLUTE VALUE
        1440- 72960             TXT       'ST '        STORE
        1441- 72048             TXT       'SA '        STORE ADDRESS
        1442- 72624             TXT       'SM '        STORE MQ
        1443- 56496             TXT       'LM '        LOAD MQ
        1444- 57600             TXT       'M  '        MULTIPLY
        1445- 59040             TXT       'MR '        MULTIPLY AND ROUND
        1446- 36864             TXT       'D  '        DIVIDE
        1447- 69120             TXT       'R  '        ROUND
        1448- 56448             TXT       'LL '        LONG LEFT SHIFT
        1449- 56736             TXT       'LR '        LONG RIGHT SHIFT
        1450- 31104             TXT       'AL '        ACCUMULATOR LEFT SHIFT
        1451- 31392             TXT       'AR '        ACCUMULATOR RIGHT SHIFT
        1452- 69888             TXT       'RD '        READ
        1453- 69792             TXT       'RB '        READ BACKWARDs
        1454- 80640             TXT       'W  '        WRITE
        1455- 81456             TXT       'WE '        WRITE END OF FILE
        1456- 70800             TXT       'RW '        REWIND TAPE
        1457- 72192             TXT       'SD '        SET DRUM DDR
        1458- 72240             TXT       'SE '        SENSE
        1459- 34560             TXT       'C  '        COPY
        1460- 72473  FNSIN      TXT       'SI$'        TRASCENDENT FUNCTION LIBRARY ROUTINES
        1461- 35897  FNCOS      TXT       'CO$'
        1462- 31529  FNARCT     TXT       'AT$'
        1463- 72857  FNSQRT     TXT       'SQ$'
        1464- 56633  FNLOG      TXT       'LO$'
        1465- 40937  FNEXP      TXT       'EX$' 
        1466- 69929  FNREAD     TXT       'RD$'        READ LIBRARY ROUTINE
        1467- 56825  FNLIST     TXT       'LS$'        LIST LIBRARY ROUTINE
        1468+15 1482 CLRBUF   + LOAD MQ   IOCL
        1469+14 1487          + STORE MQ  BUFIO
        1470+15 1508          + LOAD MQ   IOSTORE         
        1471+ 1 1479          + TR        INIT2
        1472+15 1504 READCRD  + LOAD MQ   IORDCRD
        1473+ 1 1477          + TR        INIT1
        1474+15 1506 WRITECRD + LOAD MQ   IOWRCRD
        1475+ 1 1477          + TR        INIT1
        1476+15 1507 PRINTCRD + LOAD MQ   IOPRCRD
        1477+14 1487 INIT1    + STORE MQ  BUFIO
        1478+15 1505          + LOAD MQ   IOCOPY         
        1479+14 1488 INIT2    + STORE MQ  BUFROW
        1480+ 9 1514          + ADD       TWO          
        1481+13 1503          + STORE A   EXIT
        1482+10 1510 IOCL     + R ADD     ZERO         RESET TO INITIAL COPY LOOP ADDRESS     
        1483+13 1488          + STORE A   BUFROW       FOR BUFFER
        1484+10 1488          + R ADD     BUFROW       X .*echo Print
        1485+ 5 1515          + SUB       D48          X 
        1486+12 1512          + STORE     ENDLP        X LOOP END VALUE
        1487- 0    0   BUFIO  - STOP      /   /        READ OR WRITE
        1488-31    0   BUFROW - COPY      /   /        COPY WORD TO/FROM PRINTER/CARDREADER
        1489+ 1 1493          + TR        BUFOK2       NORMAL PROCESSING 
        1490+ 1 1500          + TR        EODECK       FOR COPY READING END OF REG (=END OF DECK BEING READ)
        1491+ 6 1514          + R SUB     TWO          END OF FILE -> NO CARD TO READ -> STOP with Acc=-2
        1492+ 0 1487          + STOP      BUFIO        ON PRESSING START RETRY CARD READ
        1493+10 1488   BUFOK2 + R ADD     BUFROW       X
        1494+ 5 1514          + SUB       TWO          INCR BUF ADDR
        1495+13 1488          + STORE A   BUFROW       X
        1496+ 5 1512          + SUB       ENDLP        CHECK FOR END
        1497+ 4 1502          + TR 0      ENDIO
        1498+10 1510          + R ADD     ZERO         CLEAR ACC IN CASE WE ARE CLEANING THE BUFFER
        1499+ 1 1488          + TR        BUFROW
        1500+10 1513 EODECK   + R ADD     ONE          SET OV FLAG TO SIGNAL END OF DECK CONDITION
        1501+22   36          + A LEFT    36
        1502+26 2052 ENDIO    + WRITE     2052         END OF I/O: INSURE THAT MQ NOT IN USE            
        1503+ 1    0 EXIT     + TR        /   /
        1504+24 2048 IORDCRD  + READ      2048         PREPARE TO READ FROM CARD READER
        1505-31    0 IOCOPY   - COPY      /   /   
        1506+26 1024 IOWRCRD  + WRITE     1024         PREPARE TO PUNCH CARD 
        1507+26  512 IOPRCRD  + WRITE     0512         PREPARE WRITE PRTBUF ON PRINTER
        1508-12    0 IOSTORE  - STORE     /   /        CLEAR BUFFER
        1509+     0             ORG       EVEN           
        1510+     0  ZERO       DEF       0            
        1511+     0             DEF       0            
        1512+     0  ENDLP      DEF       0            LOOP END VALUE
        1513+     1  ONE        DEF       1
        1514+     2  TWO        DEF       2
        1515+    48  D48        DEF       48
        1516+ 9 1787 PRTPARM2 + ADD       TWO          GET 2 PARAMS: LEN AND COL (EITHER VALUE OR VAR ADDR)
        1517+13 1536          + STORE A   PRTPRMEX
        1518+10 1526          + R ADD     PRTP1
        1519+ 9 1787          + ADD       TWO          PRINT PACKED TEXT FROM FULL-WORD VALUE IN MQ REGISTER 
        1520+13 1526          + STORE A   PRTP1        STORE ADDR OF FIRST PARAM (LEN)
        1521+ 9 1786          + ADD       ONE
        1522+13 1528          + STORE A   PRTP2        STORE ADDR OF SECOND PARAM (COL)
        1523+ 9 1786          + ADD       ONE
        1524+13 1603          + STORE A   EXIT
        1525-14 1776          - STORE MQ  NUM          SAVE VALUE TO PRINT PARAM MQ (NUM IS ALIASED TO TXT)
        1526+10    0   PRTP1  + R ADD     /   /        GET LEN: NUMBER OF CHARS TO PRINT (1..6)
        1527+12 1780          + STORE     LEN
        1528+10    0   PRTP2  + R ADD     /   /        GET COLUMN PARAM 1..72
        1529+ 3 1532          + TR +      PRTP4
        1530+13 1531          + STORE A   PRTP3        COL<0 -> INTERPRET COL AS LOC(COL) = ADDR OF COL VAR
        1531+10    0   PRTP3  + R ADD     /   /        READ VAR COL PASED AS PARAM
        1532+ 4 1603   PRTP4  + TR 0      EXIT         COL=0 -> EXIT
        1533+ 3 1535          + TR +      PRTP5
        1534+ 1 1603          + TR        EXIT         COL<0 -> EXIT
        1535+12 1586   PRTP5  + STORE     COL
        1536+ 1    0 PRTPRMEX + TR        /   /        RETURN TO CALLER
        1537+13 1526 PRTSTR   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        1538+10 1538          + R ADD     *            FOR PRINT STRINGZ FROM MEM
        1539+ 1 1516          + TR        PRTPARM2
        1540+12 1550          + STORE     COLSZ
        1541+10 1780          + R ADD     LEN          LEN IS IN FACT THE LOCATION WHERE THE STRING STARTS
        1542+13 1545          + STORE A   STRZAD
        1543+10 1603          + R ADD     EXIT
        1544+13 1558          + STORE A   STRZEX
        1545+10    0 STRZAD   + R ADD     /   /        GET HALF-WORD WITH NEXT 3 CHARS TO PRINT
        1546+ 4 1558          + TR 0      STRZEX       IF +0 -> END OF STRING (-0 DOES NOT TERMINATES THE STRING)
        1547+21   35          + L RIGHT   0035         MQ=3-CHARS TO PRINT
        1548+10 1548          + R ADD     *            
        1549+ 1 1560          + TR        PRTALF       PRINT 3 CHARS
        1550+ 0    0 COLSZ    + STOP      0000         COL 
        1551+10 1545 STRZ1    + R ADD     STRZAD       INCR STRING ADDRESS
        1552+ 9 1786          + ADD       ONE
        1553+13 1545          + STORE A   STRZAD
        1554+10 1550          + R ADD     COLSZ        INCR COLUMN
        1555+ 9 1788          + ADD       D3
        1556+13 1550          + STORE A   COLSZ
        1557+ 1 1545          + TR        STRZAD
        1558+ 3    0 STRZEX   + TR +      /   /        IF ZERO -> END OF STRING
        1559+ 1 1551          + TR        STRZ1
        1560+ 9 1787 PRTALF   + ADD       TWO          PRINT 3-PACKED CHARS IN MQ REGISTER 
        1561+14 1782          + STORE MQ  TXT          SAVE TEXT TO PRINT (IN LEFT HALF WORD)
        1562+13 1565          + STORE A   PRTAP2       STORE ADDR OF PARAM (COL)
        1563+ 9 1786          + ADD       ONE
        1564+13 1603          + STORE A   EXIT
        1565+10    0   PRTAP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        1566+ 3 1569          + TR +      PRTAP4
        1567+13 1568          + STORE A   PRTAP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        1568+10    0   PRTAP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        1569+12 1586   PRTAP4 + STORE     COL
        1570+10 1788          + R ADD     D3
        1571+12 1780          + STORE     LEN
        1572+10 1770 PRT1     + R ADD     ZERO         UNPACK LEFTMOST CHAR 
        1573+11 1782          + ADD AB    TXT          GET TEXT DISCARD SIGN
        1574+21   35          + L RIGHT   0035         MQ=Acc
        1575+10 1770          + R ADD     ZERO
        1576+18 1795          + DIV       D48X48
        1577+12 1782          + STORE     TXT          remainder=char to print, mq=c2 * 48 + c3 in right half-word
        1578+10 1770          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        1579+20   18          + L LEFT    0018         put c2 and c3 in left half-word of MQ to be saved in CHAR half word
        1580+14 1781          + STORE MQ  CHAR         CHAR TO PRINT
        1581+10 1781          + R ADD     CHAR 
        1582+ 4 1587          + TR 0      NXTCHR       IF BLANK PROCEED TO NEXT COL
        1583+21   35          + L RIGHT   0035         MQ=CHAR TO PRINT
        1584+10 1584          + R ADD     *            PRINT CHAR
        1585+ 1 1680          + TR        PRTCHR
        1586+ 0    0 COL      + STOP      0000         COL: COLUMN NUMBER TO PRINT (1..72)
        1587+10 1780 NXTCHR   + R ADD     LEN          DECR LEN COUNT
        1588+ 5 1786          + SUB       ONE
        1589+12 1780          + STORE     LEN
        1590+ 4 1603          + TR 0      EXIT         IF NO MORE CHARS TO PRINT EXIT
        1591+10 1586          + R ADD     COL          INCR COL POSITION
        1592+ 9 1786          + ADD       ONE
        1593+12 1586          + STORE     COL
        1594+ 5 1794          + SUB       D72          IF COL > 72 RETURN TO CALLER
        1595+ 4 1597          + TR 0      GNXTCHR      ELSE PROCEED WITH NEXT CHAR
        1596+ 3 1603          + TR +      EXIT
        1597+10 1770 GNXTCHR  + R ADD     ZERO         GET NEXT CHAR 
        1598+15 1782          + LOAD MQ   TXT
        1599+16 1793          + MPY       D48
        1600+22   17          + A LEFT    0017         GET RESULT IN LEFT HALF-WORD OF ACC
        1601+12 1782          + STORE     TXT
        1602+ 1 1572          + TR        PRT1         PROCEED TO PRINT CHAR
        1603+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        1604+13 1526 PRTOCT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        1605+10 1605          + R ADD     *            FOR PRINT OCTIONARY VALUE
        1606+ 1 1516          + TR        PRTPARM2
        1607+10 1780          + R ADD     LEN          LEN = OCTAL DIGITS TO PRINT
        1608+ 9 1586          + ADD       COL
        1609+ 5 1786          + SUB       ONE
        1610+12 1622          + STORE     COLN         COL POINTS TO LEAST SIGNIFICANT DIGIT
        1611+10 1776 PRTIOCG  + R ADD     NUM          GENERATE OCTINARY DIGIT
        1612+15 1770          + LOAD MQ   ZERO         CLEAR MQ
        1613+21   21          + L RIGHT   0021         3 LSB BITS OF LEFT HALF-WORD OF ACC TO MQ
        1614+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 3 BIT)
        1615+12 1776          + STORE     NUM          SAVE BACK NUM WITH RIGHTMOST OCTIONARY DIGIY EXTRACTED (NUM'=NUM/8)
        1616+10 1770          + R ADD     ZERO
        1617+20   21          + L LEFT    0021         LEFT HALF-WORD OF ACC IS NOW RIGHTMOST OCTINARY DIGIT EXTRACTED FROM NUM 
        1618+ 4 1636          + TR 0      PRTIOZ       TR IF THIS DIGIT IS ZERO TO PRINT A '0' (BASE48 CODE = 10) INSTEAD OF A BLANK (BASE48 CODE = 0)
        1619+21   35          + L RIGHT   0035         PUT DIGIT 1..9 TO PRINT IN MQ
        1620+10 1620 PRTOCTD  + R ADD     *            PRINT OCTINARY DIGIT
        1621+ 1 1680          + TR        PRTCHR
        1622+ 0    0 COLN     + STOP      0000
        1623+10 1622          + R ADD     COLN        DECR COL NUMBER TO PRINT NEXT DIGIT
        1624+ 5 1786          + SUB       ONE
        1625+12 1622          + STORE     COLN
        1626+10 1780          + R ADD     LEN          DECR COL NUMBER TO PRINT NEXT DIGIT
        1627+ 5 1786          + SUB       ONE
        1628+ 4 1603          + TR 0      EXIT         PRINTED LEN OCTINARY DIGITS -> EXIT
        1629+12 1780          + STORE     LEN
        1630+10 1776          + R ADD     NUM          IF NUM < 0, ADD SIGN BIT TO LEFTMOST DIGIT
        1631+ 3 1611          + TR +      PRTIOCG
        1632+10 1796          + R ADD     OCT04K       
        1633+ 5 1776          + SUB       NUM
        1634+12 1776          + STORE     NUM
        1635+ 1 1611          + TR        PRTIOCG
        1636+15 1789   PRTIOZ + LOAD MQ   D10          ACC=BASE48 CODE FOR '0'
        1637+ 1 1620          + TR        PRTOCTD      TR TO PRINT IT
        1638+13 1526 PRTINT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        1639+10 1639          + R ADD     *            FOR PRINT OCTIONARY VALUE
        1640+ 1 1516          + TR        PRTPARM2
        1641+10 1586          + R ADD     COL          PRINT DECIMAL NUMBER. VALUE OF LEN = DIGITS TO PRINT, NOT INCLUDING SIGN
        1642+ 9 1780          + ADD       LEN
        1643+ 5 1786          + SUB       ONE          
        1644+12 1665          + STORE     COLNI        COL POINTS TO END OF NUMBER
        1645+10 1770          + R ADD     ZERO
        1646+12 1779          + STORE     SGN          SIGN IS POSITIVE
        1647+10 1776          + R ADD     NUM
        1648+ 3 1653          + TR +      PRTINTG
        1649+ 6 1776          + R SUB     NUM          NUM IS NEGATIVE. CONVERT TO POSITIVE
        1650+12 1776          + STORE     NUM          AND SET SGN=1
        1651+10 1786          + R ADD     ONE
        1652+12 1779          + STORE     SGN          
        1653+10 1776 PRTINTG  + R ADD     NUM          GENERATE DECIMAL DIGIT
        1654+21   35          + L RIGHT   0035         MQ=Acc
        1655+10 1770          + R ADD     ZERO
        1656+18 1789          + DIV       D10
        1657+ 4 1678          + TR 0      PRTINZ
        1658+12 1781 PRTINTG2 + STORE     CHAR         acc=remainder=digit to print, mq=num/10
        1659+10 1770          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        1660+20   18          + L LEFT    0018         digit in left half-word of MQ to be saved in CHAR half word
        1661+14 1776          + STORE MQ  NUM 
        1662+15 1781          + LOAD MQ   CHAR 
        1663+10 1663 PRTINTD  + R ADD     *            PRINT DECIMAL DIGIT
        1664+ 1 1680          + TR        PRTCHR
        1665+ 0    0 COLNI    + STOP      0000
        1666+10 1665          + R ADD     COLNI        DECR COL NUMBER TO PRINT NEXT DIGIT
        1667+ 5 1786          + SUB       ONE
        1668+12 1665          + STORE     COLNI
        1669+10 1776          + R ADD     NUM          DO NOT CARE ABOUT LEN, JUST CHECK IF NUM=0 
        1670+ 4 1672          + TR 0      PRTINS       (SO NO MORE DIGITS REMAINS TO BE PRINTED)
        1671+ 1 1653          + TR        PRTINTG      NUM NOT FINISHED, PROCEED WITH NEXT DIGIT
        1672+10 1779 PRTINS   + R ADD     SGN
        1673+ 4 1603          + TR 0      EXIT         NO SIGN -> NUM FINISHED
        1674+10 1770          + R ADD     ZERO
        1675+12 1779          + STORE     SGN          CLEAR SGN FLAG
        1676+15 1790          + LOAD MQ   D11          BASE48 CODE FOR '-' (MINUS) CHAR
        1677+ 1 1663          + TR        PRTINTD      GO TO PRINT IT
        1678+10 1789   PRTINZ + R ADD     D10          ACC=BASE48 CODE FOR '0'
        1679+ 1 1658          + TR        PRTINTG2     TR TO PRINT IT
        1680+ 9 1787 PRTCHR   + ADD       TWO          PRINT CHAR IN MQ REGISTER 
        1681+14 1781          + STORE MQ  CHAR         SAVE CHAR TO PRINT (IN LEFT HALF WORD)
        1682+13 1686          + STORE A   PRTCP2       STORE ADDR OF PARAM (COL)
        1683+ 9 1786          + ADD       ONE
        1684+13 1764          + STORE A   PRTCEX
        1685+ 2 1686          + TR OV     PRTCP2       CLEAR OV JUST IN CASE
        1686+10    0   PRTCP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        1687+ 3 1690          + TR +      PRTCP4
        1688+13 1689          + STORE A   PRTCP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        1689+10    0   PRTCP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        1690+ 5 1786   PRTCP4 + SUB       ONE
        1691+12 1784          + STORE     N            N=COL-1 -> IN RANGE 0..71
        1692+ 3 1694          + TR +      PRTSA        IF N >= 0 PROCEED WITH BASE BUFFER ADDR CALCULATION
        1693+ 1 1764          + TR        PRTCEX       IF N<0 EXIT
        1694+10 1770    PRTSA + R ADD     ZERO         CARD BUFFER USES LOCATION 0..47
        1695+13 1783          + STORE A   PRTROWAD     DETERMINE ADDRESS OF LOWER ROW TO PRINT
        1696+10 1784          + R ADD     N
        1697+ 5 1792          + SUB       D36
        1698+ 3 1700          + TR +      PRTC0
        1699+ 1 1706          + TR        PRTC1
        1700+12 1784    PRTC0 + STORE     N            COL NOW 0..35 
        1701+ 5 1792          + SUB       D36
        1702+ 3 1764          + TR +      PRTCEX       IF COL >= 36 (IE COL PASSED AS PARAM > 72) THEN EXIT
        1703+10 1783          + R ADD     PRTROWAD
        1704+ 9 1787          + ADD       TWO
        1705+13 1783          + STORE A   PRTROWAD     SET BASE BUFFER ADDR 
        1706+10 1786    PRTC1 + R ADD     ONE          DETERMINE MASKCOL WITH MASK TO SET IN CARD BUFFER
        1707+21   53          + L RIGHT   53           SET RIGHTMOST BIT OF MQ TO 1 (SHIFT 35+18=53)
        1708+10 1791          + R ADD     D35
        1709+ 5 1784          + SUB       N
        1710+13 1712          + STORE A   PRTC2
        1711+10 1770          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW
        1712+20    0    PRTC2 + L LEFT    /   /        SHIFT MQ LEFT N PLACES
        1713+ 4 1716          + TR 0      PRTC3        IF ACC STILL ZERO -> MASKCOL VALID
        1714+ 6 1786          + R SUB     ONE          ACC NOT ZERO -> SHOULD GENERATE -0 TO SET SIGN BIT ON
        1715+21   72          + L RIGHT   0072         NOW MQ = -0 -> LEFTMOST BIT OF MQ SET
        1716-14 1772    PRTC3 - STORE MQ  MASKCOL
        1717+10 1770          + R ADD     ZERO         READ THE BITMAP OF CHAR 
        1718+11 1781          + ADD AB    CHAR         DISCARD SIGN OF CHAR, IF ANY
        1719+12 1781          + STORE     CHAR
        1720+ 5 1793          + SUB       D48
        1721+ 3 1764          + TR +      PRTCEX       IF CHAR >= 48 EXIT
        1722+10 1778          + R ADD     BITMAPAD     IF ADDR OF BASE48 BITMAP NOT COMPUTED
        1723+ 4 1765          + TR 0      GETBMP1      TR TO LOAD IT
        1724+ 9 1781  GETBMP2 + ADD       CHAR         READ THE BITMAP OF CHAR 
        1725+13 1726          + STORE A   PRTC4        INDICATES THE BITS TO SET IN SELECTED 
        1726+10    0    PRTC4 + R ADD     /   /        COLUMN OF CARD BUFFER 
        1727+12 1785          + STORE     BITS
        1728+ 6 1786          + R SUB     ONE
        1729+12 1784          + STORE     N            SET TO -1
        1730+10 1784    LOOP1 + R ADD     N            CURRENT ROW (STARTS AT ZERO) = OFFSET ON PRTROWAD     
        1731+ 9 1786          + ADD       ONE
        1732+12 1784          + STORE     N
        1733+10 1785          + R ADD     BITS         EXTRACT RIGHTMOST BIT OF LEFT HALF OF ACC TO MQ
        1734+ 4 1764          + TR 0      PRTCEX       NO MORE BITS -> EXIT
        1735+21   19          + L RIGHT   0019         LSB BIT OF LEFT HALF-WORD OF ACC TO MQ
        1736+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 1 BIT)
        1737+12 1785          + STORE     BITS         SAVE BACK BITS. LSB HAS BEEN EXTACTED, CONTENTS SHIFTED RIGHT ONE PLACE
        1738+10 1770          + R ADD     ZERO
        1739+20    1          + L LEFT    0001         PUT EXTACTED BIT BACK INTO ACC
        1740+ 4 1730          + TR 0      LOOP1        NO BIT 
        1741+10 1784          + R ADD     N            READ THE ROW N AT CARD BUFFER 
        1742+22    2          + A LEFT    0002         MULT N BY 4 AS THERE ARE 4 HALF WORDS PER ROW
        1743+ 9 1783          + ADD       PRTROWAD     
        1744+13 1746          + STORE A   PRTROWR
        1745+13 1762          + STORE A   PRTROWW
        1746-10    0  PRTROWR - R ADD     /   /        
        1747-12 1774          - STORE     ROW          CURRENT CONTENTS OF ROW
        1748-10 1772          - R ADD     MASKCOL      "OR" MASKCOL IN SELECTED ROW
        1749+ 3 1757          + TR +      PRTW2
        1750-10 1774          - R ADD     ROW 
        1751+ 4 1755          + TR 0      PRTW1         
        1752+10 1770          + R ADD     ZERO         MASKCOL IS MINUS ZERO AND ROW IS NOT-EMPTY (EITHER POSITIVE OR NEGATIVE) -> SET ROW AS NEGATIVE
        1753- 7 1774          - SUB AB    ROW 
        1754+ 1 1762          + TR        PRTROWW
        1755-10 1772    PRTW1 - R ADD     MASKCOL      MASKCOL IS MINUS ZERO AND ROW IS EMPTY -> SET ROW = MASKCOL = MINUS ZERO
        1756+ 1 1762          + TR        PRTROWW
        1757-10 1774    PRTW2 - R ADD     ROW          
        1758+ 3 1761          + TR +      PRTW3              
        1759- 5 1772          - SUB       MASKCOL      MASKCOL IS POSITIVE AND ROW IS NEGATIVE -> SUB MASKCOL FROM ROW
        1760+ 1 1762          + TR        PRTROWW
        1761- 9 1772    PRTW3 - ADD       MASKCOL      MASKCOL IS POSITIVE AND ROW IS POSITIVE OR EMPTY -> ADD MASKCOL TO ROW         
        1762-12    0  PRTROWW - STORE     /   /        ROW UPDTATE
        1763+ 1 1730          + TR        LOOP1        PROCEED TO NEXT ROW
        1764+ 1    0 PRTCEX   + TR        /   /
        1765+10 1765 GETBMP1  + R ADD     *
        1766+ 1   85          + TR        BMPAD        GET BASE48 CHARS BITMAP ADDRESS
        1767+12 1778          + STORE     BITMAPAD     
        1768+ 1 1724          + TR        GETBMP2      RETURN
        1769+     0             ORG       EVEN
        1770+     0  ZERO       DEF       0            
        1771+     0             DEF       0            
        1772+     0  MASKCOL    DEF       0
        1773+     0             DEF       0
        1774+     0  ROW        DEF       0
        1775+     0             DEF       0
        1776+     0  NUM        DEF       0
        1777+     0             DEF       0
        1778+     0  BITMAPAD   DEF       0
        1779+     0  SGN        DEF       0
        1780+     0  LEN        DEF       0
        1781+     0  CHAR       DEF       0
        1782+     0  TXT        DEF       0
        1783+     0  PRTROWAD   DEF       0
        1784+     0  N          DEF       0
        1785+     0  BITS       DEF       0
        1786+     1  ONE        DEF       1
        1787+     2  TWO        DEF       2
        1788+     3  D3         DEF       3
        1789+    10  D10        DEF       10
        1790+    11  D11        DEF       11
        1791+    35  D35        DEF       35
        1792+    36  D36        DEF       36
        1793+    48  D48        DEF       48
        1794+    72  D72        DEF       72
        1795+  2304  D48X48     DEF       2304
        1796+ 16384  OCT04K     DEF       *040000      BIT SIGN ON 5TH OCTINARY DIGIT
        1798+ 9 1873 PRTNLINE + ADD       TWO          PRINT A NEW LINE OF DATA
        1799+12 1876          + STORE     PARAM        SAVE PARAM LIST ADDR
        1800+10 1800          + R ADD     *            CLEAR CARD BUFFER
        1801+ 1   53          + TR        CLRBUF 
        1802+10 1876 GPARAM   + R ADD     PARAM        GET PARAM PAIR FMT/DATA
        1803+13 1808          + STORE A   P1
        1804+ 9 1872          + ADD       ONE
        1805+13 1812          + STORE A   P2
        1806+ 9 1872          + ADD       ONE
        1807+12 1876          + STORE     PARAM
        1808+10    0 P1       + R ADD     /   /
        1809+12 1878          + STORE     FMT
        1810+ 3 1812          + TR +      P2           IF FMT < 0 THEM SKIP THIS PAIR FMT/DATA
        1811+ 1 1802          + TR        GPARAM
        1812+10    0 P2       + R ADD     /   /
        1813+12 1838          + STORE     DATALOC      GET DATA ADDRESS PASED AS PARAM
        1814+13 1815          + STORE A   P2A
        1815+10    0 P2A      + R ADD     /   /
        1816+12 1877          + STORE     DATA         GET EFFECTIVE DATA
        1817+10 1871          + R ADD     ZERO
        1818+15 1878          + LOAD MQ   FMT
        1819+18 1875          + DIV       D100         ACC=REMAINDER=COL NUMBER, MQ=QUOTIEN=TYPE OF DATA
        1820+12 1879          + STORE     COL
        1821+10 1871          + R ADD     ZERO
        1822+20   18          + L LEFT    0018
        1823+14 1878          + STORE MQ  FMT
        1824+15 1877          + LOAD MQ   DATA
        1825+10 1829          + R ADD     TYPETRAD
        1826+ 9 1878          + ADD       FMT
        1827+13 1828          + STORE A   TYPETR
        1828+ 1    0 TYPETR   + TR        /   /        TR SELECTED ROUTINE
        1829+ 0 1830 TYPETRAD + STOP      TYPETRT      TYPE TRANSFER TABLE ADDRESS
        1830+ 1 1859 TYPETRT  + TR        EOL          FMT=0..6 (IE <100) -> END OF PARAM LIST -> END OF LINE 
        1831+ 1 1836          + TR        TYSTR        FMT=1 -> PRINT A STRINGZ
        1832+ 1 1841          + TR        TYINT        FMT=2 -> PRINT AN INT
        1833+ 1 1846          + TR        TYOCT        FMT=3 -> PRINT AN OCT
        1834+ 1 1851          + TR        TYCHR        FMT=4 -> PRINT A CHAR
        1835+ 1 1855          + TR        TYALF        FMT=5 -> PRINT A 3-CHR PACKED ALFA STRING
        1836+10 1836 TYSTR    + R ADD     *            PRINT STRINGZ
        1837+ 1   81          + TR        PRTSTR
        1838+ 0    0 DATALOC  + STOP      /   /
        1839- 0 1879          - STOP      COL          COLUMN WHERE TXT STARTS
        1840+ 1 1802          + TR        GPARAM
        1841+10 1841 TYINT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1842+ 1   61          + TR        PRTINT
        1843+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        1844- 0 1879          - STOP      COL          COLUMN WHERE TXT STARTS
        1845+ 1 1802          + TR        GPARAM
        1846+10 1846 TYOCT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1847+ 1   83          + TR        PRTOCT
        1848+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        1849- 0 1879          - STOP      COL          COLUMN WHERE TXT STARTS
        1850+ 1 1802          + TR        GPARAM
        1851+10 1851 TYCHR    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1852+ 1   63          + TR        PRTCHR
        1853- 0 1879          - STOP      COL          COLUMN WHERE TXT STARTS
        1854+ 1 1802          + TR        GPARAM
        1855+10 1855 TYALF    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1856+ 1   59          + TR        PRTALF
        1857- 0 1879          - STOP      COL          COLUMN WHERE TXT STARTS
        1858+ 1 1802          + TR        GPARAM
        1859+10 1879 EOL      + R ADD     COL          SEND CARD BUFFER TO PRINTER AND RETURN TO CALLER
        1860+ 4 1865          + TR 0      DOPRINT      =0 -> PRINT ALLWAYS (NO SENSE SW CHECK)
        1861+ 9 1874          + ADD       D68          =1..6 -> SENSE 69..74 = OPERATOR'S PANEL SENSE SWITCH 1..6
        1862+13 1863          + STORE A   CHKSW
        1863+30    0 CHKSW    + SENSE     /   /         
        1864+ 1 1867          + TR        RETURN       SW NOT AT ON POSITION
        1865+10 1865 DOPRINT  + R ADD     *            PRINT CARD BUFFER
        1866+ 1   57          + TR        PRINTCRD
        1867+10 1876 RETURN   + R ADD     PARAM        PARAM-1 IS THE RETURN ADDR      
        1868+ 5 1872          + SUB       ONE
        1869+13 1870          + STORE A   EXIT
        1870+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        1871+ 0    0 ZERO     + STOP      0000
        1872+ 0    1 ONE      + STOP      0001
        1873+ 0    2 TWO      + STOP      0002
        1874+ 0   68 D68      + STOP      0068
        1875+ 0  100 D100     + STOP      100
        1876+ 0    0 PARAM    + STOP      0000
        1877+ 0    0 DATA     + STOP      0000
        1878+ 0    0 FMT      + STOP      0000
        1879+ 0    0 COL      + STOP      0000
        1880+ 9 1894 BMPAD    + ADD       TWO
        1881+13 1883          + STORE A   EXIT
        1882+10 1884          + R ADD     BITMAPAD
        1883+ 1    0 EXIT     + TR        /   /
        1884+ 0 1886 BITMAPAD + STOP      BITMAP
        1885+     0             ORG       EVEN
        1886+     0  BITMAP     DEF       0              <blank>     0     <none>
        1887+   256             DEF       256               1        1       1        256          =  256   
        1888+   128             DEF       128               2        2       2        128          =  128   
        1889+    64             DEF       64                3        3       3         64          =   64   
        1890+    32             DEF       32                4        4       4         32          =   32   
        1891+    16             DEF       16                5        5       5         16          =   16   
        1892+     8             DEF       8                 6        6       6          8          =    8   
        1893+     4             DEF       4                 7        7       7          4          =    4   
        1894+     2  TWO        DEF       2                 8        8       8          2          =    2   
        1895+     1             DEF       1                 9        9       9          1          =    1   
        1896+   512             DEF       512               0       10       0        512          =  512   
        1897+  1024             DEF       1024              -       11       X       1024          = 1024   
        1898+  2048             DEF       2048              +       12       Y       2048          = 2048   
        1899+  2304             DEF       2304              A       13      Y-1        256+2048    = 2304   
        1900+  2176             DEF       2176              B       14      Y-2        128+2048    = 2176   
        1901+  2112             DEF       2112              C       15      Y-3         64+2048    = 2112   
        1902+  2080             DEF       2080              D       16      Y-4         32+2048    = 2080   
        1903+  2064             DEF       2064              E       17      Y-5         16+2048    = 2064   
        1904+  2056             DEF       2056              F       18      Y-6          8+2048    = 2056   
        1905+  2052             DEF       2052              G       19      Y-7          4+2048    = 2052   
        1906+  2050             DEF       2050              H       20      Y-8          2+2048    = 2050   
        1907+  2049             DEF       2049              I       21      Y-9          1+2048    = 2049   
        1908+  1280             DEF       1280              J       22      X-1        256+1024    = 1280   
        1909+  1152             DEF       1152              K       23      X-2        128+1024    = 1152   
        1910+  1088             DEF       1088              L       24      X-3         64+1024    = 1088   
        1911+  1056             DEF       1056              M       25      X-4         32+1024    = 1056   
        1912+  1040             DEF       1040              N       26      X-5         16+1024    = 1040   
        1913+  1032             DEF       1032              O       27      X-6          8+1024    = 1032   
        1914+  1028             DEF       1028              P       28      X-7          4+1024    = 1028   
        1915+  1026             DEF       1026              Q       29      X-8          2+1024    = 1026   
        1916+  1025             DEF       1025              R       30      X-9          1+1024    = 1025   
        1917+   640             DEF       640               S       31      0-2        128+512     = 640    
        1918+   576             DEF       576               T       32      0-3         64+512     = 576    
        1919+   544             DEF       544               U       33      0-4         32+512     = 544    
        1920+   528             DEF       528               V       34      0-5         16+512     = 528    
        1921+   520             DEF       520               W       35      0-6          8+512     = 520    
        1922+   516             DEF       516               X       36      0-7          4+512     = 516    
        1923+   514             DEF       514               Y       37      0-8          2+512     = 514    
        1924+   513             DEF       513               Z       38      0-9          1+512     = 513    
        1925+   578             DEF       578               ,       39      8-3-0        2+64+512  = 578    
        1926+   546             DEF       546               %       40      8-4-0        2+32+512  = 546    
        1927+  1090             DEF       1090              $       41      8-3-X        2+64+1024 = 1090   
        1928+  1058             DEF       1058              *       42      8-4-X        2+32+1024 = 1058   
        1929+  2114             DEF       2114              .       43      8-3-Y        2+64+2048 = 2114   
        1930+  2082             DEF       2082              #       44      8-4-Y        2+32+2048 = 2082   
        1931+   768             DEF       768               /       45      0-1          512+256   = 768    
        1932+    66             DEF       66                +       46      8-3          2+64      = 66     
        1933+    34             DEF       34                -       47      8-4          2+32      = 34    This is the non-minus-sign separator
        1934+ 9 1958 CLMEM    + ADD       TWO 
        1935+13 1940          + STORE A   P1           PARM: ADDR 
        1936+ 9 1957          + ADD       ONE          
        1937+13 1942          + STORE A   P2           PARM: LOCATION OF LEN=NUMBER OF HALF-WORDS TO CLEAR 
        1938+ 9 1957          + ADD       ONE          
        1939+13 1948          + STORE A   EXIT
        1940+10    0 P1       + R ADD     /   /        GET ADDR TO CLEAR
        1941+13 1951          + STORE A   MEM
        1942+10    0 P2       + R ADD     /   /        GET LEN ADDR
        1943+13 1944          + STORE A   P2A
        1944+10    0 P2A      + R ADD     /   /        GET LEN 
        1945+12 1959          + STORE     LEN
        1946+15 1956          + LOAD MQ   ZERO
        1947+10 1959 LOOP     + R ADD     LEN
        1948+ 4    0 EXIT     + TR 0      /   /
        1949+ 5 1957          + SUB       ONE
        1950+12 1959          + STORE     LEN
        1951+14    0 MEM      + STORE MQ  /   /        
        1952+10 1951          + R ADD     MEM
        1953+ 9 1957          + ADD       ONE
        1954+13 1951          + STORE A   MEM
        1955+ 1 1947          + TR        LOOP
        1956+ 0    0 ZERO     + STOP      0000
        1957+ 0    1 ONE      + STOP      0001         constant 1
        1958+ 0    2 TWO      + STOP      0002         constant 2
        1959+ 0    0 LEN      + STOP      0000
        1960+ 9 2033 RWDRUM   + ADD       TWO 
        1961+13 1970          + STORE A   PDR1         PARM1: DRUM INSTR: READ/WRITE 0128  0129  0130  0131
        1962+ 9 2032          + ADD       ONE          
        1963+13 1972          + STORE A   PDR2         PARM2: DRUM ADDRESS (0..4094)
        1964+ 9 2032          + ADD       ONE          
        1965+13 1974          + STORE A   PDR3         PARM3: BUF START ADDRESS
        1966+ 9 2032          + ADD       ONE          
        1967+13 1976          + STORE A   PDR4         PARM4: LEN: NUMBER OF HALF-WORDS (MUST BE EVEN)
        1968+ 9 2032          + ADD       ONE          
        1969+13 2030          + STORE A   EXIT               
        1970+10    0 PDR1     + R ADD     /   /        GET DRUM INSTR
        1971+12 1978          + STORE     DRIO
        1972+10    0 PDR2     + R ADD     /   /        GET DRUM ADDR
        1973+13 1979          + STORE A   DRADDR
        1974+10    0 PDR3     + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1975+13 2017          + STORE A   RWCOPY    
        1976+10    0 PDR4     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        1977+12 2034          + STORE     LEN
        1978+ 0    0 DRIO     + STOP      /   /        INSTR: READ/WRITE 0128  0129  0130  0131
        1979+29    0 DRADDR   + SET DR    /   /
        1980+ 1 2013          + TR        LOOP
        1981+ 9 2033 RDTAPE   + ADD       TWO 
        1982+13 1989          + STORE A   PR1          PARM1: TAPE ADDRESS
        1983+ 9 2032          + ADD       ONE          
        1984+13 1991          + STORE A   PR2          PARM2: BUF START ADDRESS
        1985+ 9 2032          + ADD       ONE          
        1986+13 2030          + STORE A   EXIT
        1987+ 2 1988          + TR OV     CLOV1        CLEAR OV THAT MAY HAVE BEEN SET
        1988+ 8    0    CLOV1 + NOOP      0000
        1989+10    0 PR1      + R ADD     /   /        GET TAPE ADDR
        1990+13 1993          + STORE A   RTAPAD       TAPE UNITS: 0256  0257  0258  0259
        1991+10    0 PR2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1992+13 2017          + STORE A   RWCOPY    
        1993+24    0 RTAPAD   + READ      /   /
        1994+10 2031          + R ADD     ZERO
        1995+ 1 2015          + TR        LOOP1
        1996+ 9 2033 WRTAPE   + ADD       TWO 
        1997+13 2004          + STORE A   PW1          PARM1: TAPE ADDRESS
        1998+ 9 2032          + ADD       ONE          
        1999+13 2006          + STORE A   PW2          PARM2: BUF START ADDRESS
        2000+ 9 2032          + ADD       ONE          
        2001+13 2008          + STORE A   PW3          PARM3: BUF LEN
        2002+ 9 2032          + ADD       ONE          
        2003+13 2030          + STORE A   EXIT
        2004+10    0 PW1      + R ADD     /   /        GET TAPE ADDR
        2005+13 2012          + STORE A   WTAPAD       TAPE UNITS: 0256  0257  0258  0259
        2006+10    0 PW2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        2007+13 2017          + STORE A   RWCOPY    
        2008+10    0 PW3      + R ADD     /   /        GET ADDR OF LEN 
        2009+13 2010          + STORE A   PW3A
        2010+10    0 PW3A     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        2011+12 2034          + STORE     LEN
        2012+26    0 WTAPAD   + WRITE     /   /        PREPARE TO WRITE ON TAPE
        2013+10 2034 LOOP     + R ADD     LEN
        2014+ 4 2029          + TR 0      RWOK
        2015+ 5 2033 LOOP1    + SUB       TWO
        2016+12 2034          + STORE     LEN
        2017-31    0 RWCOPY   - COPY      /   /        WRITE BUFFER TO TAPE
        2018+ 1 2021          + TR        GO 
        2019+ 1 2025          + TR        EOF          END OF FILE
        2020+ 1 2027          + TR        EOR          END OF RECORD
        2021+10 2017 GO       + R ADD     RWCOPY
        2022+ 5 2033          + SUB       TWO
        2023+13 2017          + STORE A   RWCOPY
        2024+ 1 2013          + TR        LOOP
        2025+10 2032 EOF      + R ADD     ONE          SET OV FLAG TO SIGNAL END OF FILE CONDITION
        2026+22   36          + A LEFT    36
        2027+ 6 2034 EOR      + R SUB     LEN          RETURN NUMBER OF HALF-WORDS READ
        2028+ 5 2033          + SUB       TWO
        2029+26 2052 RWOK     + WRITE     2052         INSURE THAT MQ NOT IN USE            
        2030+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        2031+ 0    0 ZERO     + STOP      0000
        2032+ 0    1 ONE      + STOP      0001         
        2033+ 0    2 TWO      + STOP      0002         
        2034+     0  LEN        RES       1
        2036+12 2112 RDBTAPE  + STORE     DUMMY
        2037+10 2106          + R ADD     RDBKW        SET THE TAPE I/O INSTRUCTION
        2038+12 2076          + STORE     RTAPAD
        2039+10 2107          + R ADD     ADD2         SET TO DECREMENT RWCOPY ADDRESS
        2040+12 2086          + STORE     INCR         (INSTR IS -COPY -> NEGATIVE -> DECREMENT BY ADDING TWO)
        2041+15 2110          + LOAD MQ   ONE          FLAG OF COMPUTE: ADD=ADD+LEN-2
        2042+ 1 2049          + TR        READ
        2043+12 2112 RDFTAPE  + STORE     DUMMY
        2044+10 2105          + R ADD     RDFWD        SET THE TAPE I/O INSTRUCTION
        2045+12 2076          + STORE     RTAPAD
        2046+10 2108          + R ADD     SUB2         SET TO INCREMENT RWCOPY ADDRESS
        2047+12 2086          + STORE     INCR         (INSTR IS -COPY -> NEGATIVE -> INCREMENT BY SUBSTRACTING TWO)
        2048+15 2109          + LOAD MQ   ZERO
        2049+10 2112 READ     + R ADD     DUMMY        PROCEED
        2050+ 9 2111          + ADD       TWO 
        2051+13 2058          + STORE A   PR1          PARM1: TAPE ADDRESS
        2052+ 9 2110          + ADD       ONE          
        2053+13 2061          + STORE A   PR2          PARM2: BUF START ADDRESS
        2054+ 9 2110          + ADD       ONE          
        2055+13 2063          + STORE A   PR3          PARM2: BUF LEN ADDRESS
        2056+ 9 2110          + ADD       ONE          
        2057+13 2104          + STORE A   EXIT
        2058+10    0 PR1      + R ADD     /   /        GET TAPE ADDR
        2059+13 2076          + STORE A   RTAPAD       TAPE UNITS: 0256  0257  0258  0259
        2060+ 2 2061          + TR OV     PR2          CLEAR OVERFLOW FLAG
        2061+10    0 PR2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        2062+13 2081          + STORE A   RWCOPY    
        2063+10    0 PR3      + R ADD     /   /        GET ADDR OF LEN 
        2064+13 2065          + STORE A   PR3A
        2065+10    0 PR3A     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        2066+12 2113          + STORE     LEN
        2067+10 2109          + R ADD     ZERO
        2068+20   35          + L LEFT    0035         ACC=MQ
        2069+ 4 2074          + TR 0      PR4          IF MQ=0 -> READ FWD -> TR TO PR4
        2070+10 2081          + R ADD     RWCOPY       HERE READ BKW -> SET BUFFER START AT ADD+LEN-2
        2071+ 5 2113          + SUB       LEN
        2072+ 9 2111          + ADD       TWO
        2073+13 2081          + STORE A   RWCOPY
        2074+10 2109 PR4      + R ADD     ZERO
        2075+12 2114          + STORE     RECLEN
        2076+ 0    0 RTAPAD   + STOP      /   /        WILL BE REPLACED BY RDFWD OR RDBKW
        2077+10 2113 LOOP     + R ADD     LEN
        2078+ 4 2092          + TR 0      SKIP
        2079+ 5 2111          + SUB       TWO
        2080+12 2113          + STORE     LEN
        2081-31    0 RWCOPY   - COPY      /   /        WRITE BUFFER TO TAPE
        2082+ 1 2085          + TR        GO 
        2083+ 1 2100          + TR        EOF          END OF FILE
        2084+ 1 2102          + TR        EOR          END OF RECORD
        2085+10 2081 GO       + R ADD     RWCOPY
        2086+ 5 2111 INCR     + SUB       TWO
        2087+13 2081          + STORE A   RWCOPY
        2088+10 2114          + R ADD     RECLEN
        2089+ 9 2111          + ADD       TWO
        2090+12 2114          + STORE     RECLEN
        2091+ 1 2077          + TR        LOOP
        2092-31 2112 SKIP     - COPY      DUMMY
        2093+ 1 2096          + TR        GO2 
        2094+ 1 2100          + TR        EOF          END OF FILE
        2095+ 1 2102          + TR        EOR          END OF RECORD
        2096+10 2114 GO2      + R ADD     RECLEN
        2097+ 9 2111          + ADD       TWO
        2098+12 2114          + STORE     RECLEN
        2099+ 1 2092          + TR        SKIP
        2100+10 2110 EOF      + R ADD     ONE          SET OV FLAG TO SIGNAL END OF FILE CONDITION
        2101+22   36          + A LEFT    36
        2102+10 2114 EOR      + R ADD     RECLEN       RETURN NUMBER OF HALF-WORDS IN TAPE RECORD
        2103+26 2052          + WRITE     2052         INSURE THAT MQ NOT IN USE            
        2104+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        2105+24    0 RDFWD    + READ      0000         TAPE I/O INSTRUCTIONS 
        2106+25    0 RDBKW    + READ B    0000
        2107+ 9 2111 ADD2     + ADD       TWO
        2108+ 5 2111 SUB2     + SUB       TWO
        2109+ 0    0 ZERO     + STOP      0000
        2110+ 0    1 ONE      + STOP      0001         
        2111+ 0    2 TWO      + STOP      0002         
        2112+     0  DUMMY      RES       1
        2113+     0  LEN        RES       1
        2114+     0  RECLEN     RES       1
        2116+ 9 2131 CHAIN    + ADD       TWO
        2117+13 2118          + STORE A   CHP1
        2118+10    0 CHP1     + R ADD     /   /        GET TAPE NUMBER
        2119+13 2126          + STORE A   TAPELOAD
        2120+30   70          + SENSE     0070         SENSE SWITCH 2                                  
        2121+ 1 2125 CONTAD   + TR        ENDSTOP      (ON POSITION MAKES SENSE OPCODE TO SKIP NEXT INSTR)
        2122+10 2121          + R ADD     CONTAD       IF SW2 IS ON, A +STOP 4095 IS EXECUTED.  
        2123+12 4095          + STORE     4095         IF THEN USER PRESS START, EXECUTION WILL BE RESUMED 
        2124+ 0 4095          + STOP      4095         AND CHAINED PROGRAM WILL BE LOADED AND EXECUTED
        2125+ 8    0 ENDSTOP  + NOOP      0000
        2126+24    0 TAPELOAD + READ      0000         
        2127-31    0 TL0      - COPY      0000         READ 1ST WORD OF SELF-LOADER FROM TAPE
        2128+ 1    0          + TR        0000         TR TO SELF-LOADER
        2129+ 0 2221          + STOP      2221         ERROR LOADING: UNEXPECTED END OF FILE
        2130+ 0 2222          + STOP      2222         ERROR LOADING: UNEXPECTED END OF RECORD 
        2131+ 0    2 TWO      + STOP      0002         ERROR LOADING: UNEXPECTED END OF FILE
          48-     0  ROUTINE INIT
          49+ 1  112 ENTRY POINT
          50-     0  ROUTINE CHAIN
          51+ 1 2116 ENTRY POINT
          52-     0  ROUTINE CLRBUF
          53+ 1 1468 ENTRY POINT
          54-     0  ROUTINE PRTNLINE
          55+ 1 1798 ENTRY POINT
          56-     0  ROUTINE PRINTCRD
          57+ 1 1476 ENTRY POINT
          58-     0  ROUTINE PRTALF
          59+ 1 1560 ENTRY POINT
          60-     0  ROUTINE PRTINT
          61+ 1 1638 ENTRY POINT
          62-     0  ROUTINE PRTCHR
          63+ 1 1680 ENTRY POINT
          64-     0  ROUTINE RDFTAPE
          65+ 1 2043 ENTRY POINT
          66-     0  ROUTINE RDBTAPE
          67+ 1 2036 ENTRY POINT
          68-     0  ROUTINE RDTAPE
          69+ 1 1981 ENTRY POINT
          70-     0  ROUTINE WRTAPE
          71+ 1 1996 ENTRY POINT
          72-     0  ROUTINE RWDRUM
          73+ 1 1960 ENTRY POINT
          74-     0  ROUTINE CLMEM
          75+ 1 1934 ENTRY POINT
          76-     0  ROUTINE READCRD
          77+ 1 1472 ENTRY POINT
          78-     0  ROUTINE WRITECRD
          79+ 1 1474 ENTRY POINT
          80-     0  ROUTINE PRTSTR
          81+ 1 1537 ENTRY POINT
          82-     0  ROUTINE PRTOCT
          83+ 1 1604 ENTRY POINT
          84-     0  ROUTINE BMPAD
          85+ 1 1880 ENTRY POINT
        4094+    48  REGION ORIGIN TABLE LOCATION
        4095+   112  INITIAL REGION
           0+ 1  112          + TR        INIT         PROGRAM START
