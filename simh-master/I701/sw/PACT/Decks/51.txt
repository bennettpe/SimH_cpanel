        DEC
        NNNN OP ADDR COMMENTS
          96+ 9 2669 LOADCC   + ADD       TWO          LOAD PACTSCR INTO CARD IMAGE SO 
          97+13  116          + STORE A   CPCCEX       CURRENT PACT SOURCE CODE CAN BE PRINTED
          98+10 2666          + R ADD     ZERO         COPY TO LEFT SIDE OF SOURCE CODE CARD IMAGE
          99+13  103          + STORE A   CPCC1        AT 0..46 FROM PACTSCR
         100+10  119          + R ADD     CPCC2
         101+13  102          + STORE A   CPCC 
         102-10    0 CPCC     - R ADD     /   /
         103-12    0 CPCC1    - STORE     /   /
         104+10  103          + R ADD     CPCC1
         105+ 5 2669          + SUB       TWO
         106+13  108          + STORE A   CPCC1B
         107+10 2666          + R ADD     ZERO
         108-12    0 CPCC1B   - STORE     /   /
         109+10  102          + R ADD     CPCC
         110+ 5 2669          + SUB       TWO
         111+13  102          + STORE A   CPCC
         112+10  103          + R ADD     CPCC1
         113+ 5 2671          + SUB       D4
         114+13  103          + STORE A   CPCC1
         115+ 5  118          + SUB       CPCCE
         116+ 4    0 CPCCEX   + TR 0      /   /        RETURN TO CALLER
         117+ 1  102          + TR        CPCC
         118-12   48 CPCCE    - STORE     0048         LAST LOCATION TO COPY FROM 
         119+ 8 1502 CPCC2    + NOOP      PACTSRC      PACTSRC = FIRST LOCATION TO COPY FROM
         120+10  120 INIT     + R ADD     *            
         121+ 1   55          + TR        PRTNLINE     
         122+ 0  101          + STOP      0101         STRINGZ AT COL 1
         123+ 0 2815          + STOP      MSGSTART     "LOOP EXPANSION"
         124+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         125+10 2666          + R ADD     ZERO         CLEAR CC RECORD
         126+12 1526          + STORE     REGION     
         127+12 1527          + STORE     STEP       
         128+12 1528          + STORE     OP         
         129+12 1529          + STORE     FACT       
         130+12 1530          + STORE     S1         
         131+12 1531          + STORE     S2         
         132+12 1532          + STORE     QR         
         133+12 1533          + STORE     QF         
         134-12 1534          - STORE     NUM        
         135+12 1536          + STORE     CLUE       
         136+12 1537          + STORE     STEPN      
         137+12 1538          + STORE     FACTN      
         138+12 1539          + STORE     FACTREG    
         139+12 1540          + STORE     S1N        
         140+12 1541          + STORE     S2N        
         141+12 1542          + STORE     D1N        
         142+12 1543          + STORE     D2N        
         143+12 1544          + STORE     NINST      
         144+12 1545          + STORE     NINCR 
         145+10 1746          + R ADD     CCLEN        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         146+10 1990          + R ADD     TPARSTEP     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         147+10 2058          + R ADD     TPARFACT     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         148+10 2316          + R ADD     TREFIDX1     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         149+10 2366          + R ADD     TREFIDX2     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         150+10 2416          + R ADD     TREFSTEP     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         151+10 2466          + R ADD     TREFINCR     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         152+10 2566          + R ADD     TREFADDR     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         153+10  153          + R ADD     *            CLEAR GENERATED MACHINE CODE INSTR ON CC RECORD
         154+ 1   81          + TR        CLMEM        
         155+ 0 1546 TINSTAD  + STOP      TINST      
         156+ 0 2686          + STOP      D200         TINST (200 HALF-WORDS) = 2 * MAXNINST (MAX NUMBER OF MACHINE CODE INSTRUTIONS PER STEP)
         157+10 2666          + R ADD     ZERO
         158+12 2691          + STORE     NREGIONS     NUMBER OF REGIONS PROCESSED
         159+28  258          + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE)
         160+28  257          + REWIND    TAPEOUT      REWIND TAPE OUT WITH UPDATED PACT COMPACT CODE
         161+28  259          + REWIND    TAPEOUTR     OUTPUT TO TAPE 4 (PASS1 POPULATED TABLES FOR EACH REGION)
         162+10 2666 READREG  + R ADD     ZERO
         163+12 2127          + STORE     NIDXS        INIT NUMBER OF INDEXES IN THIS REGION
         164+12 2265          + STORE     NREFS        INIT NUMBER OF REFERENCES
         165+12 1955          + STORE     NPARAMS      INIT NUMBER OF PARAMS DEFINED
         166+12 1753          + STORE     NLOCONST     NUM OF ENTRIES IN LOOP CONSTANT POOL OF REGION 
         167+12 2732          + STORE     SVNINST      SO WE CAN PRINT A LOG OF CC THAT GET GENERATED MC INSTR
         168+12 2733          + STORE     SVSTEPN      SAVE LAST STEPN 
         169+12 2701          + STORE     PRGSTEPN     FIRST STEPN OF PROGRAM AFTER INITIAL CALL/ID/FOR (IE STEP-1 IS CALL/ID/FOR INSTR)
         170+12 2700          + STORE     REGCSTEP     STEPN WHERE THE REG.C SITS
         171+10  171 READSTEP + R ADD     *            READ PACT USER PROGRAM SOURCE CODE FROM TAPE IN
         172+ 1   67          + TR        RDTAPE
         173+ 0  258          + STOP      TAPEIN
         174+ 0 1502          + STOP      CCODE        BUF TO READ IN FROM TAPE
         175+ 2  260          + TR OV     EOF          TR IF END OF FILE
         176+10 1528          + R ADD     OP
         177+ 4  251          + TR 0      EOR          TR IF END OF REGION
         178+10  178          + R ADD     *            LOAD PACTSCR INTO CARD IMAGE SO 
         179+ 1   96          + TR        LOADCC       CURRENT PACT SOURCE CODE CAN BE PRINTED
         180+10 1544          + R ADD     NINST        SAVE CURRENT NUMBER OF MC INSTR IN THE COMPACT CODE RECORD
         181+12 2732          + STORE     SVNINST      SO WE CAN PRINT A LOG OF CC THAT GET GENERATED MC INSTR
         182+10 1537          + R ADD     STEPN
         183+12 2733          + STORE     SVSTEPN      SAVE LAST STEPN TO MAKE EOR RECORD FOLLOW
         184+10 1528          + R ADD     OP           JUMP TABLE TO HANDLE EACH TYPE OF PACT OPERATION
         185+ 9  188          + ADD       OPTBL
         186+13  187          + STORE A   OPTBLTR
         187+ 1    0 OPTBLTR  + TR        /   /
         188+ 0  188 OPTBL    + STOP      *
         189+ 1 1037          + TR        CHECKREF     OP=1   TAKE   FACTOR CANNOT BE BLANK 
         190+ 1 1037          + TR        CHECKREF     OP=2   ADD    ALLOWS BLANK FACTOR 
         191+ 1 1037          + TR        CHECKREF     OP=3   SUB    ALLOWS BLANK FACTOR 
         192+ 1 1037          + TR        CHECKREF     OP=4   MUL    ALLOWS BLANK FACTOR
         193+ 1 1037          + TR        CHECKREF     OP=5   DIV    FACTOR CANNOT BE BLANK 
         194+ 1  233          + TR        NEXT         OP=6   RES    NO FACTOR
         195+ 1 1037          + TR        CHECKREF     OP=7   EQ     NEEDS VARIABLE AS FACTOR
         196+ 1 1037          + TR        CHECKREF     OP=8   +ABS   ALLOWS BLANK FACTOR
         197+ 1 1037          + TR        CHECKREF     OP=9   -ABS   ALLOWS BLANK FACTOR
         198+ 1 1037          + TR        CHECKREF     OP=10  ABS    FACTOR CANNOT BE BLANK 
         199+ 1  233          + TR        NEXT         OP=11  T      FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         200+ 1  233          + TR        NEXT         OP=12  TZ     FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         201+ 1  233          + TR        NEXT         OP=13  TP     FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         202+ 1  233          + TR        NEXT         OP=14  TN     FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         203+ 1  233          + TR        NEXT         OP=15  TF     FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         204+ 1  233          + TR        NEXT         OP=16  HALT   FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         205+ 1  679          + TR        TEST         OP=17  TEST   
         206+ 1  588          + TR        USESET       OP=18  SET    
         207+ 1  588          + TR        USESET       OP=19  USE    
         208+ 1  233          + TR        NEXT         OP=20  DO     ALREADY PROCESSED IN OPERATION EXPANSION
         209+ 1  233          + TR        NEXT         OP=21  EXIT
         210+ 1  232          + TR        BADOP        OP=22  DUP    SHOULD NOT BE PRESENT. IT IS ALREADY PROCESSED
         211+ 1  233          + TR        NEXT         OP=23  LIB    ALREADY PROCESSES IN OPERATIOn EXPANSION
         212+ 1  232          + TR        BADOP        OP=24  ID     SHOULD NOT BE PRESENT. IT IS DESAMBIGUATED
         213+ 1  232          + TR        BADOP        OP=25  FOR    SHOULD NOT BE PRESENT. IT IS DESAMBIGUATED
         214+ 1  233          + TR        NEXT         OP=26  CALL   
         215+ 1 1037          + TR        CHECKREF     OP=27  SIN    ALLOWS BLANK FACTOR
         216+ 1 1037          + TR        CHECKREF     OP=28  COS    ALLOWS BLANK FACTOR
         217+ 1 1037          + TR        CHECKREF     OP=29  ARCT   ALLOWS BLANK FACTOR
         218+ 1 1037          + TR        CHECKREF     OP=30  SQRT   ALLOWS BLANK FACTOR
         219+ 1 1037          + TR        CHECKREF     OP=31  LOG    ALLOWS BLANK FACTOR
         220+ 1 1037          + TR        CHECKREF     OP=32  EXP    ALLOWS BLANK FACTOR
         221+ 1  233          + TR        NEXT         OP=33  SE
         222+ 1 1037          + TR        CHECKREF     OP=34  CL     NEEDS VARIABLE AS FACTOR
         223+ 1  233          + TR        NEXT         OP=35  READ
         224+ 1  233          + TR        NEXT         OP=36  LIST
         225+ 1  233          + TR        NEXT         OP=37  RES for MULT
         226+ 1  233          + TR        NEXT         OP=38  RES for DIV
         227+ 1 1037          + TR        CHECKREF     OP=39  ID for LIST         FACTOR CANNOT BE BLANK 
         228+ 1 1037          + TR        CHECKREF     OP=40  ID for DO/LIB       ONLY APPLIES INDEX IF IT IS ACTIVE
         229+ 1  424          + TR        IDCALL       OP=41  ID for CALL         
         230+ 1  233          + TR        NEXT         OP=42  FOR for DO/LIB      
         231+ 1  504          + TR        FORCALL      OP=43  FOR for CALL        
         232+ 0 1111 BADOP    + STOP      1111         INTERNAL COMPILER ERROR: SHOULD NOT BE PRESENT. IT SHOULD HAVE BEEN DESAMBIGUATED
         233+ 8    0 NEXT     + NOOP      0000         CONTINUE 
         234+10 1528          + R ADD     OP           IF OP=26 (CALL), OP=41 (ID for CALL), OP=43  FOR for CALL
         235+ 5 2678          + SUB       OPCALL       WE ARE IN THE PARAMETERS SECTION OF THIS REGION
         236+ 4  248          + TR 0      NXWR         WHEN FIRST STEPN OF PROGRAM ARRIVES, SAVE ITS NUMBER IN 
         237+10 1528          + R ADD     OP           PRGSTEPN VARIABLE. THIS IS THE FIRST PROGRAM STEPN  
         238+ 5 2682          + SUB       OPIDCALL     AFTER INITIAL CALL/ID/FOR. 
         239+ 4  248          + TR 0      NXWR
         240+10 1528          + R ADD     OP
         241+ 5 2683          + SUB       OPFORCAL
         242+ 4  248          + TR 0      NXWR
         243+10 2701          + R ADD     PRGSTEPN     =0?   
         244+ 5 2668          + SUB       ONE 
         245+ 3  248          + TR +      NXWR         NO, IS >0 -> ALREADY SET -> CONTINUE
         246+10 1537          + R ADD     STEPN        YES, IS=0 -> SET PRGSTEPN=CURRENT STEPN
         247+12 2701          + STORE     PRGSTEPN     FIRST STEPN OF PROGRAM AFTER INITIAL CALL/ID/FOR (IE STEP-1 IS CALL/ID/FOR INSTR)
         248+10  248 NXWR     + R ADD     *            WRITE COMPACT CODE ON TAPEOUT
         249+ 1  277          + TR        WRCC         WITH LOG
         250+ 1  171          + TR        READSTEP     
         251+ 8    0 EOR      + NOOP      0000         END OF REGION  
         252+10  252          + R ADD     *
         253+ 1  310          + TR        WREORCC      IF NEEDED, ADD COMPACT CODE RECORD OP=44 OPNCONST
         254+10  254          + R ADD     *            SAVE IN TAPEOUTR THE POPULATED TABLES
         255+ 1  380          + TR        WREORTBL     TO BE USED BY PASS 2
         256+10 2691          + R ADD     NREGIONS     NUMBER OF REGIONS PROCESSED
         257+ 9 2668          + ADD       ONE
         258+12 2691          + STORE     NREGIONS     
         259+ 1  162          + TR        READREG      PROCESS NEXT REGION
         260+ 8    0 EOF      + NOOP      0000         END OF FILE
         261+27  257          + WRITE EF  TAPEOUT      WRITE EOF IN TAPE OUT (COMPACT CODE)
         262+27  259          + WRITE EF  TAPEOUTR     WRITE EOF IN TAPE OUT (REGION TABLES)
         263+30   74          + SENSE     0074         SENSE SWITCH 6
         264+ 1  272          + TR        ENDLOG1B     TR IF NO LOG SELECTED
         265+10  265          + R ADD     *
         266+ 1   55          + TR        PRTNLINE     
         267+ 0  101          + STOP      0101         STRINGZ AT COL 1
         268+ 0 2823          + STOP      MSGDONE      "REGIONS"
         269+ 0  210          + STOP      0210         INT AT COL 10
         270+ 0 2691          + STOP      NREGIONS     NUMBER OF REGIONS PROCESSED
         271+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         272+ 8    0 ENDLOG1B + NOOP      0000
         273+10  273          + R ADD     *
         274+ 1   51          + TR        CHAIN        IF SW2 IS ON, A +STOP 4095 IS EXECUTED 
         275+ 0  256          + STOP      PACTCOMP     CHAIN TO NEXT STAGE IN PACT COMPILER TAPE
         276+ 0 4095          + STOP      4095
         277+ 9 2669 WRCC     + ADD       TWO          WRITE COMPACT CODE ON TAPE WITH TRAILING RECORD
         278+13  309          + STORE A   WRCCEXIT     TO ALLOW READING BACKWARDS. IF SW6 ON PRINT LOG
         279+10 1746          + R ADD     CCLEN        SAVE MC INSTRUCTIONS GENERATED SO FAR
         280+ 9 1544          + ADD       NINST        ADD NINST TWICE AS EACH MC INSTR USES TWO HALF-WORDS
         281+ 9 1544          + ADD       NINST
         282+12 1747          + STORE     N
         283+10  283          + R ADD     *
         284+ 1   69          + TR        WRTAPE       WRITE MAGNETIC TAPE TAPEOUT (PACT COMPACT CODE)
         285+ 0  257          + STOP      TAPEOUT
         286+ 0 1502          + STOP      CCODE        BUF TO WRITE TO TAPE
         287+ 0 1747          + STOP      N            LEN
         288+10 1537          + R ADD     STEPN
         289+12 1750          + STORE     DATA
         290+10 1544          + R ADD     NINST
         291+12 1751          + STORE     DATA2
         292+10  292          + R ADD     *            WRITE TRAILING IDENTIFICATION RECORD
         293+ 1   69          + TR        WRTAPE       (MC CODE GENERATED STEPN + NINST)
         294+ 0  257          + STOP      TAPEOUT      SO TAPE CAN BE READ BACKWARDS ON PASS 2
         295+ 0 1750          + STOP      DATA         BUF TO WRITE TO TAPE
         296+ 0 2669          + STOP      TWO          LEN
         297+30   74          + SENSE     0074         SENSE SWITCH 6
         298+ 1  308          + TR        ENDLOG1      TR IF NO LOG SELECTED
         299+10 1528          + R ADD     OP
         300+ 4  308          + TR 0      ENDLOG1      DO NOT PRINT EOR 
         301+10  301          + R ADD     *            PRINT STEP JUST PROCESSED
         302+ 1   57          + TR        PRINTCRD
         303+10 1544          + R ADD     NINST        IF NUMBER OF MC INSTR IN THE COMPACT CODE RECORD HAS CHANGED
         304+ 5 2732          + SUB       SVNINST      -> CC GOT GENERATED MC INSTR -> PRINT MC INSTR GENERATED
         305+ 4  308          + TR 0      ENDLOG1
         306+10  306          + R ADD     *
         307+ 1 1358          + TR        PRTMC        PRINT TINST TABLE WITH MC INSTRUCTIONS GENERATED FOR THIS STEP
         308+ 8    0 ENDLOG1  + NOOP      0000 
         309+ 1    0 WRCCEXIT + TR        /   /         
         310+ 9 2669 WREORCC  + ADD       TWO          ADD LOOP CONSTANTS POOL AS TINST ON CC RECORD                           
         311+13  379          + STORE A   WREOREX
         312+10 1753          + R ADD     NLOCONST     
         313+12 1544          + STORE     NINST
         314+22    1          + A LEFT    0001
         315+ 4  377          + TR 0      SVEOR        SKIP IF NO LOOP CONSTANTS POOL
         316+12 2734          + STORE     LEN
         317+10  317          + R ADD     *            
         318+ 1   83          + TR        MEMCOPY
         319+ 0 1754          + STOP      TLOCONST   
         320+ 0 1546          + STOP      TINST      
         321+ 0 2734          + STOP      LEN
         322+10 2684          + R ADD     OPNCONST     MAKE EOR RECORD A NEW ADDED OPNCONST CONSTANT LOOP POOL RECORD
         323+12 1528          + STORE     OP           WILL CONTAINS THE LOOP CONSTANTS AS MC INSTR
         324+10 2733          + R ADD     SVSTEPN                        STEPN = REGCSTEP
         325+ 9 2668          + ADD       ONE                            FACTN = PRGSTEPN FIRST STEPN OF PROGRAM AFTER INITIAL CALL/ID/FOR (IE STEP-1 IS CALL/ID/FOR INSTR) 
         326+12 2733          + STORE     SVSTEPN
         327+12 2700          + STORE     REGCSTEP     THIS IS THE STEPN WHERE THE REG.C SITS
         328+12 1537          + STORE     STEPN
         329+10 2701          + R ADD     PRGSTEPN     FIRST STEPN OF PROGRAM AFTER INITIAL CALL/ID/FOR (IE STEP-1 IS CALL/ID/FOR INSTR) 
         330+12 1538          + STORE     FACTN
         331+10 2666          + R ADD     ZERO
         332+12 2732          + STORE     SVNINST
         333+10  333          + R ADD     *            CLEAR CARD BUFFER
         334+ 1   53          + TR        CLRBUF 
         335+15 1526          + LOAD MQ   REGION
         336+10  336          + R ADD     *            
         337+ 1   61          + TR        PRTALF
         338+ 0    1          + STOP      0001         AT COL 1
         339+10  339          + R ADD     *            PRINT STRINGZ
         340+ 1   59          + TR        PRTSTR
         341+ 0 2827          + STOP      HALTTXT      "HALT"
         342+ 0    8          + STOP      0008         COLUMN WHERE TXT STARTS
         343+15 2672          + LOAD MQ   D10          PRINT '0'
         344+10  344          + R ADD     *
         345+ 1   65          + TR        PRTCHR
         346+ 0   15          + STOP      0015         COLUMN WHERE CHR IS
         347+10 2666          + R ADD     ZERO         COPY LEFT SIDE OF SOURCE CODE CARD IMAGE
         348+13  351          + STORE A   DPCC1        AT 0..46 TO PACTSCR
         349+10  363          + R ADD     DPCC2
         350+13  352          + STORE A   DPCC 
         351-10    0 DPCC1    - R ADD     /   /
         352-12    0 DPCC     - STORE     /   /
         353+10  352          + R ADD     DPCC
         354+ 5 2669          + SUB       TWO
         355+13  352          + STORE A   DPCC
         356+10  351          + R ADD     DPCC1
         357+ 5 2671          + SUB       D4
         358+13  351          + STORE A   DPCC1
         359+ 5  362          + SUB       DPCCE
         360+ 4  363          + TR 0      DPCC2
         361+ 1  351          + TR        DPCC1 
         362-10   48 DPCCE    - R ADD     0048         LAST LOCATION TO COPY FROM 
         363+ 8 1502 DPCC2    + NOOP      PACTSRC      PACTSRC = FIRST LOCATION TO COPY TO 
         364+10  364          + R ADD     *            WRITE COMPACT CODE ON TAPEOUT
         365+ 1  277          + TR        WRCC         WITH LOG
         366+10 2666          + R ADD     ZERO         REVERT CHANGES TO EOR RECORD
         367+12 1528          + STORE     OP
         368+12 1544          + STORE     NINST
         369+12 2732          + STORE     SVNINST
         370+10 1537          + R ADD     STEPN
         371+ 9 2668          + ADD       ONE
         372+12 1537          + STORE     STEPN
         373+10  373          + R ADD     *
         374+ 1   81          + TR        CLMEM        
         375+ 0 1502          + STOP      PACTSRC      
         376+ 0 2677          + STOP      D24
         377+10  377 SVEOR    + R ADD     *            WRITE NEW EOR RECORD
         378+ 1  277          + TR        WRCC         
         379+ 1    0 WREOREX  + TR        /   /
         380+ 9 2669 WREORTBL + ADD       TWO          SAVE IN TAPEOUTR THE POPULATED TABLES
         381+13  411          + STORE A   WREORTEX     TO BE USED BY PASS 2
         382+10 2127          + R ADD     NIDXS        MAKE NAME OF ALL INDEXES NEGATIVE
         383+12 1747          + STORE     N            BEFORE SAVING THEM TO TAPE
         384+10  399          + R ADD     TIDXNAAD
         385+13  392          + STORE A   SVIXRD
         386+13  393          + STORE A   SVIXWR
         387+10 1747 SVIXLO   + R ADD     N
         388+ 4  400          + TR 0      SVIXEND
         389+ 5 2668          + SUB       ONE         
         390+12 1747          + STORE     N
         391+10 2666          + R ADD     ZERO
         392+ 7    0 SVIXRD   + SUB AB    /   /
         393+12    0 SVIXWR   + STORE     /   / 
         394+10  392          + R ADD     SVIXRD
         395+ 9 2668          + ADD       ONE
         396+13  392          + STORE A   SVIXRD
         397+13  393          + STORE A   SVIXWR
         398+ 1  387          + TR        SVIXLO
         399+ 0 2128 TIDXNAAD + STOP      TIDXNAME
         400+ 8    0 SVIXEND  + NOOP      0000
         401+ 8 1954 SVTA1    + NOOP      MAXNPAR      FIRST VAR OF TABLES TO SAVE TO TAPE
         402+ 8 2264 SVTA2    + NOOP      MAXNREFS     VAR JUST AFTER TABLES, NOT TO SAVE 
         403+10  402          + R ADD     SVTA2
         404+ 5  401          + SUB       SVTA1        SAVE AT ONCE TPAR TABLES ( 2 + 5*34 HALF WORDS )
         405+12 1747          + STORE     N            AND TIDX TABLES ( 2 + 4*34 HALF WORDS )
         406+10  406          + R ADD     *                              = 155 FULLWORDS ON TAPE
         407+ 1   69          + TR        WRTAPE       
         408+ 0  259          + STOP      TAPEOUTR     
         409+ 0 1954          + STOP      MAXNPAR      BUF TO WRITE TO TAPE
         410+ 0 1747          + STOP      N            LEN
         411+ 1    0 WREORTEX + TR        /   /
         412+ 9 2669 ERROR    + ADD       TWO
         413+13  414          + STORE A   ERRP1
         414+10    0 ERRP1    + R ADD     /   /
         415+13  421          + STORE A   ERRSTRZ      SAVE ADDR OF ERROR TXT MESSAGE
         416+10  416          + R ADD     *            PRINT USER PROGRAM SOURCE CODE CARD JUST PROCESSED
         417+ 1   57          + TR        PRINTCRD
         418+10  418          + R ADD     *
         419+ 1   55          + TR        PRTNLINE     
         420+ 0  101          + STOP      0101         STRINGZ AT COL 1
         421+ 0    0 ERRSTRZ  + STOP      /   /        ERROR MESSAGE
         422+ 0    0          + STOP      0000         END OF LINE
         423+ 0  171          + STOP      READSTEP     IF USER PRESS STARTS, PROGRAM RESUMES PROCESSING NEXT SOURCE CODE STEP 
         424+ 8    0 IDCALL   + NOOP      0000
         425+10 1534          + R ADD     NUM
         426+ 4  428          + TR 0      AP0A
         427+ 1  439          + TR        PARAMNUM     TR PARAM IS A CONSTANT
         428+10 1539 AP0A     + R ADD     FACTREG
         429+ 5 2680          + SUB       D34          'V'
         430+ 4  434          + TR 0      AP0B
         431+10  431          + R ADD     *
         432+ 1  412          + TR        ERROR         
         433+ 0 2812          + STOP      ERRNOVAR     ERROR: ID PARAM MUST BE A VAR (CANNOT BE A TEMP/PERISHABLE VAR)
         434+10 1540 AP0B     + R ADD     S1N
         435+ 4  448          + TR 0      PARAMSCA     TR PARAM IS A SCALAR VAR
         436+10 1541          + R ADD     S2N
         437+ 4  454          + TR 0      PARAMVEC     TR PARAM IS A VECTOR
         438+ 1  452          + TR        PARAMMAT     TR PARAM IS A MATRIX
         439+ 6 2668 PARAMNUM + R SUB     ONE          NUMERIC CONSTANT PARAM: TPARTYPE=-1
         440+12 2731          + STORE     PTYPE
         441+10 2688          + R ADD     D4096
         442+12 2730          + STORE     PNAME        TPARNAME=4096
         443+10 2666          + R ADD     ZERO         
         444+12 1751          + STORE     DATA2        TPARLOC1=0
         445+10 1534          + R ADD     NUM
         446+12 1750          + STORE     DATA         TPARFACT=number
         447+ 1  465          + TR        ADDPARAM
         448+10 2666 PARAMSCA + R ADD     ZERO         SCALAR VAR PARAM: TPARTYPE=0
         449+12 2731          + STORE     PTYPE        NOTE THAT SCALAR -> NO D1 VALUE TO SEND AS PARAM
         450+12 1751          + STORE     DATA2        -> TPARLOC1=0
         451+ 1  461          + TR        PARAMVAR
         452+10 2669 PARAMMAT + R ADD     TWO          VECTOR MATRIX: TPARTYPE=2
         453+ 1  455          + TR        AP1
         454+10 2668 PARAMVEC + R ADD     ONE          VECTOR PARAM: TPARTYPE=1
         455+12 2731 AP1      + STORE     PTYPE        
         456+10  456          + R ADD     *
         457+ 1 1178          + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
         458+ 0 2830          + STOP      REG.A        '+H  A 0000' -> ENTRY IN CONTANT POOL THAT CONTAINS THE D1 DIMENSION 
         459+ 0    0          + STOP      0000         PASSED AS PARAM. "STOP 0000" -> CREATE A NEW ENTRY WITH ZERO VALUE
         460+12 1751          + STORE     DATA2        TPARLOC1=ENTRY IN POOL THAT CONTAINS D1 PASSED AS PARAM (0000=FIRST ENTRY)
         461+10 1538 PARAMVAR + R ADD     FACTN        THE NAME (SHOULD BE UNIQUE) OF THE PARAM IS THE VAR ADDRESS
         462+12 2730          + STORE     PNAME
         463+12 1750          + STORE     DATA         TPARFACT=FACTN -> THE ADDR OF MATRIX/VECTOR (REGION IS ALLWAYS 'V')
         464+ 1  465          + TR        ADDPARAM
         465+10  465 ADDPARAM + R ADD     *
         466+ 1  468          + TR        ADDPAR
         467+ 1  233          + TR        NEXT    
         468+ 9 2669 ADDPAR   + ADD       TWO
         469+13  503          + STORE A   ADDPAREX
         470+10 2730          + R ADD     PNAME
         471+ 5 2688          + SUB       D4096
         472+ 4  485          + TR 0      AP2          TR AS PARAM IS NUMERIC
         473+10  473          + R ADD     *
         474+ 1   79          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         475+ 0 1956          + STOP      TPARNAME     ... INDEX NAME TABLE
         476+ 0 1955          + STOP      NPARAMS      ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
         477+ 0 2730          + STOP      PNAME        ... THE VALUE TO FIND 
         478+ 4  485          + TR 0      AP2          TR AS PNAME NOT USED AS PARAM
         479+10  479          + R ADD     *
         480+ 1  412          + TR        ERROR
         481+ 0 2799          + STOP      ERRDPARS     ERROR: DUPLICATED PARAMETER NAME
         482+10  482 ERROVPAR + R ADD     *
         483+ 1  412          + TR        ERROR
         484+ 0 2804          + STOP      ERROVPAS     ERROR: TOO MANY PARAMS DEFINED (MAX 34)
         485+10 1955 AP2      + R ADD     NPARAMS      CREATE A NEW CALLED REGION PARAMETER ENTRY
         486+ 5 1954          + SUB       MAXNPAR
         487+ 4  482          + TR 0      ERROVPAR
         488+10 1955          + R ADD     NPARAMS
         489+ 9 2668          + ADD       ONE
         490+12 1955          + STORE     NPARAMS
         491+12 2708          + STORE     NPAR
         492+10  492          + R ADD     *            STORE IN TABLES
         493+ 1   73          + TR        EQTBL2
         494+ 0 1956          + STOP      TPARNAME     
         495+ 0 1954          + STOP      MAXNPAR
         496+ 0 2708          + STOP      NPAR
         497+ 0 2730          + STOP      PNAME        TPARNAME[NPAR] = 
         498+ 0 1537          + STOP      STEPN        TPARSTEP[NPAR] =
         499+ 0 2731          + STOP      PTYPE        TPARTYPE[NPAR] = 
         500+ 0 1750          + STOP      DATA         TPARFACT[NPAR] = 
         501+ 0 1751          + STOP      DATA2        TPARLOC1[NPAR] = 
         502+ 0    0          + STOP      0000
         503+ 1    0 ADDPAREX + TR        /   /
         504+10 1529 FORCALL  + R ADD     FACT
         505+ 3  530          + TR +      FC1          IF >=0 -> TR AS NOT AN INDEX (IS A NUM)
         506+10 1539          + R ADD     FACTREG
         507+ 5 2680          + SUB       D34          'V'
         508+ 3  530          + TR +      FC1          IF ='V' -> TR AS NOT AN INDEX (IS A VAR)
         509+10 1530          + R ADD     S1
         510+ 4 1157          + TR 0      ERRNDIX1     MISSING LOOP START PLACEHOLDER
         511+10 1531          + R ADD     S2
         512+ 4 1160          + TR 0      ERRNDIX2     MISSING LOOP END PLACEHOLDER
         513+ 6 2669          + R SUB     TWO          INDEX LIMITS PARAM: TPARTYPE=-2
         514+12 2731          + STORE     PTYPE        
         515+10 1529          + R ADD     FACT         TPARNAME=THE BASE48 NAME OF INDEX
         516+12 2730          + STORE     PNAME
         517+10  517          + R ADD     *
         518+ 1 1178          + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
         519+ 0 2830          + STOP      REG.A        '+H  A 0000' -> ENTRY IN CONTANT POOL THAT CONTAINS THE LOOP START VALUE PASSED AS PARAM
         520+ 0    0          + STOP      0000         0000 -> CREATE A NEW ENTRY WITH ZERO VALUE
         521+12 1749          + STORE     VAL          TPARLOC1=THE ENTRY IN POOL THAT CONTAINS LOOP START VALUE PASSED AS PARAM (0000=FIRST ENTRY)
         522+10  522          + R ADD     *
         523+ 1 1178          + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
         524+ 0 2830          + STOP      REG.A        '+H  A 0000' -> ENTRY IN CONTANT POOL THAT CONTAINS THE LOOP END VALUE PASSED AS PARAM
         525+ 0    0          + STOP      0000         0000 -> CREATE A NEW ENTRY WITH ZERO VALUE
         526+12 1751          + STORE     DATA2        TPARLOC1=THE ENTRY IN POOL THAT CONTAINS LOOP END VALUE PASSED AS PARAM (0000=FIRST ENTRY)
         527+10 1749          + R ADD     VAL
         528+12 1750          + STORE     DATA         TPARFACT= THE LOOP START VALUE PASSED AS PARAM
         529+ 1  465          + TR        ADDPARAM
         530+10  530 FC1      + R ADD     *
         531+ 1  550          + TR        ADDFORPA
         532+ 0 1529          + STOP      FACT         IF FACT is var -> <0 -> type=-3 scalar passed by value
         533+ 0 1538          + STOP      FACTN                   num -> =0 -> type=-1
         534+ 0 1534          + STOP      NUM
         535+10 1530          + R ADD     S1
         536+ 4  233          + TR 0      NEXT         NO MORE PARAMS IN "FOR" INSTR
         537+10  537          + R ADD     *
         538+ 1  550          + TR        ADDFORPA
         539+ 0 1530          + STOP      S1           IF S1 is var -> <0 -> type=-3 scalar passed by value
         540+ 0 1540          + STOP      S1N                   num -> >0 -> type=-1
         541+ 0 1530          + STOP      S1
         542+10 1531          + R ADD     S2
         543+ 4  233          + TR 0      NEXT         NO MORE PARAMS IN "FOR" INSTR
         544+10  544          + R ADD     *
         545+ 1  550          + TR        ADDFORPA
         546+ 0 1531          + STOP      S2           IF S2 is var -> <0 -> type=-3 scalar passed by value
         547+ 0 1541          + STOP      S2N                   num -> >0 -> type=-1
         548+ 0 1531          + STOP      S2
         549+ 1  233          + TR        NEXT    
         550+ 9 2669 ADDFORPA + ADD       TWO          ADD PARAM USING FOR DATA
         551+13  566          + STORE A   AF1
         552+ 9 2668          + ADD       ONE
         553+13  558          + STORE A   AF2
         554+ 9 2668          + ADD       ONE
         555+13  562          + STORE A   AF3
         556+ 9 2668          + ADD       ONE
         557+13  587          + STORE A   ADDFOREX
         558+10    0 AF2      + R ADD     /   /        PARAM: DATA TO STORE IN TPARFACT IF SCALAR PASSED BY VALUE
         559+13  560          + STORE A   AF2A
         560+10    0 AF2A     + R ADD     /   /        DERREFERENCE TO GET VNNNN PACT VAR ADDR
         561+12 2718          + STORE     RADDR
         562+10    0 AF3      + R ADD     /   /        PARAM: DATA TO STORE IN TPARFACT IF NUM CONST PARAM
         563+13  564          + STORE A   AF3A
         564+10    0 AF3A     + R ADD     /   /        DERREFERENCE TO GET CONST
         565+12 1747          + STORE     N
         566+10    0 AF1      + R ADD     /   /        PARAM: NAME >0 -> NUM CONST, <0 -> SCALAR VAR PASSED BY VALUE
         567+13  568          + STORE A   AF1A
         568+10    0 AF1A     + R ADD     /   /        DERREFERENCE TO GET CONST
         569+12 2730          + STORE     PNAME
         570+ 3  578          + TR +      AF4          TR IF PARAM IS NUMERIC CONST
         571+ 6 2670          + R SUB     D3           PARAM IS A SCALAR PASSED BY VALUE : TPARTYPE=-3
         572+12 2731          + STORE     PTYPE
         573+10 2666          + R ADD     ZERO         
         574+12 1751          + STORE     DATA2        TPARLOC1=0 
         575+10 2718          + R ADD     RADDR
         576+12 1750          + STORE     DATA        
         577+ 1  585          + TR        AF5         
         578+ 6 2668 AF4      + R SUB     ONE          NUMERIC CONSTANT PARAM: TPARTYPE=-1
         579+12 2731          + STORE     PTYPE
         580+10 2688          + R ADD     D4096        TPARNAME=4096
         581+12 2730          + STORE     PNAME
         582+12 1751          + STORE     DATA2        TPARLOC1=0
         583+10 1747          + R ADD     N
         584+12 1750          + STORE     DATA        
         585+10  585 AF5      + R ADD     *
         586+ 1  468          + TR        ADDPAR
         587+ 1    0 ADDFOREX + TR        /   /
         588+10 1540 USESET   + R ADD     S1N
         589+ 3  658          + TR +      ERRNOIDX     ERROR: MISSING INDEX
         590+10 1541          + R ADD     S2N
         591+ 4  661          + TR 0      ERRNOIDV     ERROR: MISSING INDEX VALUE
         592+10  592          + R ADD     *
         593+ 1   79          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         594+ 0 2128          + STOP      TIDXNAME     ... INDEX NAME TABLE
         595+ 0 2127          + STOP      NIDXS        ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
         596+ 0 1540          + STOP      S1N          ... THE VALUE TO FIND 
         597+ 4  610          + TR 0      SE1          IF NOT FOUND TR TO CREATE A NEW ONE
         598+12 2702          + STORE     NIDX
         599+10 1528          + R ADD     OP           INDEX ALREADY DEFINED. 
         600+ 5 2676          + SUB       OPUSE        IF OP=USE -> JUST PROCEED TO NEXT STEP
         601+ 4  233          + TR 0      NEXT    
         602+10  602          + R ADD     *            
         603+ 1   75          + TR        READTBL      IF VAL > 0 IT IS ALSO ACTIVE
         604+ 0 2230          + STOP      TIDXSETN   
         605+ 0 2702          + STOP      NIDX
         606+ 0 1749          + STOP      VAL          = TIDXSETN[NIDX] 
         607+10 1749          + R ADD     VAL
         608+ 4  637          + TR 0      SE2          INDEX IS ONLY DEFINED. TR TO MAKE IT ACTIVE
         609+ 1  664          + TR        ERRDSET      ERROR: INDEX ALREADY ACTIVE -> DUPLICATED SET ON INDEX
         610+ 6 1540 SE1      + R SUB     S1N          CHECK IF THIS INDEX NAME HAS BEEN ALREADY USED IN A 
         611+12 1749          + STORE     VAL          PREVIOUS SET-TEST LOOP. IF SO, THE INDEX IS NOT DEFINED (AND NAME HAS
         612+10  612          + R ADD     *
         613+ 1   79          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         614+ 0 2128          + STOP      TIDXNAME     ... INDEX NAME TABLE
         615+ 0 2127          + STOP      NIDXS        ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
         616+ 0 1749          + STOP      VAL          ... THE VALUE TO FIND 
         617+ 4  620          + TR 0      NEWIDX       TR BECAUSE IT IS FIRST TIME S1N INDEX IS SET
         618+12 2702          + STORE     NIDX         S1N INDEX IS NOT ACTIVE, IT HAS BEEN USED IN A PREVIOUS SET-TEST LOOP
         619+ 1  637          + TR        SE2          TR TO RE-ACTIVATE IT BY MAKING ITS NAME SIGN NEGATIVE AGAIN
         620+10 2127 NEWIDX   + R ADD     NIDXS        ADD A NEW INDEX 
         621+ 5 2126          + SUB       MAXNIDXS
         622+ 4  667          + TR 0      ERRIDXOV     ERROR: TOO MANY INDEXES (MAX 34)
         623+10 2127          + R ADD     NIDXS        NUMBER OF INDEXES IN THIS REGION
         624+ 9 2668          + ADD       ONE
         625+12 2127          + STORE     NIDXS
         626+12 2702          + STORE     NIDX
         627+10  627          + R ADD     *
         628+ 1 1178          + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
         629+ 0 2830          + STOP      REG.A        '+H  A 0000' -> INITIAL VALUE FOR INDEX 
         630+ 0    0          + STOP      0000         0000 -> CREATE A NEW ENTRY WITH ZERO VALUE
         631+12 2726          + STORE     ECONSTMK     SAVE THE ENTRY IN POOL THAT CONTAINS THE CREATED CONSTANT (0000=FIRST ENTRY)
         632+10  632          + R ADD     *            SET NEW INDEX VALUE
         633+ 1   71          + TR        EQTBL
         634+ 0 2162          + STOP      TIDXLOC
         635+ 0 2702          + STOP      NIDX
         636+ 0 2726          + STOP      ECONSTMK     TIDXLOC [NIDX] = ECONSTMK   LOCATION OF INDEX VALUE (NOT USED FOR ADDRESS INDEX, BUT CREATED ANYWAY)
         637+10  637 SE2      + R ADD     *            SET THE NAME OF INDEX 
         638+ 1   71          + TR        EQTBL   
         639+ 0 2128          + STOP      TIDXNAME
         640+ 0 2702          + STOP      NIDX        
         641+ 0 1540          + STOP      S1N          TIDXNAME[NIDX] = S1N = ALFA NAME OF INDEX (<0)
         642+10  642          + R ADD     *            SET INDEX TYPE AS "ADDRESS INDEX" 
         643+ 1   71          + TR        EQTBL
         644+ 0 2196          + STOP      TIDXTYPE
         645+ 0 2702          + STOP      NIDX
         646+ 0 2666          + STOP      ZERO         TIDXTYPE[NIDX] = 0 -> "ADDRESS INDEX" 
         647+10 1528          + R ADD     OP           
         648+ 5 2676          + SUB       OPUSE        IF OP=USE -> TIDXSETN[NIDX] = 0
         649+ 4  651          + TR 0      SE3          IF OP=SET -> TIDXSETN[NIDX] = STEPN
         650+10 1537          + R ADD     STEPN
         651+12 1749 SE3      + STORE     VAL
         652+10  652          + R ADD     *            SAVE STEPN OF "SET" INSTR: IS THE START OF LOOP
         653+ 1   71          + TR        EQTBL        ELSE IS A "USE" INSTR THUS SETN=0
         654+ 0 2230          + STOP      TIDXSETN
         655+ 0 2702          + STOP      NIDX      
         656+ 0 1749          + STOP      VAL          TIDXSETN[NIDX] = STEPN OF CURRENT PACT "SET" INSTR / ZERO FOT "USE" INSTR
         657+ 1  233          + TR        NEXT    
         658+10  658 ERRNOIDX + R ADD     *
         659+ 1  412          + TR        ERROR
         660+ 0 2741          + STOP      ERRNOIXS     ERROR: MISSING INDEX
         661+10  661 ERRNOIDV + R ADD     *
         662+ 1  412          + TR        ERROR
         663+ 0 2745          + STOP      ERRNOIVS     ERROR: MISSING INDEX VALUE
         664+10  664 ERRDSET  + R ADD     *
         665+ 1  412          + TR        ERROR
         666+ 0 2749          + STOP      ERRDSETS     ERROR: DUPLICATED SET ON SAME INDEX
         667+10  667 ERRIDXOV + R ADD     *
         668+ 1  412          + TR        ERROR
         669+ 0 2753          + STOP      ERRIXOVS     ERROR: TOO MANY INDEXS (MAX 34)
         670+10  670 ERRNDIDX + R ADD     *
         671+ 1  412          + TR        ERROR
         672+ 0 2760          + STOP      ERRNDIDS     ERROR: INDEX NOT ACTIVE (MISSING SET INSTR FOR THIS INDEX)
         673+10  673 ERRBADTD + R ADD     *
         674+ 1  412          + TR        ERROR
         675+ 0 2767          + STOP      ERRBADTS     ERROR: BAD TEST DESTINATION IN FACTOR. SHOULD BE BLANK OR A STEP NUMBER         
         676+10  676 ERROVLOC + R ADD     *
         677+ 1  412          + TR        ERROR
         678+ 0 2771          + STOP      ERROVLOS     ERROR: TOO MANY LOOP CONSTANTS IN POOL         
         679+10 1540 TEST     + R ADD     S1N
         680+ 3  658          + TR +      ERRNOIDX     ERROR: MISSING INDEX
         681+10 1541          + R ADD     S2N
         682+ 4  661          + TR 0      ERRNOIDV     ERROR: MISSING INDEX VALUE
         683+10  683          + R ADD     *            SET VARIABLES FOR START OF LOOP STEPN TO TRANSFER TO 
         684+ 1  702          + TR        TSETN                      INDEX USED IN TEST, END OF LOOP VALUE
         685+10  685          + R ADD     *            GENERATE INST TO INCREMENT VECTOR/MATRIX REFERENCES THAT USES NIDX
         686+ 1  882          + TR        TMATVEC 
         687+10  687          + R ADD     *            GENERATE MC INSTS TO TEST END OF LOOP CONDITION
         688+ 1  737          + TR        TENDLOOP
         689+ 6 1540          + R SUB     S1N          MAKE INDEX NAME POSITIVE TO SIGNAL IT IS ALREADY PROCESSED.
         690+12 1749          + STORE     VAL          THE DATA OF INDEX STILL IN TABLE, BUT AS NAME IS POSITIVE
         691+10  691          + R ADD     *            
         692+ 1   71          + TR        EQTBL
         693+ 0 2128          + STOP      TIDXNAME     
         694+ 0 2702          + STOP      NIDX
         695+ 0 1749          + STOP      VAL          TIDXNAME[NIDX] = VAL = -S1N
         696+10  696          + R ADD     *            CLEAR SETN FIELD AS LOOP HAS FINISHED
         697+ 1   71          + TR        EQTBL        
         698+ 0 2230          + STOP      TIDXSETN
         699+ 0 2702          + STOP      NIDX      
         700+ 0 2666          + STOP      ZERO         TIDXSETN[NIDX] = ZERO 
         701+ 1  233          + TR        NEXT         SAVE GENERATED CODE, THEN PROCEED WITH NEXT INSTR
         702+ 9 2669 TSETN    + ADD       TWO          SET VARIABLE SETN = THE START OF LOOP STEPN, 
         703+13  736          + STORE A   TSETEX                    NIDX = THE INDEX USED IN "TEST" INSTR
         704+10  704          + R ADD     *
         705+ 1   79          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         706+ 0 2128          + STOP      TIDXNAME     ... INDEX NAME TABLE
         707+ 0 2127          + STOP      NIDXS        ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
         708+ 0 1540          + STOP      S1N          ... THE VALUE TO FIND 
         709+ 4 1157          + TR 0      ERRNDIX1     ERROR: INDEX NOT DEFINED
         710+12 2702          + STORE     NIDX
         711+10  711          + R ADD     *            READ FROM TIDX TABLES
         712+ 1   77          + TR        READTBL2
         713+ 0 2162          + STOP      TIDXLOC      
         714+ 0 2126          + STOP      MAXNIDXS
         715+ 0 2702          + STOP      NIDX
         716+ 0 2705          + STOP      ECONSTIX     = TIDXLOC [NIDX] 
         717+ 0 1749          + STOP      VAL          = TIDXTYPE[NIDX] 
         718+ 0 2704          + STOP      SETN         = TIDXSETN[NIDX] 
         719+ 0    0          + STOP      0000
         720+10 1749          + R ADD     VAL          TYPE OF INDEX: 0="ADDRESS TYPE", 1="COUNT TYPE"
         721+ 5 2668          + SUB       ONE
         722+ 3  725          + TR +      TSE2
         723+10 2666          + R ADD     ZERO
         724+12 2705          + STORE     ECONSTIX     CLEAR ECONSTIX AS INDEX TYPE IS "ADDRESS TYPE"
         725+10 2704 TSE2     + R ADD     SETN
         726+ 4  670          + TR 0      ERRNDIDX     ERROR: INDEX NOT ACTIVE (MISSING SET INSTR FOR THIS INDEX)
         727+ 9 2668          + ADD       ONE
         728+12 2704          + STORE     SETN         TEST WILL LOOP TO STEPN INMEDIATELLY FOLLOWING START OF LOOP "SET" PACT INSTR 
         729+10 1529          + R ADD     FACT
         730+ 4  735          + TR 0      TSE1         TR IF NO EXPLICIT TEST DESTINATION -> KEEP SETN AS START OF LOOP
         731+ 3  733          + TR +      TSE0
         732+ 1  673          + TR        ERRBADTD     ERROR: BAD TEST DESTINATION IN FACTOR. SHOULD BE BLANK OR A STEP NUMBER
         733+10 1538 TSE0     + R ADD     FACTN        IF "TEST" INST HAS AN EXPLICIT DESTINATION (FACTN=DESTINATION STEPN), USE IT INSTEAD OF "SET" STEPN
         734+12 2704          + STORE     SETN
         735+ 8    0 TSE1     + NOOP      0000         HERE SETN IS THE LOOP START STEPN. 
         736+ 1    0 TSETEX   + TR        /   /
         737+ 9 2669 TENDLOOP + ADD       TWO          GENERATE INSTR TO INCR LOOP INDEX AND TEST END OF LOOP CONDITION
         738+13  881          + STORE A   TENDLOEX
         739+ 6 2668          + R SUB     ONE          INIT TO -1 TO SIGNAL NOT USED  
         740+12 2707          + STORE     ECONSEND     = ADDR IN REG C OF END OF LOOP VALUE. 
         741+10  741          + R ADD     *            AN INDEX IS SEARCHED IN PARAMETERS TABLE BY ITS NAME
         742+ 1   79          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         743+ 0 1956          + STOP      TPARNAME     ... PARAMETERS NAME TABLE
         744+ 0 1955          + STOP      NPARAMS      ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NPARAMS
         745+ 0 1540          + STOP      S1N          ... THE VALUE TO FIND 
         746+ 4  763          + TR 0      TE2          =0 -> NO PARAM MATCHES THE INDEX NAME USED IN "TEST" INSTR
         747+12 2708          + STORE     NPAR
         748+10  748          + R ADD     *            READ FROM TPARAMS TABLES
         749+ 1   75          + TR        READTBL
         750+ 0 2024          + STOP      TPARTYPE
         751+ 0 2708          + STOP      NPAR
         752+ 0 1749          + STOP      VAL          = TPARTYPE[NPAR] 
         753+10 1749          + R ADD     VAL          GET PARAM TYPE
         754+ 9 2669          + ADD       TWO          =-2 FOR "FOR I A B INDEX LOOP START/END"?
         755+ 4  757          + TR 0      TE1          YES -> TR
         756+ 1  763          + TR        TE2          NOT AN INDEX LOOP START/END -> CONTINUE
         757+10  757 TE1      + R ADD     *            READ FROM TPARAMS TABLES
         758+ 1   75          + TR        READTBL
         759+ 0 2092          + STOP      TPARLOC1     AS TYPE=-2 (PARAM IS INDEX LOOP START/END), LOC1=ENTRY IN LOOP CONSTANTS POOL THAT CONTAINS THE END OF LOOP VALUE
         760+ 0 2708          + STOP      NPAR
         761+ 0 2707          + STOP      ECONSEND     = TPARLOC1[NPAR] = ADDR IN REGION C OF END OF LOOP VALUE
         762+ 1  804          + TR        TECOUNT      TR AS END OF LOOP IS A PARAM STORED IN CONST POOL (ECONSEND)
         763+ 6 1541 TE2      + R SUB     S2N
         764+ 3  804          + TR +      TECOUNT      TR AS END OF LOOP IS A VAR OR AN INDEX 
         765+10 2711          + R ADD     NLASTREF     LAST ADDR REFERENCE USED
         766+ 4  804          + TR 0      TECOUNT      TR AS THERE IS NO A LAST REFERENCE OF VECTOR INCR TO BE USED AS END OF LOOP 
         767+10 2705          + R ADD     ECONSTIX     ECONSTIX =0 IF INDEX IS "ADDRESS TYPE", >0 IF INDEX IS "COUNT TYPE", 
         768+ 4  770          + TR 0      TEADDR       IF INDEX IS ADDRESS TYPE TR TO PERFORM END OF LOOP CHECK ON ADDRESS OF LAST VECTOR INCREMENTED
         769+ 1  804          + TR        TECOUNT      TR AS INDEX IS COUNT TYPE
         770+ 8    0 TEADDR   + NOOP      0000         HERE END OF LOOP IS A COMPILE TIME CONSTANT VALUE (S2N) 
         771+10 2666          + R ADD     ZERO
         772+12 1532          + STORE     QR           SET QR=0 IN CC RECORD TO SIGNAL INDEX IS "ADDRESS TYPE"
         773+10  773          + R ADD     *            READ SEVERAL VALUES FROM TREF TABLES
         774+ 1   77          + TR        READTBL2
         775+ 0 2516          + STOP      TREFOP       READ THE OP/ADDR OF VARIABLE REFERENCE
         776+ 0 2264          + STOP      MAXNREFS
         777+ 0 2711          + STOP      NLASTREF     
         778+ 0 2717          + STOP      ROP          = TREFOP  [NLASTREF]   THE OPCODE THAT APPLIES ON VECT/MATRIX
         779+ 0 2718          + STOP      RADDR        = TREFADDR[NLASTREF]   THE ADDR OF VECT/MATRIX
         780+ 0    0          + STOP      0000
         781+10  791          + R ADD     TE3          SET THE REGION REG.V IN ROP
         782+13 2717          + STORE A   ROP
         783+10 2717          + R ADD     ROP
         784+12  791          + STORE     TE3
         785+10 2718          + R ADD     RADDR        COMPUTE END OF LOOP ADDR = VAR ADDR + (END OF LOOP CONSTANT - 1)*2 + 2
         786+ 9 1541          + ADD       S2N          LAST +2 IS NEEDED BECAUSE TEST IS DONE AFTER INCREMENTING VAR ADDR
         787+ 9 1541          + ADD       S2N
         788+12 2718          + STORE     RADDR
         789+10  789          + R ADD     *
         790+ 1 1178          + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
         791+ 0 2832 TE3      + STOP      REG.V        '+RA  V 0002' -> THE MC INST THAT ACCESS THE LAST VECTOR INCREMENTED ON LOOP
         792+ 0 2718          + STOP      RADDR
         793+12 2706          + STORE     ECONST       SAVE THE ENTRY IN CONSTANTS POOL THAT CONTAINS THE CREATED END OF LOOP VALUE (0000=FIRST ENTRY)
         794+10 2704          + R ADD     SETN         SET IN TRANFER THE STEPN OF START OF LOOP ALREADT COMPUTED
         795+12 2693          + STORE     TRANSFER     INN = addr of stepN given in var TRANSFER = stepN of reference, TRSTLOC = location in reference stepn machine code
         796+10 2668          + R ADD     ONE          CNN = location in region loop constants pool
         797+12 2694          + STORE     TRSTLOC
         798+10  798          + R ADD     *            GENERATE THE INSTRUCTIONS TO TEST ADDRESS TYPE LOOP END
         799+ 1 1248          + TR        GENINST     
         800+ 5 1003          + SUB       CNN          '+S  C econst'   substract the end of loop constant
         801+ 3 1002          + TR +      INN          '+TP I /  /'     if >=0 tr to start of loop
         802+ 0    0          + STOP      0000         END OF INSTR TABLE
         803+ 1  881          + TR        TENDLOEX     END OF LOOP TEST GENERATED
         804+ 8    0 TECOUNT  + NOOP      0000         HERE END OF LOOP IS A VALUE FOR COUNT INDEX (ECONSTIX). 
         805+10 2668          + R ADD     ONE
         806+12 1532          + STORE     QR           SET QR=1 IN CC RECORD TO SIGNAL INDEX IS "COUNT TYPE"
         807+10  807          + R ADD     *            
         808+ 1 1163          + TR        MAKEIDXC     MAKE INDEX TYPE "COUNT TYPE"
         809+ 0 2702          + STOP      NIDX
         810+10  810          + R ADD     *            READ FROM TIDX TABLES
         811+ 1   75          + TR        READTBL
         812+ 0 2162          + STOP      TIDXLOC      READ THE ENTRY IN LOOP CONSTANT POOLS THAT CONTAINS THE CURRENT INDEX VALUE
         813+ 0 2702          + STOP      NIDX
         814+ 0 2705          + STOP      ECONSTIX     = TIDXLOC [NIDX] 
         815+10 2705          + R ADD     ECONSTIX     
         816+12 2706          + STORE     ECONST
         817+10  817          + R ADD     *            GENERATE THE INSTRUCTIONS TO INCR INDEX
         818+ 1 1248          + TR        GENINST     
         819+10 1003          + R ADD     CNN          '+RA C econst'   is location of index value
         820+ 9 1004          + ADD       C01          '+S  C econst with value 1'  
         821+12 1003          + STORE     CNN          '+SA C econst'   save incremented index back
         822+ 0    0          + STOP      0000         END OF INSTR TABLE
         823+10 2707          + R ADD     ECONSEND
         824+ 3  831          + TR +      TEEPARAM     TR AS LOOP END VALUE IS A PARAM
         825+10 1541          + R ADD     S2N
         826+ 3  859          + TR +      TECONST      TR AS LOOP END VALUE IS A CONSTANT
         827+10 1539          + R ADD     FACTREG
         828+ 5 2680          + SUB       D34          'V'
         829+ 4  834          + TR 0      TEVAR        TR AS LOOP END IS A VARIABLE
         830+ 1  842          + TR        TEINDEX      TR AS LOOP END VALUE IS ANOTHER INDEX
         831+ 8    0 TEEPARAM + NOOP      0000         LOOP END VALUE PASSED AS PARAM (ECONSEND=nnnn) IN "FOR I A B" INSTR 
         832+10 2707          + R ADD     ECONSEND     GET THE LOOP POOL ENTRY THAT HAS THE LOOP END VALUE PASSED AS PARAM
         833+ 1  864          + TR        TE11
         834+ 8    0 TEVAR    + NOOP      0000         LOOP END IS A VARIABLE (FACTN=nnnn, FACTREG='V')
         835+10  835          + R ADD     *            GENERATE THE INSTRUCTIONS FOR ACC=END OF LOOP VALUE
         836+ 1 1248          + TR        GENINST     
         837+10 1001          + R ADD     CC.FACT      '+RA V nnnn'   is end of loop value 
         838+ 0    0          + STOP      0000         END OF INSTR TABLE
         839+10 1544          + R ADD     NINST        SAVE IN NINCR THE LOCATION INTO STEPN OF MC INSTR THAT ACCESS THE LOOP END
         840+12 1545          + STORE     NINCR        VARIABLE, SO IT CAN BE REPLACED LATER IF THIS VARIABLE IS A PARAM BY REFERENCE
         841+ 1  869          + TR        TESTOIDX     TR TO GENERATE INSTR TO TEST FOR END LOOP AND TR TO LOOP START
         842+ 8    0 TEINDEX  + NOOP      0000         LOOP END VALUE IS ANOTHER INDEX (S2N)
         843+10  843          + R ADD     *
         844+ 1   79          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         845+ 0 2128          + STOP      TIDXNAME     ... INDEX NAME TABLE
         846+ 0 2127          + STOP      NIDXS        ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
         847+ 0 1541          + STOP      S2N          ... THE VALUE TO FIND 
         848+ 4 1160          + TR 0      ERRNDIX2     ERROR: END OF LOOP INDEX NOT DEFINED (SHOULD BE DEFINED WITH SET, USE OR ID FOLLOWING A CALL)
         849+12 2703          + STORE     NIDX2
         850+10  850          + R ADD     *            
         851+ 1 1163          + TR        MAKEIDXC     MAKE INDEX TYPE "COUNT TYPE"
         852+ 0 2703          + STOP      NIDX2
         853+10  853          + R ADD     *            READ FROM TIDX TABLES
         854+ 1   75          + TR        READTBL
         855+ 0 2162          + STOP      TIDXLOC      READ THE ENTRY IN LOOP CONSTANT POOL THAT CONTAINS INDEX VALUE
         856+ 0 2703          + STOP      NIDX2
         857+ 0 2706          + STOP      ECONST       = TIDXLOC [NIDX2] 
         858+ 1  865          + TR        TE12
         859+ 8    0 TECONST  + NOOP      0000         LOOP END VALUE IS A COMPILE TIME CONSTANT VALUE (S2N=nnnn)  IN "TEST   I B" INSTR
         860+10  860          + R ADD     *
         861+ 1 1178          + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
         862+ 0 2830          + STOP      REG.A        '+H  A nnnn' -> CONSTANT VALUE = CONTENTS OF LOOP END VALUE VAR S2N
         863+ 0 1541          + STOP      S2N
         864+12 2706 TE11     + STORE     ECONST       SAVE THE ENTRY IN POOL THAT CONTAINS THE CREATED LOOP END VALUE (0000=FIRST ENTRY)
         865+10  865 TE12     + R ADD     *            GENERATE THE INSTRUCTIONS FOR ACC=END OF LOOP VALUE
         866+ 1 1248          + TR        GENINST     
         867+10 1003          + R ADD     CNN          '+RA C econst'   is end of loop value 
         868+ 0    0          + STOP      0000         END OF INSTR TABLE
         869+ 8    0 TESTOIDX + NOOP      0000         GENERATE INSTR TO TEST FOR END LOOP AND TR TO LOOP START
         870+10 2705          + R ADD     ECONSTIX     
         871+12 2706          + STORE     ECONST
         872+10 2704          + R ADD     SETN         STORE IN TRANSFER THE STEPN OF START OF LOOP ALREADY COMPUTED
         873+12 2693          + STORE     TRANSFER     INN = addr of stepN given in var TRANSFER = stepN of reference, TRSTLOC = location in reference stepn machine code
         874+10 2668          + R ADD     ONE          CNN = location in region loop constants pool
         875+12 2694          + STORE     TRSTLOC
         876+10  876          + R ADD     *            GENERATE THE INSTRUCTIONS FOR TEST AND TR TO START OF LOOP
         877+ 1 1248          + TR        GENINST     
         878+ 5 1003          + SUB       CNN          '+S  C econst'   is current index value 
         879+ 3 1002          + TR +      INN          '+TP I /  /'     if >=0 tr to start of loop
         880+ 0    0          + STOP      0000         END OF INSTR TABLE
         881+ 1    0 TENDLOEX + TR        /   /        END OF LOOP TEST GENERATED
         882+ 9 2669 TMATVEC  + ADD       TWO          GENERATE INST TO INCREMENT MATRIX/VECTORS REFERENCES THAT USES NIDX
         883+13  925          + STORE A   TMATEX
         884+10 2666          + R ADD     ZERO         EXAMINE ALL REFERENCES TO MATRIX/VECTOR USING INDEX S1N
         885+12 2709          + STORE     NREF
         886+12 2711          + STORE     NLASTREF     LAST ADDR REFERENCE USED
         887+10 2709 TMLOOP1  + R ADD     NREF
         888+ 5 2265          + SUB       NREFS
         889+ 4  925          + TR 0      TMATEX       ALL REFERENCES PROCESSED -> EXIT
         890+10 2709          + R ADD     NREF
         891+ 9 2668          + ADD       ONE
         892+12 2709          + STORE     NREF
         893+10  893          + R ADD     *            READ VALUES FROM TREF TABLES
         894+ 1   77          + TR        READTBL2
         895+ 0 2266          + STOP      TREFNAME     
         896+ 0 2264          + STOP      MAXNREFS
         897+ 0 2709          + STOP      NREF
         898+ 0 2712          + STOP      RNAME        = TREFNAME[NREF]   REFERENCE NAME
         899+ 0 2713          + STOP      RIDX1        = TREFIDX1[NREF]   <0 -> INDEX1 NAME, =0 -> NO INDEX,  >0 -> CONSTANT
         900+ 0 2714          + STOP      RIDX2        = TREFIDX2[NREF]   <0 -> INDEX2 NAME, =0 -> NO INDEX,  >0 -> CONSTANT
         901+ 0 2715          + STOP      RSTEPN       = TREFSTPN[NREF]   STEPN OF INSTR WHERE THE REFERENCE IS MADE
         902+ 0 2716          + STOP      RINCRN       = TREFINCN[NREF]   INCRN OF REFERENCE IN THIS STEP
         903+ 0 1749          + STOP      VAL          = TREFOP[NREF]   
         904+ 0 2718          + STOP      RADDR        = TREFADDR[NREF]   ADDRESS OF VARIABLE/MATRIX Vnnnn
         905+ 0    0          + STOP      0000
         906+10 2712          + R ADD     RNAME        IF NAME=0 -> REFERENCE ALREADY PROCESSED. SKIP IT
         907+ 4  887          + TR 0      TMLOOP1 
         908+10 2713          + R ADD     RIDX1
         909+ 5 1540          + SUB       S1N
         910+ 4  915          + TR 0      TM2          TR IF REFERENCE IS USING SAME 1ST INDEX AS IN "TEST" INSTR 
         911+10 2714          + R ADD     RIDX2
         912+ 5 1540          + SUB       S1N
         913+ 4  915          + TR 0      TM2          TR IF REFERENCE IS USING SAME 2ND INDEX AS IN "TEST" INSTR 
         914+ 1  887          + TR        TMLOOP1      TR TO TRY NEXT REFERENCE, AS THIS ONE IS NOT USING SAME INDEX AS IN "TEST" INSTR 
         915+10  915 TM2      + R ADD     *            GENERATE MC CODE TO INCR THE ADDR (AT RSTEN/RINCRN) OF REFERENCE (RNAME)
         916+ 1  926          + TR        GMATVEC      ACCORDING TO ITS INDEX VALUES (RIDX1, RIDX2)
         917+10  917          + R ADD     *            
         918+ 1   71          + TR        EQTBL
         919+ 0 2266          + STOP      TREFNAME     CLEAR THE NAME OF REFERENCE TO SIGNAL IT IS ALREADY PROCESSED -> BECOMES AN EMPTY ENTRY 
         920+ 0 2709          + STOP      NREF
         921+ 0 2666          + STOP      ZERO         TREFNAME[NREF] = 0
         922+10  922          + R ADD     *            EXAMINE REMAINING REFERENCES. GENERATE '+SA ' INSTR TO SAVE THE 
         923+ 1  984          + TR        SASAME       INCREMENTED ADDR ON REFERENCES TO SAME MATRIX WITH SAME INDEXES
         924+ 1  887          + TR        TMLOOP1      NOW TRY WITH NEXT MATRIX
         925+ 1    0 TMATEX   + TR        /   /
         926+ 9 2669 GMATVEC  + ADD       TWO          GENERATE MC CODE TO INCR THE ADDR (AT RSTEN/RINCRN) OF REFERENCE (RNAME)         
         927+13  983          + STORE A   GMVEXIT      ACCORDING TO ITS INDEX VALUES (RIDX1, RIDX2)
         928+10 2715          + R ADD     RSTEPN       
         929+12 2693          + STORE     TRANSFER     INN = addr of stepN given in var TRANSFER = stepN of reference, TRSTLOC = location in reference stepn machine code
         930+10 2716          + R ADD     RINCRN       CNN = location in region loop constants pool
         931+12 2694          + STORE     TRSTLOC
         932+10  932          + R ADD     *            GENERATE THE INSTRUCTIONS TO SET ACC=ADDR OF REFERENCED MATRIX ADDRESS 
         933+ 1 1248          + TR        GENINST     
         934+10 1002          + R ADD     INN          '+RA I /  /'     is location of    V nnnn    of reference
         935+ 0    0          + STOP      0000         END OF INSTR TABLE
         936+10 2709          + R ADD     NREF         SAVE AS POSSIBLE LAST REF FOR "ADDRESS INDEX" END OF LOOP CALCULATION
         937+12 2711          + STORE     NLASTREF
         938+10  938          + R ADD     *            A VARIABLE IS SEARCHED IN PARAMETERS TABLE BY ITS ADDRESS
         939+ 1   79          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         940+ 0 1956          + STOP      TPARNAME     ... CALL PARAMETERS NAME TABLE
         941+ 0 1955          + STOP      NPARAMS      ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NPARAMS
         942+ 0 2718          + STOP      RADDR        ... THE VALUE TO FIND 
         943+ 4  953          + TR 0      TM5          IF NOT FOUND -> REFERENCED VECTOR/MATRIX IS NOT A PARAM -> USE STANDARD VALUE D1 
         944+12 2708          + STORE     NPAR         HERE REFERENCED VECTOR/MATRIX IS PASSED AS PARAM -> SHOULD GET THE D1 VALUE ALSO PASSED AS PARAM
         945+10  945          + R ADD     *            READ FROM TPARAMS TABLES
         946+ 1   75          + TR        READTBL
         947+ 0 2092          + STOP      TPARLOC1     LOC1=ENTRY IN LOOP CONSTANT POOL THAT CONTAINS THE D1 VALUE PASSED AS PARAM
         948+ 0 2708          + STOP      NPAR
         949+ 0 2706          + STOP      ECONST       = TPARLOC1[NPAR] ENTRY IN LOOP CONSTANT POOL THAT CONTAINS THE D1 PASSED AS PARAM
         950+10 2666          + R ADD     ZERO         THIS REFERENCE IS A PARAM, ITS ADDRESS WILL BE SET IN RUN TIME -> THIS REF IS
         951+12 2711          + STORE     NLASTREF     NOT SUITABLE TO BE USED AS POSSIBLE LAST REF FOR "ADDRESS INDEX" END OF LOOP CALCULATION
         952+ 1  963          + TR        TM6
         953+10  953 TM5      + R ADD     *            READ FROM TREFS TABLES
         954+ 1   75          + TR        READTBL
         955+ 0 2616          + STOP      TREFD1       READ D1 VALUE OF VECTOR/MATRIX REFERENCED
         956+ 0 2709          + STOP      NREF
         957+ 0 1749          + STOP      VAL          = TREFD1[NREF] 
         958+10  958          + R ADD     *            
         959+ 1 1178          + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
         960+ 0 2830          + STOP      REG.A        '+H  A nnnn' -> CONSTANT VALUE GIVEN IN VAL VARIABLE =D1 OF REFERENCED MATRIX
         961+ 0 1749          + STOP      VAL
         962+12 2706          + STORE     ECONST       SAVE THE ENTRY IN POOL THAT CONTAINS THE CREATED D1 VALUE (1ST ENTRY = 0000)
         963+10 2713 TM6      + R ADD     RIDX1
         964+ 5 1540          + SUB       S1N
         965+ 4  967          + TR 0      TM6A         TR IF REFERENCE IS USING SAME 1ST INDEX AS IN "TEST" INSTR 
         966+ 1  971          + TR        TM6I         TR TO CHECK IF REFERENCE IS USING SAME 2ND INDEX AS IN "TEST" INSTR 
         967+10  967 TM6A     + R ADD     *            GENERATE THE INSTRUCTIONS TO INCREMENT REFERENCED MATRIX ADDRESS ON 1ST DIMENSION
         968+ 1 1248          + TR        GENINST
         969+ 5 1003          + SUB       CNN          '+S  C econst'   substract D1 value (=2 or value passed as param) to instr to increment addr (as instr is negative)
         970+ 0    0          + STOP      0000         END OF INSTR TABLE
         971+10 2714 TM6I     + R ADD     RIDX2        TR IF REFERENCE IS USING SAME 2ND INDEX AS IN "TEST" INSTR. NOTE THAT 
         972+ 5 1540          + SUB       S1N          "MATRIX I I" IS POSSIBLE, SO EACH INDEX CAN INCREMENT THE REFERENCED MATRIX ADDR
         973+ 4  975          + TR 0      TM6J
         974+ 1  979          + TR        TM6K         TR TO PROCEED
         975+10  975 TM6J     + R ADD     *            GENERATE THE INSTRUCTIONS TO INCREMENT REFERENCED MATRIX ADDRESS ON 2ND DIMENSION
         976+ 1 1248          + TR        GENINST     
         977+ 5 1005          + SUB       C02          '+S  C econst with value 2'   substract D2 value. D2 allways is =2, no need to check if matrix is passed as param
         978+ 0    0          + STOP      0000         END OF INSTR TABLE
         979+10  979 TM6K     + R ADD     *            GENERATE THE INSTRUCTIONS TO SAVE INCREMENTED VECTOR/MATRIX ADDRESS
         980+ 1 1248          + TR        GENINST     
         981+13 1002          + STORE A   INN          '+SA I /  /'     store back the address of reference var incremented by D1 
         982+ 0    0          + STOP      0000         END OF INSTR TABLE
         983+ 1    0 GMVEXIT  + TR        /   /
         984+ 9 2669 SASAME   + ADD       TWO          EXAMINE REMAINING REFERENCES. GENERATE '+SA ' INSTR TO SAVE THE 
         985+13 1036          + STORE A   SASAMEEX     INCREMENTED ADDR ON ACC TO REFERENCES TO SAME VECTOR/MATRIX
         986+10 2709          + R ADD     NREF         EXAMINE REMAINING REFERENCES. 
         987+12 2710          + STORE     NREF2        
         988+10 2710 SALOOP2  + R ADD     NREF2
         989+ 5 2265          + SUB       NREFS        GENERATE '+SA I /  /' MC INST FOR
         990+ 4 1036          + TR 0      SASAMEEX     ALL REFERENCES OF SAME VECTOR/MATRIX PROCESSED
         991+10 2710          + R ADD     NREF2
         992+ 9 2668          + ADD       ONE
         993+12 2710          + STORE     NREF2
         994+10  994          + R ADD     *            READ SEVERAL VALUES FROM TREF TABLES
         995+ 1   77          + TR        READTBL2
         996+ 0 2266          + STOP      TREFNAME     READ THE FIRST VARIABLE REFERENCE
         997+ 0 2264          + STOP      MAXNREFS
         998+ 0 2710          + STOP      NREF2
         999+ 0 2719          + STOP      R2NAME       = TREFNAME[NREF2]   REFERENCE NAME
        1000+ 0 2720          + STOP      R2IDX1       = TREFIDX1[NREF2]   INDEX1 USED BY REFERENCE 
        1001+ 0 2721          + STOP      R2IDX2       = TREFIDX2[NREF2]   INDEX2 USED BY REFERENCE 
        1002+ 0 2722          + STOP      R2STEPN      = TREFSTPN[NREF2]   STEPN OF INSTR WHERE THE REFERENCE IS MADE
        1003+ 0 2723          + STOP      R2INCRN      = TREFINCN[NREF2]   INCRN OF REFERENCE IN THIS STEP
        1004+ 0 1749          + STOP      VAL          = TREFOP  [NREF2]   
        1005+ 0 2724          + STOP      R2ADDR       = TREFADDR[NREF2]   ADDRESS OF VARIABLE/MATRIX Vnnnn
        1006+ 0    0          + STOP      0000
        1007+10 2719          + R ADD     R2NAME       CHECK IF REFERENCE ALREADY PROCESSED
        1008+ 4  988          + TR 0      SALOOP2      IF SO, TRY NEXT REFERENCE 
        1009+10 2724          + R ADD     R2ADDR       CHECK IF SAME MATRIX/VECTOR 
        1010+ 5 2718          + SUB       RADDR        IF NOT, TRY NEXT REFERENCE 
        1011+ 4 1013          + TR 0      SA6A
        1012+ 1  988          + TR        SALOOP2
        1013+10 2720 SA6A     + R ADD     R2IDX1
        1014+ 5 2713          + SUB       RIDX1
        1015+ 4 1017          + TR 0      SA6B
        1016+ 1  988          + TR        SALOOP2
        1017+10 2721 SA6B     + R ADD     R2IDX2
        1018+ 5 2714          + SUB       RIDX2
        1019+ 4 1021          + TR 0      SA6C
        1020+ 1  988          + TR        SALOOP2
        1021+ 8    0 SA6C     + NOOP      0000         HERE WE HAVE ANOTHER REFERENCE TO SAME VECTOR
        1022+10 2722          + R ADD     R2STEPN       
        1023+12 2693          + STORE     TRANSFER     INN = addr of stepN given in var TRANSFER = stepN of reference, TRSTLOC = location in reference stepn machine code
        1024+10 2723          + R ADD     R2INCRN      CNN = location in region loop constants pool
        1025+12 2694          + STORE     TRSTLOC
        1026+10 1026          + R ADD     *            GENERATE THE INSTRUCTIONS TO INCREMENT THE SAME REFERENCED VECTOR ADDRESS 
        1027+ 1 1248          + TR        GENINST     
        1028+13 1002          + STORE A   INN          '+SA I /  /'     store back the address of reference var incremented by D1
        1029+ 0    0          + STOP      0000         END OF INSTR TABLE
        1030+10 1030          + R ADD     *            
        1031+ 1   71          + TR        EQTBL
        1032+ 0 2266          + STOP      TREFNAME     CLEAR THE NAME OF REFERENCE TO SIGNAL IT IS ALREADY PROCESSED -> BECOMES AN EMPTY ENTRY 
        1033+ 0 2710          + STOP      NREF2
        1034+ 0 2666          + STOP      ZERO         TREFNAME[NREF] = 0
        1035+ 1  988          + TR        SALOOP2
        1036+ 1    0 SASAMEEX + TR        /   /
        1037+10 1539 CHECKREF + R ADD     FACTREG
        1038+ 5 2680          + SUB       D34          'V'
        1039+ 4 1041          + TR 0      CK1
        1040+ 1  233          + TR        NEXT         STEP NOT USING A VARIABLE
        1041+10 1540 CK1      + R ADD     S1N          IF S1N <0 (ALFA BASE48 INDEX NAME) -> STORE IN REFERENCES
        1042+ 3 1044          + TR +      CK1A         IF S1N >=0 (NUMERIC CONSTANT/BLANK) -> IS NOT AN INDEX -> TR TO CHECK INDEX2
        1043+ 1 1047          + TR        CK1B
        1044+10 1541 CK1A     + R ADD     S2N          IF S1N <0 (ALFA BASE48 INDEX NAME) -> STORE IN REFERENCES
        1045+ 3  233          + TR +      NEXT         IF S1N >=0 (NUMERIC CONSTANT/BLANK) -> IS NEITHER AN INDEX -> NOT USING INDEXES -> TR TO PROCESS NEXT STEP
        1046+ 1 1047          + TR        CK1B
        1047+10 2265 CK1B     + R ADD     NREFS        CREATE A NEW REFERENCE ENTRY
        1048+ 4 1057          + TR 0      CK1NEW       IF TABLE EMPTY -> TR TO CREATE A NEW ENTRY
        1049+10 1049          + R ADD     *
        1050+ 1   79          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
        1051+ 0 2266          + STOP      TREFNAME     ... INDEX NAME TABLE
        1052+ 0 2265          + STOP      NREFS        ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
        1053+ 0 2666          + STOP      ZERO         ... THE VALUE TO FIND 
        1054+ 4 1057          + TR 0      CK1NEW       NO EMPTY ENTRY FOUND -> TR TO CREATE A NEW ONE
        1055+12 2709          + STORE     NREF         EMPTY ENTRY FOUND -> TR TO USE IT
        1056+ 1 1064          + TR        CK1NEW2
        1057+10 2265 CK1NEW   + R ADD     NREFS        CHECK IF TABLE OVERLOW
        1058+ 5 2264          + SUB       MAXNREFS     
        1059+ 4 1154          + TR 0      ERROVREF     
        1060+10 2265          + R ADD     NREFS        CREATE NEW REF
        1061+ 9 2668          + ADD       ONE
        1062+12 2265          + STORE     NREFS
        1063+12 2709          + STORE     NREF
        1064+15 2668 CK1NEW2  + LOAD MQ   ONE   
        1065+10 1528          + R ADD     OP           OP=40  ID for DO/LIB       ONLY APPLIES INDEX IF IT IS ACTIVE
        1066+ 5 2681          + SUB       OPIDDO       On ID for DO/LIB, non-active index indicates the dimension
        1067+ 4 1069          + TR 0      CK2A         of vector/matrix to pass as param to the called routine
        1068+15 2666          + LOAD MQ   ZERO         so flag CKIDXACT=1 -> set index S1N/S2N to -777777 octal if index not active
        1069+14 2729 CK2A     + STORE MQ  CKIDXACT                                                -777776 octal if index not defined
        1070+10 1541          + R ADD     S2N          IF NO 2ND INDEX -> REFERENCE TO A VECTOR -> INDEX CAN BE "ADDRESS TYPE" 
        1071+ 4 1073          + TR 0      CK2B         IF THERE IS A 2ND INDEX -> REFERENCE TO A MATRIX -> BOTH INDEX SHOULD BE "COUNT TYPE"
        1072+10 2668          + R ADD     ONE          
        1073+12 2727 CK2B     + STORE     CKMKCNT      FLAG: =1 -> MAKE INDEX "COUNT TYPE" IF IT IS DEFINED
        1074+10 1540          + R ADD     S1N          USING 1ST INDEX?
        1075+ 3 1080          + TR +      CK3A
        1076+10 1076          + R ADD     *            YES, CHECK IF DEFINED
        1077+ 1 1109          + TR        CKINDEX
        1078+ 0 1540          + STOP      S1N
        1079+ 2 1157          + TR OV     ERRNDIX1     TR TO ERROR IF 1ST INDEX IS NOT DEFINED       
        1080+10 1541 CK3A     + R ADD     S2N          USING 2ND INDEX?
        1081+ 3 1086          + TR +      CK3B
        1082+10 1082          + R ADD     *            YES, CHECK IF DEFINED
        1083+ 1 1109          + TR        CKINDEX
        1084+ 0 1541          + STOP      S2N
        1085+ 2 1160          + TR OV     ERRNDIX2     TR TO ERROR IF 2ND INDEX IS NOT DEFINED       
        1086+10 1545 CK3B     + R ADD     NINCR        GET THE MC INSTR POINTED BY
        1087+ 4  232          + TR 0      BADOP        NINCR THAT REFERENCES THE 
        1088+ 5 2668          + SUB       ONE          FACTOR VARIABLE
        1089+22    1          + A LEFT    0001
        1090+ 9  155          + ADD       TINSTAD
        1091+13 1092          + STORE A   CK3C
        1092-10    0 CK3C     - R ADD     /   /
        1093-12 1750          - STORE     DATA         
        1094+10 1094          + R ADD     *            STORE IN TABLES
        1095+ 1   73          + TR        EQTBL2
        1096+ 0 2266          + STOP      TREFNAME     
        1097+ 0 2264          + STOP      MAXNREFS
        1098+ 0 2709          + STOP      NREF
        1099+ 0 1529          + STOP      FACT         TREFNAME[NREF] = 
        1100+ 0 1540          + STOP      S1N          TREFIDX1[NREF] <0 -> INDEX NAME, =0 -> NO INDEX,  >0 -> CONSTANT, *777777/6 -> NOT ACTIVE/DEFINED INDEX
        1101+ 0 1541          + STOP      S2N          TREFIDX2[NREF] <0 -> INDEX NAME, =0 -> NO INDEX,  >0 -> CONSTANT, *777777/6 -> NOT ACTIVE/DEFINED INDEX
        1102+ 0 1537          + STOP      STEPN        TREFSTEP[NREF] = 
        1103+ 0 1545          + STOP      NINCR        TREFINCR[NREF] = 
        1104+ 0 1750          + STOP      DATA         TREFOP  [NREF] = 
        1105+ 0 1751          + STOP      DATA2        TREFADDR[NREF] = 
        1106+ 0 1542          + STOP      D1N          TREFD1  [NREF] = 
        1107+ 0    0          + STOP      0000
        1108+ 1  233          + TR        NEXT         
        1109+ 9 2669 CKINDEX  + ADD       TWO          CHECK IF INDEX ACTIVE OR DEFINED
        1110+13 1113          + STORE A   CKIP1        PARAM: THE INDEX VAR. 
        1111+ 9 2668          + ADD       ONE          RETURN OV SET IF INDEX NOT DEFINED
        1112+13 1153          + STORE A   CKIDEX
        1113+10    0 CKIP1    + R ADD     /   /        GET ADDR WHERE THE INDEX NAME IS STORED
        1114+13 1116          + STORE A   CKIP1A
        1115+13 1152          + STORE A   CKI4ST
        1116+10    0 CKIP1A   + R ADD     /   /        DERREFERENCE TO GET THE INDEX NAME (IF <0)  
        1117+12 2728          + STORE     CKIDX
        1118+10 1118          + R ADD     *
        1119+ 1   79          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
        1120+ 0 2128          + STOP      TIDXNAME     ... INDEX NAME TABLE
        1121+ 0 2127          + STOP      NIDXS        ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
        1122+ 0 2728          + STOP      CKIDX        ... THE VALUE TO FIND 
        1123+12 2702          + STORE     NIDX    
        1124+10 2729          + R ADD     CKIDXACT     IS =1?  
        1125+ 5 2668          + SUB       ONE
        1126+ 4 1139          + TR 0      CKI4         YES, TR TO set CC index name to -777777 octal if index not active
        1127+10 2702          + R ADD     NIDX
        1128+ 4 1135          + TR 0      CKI3ND       TR IF INDEX IS NOT DEFINED -> RETURN OV=1
        1129+10 2727 CKI2B    + R ADD     CKMKCNT      FLAG>0 -> MAKE INDEX COUNT TYPE IF DEFINED
        1130+ 4 1153          + TR 0      CKIDEX       FLAG=0 -> JUST EXIT 
        1131+10 1131          + R ADD     *            
        1132+ 1 1163          + TR        MAKEIDXC     MAKE INDEX TYPE "COUNT TYPE"
        1133+ 0 2702          + STOP      NIDX
        1134+ 1 1153          + TR        CKIDEX       JUST EXIT
        1135+ 8    0 CKI3ND   + NOOP      0000         HERE, INDEX IS NOT DEFINED. 
        1136+10 2668          + R ADD     ONE          
        1137+22   36          + A LEFT    0036         SET OV FLAG TO NOTIFY INDEX NOT DEFINED AND THUS NOT ACTIVE)
        1138+ 1 1153          + TR        CKIDEX       EXIT 
        1139+10 2702 CKI4     + R ADD     NIDX
        1140+ 4 1149          + TR 0      CKI4ND       TR IF INDEX IS NOT DEFINED -> SET CALLER'S S1N/S2N TO *777776
        1141+10 1141          + R ADD     *            
        1142+ 1   75          + TR        READTBL      CHECK IF INDEX IS ALSO ACTIVE
        1143+ 0 2230          + STOP      TIDXSETN     IF SETN > 0 INDEX IS ACTIVE
        1144+ 0 2702          + STOP      NIDX
        1145+ 0 2704          + STOP      SETN         = TIDXSETN[NIDX] 
        1146+10 2704          + R ADD     SETN
        1147+ 4 1151          + TR 0      CKI4NA       TR IF INDEX IS NOT ACTIVE -> SET CALLER'S S1N/S2N TO *777777
        1148+ 1 1129          + TR        CKI2B        INDEX IS ACTIVE -> NO WORRIES FOR OP=40 DO for DO/LIB instr -> NORMAL PROCESSING
        1149+10 2689 CKI4ND   + R ADD     O776K        INDEX IS NOT DEFINED
        1150+ 1 1152          + TR        CKI4ST
        1151+10 2690 CKI4NA   + R ADD     O777K        INDEX IS NOT ACTIVE    
        1152+12    0 CKI4ST   + STORE     /   /        SET INDEX NAME IN CALLER ROUTINE TO OCTAL 777777/6 THEN EXIT
        1153+ 1    0 CKIDEX   + TR        /   /
        1154+10 1154 ERROVREF + R ADD     *
        1155+ 1  412          + TR        ERROR
        1156+ 0 2779          + STOP      ERROVRFS     ERROR: TOO MANY REFERENCES TO MATRIX/VECTOR IN REGION (MAX 50)
        1157+10 1157 ERRNDIX1 + R ADD     *
        1158+ 1  412          + TR        ERROR
        1159+ 0 2785          + STOP      ERRNDI1S     ERROR: 1ST INDEX NOT DEFINED (TO BE USED WITH VECTOR/MATRIX INDEX SHOULD BE DEFINED WITH USE/SET)
        1160+10 1160 ERRNDIX2 + R ADD     *
        1161+ 1  412          + TR        ERROR
        1162+ 0 2792          + STOP      ERRNDI2S     ERROR: 2ND INDEX NOT DEFINED (TO BE USED WITH VECTOR/MATRIX INDEX SHOULD BE DEFINED WITH USE/SET)
        1163+ 9 2669 MAKEIDXC + ADD       TWO          MAKE SURE IDX IS COUNT TYPE. 
        1164+13 1167          + STORE A   MKIXCP1      
        1165+ 9 2668          + ADD       ONE
        1166+13 1177          + STORE A   MAKEIDEX
        1167+10    0 MKIXCP1  + R ADD     /   /
        1168+13 1169          + STORE A   MKIXCP1A
        1169+10    0 MKIXCP1A + R ADD     /   /
        1170+12 2725          + STORE     MKCIDX       INDEX TO SET 
        1171+ 4 1177          + TR 0      MAKEIDEX     EXIT IF INDEX TO SET = 0 
        1172+10 1172          + R ADD     *            
        1173+ 1   71          + TR        EQTBL   
        1174+ 0 2196          + STOP      TIDXTYPE     SET THE INDEX TYPE TO "COUNT INDEX"
        1175+ 0 2725          + STOP      MKCIDX       
        1176+ 0 2668          + STOP      ONE          TIDXTYPE[MKCIDX] = 1
        1177+ 1    0 MAKEIDEX + TR        /   /
        1178+ 9 2669 ADDCONST + ADD       TWO          ADD CONSTANT TO LOOP CONSTANT POOL 
        1179+13 1184          + STORE A   ADDCP1       PARAMS: +OP    REG     <-- THE SIGNED OP AND REGION OF CONSTANT
        1180+ 9 2668          + ADD       ONE                   00    ADDR        THE ADDR. IF =0 -> ALLWAYS STORE A NEW CONSTANT 
        1181+13 1201          + STORE A   ADDCP2       RETURN IN ACC THE ENTRY OF ADDED CONST (FIRST ENTRY = 0000)
        1182+ 9 2668          + ADD       ONE                           
        1183+13 1247          + STORE A   ADDCONEX     SEARCH IF CONST ALREADY BEEN ADDED, IF SO RETURN ITS ENTRY
        1184+10    0 ADDCP1   + R ADD     /   /        THE OP AND REGION PART OF CONSTANT
        1185+13 1187          + STORE A   ADDCP1A      SAVE THE ADDR OF VAR THAT HOLD THE REGION NUMBER 0..7
        1186+12 1750          + STORE     DATA         SAVE OP
        1187+10    0 ADDCP1A  + R ADD     /   /        READ THE REGION NUM FROM VAR 
        1188+13 1750          + STORE A   DATA         ADD TO OP. NOW OP= +/- OPCODE AND REGION 0..7
        1189+10 1753          + R ADD     NLOCONST     GET NUMBER OF ENTRIES
        1190+ 4 1192          + TR 0      AN1A         IF EMPTY, ADD 1ST ENTRY '+H A 0002'
        1191+ 1 1199          + TR        AN1Z                       2ND ENTRY '+H A 0001'
        1192+10 2669 AN1A     + R ADD     TWO
        1193+12 1753          + STORE     NLOCONST     
        1194+23   18          + A RIGHT   0018
        1195-12 1754          - STORE     TLOCONST
        1196+10 2668          + R ADD     ONE
        1197+23   18          + A RIGHT   0018
        1198-12 1756          - STORE     TLOCONS2
        1199+10 2666 AN1Z     + R ADD     ZERO
        1200+12 1751          + STORE     DATA2
        1201+10    0 ADDCP2   + R ADD     /   /        THE ADDR OF VALUE TO STORE IN ADDR PART OF CONSTANT 
        1202+ 4 1227          + TR 0      ADDNEW       IF ZERO -> JUST ADD A NEW ENTRY IN POOL
        1203+13 1204          + STORE A   ADDCP2A
        1204+10    0 ADDCP2A  + R ADD     /   /
        1205+12 1751          + STORE     DATA2
        1206+10 1244          + R ADD     TLOCONAD     ADDR OF START OF LOOP CONSTANT TABLE
        1207+13 1212          + STORE A   ADDCLOOP 
        1208+10 1753          + R ADD     NLOCONST 
        1209+22    1          + A LEFT    0001
        1210+ 9 1244          + ADD       TLOCONAD
        1211+13 1245          + STORE A   TLOCOEND     ADDR OF END OF LOOP CONSTANT TABLE
        1212-10    0 ADDCLOOP - R ADD     /   /
        1213- 5 1750          - SUB       DATA
        1214+ 4 1221          + TR 0      ADDFND       FOUND IN LOOP CONSTANT POOL
        1215+10 1212          + R ADD     ADDCLOOP 
        1216+ 5 2669          + SUB       TWO
        1217+13 1212          + STORE A   ADDCLOOP 
        1218+ 5 1245          + SUB       TLOCOEND
        1219+ 4 1229          + TR 0      ADDNFND      NOT FOUND IN POOL -> JUST ADD A NEW ENTRY IN POOL
        1220+ 1 1212          + TR        ADDCLOOP 
        1221+ 6 1212 ADDFND   + R SUB     ADDCLOOP     COMPUTE THE ENTRY NUMBER (FIRST ENTRY = 0000)
        1222+ 5 1244          + SUB       TLOCONAD     
        1223+13 1246          + STORE A   TLOCENT  
        1224+10 1246          + R ADD     TLOCENT  
        1225+23    1          + A RIGHT   0001
        1226+ 1 1247          + TR        ADDCONEX 
        1227+10 2666 ADDNEW   + R ADD     ZERO         NEW ENTRY IS INIT TO ZERO
        1228-12 1750          - STORE     DATA
        1229+10 1753 ADDNFND  + R ADD     NLOCONST     ADD NEW ENTRY
        1230+ 5 1752          + SUB       MAXNCONS
        1231+ 4  676          + TR 0      ERROVLOC     ERROR: TOO MANY LOOP CONSTANTS IN POOL
        1232+10 1753          + R ADD     NLOCONST     ADD NEW ENTRY
        1233+12 1246          + STORE     TLOCENT      THE ENTRY (0000=1ST ENTRY) FOR NEW CONSTANT CREATED IN POOL
        1234+ 9 2668          + ADD       ONE
        1235+12 1753          + STORE     NLOCONST     
        1236+ 5 2668          + SUB       ONE
        1237+22    1          + A LEFT    0001
        1238+ 9 1244          + ADD       TLOCONAD 
        1239+13 1241          + STORE A   ADDENT
        1240-10 1750          - R ADD     DATA
        1241-12    0 ADDENT   - STORE     /   /
        1242+10 1246          + R ADD     TLOCENT      RETURN THE ENTRY
        1243+ 1 1247          + TR        ADDCONEX 
        1244+ 0 1754 TLOCONAD + STOP      TLOCONST
        1245-10    0 TLOCOEND - R ADD     0000
        1246+ 0    0 TLOCENT  + STOP      0000
        1247+ 1    0 ADDCONEX + TR        /   /
        1248+ 9 2669 GENINST  + ADD       TWO          GENERATE MACHINE CODE (MC) INSTRUCTIONS
        1249+13 2692          + STORE A   MC.TABLE     MC TABLE FOLLOWS CALL AS PARAMTERS (UNTIL -STOP 0000 INSTR)
        1250+10 1250          + R ADD     *
        1251+ 1 1259          + TR        GENTABLE
        1252+10 1263          + R ADD     GEN1
        1253+ 9 2668          + ADD       ONE
        1254+13 1255          + STORE A   GENEXIT2      
        1255+ 1    0 GENEXIT2 + TR        /   /
        1256+10 1256 GENTBOV  + R ADD     *
        1257+ 1  412          + TR        ERROR
        1258+ 0 2735          + STOP      ERROVINS     ERROR: TOO MANY INSTR IN THIS STEP
        1259+ 9 2669 GENTABLE + ADD       TWO          GENERATE MACHINE CODE (MC) INSTRUCTIONS
        1260+13 1264          + STORE A   GENEXIT      MC TABLE AT LOCATION IN MC.TABLE VAR
        1261+10 2692          + R ADD     MC.TABLE
        1262+13 1263          + STORE A   GEN1
        1263+10    0 GEN1     + R ADD     /   /        READ MACHINE CODE TABLE
        1264+ 4    0 GENEXIT  + TR 0      /   /        =0 -> END OF MC.TABLE-> RETURN TO CALLER
        1265+12 2695          + STORE     MC
        1266+23   30          + A RIGHT   0030         SAVE OPCODE ONLY
        1267+22   30          + A LEFT    0030         (WITH SIGN)
        1268+12 2696          + STORE     MC.OP        IN MC.OP
        1269+10 1544          + R ADD     NINST        INCR NUMBER OF MC INSTRUCTIONS IN CC TABLE
        1270+ 9 2668          + ADD       ONE          ERROR IF > MAXIMUN ALLOWED
        1271+12 1544          + STORE     NINST
        1272+ 5 1748          + SUB       MAXNINST
        1273+ 4 1256          + TR 0      GENTBOV      ERROR: TOO MANY INSTR IN THIS STEP
        1274+10 2666          + R ADD     ZERO
        1275+11 2695          + ADD AB    MC           EXTRACT ADDR PART OF MC 
        1276+ 7 2696          + SUB AB    MC.OP        
        1277+ 5 2687          + SUB       D1000
        1278+ 3 1280          + TR +      GEN2
        1279+ 0 1111          + STOP      1111         INVALID MC.TABLE
        1280+ 9 1285 GEN2     + ADD       ADTBL        USE THE TRANSFER TABLE TO PROCESS IT
        1281+13 1284          + STORE A   ADTBLTR
        1282+10 2666          + R ADD     ZERO
        1283+11 2696          + ADD AB    MC.OP        ON ENTRY TO ROUTINE, ACC=ABS(MC.OP). SIGN IS IN MC VARIABLE
        1284+ 1    0 ADTBLTR  + TR        /   /
        1285+ 0 1285 ADTBL    + STOP      *
        1286+ 1 1336          + TR        GEN.FACT     factor to be replaced by V 0005 (variable), T 0010 (result of a step) or N 0012 (a number)
        1287+ 1 1310          + TR        GEN.INN      transfer to location n (1..199) into stepN given in var TRANSFER = stepN, TRSTLOC = location in step machine code
        1288+ 1 1315          + TR        GEN.CNN      C nnnn  where nnnn is the value of ECONST var
        1289+ 1 1320          + TR        GEN.C01      C nnnn  where nnnn is the value ONE in LOOP CONSTANTS POOL
        1290+ 1 1328          + TR        GEN.C02      C nnnn  where nnnn is the value TWO in LOOP CONSTANTS POOL
        1291+10 2695 GENADD   + R ADD     MC           ADD A GENERATED MC INSTR TO TINST TABLE
        1292+ 3 1295          + TR +      GENADD1      TAKE THE SIGN OF MC AND PLACE IT IN MC.OP
        1293+ 6 2696          + R SUB     MC.OP
        1294+12 2696          + STORE     MC.OP
        1295+10 1544 GENADD1  + R ADD     NINST        ADD NINST TWICE AS EACH MC INSTR USES TWO HALF-WORDS
        1296+ 9 1544          + ADD       NINST
        1297+ 5 2669          + SUB       TWO          
        1298+ 9  155          + ADD       TINSTAD      TINSTAD=LOCATION OF TABLE WITH MC INSTRUCTIONS GENERATED FOR THE CURRENT STEP
        1299+13 1303          + STORE A   GENADD2      TINST[ (INST- 1)*2 ] =MC instr op and region
        1300+ 9 2668          + ADD       ONE
        1301+13 1305          + STORE A   GENADD3      TINST[ (INST- 1)*2 ] =MC instr addr
        1302+10 2696          + R ADD     MC.OP        
        1303+12    0 GENADD2  + STORE     /   /        STORE GENERATED MC INSTRUCTION MC.OP (MC.OP CAN BE >0 OR <0)
        1304+10 2698          + R ADD     MC.ADDR
        1305+12    0 GENADD3  + STORE     /   /                                       MC.ADDR (CAN BE >0 OR <0 IF HOLDS A STEPN/LOCATION PAIR)
        1306+10 1263          + R ADD     GEN1         PROCEED WITH NEXT MC INST N LIST
        1307+ 9 2668          + ADD       ONE
        1308+13 1263          + STORE A   GEN1
        1309+ 1 1263          + TR        GEN1
        1310+ 9 2694 GEN.INN  + ADD       TRSTLOC      TRSTLOC=LOCATION INTO STEPN NUMBER THE MC INSTR HAS TO TRANSFER TO 
        1311+12 2696          + STORE     MC.OP        MC.OP   = OPCODE + LOCATION INTO STEPN
        1312+ 6 2693          + R SUB     TRANSFER     TRANSFER=STEPN NUMBER THE MC INSTR HAS TO TRANSFER TO 
        1313+12 2698          + STORE     MC.ADDR      MC.ADDR = STEPN (WITH MINUS SIGN, TO SIGNAL ADDR POINTS TO STEPN/LOCATION IN THIS STEP PAIR)
        1314+ 1 1291          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
        1315+ 9 2835 GEN.CNN  + ADD       REG.C
        1316+12 2696          + STORE     MC.OP        MC.OP   = OPCODE + REGION C
        1317+10 2706          + R ADD     ECONST
        1318+12 2698          + STORE     MC.ADDR      MC.ADDR = ADDR IN REGION C
        1319+ 1 1291          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
        1320+ 9 2835 GEN.C01  + ADD       REG.C
        1321+12 2696          + STORE     MC.OP        MC.OP   = OPCODE + REGION C
        1322+10 1322          + R ADD     *
        1323+ 1 1178          + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
        1324+ 0 2830          + STOP      REG.A        '+H  A 0001' -> CONSTANT VALUE 1
        1325+ 0 2668          + STOP      ONE
        1326+12 2698          + STORE     MC.ADDR      MC.ADDR = ADDR IN REGION C
        1327+ 1 1291          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
        1328+ 9 2835 GEN.C02  + ADD       REG.C
        1329+12 2696          + STORE     MC.OP        MC.OP   = OPCODE + REGION C
        1330+10 1330          + R ADD     *
        1331+ 1 1178          + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
        1332+ 0 2830          + STOP      REG.A        '+H  A 0002' -> CONSTANT VALUE 2
        1333+ 0 2669          + STOP      TWO
        1334+12 2698          + STORE     MC.ADDR      MC.ADDR = ADDR IN REGION C
        1335+ 1 1291          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
        1336+15 2832 GEN.FACT + LOAD MQ   REG.V
        1337+10 1539          + R ADD     FACTREG
        1338+ 5 2680          + SUB       D34          'V'
        1339+ 4 1349          + TR 0      GEN.FA1
        1340+15 2834          + LOAD MQ   REG.N
        1341+10 1539          + R ADD     FACTREG
        1342+ 5 2678          + SUB       D26          'N'
        1343+ 4 1349          + TR 0      GEN.FA1
        1344+15 2833          + LOAD MQ   REG.T
        1345+10 1539          + R ADD     FACTREG
        1346+ 5 2679          + SUB       D32          'T'
        1347+ 4 1349          + TR 0      GEN.FA1
        1348+ 0 1111          + STOP      1111         INTERNAL COMPILER ERROR: INVALID FACT REGION
        1349+10 2666 GEN.FA1  + R ADD     ZERO
        1350+20   35          + L LEFT    0035         A=MQ
        1351+11 2696          + ADD AB    MC.OP
        1352+12 2696          + STORE     MC.OP        MC.OP   = OPCODE + REGION OF FACTOR (CAN BE V, N OR T)
        1353+10 1538          + R ADD     FACTN
        1354+12 2698          + STORE     MC.ADDR      MC.ADDR = FACTN
        1355+10 1544          + R ADD     NINST   
        1356+12 1545          + STORE     NINCR        NINCR= THE LOCATION OF FACTOR MC INSTRUCTION INTO THE STEP 
        1357+ 1 1291          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
        1358+ 9 2669 PRTMC    + ADD       TWO          PRINT TINST TABLE WITH MC INSTRUCTIONS GENERATED FOR THIS STEP
        1359+13 1501          + STORE A   PRTMCEX
        1360+10 2666          + R ADD     ZERO
        1361+12 2699          + STORE     PRTMCNUM
        1362+10 2699 PMCLOOP  + R ADD     PRTMCNUM
        1363+ 5 1544          + SUB       NINST
        1364+ 4 1501          + TR 0      PRTMCEX      EXIT IF ALL NINST INSTRUCTIONS PRINTED
        1365+10 2699          + R ADD     PRTMCNUM     INCR COUNT
        1366+ 9 2668          + ADD       ONE
        1367+12 2699          + STORE     PRTMCNUM     GET MC INSTR FROM TINST[ (PRTMCNUM-1)*2 ]
        1368+ 9 2699          + ADD       PRTMCNUM
        1369+ 5 2669          + SUB       TWO
        1370+ 9  155          + ADD       TINSTAD
        1371+13 1376          + STORE A   PMCAD1
        1372+ 9 2668          + ADD       ONE
        1373+13 1380          + STORE A   PMCAD2
        1374+10 2666          + R ADD     ZERO
        1375+12 2697          + STORE     MC.REG       INIT REGION REFERENCED BY MC
        1376+10    0 PMCAD1   + R ADD     /   /
        1377+13 2697          + STORE A   MC.REG
        1378+23   12          + A RIGHT   0012
        1379+12 2696          + STORE     MC.OP        MC.OP HAS NOW THE SIGNED OPCODE -31..31 
        1380+10    0 PMCAD2   + R ADD     /   /
        1381+12 2698          + STORE     MC.ADDR
        1382+ 3 1389          + TR +      PMC3         IF MC.ADDR >=0 THEN MC.REG HOLDS THE REGION FOR MC.ADDR 
        1383+10 2697          + R ADD     MC.REG       IF MC.ADDR <0 THEN MC.REG VAR HOLDS THE LOCATION INTO STEPN REFERENCED BY MC.ADDR
        1384+12 2694          + STORE     TRSTLOC      LOCATION IN STEP GIVEN BY MC.ADDR
        1385+ 6 2698          + R SUB     MC.ADDR      MAKES MC.ADDR POSITIVE. IT IS THE DESTINATION STEP
        1386+12 2698          + STORE     MC.ADDR
        1387+10 2831          + R ADD     REG.I
        1388+12 2697          + STORE     MC.REG       SET REGION I -> MC.ADDR=THE STEPN, TRSTLOC=THE NINST REFERENCED IN THIS STEPN
        1389+10 1389 PMC3     + R ADD     *            START NEW LINE TO PRINT
        1390+ 1   53          + TR        CLRBUF
        1391+10 2700          + R ADD     REGCSTEP     THIS IS THE STEPN WHERE THE REG.C SITS
        1392+ 5 1537          + SUB       STEPN
        1393+ 4 1395          + TR 0      PMC3C        TR TO PRINT REG "C NNNN" INSTEAD OF STEPN.MCNUM
        1394+ 1 1407          + TR        PMC3Z
        1395+15 2675 PMC3C    + LOAD MQ   D15          PRINT 'C'
        1396+10 1396          + R ADD     *
        1397+ 1   65          + TR        PRTCHR
        1398+ 0   39          + STOP      0039         AT COL 39
        1399+10 2699          + R ADD     PRTMCNUM     INST NUMBER 1..99
        1400+ 5 2668          + SUB       ONE          -1 -> IS THE ADDRESS IN REGION C
        1401+21   35          + L RIGHT   0035         ACC->MQ
        1402+10 1402          + R ADD     *
        1403+ 1   63          + TR        PRTINT
        1404+ 0   40          + STOP      0040         AT COL 40 
        1405+ 0    4          + STOP      0004         LEN=4
        1406+ 1 1427          + TR        PMC5SGN
        1407+15 1537 PMC3Z    + LOAD MQ   STEPN        PRINT STEPN
        1408+10 1408          + R ADD     *
        1409+ 1   63          + TR        PRTINT
        1410+ 0   40          + STOP      0040         AT COL 40 
        1411+ 0    4          + STOP      0004         LEN=4
        1412+15 2683          + LOAD MQ   D43          PRINT '.'
        1413+10 1413          + R ADD     *
        1414+ 1   65          + TR        PRTCHR
        1415+ 0   44          + STOP      0044         AT COL 44 
        1416+15 2669          + LOAD MQ   TWO
        1417+10 2699          + R ADD     PRTMCNUM     IF INST NUMBER < 10 PRINT IT
        1418+ 5 2672          + SUB       D10          WITH LEN=1, IF >= 10 USE LEN=2
        1419+ 3 1421          + TR +      PMC4
        1420+15 2668          + LOAD MQ   ONE
        1421+14 1426 PMC4     + STORE MQ  PMC5
        1422+15 2699          + LOAD MQ   PRTMCNUM
        1423+10 1423          + R ADD     *
        1424+ 1   63          + TR        PRTINT
        1425+ 0   45          + STOP      0045         AT COL 45 
        1426+ 0    2 PMC5     + STOP      0002         LEN=1 OR 2
        1427+15 2674 PMC5SGN  + LOAD MQ   D12          '+'
        1428+10 2696          + R ADD     MC.OP
        1429+ 3 1431          + TR +      PMC6
        1430+15 2673          + LOAD MQ   D11          '-'
        1431+10 1431 PMC6     + R ADD     *            PRINT OP SIGN
        1432+ 1   65          + TR        PRTCHR
        1433+ 0   48          + STOP      0048         AT COL 48
        1434+10 2666          + R ADD     ZERO
        1435+11 2696          + ADD AB    MC.OP
        1436+ 9 1475          + ADD       TMNEAD
        1437+13 1438          + STORE A   PMC7
        1438+15    0 PMC7     + LOAD MQ   /   /
        1439+10 1439          + R ADD     *            PRINT OP MNEMONIC
        1440+ 1   61          + TR        PRTALF
        1441+ 0   49          + STOP      0049         AT COL 49
        1442+10 2697          + R ADD     MC.REG
        1443+ 9 1476          + ADD       TREGMNEA     CHARS IN TREGMNE ARE TXT ALFA VALUES  
        1444+13 1445          + STORE A   PMC8         THUS ARE NEGATIVE
        1445+ 6    0 PMC8     + R SUB     /   /        CHANGE SIGN BEFORE STORING IT IN MQ
        1446+21   35          + L RIGHT   0035
        1447+10 1447          + R ADD     *            PRINT REGION LETTER V I S T A N
        1448+ 1   65          + TR        PRTCHR
        1449+ 0   52          + STOP      0052         AT COL 52
        1450+10 2697          + R ADD     MC.REG       IF MC.REG='I' THEN ...
        1451+ 5 2831          + SUB       REG.I        
        1452+ 4 1477          + TR 0      PMC9         TR TO PRINT STEPN.LOCATION
        1453+10 2697          + R ADD     MC.REG       IF MC.REG='S' THEN ...
        1454+ 5 2836          + SUB       REG.S
        1455+ 4 1462          + TR 0      PMC8B        TR TO PRINT ALFA SYMBOL TO TRANSFER TO
        1456+15 2698          + LOAD MQ   MC.ADDR      MC.REG IS 'V', 'T', 'A' OR 'N'
        1457+10 1457          + R ADD     *            JUST PRINT THE INST ADDRESS
        1458+ 1   63          + TR        PRTINT
        1459+ 0   53          + STOP      0053         AT COL 53 
        1460+ 0    4          + STOP      0004         LEN=4
        1461+ 1 1497          + TR        PMC12
        1462+15 2685 PMC8B    + LOAD MQ   D45          PRINT ALFA SYMBOL TO TRANSFER TO
        1463+10 1463          + R ADD     *            '/'
        1464+ 1   65          + TR        PRTCHR
        1465+ 0   54          + STOP      0054         AT COL 54
        1466+15 2685          + LOAD MQ   D45          '/'
        1467+10 1467          + R ADD     *
        1468+ 1   65          + TR        PRTCHR
        1469+ 0   58          + STOP      0058         AT COL 58
        1470+15 2698          + LOAD MQ   MC.ADDR      GET SYMBOL ALFA
        1471+10 1471          + R ADD     *            
        1472+ 1   61          + TR        PRTALF
        1473+ 0   55          + STOP      0055         AT COL 55
        1474+ 1 1497          + TR        PMC12
        1475+ 0 2845 TMNEAD   + STOP      TMNE
        1476+ 0 2837 TREGMNEA + STOP      TREGMNE
        1477+15 2698 PMC9     + LOAD MQ   MC.ADDR      PRINT STEPN.TRSTLOC 
        1478+10 1478          + R ADD     *
        1479+ 1   63          + TR        PRTINT
        1480+ 0   53          + STOP      0053         AT COL 53 
        1481+ 0    4          + STOP      0004         LEN=4
        1482+15 2683          + LOAD MQ   D43          PRINT '.'
        1483+10 1483          + R ADD     *
        1484+ 1   65          + TR        PRTCHR
        1485+ 0   57          + STOP      0057         AT COL 57 
        1486+15 2669          + LOAD MQ   TWO
        1487+10 2694          + R ADD     TRSTLOC      IF INST NUMBER < 10 PRINT IT
        1488+ 5 2672          + SUB       D10          WITH LEN=1, IF >= 10 USE LEN=2
        1489+ 3 1491          + TR +      PMC10
        1490+15 2668          + LOAD MQ   ONE
        1491+14 1496 PMC10    + STORE MQ  PMC11
        1492+15 2694          + LOAD MQ   TRSTLOC
        1493+10 1493          + R ADD     *
        1494+ 1   63          + TR        PRTINT
        1495+ 0   58          + STOP      0058         AT COL 58 
        1496+ 0    2 PMC11    + STOP      0002         LEN=1 OR 2
        1497+ 8    0 PMC12    + NOOP      0000
        1498+10 1498          + R ADD     *
        1499+ 1   57          + TR        PRINTCRD
        1500+ 1 1362          + TR        PMCLOOP    
        1501+ 1    0 PRTMCEX  + TR        /   /        RETURN TO CALLER
        1502+     0  PACTSRC    RES       24           CARD IMAGE OF PACT SOURCE CODE CARD (12 FULL WORDS)
        1526+     0  REGION     DEF       0
        1527+     0  STEP       DEF       0            REGION = ALFA (<0)
        1528+     0  OP         DEF       0            STEP   = INT (>0)
        1529+     0  FACT       DEF       0            OP     = 0..43    =0 MEANS END OF REGION
        1530+     0  S1         DEF       0            FACT   < 0 -> FACTOR IS AN ALFA SYMBOL (VAR, REGION, ...) 
        1531+     0  S2         DEF       0            FACT = 0 -> BLANK FACTOR
        1532+     0  QR         DEF       0            FACT = 0..9999 -> DESTINATION STEP FOR TRANSFER/RESULT OF STEP
        1533+     0  QF         DEF       0            CLUE = -, R OR N
        1534+     0  NUM        DEF       0            
        1535+     0             DEF       0            S1/S2 = 0 -> BLANK, >0 -> INTEGER, <0 -> ALFA 
        1536+     0  CLUE       DEF       0
        1537+     0  STEPN      DEF       0            QR = +/- INTEGER OR BLANK. 
        1538+     0  FACTN      DEF       0                 IF OP=TEST THEN IF QR=0->INDEX IN GENEATED INSTR IS INDEX IS "ADDRESS TYPE", =1->IS "COUNT TYPE" 
        1539+     0  FACTREG    DEF       0            QF = SET IF THERE IS AN INTEGER FACTOR/NUMBER IN CARD
        1540+     0  S1N        DEF       0            STEPN = SEQUENTIAL NUMBER OF STEP            
        1541+     0  S2N        DEF       0            IF OP IS TRANSFER -> FACTN=DESTINATION STEPN
        1542+     0  D1N        DEF       0            FACTN=ADDR (0, 2, 4, ..) FACTREG=' ', 'T', 'V', 'N'
        1543+     0  D2N        DEF       0            S1N/S2N=INDEX (IF <0), BLANK (IF =0), CONST (IF >0), 
        1544+     0  NINST      DEF       0                   IF OP=40 -> =*777777 if non active index 
        1545+     0  NINCR      DEF       0                               =*777776 if non defined index
        1546+     0  TINST      RES       200          D1N/D2N=HALF-WORD SIZE OF EACH DIMENSION. D1N=-1 IF MATRIX/VECTOR WITH CONSTANT SUBSCRIPTS 
        1746+    44  CCLEN      DEF       0044         LENGTH OF COMPACT CODE RECORD 
        1747+     0  N          DEF       0            TEMP VAR (HERE TO MAKE TABLES START AT EVEN LOCATION)
        1748+   100  MAXNINST   DEF       100          MAX NUMBER OF MACHINE CODE INSTRUTIONS PER STEP
        1749+     0  VAL        DEF       0            TEMP
        1750+     0  DATA       DEF       0            EVEN ALIGNED TEMP VAT
        1751+     0  DATA2      DEF       0
        1752+   100  MAXNCONS   DEF       100          MAX NUMBER OF ENTRIES IN LOOP CONSTANT POOL OF REGION
        1753+     0  NLOCONST   DEF       0            NUM OF ENTRIES IN LOOP CONSTANT POOL OF REGION
        1754+     0  TLOCONST   RES       2
        1756+     0  TLOCONS2   RES       198          MACHINE CODE: 1ST HALF-WORD OPCODE + REGION
        1954+    34  MAXNPAR    DEF       34           MAX (34) NUMBER OF CALL PARAMETERS
        1955+     0  NPARAMS    DEF        0           NUMBER OF PARAMS DEFINED
        1956+     0  TPARNAME   RES       34           PARAM NAME (ALFA BASE48 <0). >0 IF VARIABLE (IS THE ADDR). =4096 IF NUMBER
        1990+     0  TPARSTEP   RES       34           STEPN WHERE PARAM IS DEFINED
        2024+     0  TPARTYPE   RES       34           PARAM TYPE: 
        2058+     0  TPARFACT   RES       34           
        2092+     0  TPARLOC1   RES       34           PACT       TYPE  FACT   LOC1   NAME       DESCR
        2126+    34  MAXNIDXS   DEF       34           MAX (34) INDEXS ACTIVE AT SAME TIME
        2127+     0  NIDXS      DEF       0            NUMBER OF INDEXES IN THIS REGION
        2128+     0  TIDXNAME   RES       34           NAME OF ACTIVE INDEX (ALFA <0). >0 IF ENTRY IS NO LONGER IN USE
        2162+     0  TIDXLOC    RES       34           = ENTRY IN LOOP CONSTANT POOL THAT HAS THE CURRENT INDEX VALUE
        2196+     0  TIDXTYPE   RES       34           = 0 -> "ADDRESS INDEX" TYPE, =1 -> "COUNT INDEX" TYPE
        2230+     0  TIDXSETN   RES       34           = 0 -> DEFINED INDEX, >0 -> ACTIVE INDEX = STEPN WHERE WHERE THE INDEX IS SET (USED TO COMPUTE START OF LOOP)
        2264+    50  MAXNREFS   DEF       50           MAX (50) NUMBER OF VECTOR/MATRIX REFERENCES SIMULATEOUSLY ACTIVE AT A GIVEN MOMENT
        2265+     0  NREFS      DEF       0            NUMBER OF REFERENCES IN REGION
        2266+     0  TREFNAME   RES       50           NAME OF VECTOR/MATRIX. =0 IS ENTRY IS NOT USED       
        2316+     0  TREFIDX1   RES       50           NAME OF INDEX1. <0->INDEX NAME,=0->NO INDEX,>0->CONSTANT,=*777777 if non active index with OP=40                   
        2366+     0  TREFIDX2   RES       50           NAME OF INDEX2.                                      
        2416+     0  TREFSTEP   RES       50           STEPN WHERE THIS VECTOR/MATRIX IS USED               TINST 0:  ...                        
        2466+     0  TREFINCR   RES       50           INCRN ON PREVIOUS STEPN TO ACCESS THE VAR LOCATION   STEPN  :  ... VAR I  J                
        2516+     0  TREFOP     RES       50           THE OPCODE THAT APPLIES ON VECT/MATRIX                     2:  ...                         
        2566+     0  TREFADDR   RES       50           THE ADDR OF VECT/MATRIX                                    4:  +RA V 0003  <-- INCR VALUE  
        2616+     0  TREFD1     RES       50           D1 VALUE IF REF IS A MATRIX                                    ^^^   ^^^^                  
        2666+     0  ZERO       DEF       0
        2667+     0             DEF       0
        2668+     1  ONE        DEF       1
        2669+     2  TWO        DEF       2
        2670+     3  D3         DEF       3
        2671+     4  D4         DEF       4
        2672+    10  D10        DEF       10
        2673+    11  D11        DEF       11
        2674+    12  D12        DEF       12
        2675+    15  D15        DEF       15
        2676+    19  D19        DEF       19
        2677+    24  D24        DEF       24
        2678+    26  D26        DEF       26
        2679+    32  D32        DEF       32
        2680+    34  D34        DEF       34
        2681+    40  D40        DEF       40
        2682+    41  D41        DEF       41
        2683+    43  D43        DEF       43
        2684+    44  D44        DEF       44
        2685+    45  D45        DEF       45
        2686+   200  D200       DEF       200
        2687+  1000  D1000      DEF       1000
        2688+  4096  D4096      DEF       4096
        2689-131070  O776K      DEF       *777776      OCTAL ALL ONES
        2690-131071  O777K      DEF       *777777      OCTAL ALL ONES
        2691+     0  NREGIONS   DEF       0            NUMBER OF REGIONS PROCESSED
        2692+     0  MC.TABLE   DEF       0            ADDRESS TO MACHINE CODE GENERATION TABLE TO USE 
        2693+     0  TRANSFER   DEF       0            STEPN NUMBER THE MC INSTR HAS TO TRANSFER TO 
        2694+     0  TRSTLOC    DEF       0            LOCATION INTO STEPN NUMBER THE MC INSTR HAS TO TRANSFER TO 
        2695+     0  MC         DEF       0            MACHINE CODE INSTR TO GENERATE FROM MC TABLE
        2696+     0  MC.OP      DEF       0            MC OPCODE GENERATED
        2697+     0  MC.REG     DEF       0            REGION REFERENCED BY MC OPCODE GENERATED
        2698+     0  MC.ADDR    DEF       0            MC ADDR GENERATED. BOTH WILL BE STORED IN TINST TABLE IN COMPCAT CODE RECORD
        2699+     0  PRTMCNUM   DEF       0            NEXT INSTR TO PRINT WITH PRTMC
        2700+     0  REGCSTEP   DEF       0            STEPN WHERE THE REG.C SITS
        2701+     0  PRGSTEPN   DEF       0            FIRST STEPN OF PROGRAM AFTER INITIAL CALL/ID/FOR (IE STEP-1 IS CALL/ID/FOR INSTR)
        2702+     0  NIDX       DEF       0            CURRENT INDEX NUMBER
        2703+     0  NIDX2      DEF       0            
        2704+     0  SETN       DEF       0            THE STEPN WHERE THE START OF LOOP "SET" PACT INSTR IS DEFINED
        2705+     0  ECONSTIX   DEF       0            =0 IF INDEX IS "ADDRESS INDEX" TYPE, >0 IF INDEX IS "COUNT INDEX" TYPE, =ENTRY IN LOOP CONSTANT POOL FOR INDEX VALUE
        2706+     0  ECONST     DEF       0
        2707+     0  ECONSEND   DEF       0
        2708+     0  NPAR       DEF       0            PARAM BEING EXAMINED
        2709+     0  NREF       DEF       0            CURRENT REFERENCE ENTRY. REFERENCES = STEPN OF INSTR THAT USES VARS WITH INDEX. 
        2710+     0  NREF2      DEF       0            THE ADDR OF VAR IN THSE STEPN SHOULD BE MODIFIED BY "TEST" INSTR
        2711+     0  NLASTREF   DEF       0            
        2712+     0  RNAME      DEF       0            REFERENCE NAME
        2713+     0  RIDX1      DEF       0            INDEX1 USED BY REFERENCE 
        2714+     0  RIDX2      DEF       0            INDEX2 USED BY REFERENCE 
        2715+     0  RSTEPN     DEF       0            STEPN OF INSTR WHERE THE REFERENCE IS MADE
        2716+     0  RINCRN     DEF       0            INCRN OF REFERENCE IN THIS STEP
        2717+     0  ROP        DEF       0
        2718+     0  RADDR      DEF       0
        2719+     0  R2NAME     DEF       0            REFERENCE NAME
        2720+     0  R2IDX1     DEF       0            INDEX1 USED BY REFERENCE 
        2721+     0  R2IDX2     DEF       0            INDEX2 USED BY REFERENCE 
        2722+     0  R2STEPN    DEF       0            STEPN OF INSTR WHERE THE REFERENCE IS MADE
        2723+     0  R2INCRN    DEF       0            INCRN OF REFERENCE IN THIS STEP
        2724+     0  R2ADDR     DEF       0
        2725+     0  MKCIDX     DEF       0            INDEX TO SET TO "COUNT TYPE"
        2726+     0  ECONSTMK   DEF       0            ENTRY IN CONSTANT POOL THAT CONTAINS THE VALUE OF INDEX
        2727+     0  CKMKCNT    DEF       0            FLAG: <0 -> MAKE INDEX COUNT TYPE IF ACTIVE
        2728+     0  CKIDX      DEF       0
        2729+     0  CKIDXACT   DEF       0            =1 -> PROCESSING AN OP=40 ID for DO/LIB INSTR 
        2730+     0  PNAME      DEF       0            PARAMETER NAME
        2731+     0  PTYPE      DEF       0            PARAMETER TYPE
        2732+     0  SVNINST    DEF       0            SAVE CURRENT NUMBER OF MC INSTR IN THE COMPACT CODE RECORD AT START OF STEP PROCESSING
        2733+     0  SVSTEPN    DEF       0            SAVE LAST STEPN 
        2734+     0  LEN        DEF       0
        2735- 75051  ERROVINS   TXT       "TOO MANY INSTR",0                ERROR: MAX 100
        2736-  1213  
        2737- 61680  
        2738- 49663  
        2739- 75168  
        2740+     0  
        2741- 61200  ERRNOIXS   TXT       "NO INDEX",0                      ERROR: MISSING INDEX
        2742- 49648  
        2743- 40896  
        2744+     0  
        2745- 61200  ERRNOIVS   TXT       "NO VALUE",0                      ERROR: MISSING INDEX VALUE
        2746- 78984  
        2747- 76848  
        2748+     0  
        2749- 38476  ERRDSETS   TXT       "DUPL SET",0                      ERROR: DUPLICATED SET ON SAME INDEX
        2750- 55327  
        2751- 40704  
        2752+     0  
        2753- 75051  ERRIXOVS   TXT       "TOO MANY INDEXES",0              ERROR: MAX 34
        2754-  1213  
        2755- 61680  
        2756- 49648  
        2757- 40913  
        2758- 71424  
        2759+     0  
        2760- 49648  ERRNDIDS   TXT       "INDEX NOT ACTIVE",0              ERROR: INDEX NOT ACTIVE (MISSING SET INSTR FOR THIS INDEX)
        2761- 40896  
        2762- 61232  
        2763-   639  
        2764- 74770  
        2765- 39168  
        2766+     0  
        2767- 32896  ERRBADTS   TXT       "BAD DEST",0                      ERROR: BAD TEST DESTINATION IN FACTOR. SHOULD BE BLANK OR A STEP NUMBER         
        2768-   785  
        2769- 72960  
        2770+     0  
        2771- 56619  ERROVLOS   TXT       "LOOP CONST OVERFLOW",0           ERROR: TOO MANY LOOP CONSTANTS IN POOL         
        2772- 64527  
        2773- 63487  
        2774- 73755  
        2775- 79182  
        2776- 42651  
        2777- 80640  
        2778+     0  
        2779- 75051  ERROVRFS   TXT       "TOO MANY REFS",0                 ERROR: TOO MANY REFERENCES TO MATRIX/VECTOR IN REGION (MAX 50)
        2780-  1213  
        2781- 61680  
        2782- 69954  
        2783- 71424  
        2784+     0  
        2785-  3824  ERRNDI1S   TXT       "1ST INDEX NOT DEF",0             ERROR: 1ST INDEX NOT DEFINED 
        2786-  1034  
        2787- 37716  
        2788-  1275  
        2789- 73744  
        2790- 40032  
        2791+     0  
        2792-  5872  ERRNDI2S   TXT       "2ND INDEX NOT DEF",0             ERROR: 2ND INDEX NOT DEFINED 
        2793-  1034  
        2794- 37716  
        2795-  1275  
        2796- 73744  
        2797- 40032  
        2798+     0  
        2799- 38476  ERRDPARS   TXT       "DUPL PARAM",0                    ERROR: DUPLICATED PARAMETER NAME
        2800- 55324  
        2801- 31405  
        2802- 57600  
        2803+     0  
        2804- 75051  ERROVPAS   TXT       "TOO MANY PARAMETERS",0           ERROR: TOO MANY PARAMS DEFINED (MAX 34)
        2805-  1213  
        2806- 61680  
        2807- 65166  
        2808- 31169  
        2809- 74574  
        2810- 71424  
        2811+     0  
        2812- 61200  ERRNOVAR   TXT       "NO VAR",0                        ERROR: ID PARAM MUST BE A VAR (CANNOT BE A TEMP/PERISHABLE VAR)
        2813- 78990  
        2814+     0  
        2815- 56619  MSGSTART   TXT       "LOOP EXPANSION PASS 1",0
        2816- 64529  
        2817- 84301  
        2818- 61413  
        2819- 63456  
        2820- 65167  
        2821- 71425  
        2822+     0  
        2823- 69955  MSGDONE    TXT       "REGIONS",0
        2824- 49706  
        2825- 71424  
        2826+     0  
        2827- 46728  HALTTXT    TXT       "HALT",0
        2828- 73728  
        2829+     0  
        2830+     0  REG.A      DEF       0            ABSOLUTE A 0000
        2831+     1  REG.I      DEF       1            INSTRUCTIONS CODE I 0000
        2832+     2  REG.V      DEF       2            VARIABLES V 0000
        2833+     3  REG.T      DEF       3            TEMPORARY T 0000
        2834+     4  REG.N      DEF       4            NUMBER N 0000
        2835+     6  REG.C      DEF       6            ENTRY IN LOOP CONSTANTS POOL C 0000
        2836+     7  REG.S      DEF       7            SYMBOL S 0000
        2837-    13  TREGMNE    TXT       '  A'
        2838-    21             TXT       '  I'
        2839-    34             TXT       '  V'
        2840-    32             TXT       '  T'
        2841-    26             TXT       '  N'
        2842-    28             TXT       '  P'        PERISHABLE STORAGE (=LIB LOCAL VARS/CONSTANTS)
        2843-    15             TXT       '  C'        LOOP CONSTANTS
        2844-    31             TXT       '  S'
        2845- 46080  TMNE       TXT       'H  '        STOP/HALT
        2846- 73728             TXT       'T  '        TRANSFER
        2847- 74592             TXT       'TF '        TRANSFER ON OVERLOF
        2848- 75072             TXT       'TP '        TRANSFER ON PLUS
        2849- 75552             TXT       'TZ '        TRANSFER ON ZERO
        2850- 71424             TXT       'S  '        SUBTRACT
        2851- 70608             TXT       'RS '        RESET AND SUBTRACT
        2852- 73056             TXT       'SV '        SUBTRACT ABSOLUTE VALUE
        2853- 59904             TXT       'N  '        NO OPERATION
        2854- 29952             TXT       'A  '        ADD
        2855- 69744             TXT       'RA '        RESET AND ADD
        2856- 31584             TXT       'AV '        ADD ABSOLUTE VALUE
        2857- 72960             TXT       'ST '        STORE
        2858- 72048             TXT       'SA '        STORE ADDRESS
        2859- 72624             TXT       'SM '        STORE MQ
        2860- 56496             TXT       'LM '        LOAD MQ
        2861- 57600             TXT       'M  '        MULTIPLY
        2862- 59040             TXT       'MR '        MULTIPLY AND ROUND
        2863- 36864             TXT       'D  '        DIVIDE
        2864- 69120             TXT       'R  '        ROUND
        2865- 56448             TXT       'LL '        LONG LEFT SHIFT
        2866- 56736             TXT       'LR '        LONG RIGHT SHIFT
        2867- 31104             TXT       'AL '        ACCUMULATOR LEFT SHIFT
        2868- 31392             TXT       'AR '        ACCUMULATOR RIGHT SHIFT
        2869- 69888             TXT       'RD '        READ
        2870- 69792             TXT       'RB '        READ BACKWARDs
        2871- 80640             TXT       'W  '        WRITE
        2872- 81456             TXT       'WE '        WRITE END OF FILE
        2873- 70800             TXT       'RW '        REWIND TAPE
        2874- 72192             TXT       'SD '        SET DRUM DDR
        2875- 72240             TXT       'SE '        SENSE
        2876- 34560             TXT       'C  '        COPY
        2878+15 2892 CLRBUF   + LOAD MQ   IOCL
        2879+14 2897          + STORE MQ  BUFIO
        2880+15 2918          + LOAD MQ   IOSTORE         
        2881+ 1 2889          + TR        INIT2
        2882+15 2914 READCRD  + LOAD MQ   IORDCRD
        2883+ 1 2887          + TR        INIT1
        2884+15 2916 WRITECRD + LOAD MQ   IOWRCRD
        2885+ 1 2887          + TR        INIT1
        2886+15 2917 PRINTCRD + LOAD MQ   IOPRCRD
        2887+14 2897 INIT1    + STORE MQ  BUFIO
        2888+15 2915          + LOAD MQ   IOCOPY         
        2889+14 2898 INIT2    + STORE MQ  BUFROW
        2890+ 9 2924          + ADD       TWO          
        2891+13 2913          + STORE A   EXIT
        2892+10 2920 IOCL     + R ADD     ZERO         RESET TO INITIAL COPY LOOP ADDRESS     
        2893+13 2898          + STORE A   BUFROW       FOR BUFFER
        2894+10 2898          + R ADD     BUFROW       X .*echo Print
        2895+ 5 2925          + SUB       D48          X 
        2896+12 2922          + STORE     ENDLP        X LOOP END VALUE
        2897- 0    0   BUFIO  - STOP      /   /        READ OR WRITE
        2898-31    0   BUFROW - COPY      /   /        COPY WORD TO/FROM PRINTER/CARDREADER
        2899+ 1 2903          + TR        BUFOK2       NORMAL PROCESSING 
        2900+ 1 2910          + TR        EODECK       FOR COPY READING END OF REG (=END OF DECK BEING READ)
        2901+ 6 2924          + R SUB     TWO          END OF FILE -> NO CARD TO READ -> STOP with Acc=-2
        2902+ 0 2897          + STOP      BUFIO        ON PRESSING START RETRY CARD READ
        2903+10 2898   BUFOK2 + R ADD     BUFROW       X
        2904+ 5 2924          + SUB       TWO          INCR BUF ADDR
        2905+13 2898          + STORE A   BUFROW       X
        2906+ 5 2922          + SUB       ENDLP        CHECK FOR END
        2907+ 4 2912          + TR 0      ENDIO
        2908+10 2920          + R ADD     ZERO         CLEAR ACC IN CASE WE ARE CLEANING THE BUFFER
        2909+ 1 2898          + TR        BUFROW
        2910+10 2923 EODECK   + R ADD     ONE          SET OV FLAG TO SIGNAL END OF DECK CONDITION
        2911+22   36          + A LEFT    36
        2912+26 2052 ENDIO    + WRITE     2052         END OF I/O: INSURE THAT MQ NOT IN USE            
        2913+ 1    0 EXIT     + TR        /   /
        2914+24 2048 IORDCRD  + READ      2048         PREPARE TO READ FROM CARD READER
        2915-31    0 IOCOPY   - COPY      /   /   
        2916+26 1024 IOWRCRD  + WRITE     1024         PREPARE TO PUNCH CARD 
        2917+26  512 IOPRCRD  + WRITE     0512         PREPARE WRITE PRTBUF ON PRINTER
        2918-12    0 IOSTORE  - STORE     /   /        CLEAR BUFFER
        2919+     0             ORG       EVEN           
        2920+     0  ZERO       DEF       0            
        2921+     0             DEF       0            
        2922+     0  ENDLP      DEF       0            LOOP END VALUE
        2923+     1  ONE        DEF       1
        2924+     2  TWO        DEF       2
        2925+    48  D48        DEF       48
        2926+ 9 3197 PRTPARM2 + ADD       TWO          GET 2 PARAMS: LEN AND COL (EITHER VALUE OR VAR ADDR)
        2927+13 2946          + STORE A   PRTPRMEX
        2928+10 2936          + R ADD     PRTP1
        2929+ 9 3197          + ADD       TWO          PRINT PACKED TEXT FROM FULL-WORD VALUE IN MQ REGISTER 
        2930+13 2936          + STORE A   PRTP1        STORE ADDR OF FIRST PARAM (LEN)
        2931+ 9 3196          + ADD       ONE
        2932+13 2938          + STORE A   PRTP2        STORE ADDR OF SECOND PARAM (COL)
        2933+ 9 3196          + ADD       ONE
        2934+13 3013          + STORE A   EXIT
        2935-14 3186          - STORE MQ  NUM          SAVE VALUE TO PRINT PARAM MQ (NUM IS ALIASED TO TXT)
        2936+10    0   PRTP1  + R ADD     /   /        GET LEN: NUMBER OF CHARS TO PRINT (1..6)
        2937+12 3190          + STORE     LEN
        2938+10    0   PRTP2  + R ADD     /   /        GET COLUMN PARAM 1..72
        2939+ 3 2942          + TR +      PRTP4
        2940+13 2941          + STORE A   PRTP3        COL<0 -> INTERPRET COL AS LOC(COL) = ADDR OF COL VAR
        2941+10    0   PRTP3  + R ADD     /   /        READ VAR COL PASED AS PARAM
        2942+ 4 3013   PRTP4  + TR 0      EXIT         COL=0 -> EXIT
        2943+ 3 2945          + TR +      PRTP5
        2944+ 1 3013          + TR        EXIT         COL<0 -> EXIT
        2945+12 2996   PRTP5  + STORE     COL
        2946+ 1    0 PRTPRMEX + TR        /   /        RETURN TO CALLER
        2947+13 2936 PRTSTR   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2948+10 2948          + R ADD     *            FOR PRINT STRINGZ FROM MEM
        2949+ 1 2926          + TR        PRTPARM2
        2950+12 2960          + STORE     COLSZ
        2951+10 3190          + R ADD     LEN          LEN IS IN FACT THE LOCATION WHERE THE STRING STARTS
        2952+13 2955          + STORE A   STRZAD
        2953+10 3013          + R ADD     EXIT
        2954+13 2968          + STORE A   STRZEX
        2955+10    0 STRZAD   + R ADD     /   /        GET HALF-WORD WITH NEXT 3 CHARS TO PRINT
        2956+ 4 2968          + TR 0      STRZEX       IF +0 -> END OF STRING (-0 DOES NOT TERMINATES THE STRING)
        2957+21   35          + L RIGHT   0035         MQ=3-CHARS TO PRINT
        2958+10 2958          + R ADD     *            
        2959+ 1 2970          + TR        PRTALF       PRINT 3 CHARS
        2960+ 0    0 COLSZ    + STOP      0000         COL 
        2961+10 2955 STRZ1    + R ADD     STRZAD       INCR STRING ADDRESS
        2962+ 9 3196          + ADD       ONE
        2963+13 2955          + STORE A   STRZAD
        2964+10 2960          + R ADD     COLSZ        INCR COLUMN
        2965+ 9 3198          + ADD       D3
        2966+13 2960          + STORE A   COLSZ
        2967+ 1 2955          + TR        STRZAD
        2968+ 3    0 STRZEX   + TR +      /   /        IF ZERO -> END OF STRING
        2969+ 1 2961          + TR        STRZ1
        2970+ 9 3197 PRTALF   + ADD       TWO          PRINT 3-PACKED CHARS IN MQ REGISTER 
        2971+14 3192          + STORE MQ  TXT          SAVE TEXT TO PRINT (IN LEFT HALF WORD)
        2972+13 2975          + STORE A   PRTAP2       STORE ADDR OF PARAM (COL)
        2973+ 9 3196          + ADD       ONE
        2974+13 3013          + STORE A   EXIT
        2975+10    0   PRTAP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        2976+ 3 2979          + TR +      PRTAP4
        2977+13 2978          + STORE A   PRTAP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        2978+10    0   PRTAP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        2979+12 2996   PRTAP4 + STORE     COL
        2980+10 3198          + R ADD     D3
        2981+12 3190          + STORE     LEN
        2982+10 3180 PRT1     + R ADD     ZERO         UNPACK LEFTMOST CHAR 
        2983+11 3192          + ADD AB    TXT          GET TEXT DISCARD SIGN
        2984+21   35          + L RIGHT   0035         MQ=Acc
        2985+10 3180          + R ADD     ZERO
        2986+18 3205          + DIV       D48X48
        2987+12 3192          + STORE     TXT          remainder=char to print, mq=c2 * 48 + c3 in right half-word
        2988+10 3180          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        2989+20   18          + L LEFT    0018         put c2 and c3 in left half-word of MQ to be saved in CHAR half word
        2990+14 3191          + STORE MQ  CHAR         CHAR TO PRINT
        2991+10 3191          + R ADD     CHAR 
        2992+ 4 2997          + TR 0      NXTCHR       IF BLANK PROCEED TO NEXT COL
        2993+21   35          + L RIGHT   0035         MQ=CHAR TO PRINT
        2994+10 2994          + R ADD     *            PRINT CHAR
        2995+ 1 3090          + TR        PRTCHR
        2996+ 0    0 COL      + STOP      0000         COL: COLUMN NUMBER TO PRINT (1..72)
        2997+10 3190 NXTCHR   + R ADD     LEN          DECR LEN COUNT
        2998+ 5 3196          + SUB       ONE
        2999+12 3190          + STORE     LEN
        3000+ 4 3013          + TR 0      EXIT         IF NO MORE CHARS TO PRINT EXIT
        3001+10 2996          + R ADD     COL          INCR COL POSITION
        3002+ 9 3196          + ADD       ONE
        3003+12 2996          + STORE     COL
        3004+ 5 3204          + SUB       D72          IF COL > 72 RETURN TO CALLER
        3005+ 4 3007          + TR 0      GNXTCHR      ELSE PROCEED WITH NEXT CHAR
        3006+ 3 3013          + TR +      EXIT
        3007+10 3180 GNXTCHR  + R ADD     ZERO         GET NEXT CHAR 
        3008+15 3192          + LOAD MQ   TXT
        3009+16 3203          + MPY       D48
        3010+22   17          + A LEFT    0017         GET RESULT IN LEFT HALF-WORD OF ACC
        3011+12 3192          + STORE     TXT
        3012+ 1 2982          + TR        PRT1         PROCEED TO PRINT CHAR
        3013+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        3014+13 2936 PRTOCT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        3015+10 3015          + R ADD     *            FOR PRINT OCTIONARY VALUE
        3016+ 1 2926          + TR        PRTPARM2
        3017+10 3190          + R ADD     LEN          LEN = OCTAL DIGITS TO PRINT
        3018+ 9 2996          + ADD       COL
        3019+ 5 3196          + SUB       ONE
        3020+12 3032          + STORE     COLN         COL POINTS TO LEAST SIGNIFICANT DIGIT
        3021+10 3186 PRTIOCG  + R ADD     NUM          GENERATE OCTINARY DIGIT
        3022+15 3180          + LOAD MQ   ZERO         CLEAR MQ
        3023+21   21          + L RIGHT   0021         3 LSB BITS OF LEFT HALF-WORD OF ACC TO MQ
        3024+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 3 BIT)
        3025+12 3186          + STORE     NUM          SAVE BACK NUM WITH RIGHTMOST OCTIONARY DIGIY EXTRACTED (NUM'=NUM/8)
        3026+10 3180          + R ADD     ZERO
        3027+20   21          + L LEFT    0021         LEFT HALF-WORD OF ACC IS NOW RIGHTMOST OCTINARY DIGIT EXTRACTED FROM NUM 
        3028+ 4 3046          + TR 0      PRTIOZ       TR IF THIS DIGIT IS ZERO TO PRINT A '0' (BASE48 CODE = 10) INSTEAD OF A BLANK (BASE48 CODE = 0)
        3029+21   35          + L RIGHT   0035         PUT DIGIT 1..9 TO PRINT IN MQ
        3030+10 3030 PRTOCTD  + R ADD     *            PRINT OCTINARY DIGIT
        3031+ 1 3090          + TR        PRTCHR
        3032+ 0    0 COLN     + STOP      0000
        3033+10 3032          + R ADD     COLN        DECR COL NUMBER TO PRINT NEXT DIGIT
        3034+ 5 3196          + SUB       ONE
        3035+12 3032          + STORE     COLN
        3036+10 3190          + R ADD     LEN          DECR COL NUMBER TO PRINT NEXT DIGIT
        3037+ 5 3196          + SUB       ONE
        3038+ 4 3013          + TR 0      EXIT         PRINTED LEN OCTINARY DIGITS -> EXIT
        3039+12 3190          + STORE     LEN
        3040+10 3186          + R ADD     NUM          IF NUM < 0, ADD SIGN BIT TO LEFTMOST DIGIT
        3041+ 3 3021          + TR +      PRTIOCG
        3042+10 3206          + R ADD     OCT04K       
        3043+ 5 3186          + SUB       NUM
        3044+12 3186          + STORE     NUM
        3045+ 1 3021          + TR        PRTIOCG
        3046+15 3199   PRTIOZ + LOAD MQ   D10          ACC=BASE48 CODE FOR '0'
        3047+ 1 3030          + TR        PRTOCTD      TR TO PRINT IT
        3048+13 2936 PRTINT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        3049+10 3049          + R ADD     *            FOR PRINT OCTIONARY VALUE
        3050+ 1 2926          + TR        PRTPARM2
        3051+10 2996          + R ADD     COL          PRINT DECIMAL NUMBER. VALUE OF LEN = DIGITS TO PRINT, NOT INCLUDING SIGN
        3052+ 9 3190          + ADD       LEN
        3053+ 5 3196          + SUB       ONE          
        3054+12 3075          + STORE     COLNI        COL POINTS TO END OF NUMBER
        3055+10 3180          + R ADD     ZERO
        3056+12 3189          + STORE     SGN          SIGN IS POSITIVE
        3057+10 3186          + R ADD     NUM
        3058+ 3 3063          + TR +      PRTINTG
        3059+ 6 3186          + R SUB     NUM          NUM IS NEGATIVE. CONVERT TO POSITIVE
        3060+12 3186          + STORE     NUM          AND SET SGN=1
        3061+10 3196          + R ADD     ONE
        3062+12 3189          + STORE     SGN          
        3063+10 3186 PRTINTG  + R ADD     NUM          GENERATE DECIMAL DIGIT
        3064+21   35          + L RIGHT   0035         MQ=Acc
        3065+10 3180          + R ADD     ZERO
        3066+18 3199          + DIV       D10
        3067+ 4 3088          + TR 0      PRTINZ
        3068+12 3191 PRTINTG2 + STORE     CHAR         acc=remainder=digit to print, mq=num/10
        3069+10 3180          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        3070+20   18          + L LEFT    0018         digit in left half-word of MQ to be saved in CHAR half word
        3071+14 3186          + STORE MQ  NUM 
        3072+15 3191          + LOAD MQ   CHAR 
        3073+10 3073 PRTINTD  + R ADD     *            PRINT DECIMAL DIGIT
        3074+ 1 3090          + TR        PRTCHR
        3075+ 0    0 COLNI    + STOP      0000
        3076+10 3075          + R ADD     COLNI        DECR COL NUMBER TO PRINT NEXT DIGIT
        3077+ 5 3196          + SUB       ONE
        3078+12 3075          + STORE     COLNI
        3079+10 3186          + R ADD     NUM          DO NOT CARE ABOUT LEN, JUST CHECK IF NUM=0 
        3080+ 4 3082          + TR 0      PRTINS       (SO NO MORE DIGITS REMAINS TO BE PRINTED)
        3081+ 1 3063          + TR        PRTINTG      NUM NOT FINISHED, PROCEED WITH NEXT DIGIT
        3082+10 3189 PRTINS   + R ADD     SGN
        3083+ 4 3013          + TR 0      EXIT         NO SIGN -> NUM FINISHED
        3084+10 3180          + R ADD     ZERO
        3085+12 3189          + STORE     SGN          CLEAR SGN FLAG
        3086+15 3200          + LOAD MQ   D11          BASE48 CODE FOR '-' (MINUS) CHAR
        3087+ 1 3073          + TR        PRTINTD      GO TO PRINT IT
        3088+10 3199   PRTINZ + R ADD     D10          ACC=BASE48 CODE FOR '0'
        3089+ 1 3068          + TR        PRTINTG2     TR TO PRINT IT
        3090+ 9 3197 PRTCHR   + ADD       TWO          PRINT CHAR IN MQ REGISTER 
        3091+14 3191          + STORE MQ  CHAR         SAVE CHAR TO PRINT (IN LEFT HALF WORD)
        3092+13 3096          + STORE A   PRTCP2       STORE ADDR OF PARAM (COL)
        3093+ 9 3196          + ADD       ONE
        3094+13 3174          + STORE A   PRTCEX
        3095+ 2 3096          + TR OV     PRTCP2       CLEAR OV JUST IN CASE
        3096+10    0   PRTCP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        3097+ 3 3100          + TR +      PRTCP4
        3098+13 3099          + STORE A   PRTCP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        3099+10    0   PRTCP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        3100+ 5 3196   PRTCP4 + SUB       ONE
        3101+12 3194          + STORE     N            N=COL-1 -> IN RANGE 0..71
        3102+ 3 3104          + TR +      PRTSA        IF N >= 0 PROCEED WITH BASE BUFFER ADDR CALCULATION
        3103+ 1 3174          + TR        PRTCEX       IF N<0 EXIT
        3104+10 3180    PRTSA + R ADD     ZERO         CARD BUFFER USES LOCATION 0..47
        3105+13 3193          + STORE A   PRTROWAD     DETERMINE ADDRESS OF LOWER ROW TO PRINT
        3106+10 3194          + R ADD     N
        3107+ 5 3202          + SUB       D36
        3108+ 3 3110          + TR +      PRTC0
        3109+ 1 3116          + TR        PRTC1
        3110+12 3194    PRTC0 + STORE     N            COL NOW 0..35 
        3111+ 5 3202          + SUB       D36
        3112+ 3 3174          + TR +      PRTCEX       IF COL >= 36 (IE COL PASSED AS PARAM > 72) THEN EXIT
        3113+10 3193          + R ADD     PRTROWAD
        3114+ 9 3197          + ADD       TWO
        3115+13 3193          + STORE A   PRTROWAD     SET BASE BUFFER ADDR 
        3116+10 3196    PRTC1 + R ADD     ONE          DETERMINE MASKCOL WITH MASK TO SET IN CARD BUFFER
        3117+21   53          + L RIGHT   53           SET RIGHTMOST BIT OF MQ TO 1 (SHIFT 35+18=53)
        3118+10 3201          + R ADD     D35
        3119+ 5 3194          + SUB       N
        3120+13 3122          + STORE A   PRTC2
        3121+10 3180          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW
        3122+20    0    PRTC2 + L LEFT    /   /        SHIFT MQ LEFT N PLACES
        3123+ 4 3126          + TR 0      PRTC3        IF ACC STILL ZERO -> MASKCOL VALID
        3124+ 6 3196          + R SUB     ONE          ACC NOT ZERO -> SHOULD GENERATE -0 TO SET SIGN BIT ON
        3125+21   72          + L RIGHT   0072         NOW MQ = -0 -> LEFTMOST BIT OF MQ SET
        3126-14 3182    PRTC3 - STORE MQ  MASKCOL
        3127+10 3180          + R ADD     ZERO         READ THE BITMAP OF CHAR 
        3128+11 3191          + ADD AB    CHAR         DISCARD SIGN OF CHAR, IF ANY
        3129+12 3191          + STORE     CHAR
        3130+ 5 3203          + SUB       D48
        3131+ 3 3174          + TR +      PRTCEX       IF CHAR >= 48 EXIT
        3132+10 3188          + R ADD     BITMAPAD     IF ADDR OF BASE48 BITMAP NOT COMPUTED
        3133+ 4 3175          + TR 0      GETBMP1      TR TO LOAD IT
        3134+ 9 3191  GETBMP2 + ADD       CHAR         READ THE BITMAP OF CHAR 
        3135+13 3136          + STORE A   PRTC4        INDICATES THE BITS TO SET IN SELECTED 
        3136+10    0    PRTC4 + R ADD     /   /        COLUMN OF CARD BUFFER 
        3137+12 3195          + STORE     BITS
        3138+ 6 3196          + R SUB     ONE
        3139+12 3194          + STORE     N            SET TO -1
        3140+10 3194    LOOP1 + R ADD     N            CURRENT ROW (STARTS AT ZERO) = OFFSET ON PRTROWAD     
        3141+ 9 3196          + ADD       ONE
        3142+12 3194          + STORE     N
        3143+10 3195          + R ADD     BITS         EXTRACT RIGHTMOST BIT OF LEFT HALF OF ACC TO MQ
        3144+ 4 3174          + TR 0      PRTCEX       NO MORE BITS -> EXIT
        3145+21   19          + L RIGHT   0019         LSB BIT OF LEFT HALF-WORD OF ACC TO MQ
        3146+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 1 BIT)
        3147+12 3195          + STORE     BITS         SAVE BACK BITS. LSB HAS BEEN EXTACTED, CONTENTS SHIFTED RIGHT ONE PLACE
        3148+10 3180          + R ADD     ZERO
        3149+20    1          + L LEFT    0001         PUT EXTACTED BIT BACK INTO ACC
        3150+ 4 3140          + TR 0      LOOP1        NO BIT 
        3151+10 3194          + R ADD     N            READ THE ROW N AT CARD BUFFER 
        3152+22    2          + A LEFT    0002         MULT N BY 4 AS THERE ARE 4 HALF WORDS PER ROW
        3153+ 9 3193          + ADD       PRTROWAD     
        3154+13 3156          + STORE A   PRTROWR
        3155+13 3172          + STORE A   PRTROWW
        3156-10    0  PRTROWR - R ADD     /   /        
        3157-12 3184          - STORE     ROW          CURRENT CONTENTS OF ROW
        3158-10 3182          - R ADD     MASKCOL      "OR" MASKCOL IN SELECTED ROW
        3159+ 3 3167          + TR +      PRTW2
        3160-10 3184          - R ADD     ROW 
        3161+ 4 3165          + TR 0      PRTW1         
        3162+10 3180          + R ADD     ZERO         MASKCOL IS MINUS ZERO AND ROW IS NOT-EMPTY (EITHER POSITIVE OR NEGATIVE) -> SET ROW AS NEGATIVE
        3163- 7 3184          - SUB AB    ROW 
        3164+ 1 3172          + TR        PRTROWW
        3165-10 3182    PRTW1 - R ADD     MASKCOL      MASKCOL IS MINUS ZERO AND ROW IS EMPTY -> SET ROW = MASKCOL = MINUS ZERO
        3166+ 1 3172          + TR        PRTROWW
        3167-10 3184    PRTW2 - R ADD     ROW          
        3168+ 3 3171          + TR +      PRTW3              
        3169- 5 3182          - SUB       MASKCOL      MASKCOL IS POSITIVE AND ROW IS NEGATIVE -> SUB MASKCOL FROM ROW
        3170+ 1 3172          + TR        PRTROWW
        3171- 9 3182    PRTW3 - ADD       MASKCOL      MASKCOL IS POSITIVE AND ROW IS POSITIVE OR EMPTY -> ADD MASKCOL TO ROW         
        3172-12    0  PRTROWW - STORE     /   /        ROW UPDTATE
        3173+ 1 3140          + TR        LOOP1        PROCEED TO NEXT ROW
        3174+ 1    0 PRTCEX   + TR        /   /
        3175+10 3175 GETBMP1  + R ADD     *
        3176+ 1   91          + TR        BMPAD        GET BASE48 CHARS BITMAP ADDRESS
        3177+12 3188          + STORE     BITMAPAD     
        3178+ 1 3134          + TR        GETBMP2      RETURN
        3179+     0             ORG       EVEN
        3180+     0  ZERO       DEF       0            
        3181+     0             DEF       0            
        3182+     0  MASKCOL    DEF       0
        3183+     0             DEF       0
        3184+     0  ROW        DEF       0
        3185+     0             DEF       0
        3186+     0  NUM        DEF       0
        3187+     0             DEF       0
        3188+     0  BITMAPAD   DEF       0
        3189+     0  SGN        DEF       0
        3190+     0  LEN        DEF       0
        3191+     0  CHAR       DEF       0
        3192+     0  TXT        DEF       0
        3193+     0  PRTROWAD   DEF       0
        3194+     0  N          DEF       0
        3195+     0  BITS       DEF       0
        3196+     1  ONE        DEF       1
        3197+     2  TWO        DEF       2
        3198+     3  D3         DEF       3
        3199+    10  D10        DEF       10
        3200+    11  D11        DEF       11
        3201+    35  D35        DEF       35
        3202+    36  D36        DEF       36
        3203+    48  D48        DEF       48
        3204+    72  D72        DEF       72
        3205+  2304  D48X48     DEF       2304
        3206+ 16384  OCT04K     DEF       *040000      BIT SIGN ON 5TH OCTINARY DIGIT
        3208+ 9 3283 PRTNLINE + ADD       TWO          PRINT A NEW LINE OF DATA
        3209+12 3286          + STORE     PARAM        SAVE PARAM LIST ADDR
        3210+10 3210          + R ADD     *            CLEAR CARD BUFFER
        3211+ 1   53          + TR        CLRBUF 
        3212+10 3286 GPARAM   + R ADD     PARAM        GET PARAM PAIR FMT/DATA
        3213+13 3218          + STORE A   P1
        3214+ 9 3282          + ADD       ONE
        3215+13 3222          + STORE A   P2
        3216+ 9 3282          + ADD       ONE
        3217+12 3286          + STORE     PARAM
        3218+10    0 P1       + R ADD     /   /
        3219+12 3288          + STORE     FMT
        3220+ 3 3222          + TR +      P2           IF FMT < 0 THEM SKIP THIS PAIR FMT/DATA
        3221+ 1 3212          + TR        GPARAM
        3222+10    0 P2       + R ADD     /   /
        3223+12 3248          + STORE     DATALOC      GET DATA ADDRESS PASED AS PARAM
        3224+13 3225          + STORE A   P2A
        3225+10    0 P2A      + R ADD     /   /
        3226+12 3287          + STORE     DATA         GET EFFECTIVE DATA
        3227+10 3281          + R ADD     ZERO
        3228+15 3288          + LOAD MQ   FMT
        3229+18 3285          + DIV       D100         ACC=REMAINDER=COL NUMBER, MQ=QUOTIEN=TYPE OF DATA
        3230+12 3289          + STORE     COL
        3231+10 3281          + R ADD     ZERO
        3232+20   18          + L LEFT    0018
        3233+14 3288          + STORE MQ  FMT
        3234+15 3287          + LOAD MQ   DATA
        3235+10 3239          + R ADD     TYPETRAD
        3236+ 9 3288          + ADD       FMT
        3237+13 3238          + STORE A   TYPETR
        3238+ 1    0 TYPETR   + TR        /   /        TR SELECTED ROUTINE
        3239+ 0 3240 TYPETRAD + STOP      TYPETRT      TYPE TRANSFER TABLE ADDRESS
        3240+ 1 3269 TYPETRT  + TR        EOL          FMT=0..6 (IE <100) -> END OF PARAM LIST -> END OF LINE 
        3241+ 1 3246          + TR        TYSTR        FMT=1 -> PRINT A STRINGZ
        3242+ 1 3251          + TR        TYINT        FMT=2 -> PRINT AN INT
        3243+ 1 3256          + TR        TYOCT        FMT=3 -> PRINT AN OCT
        3244+ 1 3261          + TR        TYCHR        FMT=4 -> PRINT A CHAR
        3245+ 1 3265          + TR        TYALF        FMT=5 -> PRINT A 3-CHR PACKED ALFA STRING
        3246+10 3246 TYSTR    + R ADD     *            PRINT STRINGZ
        3247+ 1   59          + TR        PRTSTR
        3248+ 0    0 DATALOC  + STOP      /   /
        3249- 0 3289          - STOP      COL          COLUMN WHERE TXT STARTS
        3250+ 1 3212          + TR        GPARAM
        3251+10 3251 TYINT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        3252+ 1   63          + TR        PRTINT
        3253+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        3254- 0 3289          - STOP      COL          COLUMN WHERE TXT STARTS
        3255+ 1 3212          + TR        GPARAM
        3256+10 3256 TYOCT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        3257+ 1   89          + TR        PRTOCT
        3258+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        3259- 0 3289          - STOP      COL          COLUMN WHERE TXT STARTS
        3260+ 1 3212          + TR        GPARAM
        3261+10 3261 TYCHR    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        3262+ 1   65          + TR        PRTCHR
        3263- 0 3289          - STOP      COL          COLUMN WHERE TXT STARTS
        3264+ 1 3212          + TR        GPARAM
        3265+10 3265 TYALF    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        3266+ 1   61          + TR        PRTALF
        3267- 0 3289          - STOP      COL          COLUMN WHERE TXT STARTS
        3268+ 1 3212          + TR        GPARAM
        3269+10 3289 EOL      + R ADD     COL          SEND CARD BUFFER TO PRINTER AND RETURN TO CALLER
        3270+ 4 3275          + TR 0      DOPRINT      =0 -> PRINT ALLWAYS (NO SENSE SW CHECK)
        3271+ 9 3284          + ADD       D68          =1..6 -> SENSE 69..74 = OPERATOR'S PANEL SENSE SWITCH 1..6
        3272+13 3273          + STORE A   CHKSW
        3273+30    0 CHKSW    + SENSE     /   /         
        3274+ 1 3277          + TR        RETURN       SW NOT AT ON POSITION
        3275+10 3275 DOPRINT  + R ADD     *            PRINT CARD BUFFER
        3276+ 1   57          + TR        PRINTCRD
        3277+10 3286 RETURN   + R ADD     PARAM        PARAM-1 IS THE RETURN ADDR      
        3278+ 5 3282          + SUB       ONE
        3279+13 3280          + STORE A   EXIT
        3280+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        3281+ 0    0 ZERO     + STOP      0000
        3282+ 0    1 ONE      + STOP      0001
        3283+ 0    2 TWO      + STOP      0002
        3284+ 0   68 D68      + STOP      0068
        3285+ 0  100 D100     + STOP      100
        3286+ 0    0 PARAM    + STOP      0000
        3287+ 0    0 DATA     + STOP      0000
        3288+ 0    0 FMT      + STOP      0000
        3289+ 0    0 COL      + STOP      0000
        3290+ 9 3304 BMPAD    + ADD       TWO
        3291+13 3293          + STORE A   EXIT
        3292+10 3294          + R ADD     BITMAPAD
        3293+ 1    0 EXIT     + TR        /   /
        3294+ 0 3296 BITMAPAD + STOP      BITMAP
        3295+     0             ORG       EVEN
        3296+     0  BITMAP     DEF       0              <blank>     0     <none>
        3297+   256             DEF       256               1        1       1        256          =  256   
        3298+   128             DEF       128               2        2       2        128          =  128   
        3299+    64             DEF       64                3        3       3         64          =   64   
        3300+    32             DEF       32                4        4       4         32          =   32   
        3301+    16             DEF       16                5        5       5         16          =   16   
        3302+     8             DEF       8                 6        6       6          8          =    8   
        3303+     4             DEF       4                 7        7       7          4          =    4   
        3304+     2  TWO        DEF       2                 8        8       8          2          =    2   
        3305+     1             DEF       1                 9        9       9          1          =    1   
        3306+   512             DEF       512               0       10       0        512          =  512   
        3307+  1024             DEF       1024              -       11       X       1024          = 1024   
        3308+  2048             DEF       2048              +       12       Y       2048          = 2048   
        3309+  2304             DEF       2304              A       13      Y-1        256+2048    = 2304   
        3310+  2176             DEF       2176              B       14      Y-2        128+2048    = 2176   
        3311+  2112             DEF       2112              C       15      Y-3         64+2048    = 2112   
        3312+  2080             DEF       2080              D       16      Y-4         32+2048    = 2080   
        3313+  2064             DEF       2064              E       17      Y-5         16+2048    = 2064   
        3314+  2056             DEF       2056              F       18      Y-6          8+2048    = 2056   
        3315+  2052             DEF       2052              G       19      Y-7          4+2048    = 2052   
        3316+  2050             DEF       2050              H       20      Y-8          2+2048    = 2050   
        3317+  2049             DEF       2049              I       21      Y-9          1+2048    = 2049   
        3318+  1280             DEF       1280              J       22      X-1        256+1024    = 1280   
        3319+  1152             DEF       1152              K       23      X-2        128+1024    = 1152   
        3320+  1088             DEF       1088              L       24      X-3         64+1024    = 1088   
        3321+  1056             DEF       1056              M       25      X-4         32+1024    = 1056   
        3322+  1040             DEF       1040              N       26      X-5         16+1024    = 1040   
        3323+  1032             DEF       1032              O       27      X-6          8+1024    = 1032   
        3324+  1028             DEF       1028              P       28      X-7          4+1024    = 1028   
        3325+  1026             DEF       1026              Q       29      X-8          2+1024    = 1026   
        3326+  1025             DEF       1025              R       30      X-9          1+1024    = 1025   
        3327+   640             DEF       640               S       31      0-2        128+512     = 640    
        3328+   576             DEF       576               T       32      0-3         64+512     = 576    
        3329+   544             DEF       544               U       33      0-4         32+512     = 544    
        3330+   528             DEF       528               V       34      0-5         16+512     = 528    
        3331+   520             DEF       520               W       35      0-6          8+512     = 520    
        3332+   516             DEF       516               X       36      0-7          4+512     = 516    
        3333+   514             DEF       514               Y       37      0-8          2+512     = 514    
        3334+   513             DEF       513               Z       38      0-9          1+512     = 513    
        3335+   578             DEF       578               ,       39      8-3-0        2+64+512  = 578    
        3336+   546             DEF       546               %       40      8-4-0        2+32+512  = 546    
        3337+  1090             DEF       1090              $       41      8-3-X        2+64+1024 = 1090   
        3338+  1058             DEF       1058              *       42      8-4-X        2+32+1024 = 1058   
        3339+  2114             DEF       2114              .       43      8-3-Y        2+64+2048 = 2114   
        3340+  2082             DEF       2082              #       44      8-4-Y        2+32+2048 = 2082   
        3341+   768             DEF       768               /       45      0-1          512+256   = 768    
        3342+    66             DEF       66                +       46      8-3          2+64      = 66     
        3343+    34             DEF       34                -       47      8-4          2+32      = 34    This is the non-minus-sign separator
        3344+ 9 3368 CLMEM    + ADD       TWO 
        3345+13 3350          + STORE A   P1           PARM: ADDR 
        3346+ 9 3367          + ADD       ONE          
        3347+13 3352          + STORE A   P2           PARM: LOCATION OF LEN=NUMBER OF HALF-WORDS TO CLEAR 
        3348+ 9 3367          + ADD       ONE          
        3349+13 3358          + STORE A   EXIT
        3350+10    0 P1       + R ADD     /   /        GET ADDR TO CLEAR
        3351+13 3361          + STORE A   MEM
        3352+10    0 P2       + R ADD     /   /        GET LEN ADDR
        3353+13 3354          + STORE A   P2A
        3354+10    0 P2A      + R ADD     /   /        GET LEN 
        3355+12 3369          + STORE     LEN
        3356+15 3366          + LOAD MQ   ZERO
        3357+10 3369 LOOP     + R ADD     LEN
        3358+ 4    0 EXIT     + TR 0      /   /
        3359+ 5 3367          + SUB       ONE
        3360+12 3369          + STORE     LEN
        3361+14    0 MEM      + STORE MQ  /   /        
        3362+10 3361          + R ADD     MEM
        3363+ 9 3367          + ADD       ONE
        3364+13 3361          + STORE A   MEM
        3365+ 1 3357          + TR        LOOP
        3366+ 0    0 ZERO     + STOP      0000
        3367+ 0    1 ONE      + STOP      0001         constant 1
        3368+ 0    2 TWO      + STOP      0002         constant 2
        3369+ 0    0 LEN      + STOP      0000
        3370+ 9 3402 MEMCOPY  + ADD       TWO 
        3371+13 3378          + STORE A   P1           PARM: SRCADDR 
        3372+ 9 3401          + ADD       ONE          
        3373+13 3380          + STORE A   P2           PARM: DESTADDR
        3374+ 9 3401          + ADD       ONE          
        3375+13 3382          + STORE A   P3           PARM: LEN: LOCATION OF LEN=NUMBER OF HALF-WORDS TO CLEAR
        3376+ 9 3401          + ADD       ONE          
        3377+13 3388          + STORE A   EXIT
        3378+10    0 P1       + R ADD     /   /        GET SOURCE ADDR 
        3379+13 3391          + STORE A   MEMS
        3380+10    0 P2       + R ADD     /   /        GET DESTINATION ADDR 
        3381+13 3392          + STORE A   MEMD
        3382+10    0 P3       + R ADD     /   /        GET LEN ADDR
        3383+13 3384          + STORE A   P3A
        3384+10    0 P3A      + R ADD     /   /        GET LEN           
        3385+12 3403          + STORE     LEN
        3386+15 3400          + LOAD MQ   ZERO
        3387+10 3403 LOOP     + R ADD     LEN
        3388+ 4    0 EXIT     + TR 0      /   /
        3389+ 5 3401          + SUB       ONE
        3390+12 3403          + STORE     LEN
        3391+10    0 MEMS     + R ADD     /   /        
        3392+12    0 MEMD     + STORE     /   /        
        3393+10 3391          + R ADD     MEMS
        3394+ 9 3401          + ADD       ONE
        3395+13 3391          + STORE A   MEMS
        3396+10 3392          + R ADD     MEMD
        3397+ 9 3401          + ADD       ONE
        3398+13 3392          + STORE A   MEMD
        3399+ 1 3387          + TR        LOOP
        3400+ 0    0 ZERO     + STOP      0000
        3401+ 0    1 ONE      + STOP      0001         constant 1
        3402+ 0    2 TWO      + STOP      0002         constant 2
        3403+ 0    0 LEN      + STOP      0000
        3404+15 3471 SRCHTBL  + LOAD MQ   ZERO
        3405+ 1 3409          + TR        START
        3406+15 3472 EQTBL    + LOAD MQ   ONE
        3407+ 1 3409          + TR        START
        3408+15 3473 READTBL  + LOAD MQ   TWO
        3409+ 9 3473 START    + ADD       TWO 
        3410+13 3417          + STORE A   P1           PARM: ADDR OF TABLE
        3411+ 9 3472          + ADD       ONE          
        3412+13 3419          + STORE A   P2           PARM: LEN OF TABLE
        3413+ 9 3472          + ADD       ONE          
        3414+13 3424          + STORE A   P3           PARM: VAL TO FIND
        3415+ 9 3472          + ADD       ONE          
        3416+13 3465          + STORE A   EXIT
        3417+10    0 P1       + R ADD     /   /        GET ADDR OF TABLE
        3418+13 3468          + STORE A   TBL
        3419+10    0 P2       + R ADD     /   /        GET ADDR OF LEN OF TABLE/ENTRY ON TABLE
        3420+13 3421          + STORE A   P2A
        3421+10    0 P2A      + R ADD     /   /        DERREFERENCE -> ACC=LEN/ENTRY (1..LEN)
        3422+12 3466          + STORE     N
        3423+ 4 3465          + TR 0      EXIT         EXIT, CANNOT READ/STORE ON ENTRY 0, SEARCH ON EMPTY TABLE
        3424+10    0 P3       + R ADD     /   /        GET ADDR OF VAL TO FIND
        3425+13 3441          + STORE A   WRVAL
        3426+13 3427          + STORE A   P3A
        3427+10    0 P3A      + R ADD     /   /        DERREFERENCE -> ACC=VAL
        3428+12 3467          + STORE     VAL
        3429+14 3470          + STORE MQ  TEMP         JUMP TABLE DISPATCH
        3430+10 3470          + R ADD     TEMP
        3431+ 4 3446          + TR 0      LOOP0        TR TO SEARCH TABLE
        3432+10 3466          + R ADD     N            SUB ONE AS FIRST ENTRY ON TABLE IS "1"
        3433+ 5 3472          + SUB       ONE          
        3434+ 9 3468          + ADD       TBL          TABLE BASE ADDR
        3435+13 3444          + STORE A   WRTBL
        3436+13 3440          + STORE A   RDTBL2
        3437+10 3470          + R ADD     TEMP
        3438+ 5 3472          + SUB       ONE
        3439+ 4 3443          + TR 0      STORETBL 
        3440+10    0 RDTBL2   + R ADD     /   /        VAL=TBL[ENT]
        3441+12    0 WRVAL    + STORE     /   /
        3442+ 1 3465          + TR        EXIT
        3443+10 3467 STORETBL + R ADD     VAL          TBL[ENT]=VAL
        3444+12    0 WRTBL    + STORE     /   /    
        3445+ 1 3465          + TR        EXIT
        3446+10 3468 LOOP0    + R ADD     TBL
        3447+13 3453          + STORE A   RDTBL
        3448+10 3453          + R ADD     RDTBL
        3449+12 3469          + STORE     TBL0
        3450+ 9 3466          + ADD       N
        3451+12 3470          + STORE     TEMP         THE END ADDR OF TABLE
        3452+10 3467 LOOP     + R ADD     VAL          ACC=THE SEARCHED VALUE
        3453+ 5    0 RDTBL    + SUB       /   /    
        3454+ 2 3455          + TR OV     OVOK         CLEAR OV JUST IN CASE
        3455+ 4 3462 OVOK     + TR 0      FOUND        TR IF VAL FOUND IN ENTRY N
        3456+10 3453          + R ADD     RDTBL
        3457+ 9 3472          + ADD       ONE
        3458+13 3453          + STORE A   RDTBL
        3459+ 5 3470          + SUB       TEMP
        3460+ 4 3465          + TR 0      EXIT         NOT FOUND -> RETURN ZERO
        3461+ 1 3452          + TR        LOOP
        3462+10 3453 FOUND    + R ADD     RDTBL        RETURN ENTRY FOUND
        3463+ 5 3469          + SUB       TBL0
        3464+ 9 3472          + ADD       ONE
        3465+ 1    0 EXIT     + TR        /   /
        3466+ 0    0 N        + STOP      0000
        3467+ 0    0 VAL      + STOP      0000
        3468+ 0    0 TBL      + STOP      0000
        3469+ 0    0 TBL0     + STOP      0000
        3470+ 0    0 TEMP     + STOP      0000
        3471+ 0    0 ZERO     + STOP      0000
        3472+ 0    1 ONE      + STOP      0001         constant 1
        3473+ 0    2 TWO      + STOP      0002         constant 2
        3474+ 9 3515 READTBL2 + ADD       TWO 
        3475+13 3482          + STORE A   P1           PARM: ADDR OF TABLE
        3476+ 9 3514          + ADD       ONE          
        3477+13 3484          + STORE A   P2           PARM: MAX LEN OF TABLE
        3478+ 9 3514          + ADD       ONE          
        3479+13 3488          + STORE A   P3           PARM: ENT TO GET
        3480+ 9 3514          + ADD       ONE          
        3481+13 3495          + STORE A   PVAL         PARM: VAL TO GET
        3482+10    0 P1       + R ADD     /   /        GET ADDR OF TABLE
        3483+13 3513          + STORE A   TBL
        3484+10    0 P2       + R ADD     /   /        GET ADDR OF MAX LEN OF TABLE
        3485+13 3486          + STORE A   P2A
        3486+10    0 P2A      + R ADD     /   /        DERREFERENCE -> ACC=MAX
        3487+12 3512          + STORE     MAX
        3488+10    0 P3       + R ADD     /   /        GET ADDR OF ENTRY TO GET
        3489+13 3490          + STORE A   P3A
        3490+10    0 P3A      + R ADD     /   /        DERREFERENCE -> ACC=ENT
        3491+ 4 3507          + TR 0      ENT0         EXIT, CANNOT READ ON ENTRY 0
        3492+ 5 3514          + SUB       ONE          
        3493+ 9 3513          + ADD       TBL          TABLE BASE ADDR
        3494+13 3498          + STORE A   RDTBL        TBL[ENT] ADDRESS
        3495+10    0 PVAL     + R ADD     /   /        GET ADDR OF VAL TO FIND
        3496+ 4 3508          + TR 0      PARAMEND     END OF PARAM LIST
        3497+13 3499          + STORE A   WRVAL
        3498+10    0 RDTBL    + R ADD     /   /        VAL=TBL[ENT]
        3499+12    0 WRVAL    + STORE     /   /
        3500+10 3495          + R ADD     PVAL         SELECT NEXT PARAM FROM LIST
        3501+ 9 3514          + ADD       ONE
        3502+13 3495          + STORE A   PVAL
        3503+10 3498          + R ADD     RDTBL
        3504+ 9 3512          + ADD       MAX
        3505+13 3498          + STORE A   RDTBL
        3506+ 1 3495          + TR        PVAL     
        3507+ 0 2222 ENT0     + STOP      2222         CANNOT READTBL ON ENTRY 0
        3508+10 3495 PARAMEND + R ADD     PVAL         GET RETURN ADDR AND EXIT
        3509+ 9 3514          + ADD       ONE
        3510+13 3511          + STORE A   EXIT
        3511+ 1    0 EXIT     + TR        /   /
        3512+ 0    0 MAX      + STOP      0000
        3513+ 0    0 TBL      + STOP      0000
        3514+ 0    1 ONE      + STOP      0001         constant 1
        3515+ 0    2 TWO      + STOP      0002         constant 2
        3516+ 9 3557 EQTBL2   + ADD       TWO 
        3517+13 3524          + STORE A   P1           PARM: ADDR OF TABLE
        3518+ 9 3556          + ADD       ONE          
        3519+13 3526          + STORE A   P2           PARM: MAX LEN OF TABLE
        3520+ 9 3556          + ADD       ONE          
        3521+13 3530          + STORE A   P3           PARM: ENT TO SET
        3522+ 9 3556          + ADD       ONE          
        3523+13 3537          + STORE A   PVAL         PARM: VAL TO SET
        3524+10    0 P1       + R ADD     /   /        GET ADDR OF TABLE
        3525+13 3555          + STORE A   TBL
        3526+10    0 P2       + R ADD     /   /        GET ADDR OF MAX LEN OF TABLE
        3527+13 3528          + STORE A   P2A
        3528+10    0 P2A      + R ADD     /   /        DERREFERENCE -> ACC=MAX
        3529+12 3554          + STORE     MAX
        3530+10    0 P3       + R ADD     /   /        GET ADDR OF ENTRY TO SET
        3531+13 3532          + STORE A   P3A
        3532+10    0 P3A      + R ADD     /   /        DERREFERENCE -> ACC=ENT
        3533+ 4 3549          + TR 0      ENT0         EXIT, CANNOT READ ON ENTRY 0
        3534+ 5 3556          + SUB       ONE          
        3535+ 9 3555          + ADD       TBL          TABLE BASE ADDR
        3536+13 3541          + STORE A   WRTBL        TBL[ENT] ADDRESS
        3537+10    0 PVAL     + R ADD     /   /        GET ADDR OF VAL TO SET
        3538+ 4 3550          + TR 0      PARAMEND     END OF PARAM LIST
        3539+13 3540          + STORE A   RDVAL
        3540+10    0 RDVAL    + R ADD     /   /        TBL[ENT]=VAL
        3541+12    0 WRTBL    + STORE     /   /
        3542+10 3537          + R ADD     PVAL         SELECT NEXT PARAM FROM LIST
        3543+ 9 3556          + ADD       ONE
        3544+13 3537          + STORE A   PVAL
        3545+10 3541          + R ADD     WRTBL
        3546+ 9 3554          + ADD       MAX
        3547+13 3541          + STORE A   WRTBL
        3548+ 1 3537          + TR        PVAL     
        3549+ 0 2222 ENT0     + STOP      2222         CANNOT EQTBL ON ENTRY 0
        3550+10 3537 PARAMEND + R ADD     PVAL         GET RETURN ADDR AND EXIT
        3551+ 9 3556          + ADD       ONE
        3552+13 3553          + STORE A   EXIT
        3553+ 1    0 EXIT     + TR        /   /
        3554+ 0    0 MAX      + STOP      0000
        3555+ 0    0 TBL      + STOP      0000
        3556+ 0    1 ONE      + STOP      0001         constant 1
        3557+ 0    2 TWO      + STOP      0002         constant 2
        3558+ 9 3631 RWDRUM   + ADD       TWO 
        3559+13 3568          + STORE A   PDR1         PARM1: DRUM INSTR: READ/WRITE 0128  0129  0130  0131
        3560+ 9 3630          + ADD       ONE          
        3561+13 3570          + STORE A   PDR2         PARM2: DRUM ADDRESS (0..4094)
        3562+ 9 3630          + ADD       ONE          
        3563+13 3572          + STORE A   PDR3         PARM3: BUF START ADDRESS
        3564+ 9 3630          + ADD       ONE          
        3565+13 3574          + STORE A   PDR4         PARM4: LEN: NUMBER OF HALF-WORDS (MUST BE EVEN)
        3566+ 9 3630          + ADD       ONE          
        3567+13 3628          + STORE A   EXIT               
        3568+10    0 PDR1     + R ADD     /   /        GET DRUM INSTR
        3569+12 3576          + STORE     DRIO
        3570+10    0 PDR2     + R ADD     /   /        GET DRUM ADDR
        3571+13 3577          + STORE A   DRADDR
        3572+10    0 PDR3     + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        3573+13 3615          + STORE A   RWCOPY    
        3574+10    0 PDR4     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        3575+12 3632          + STORE     LEN
        3576+ 0    0 DRIO     + STOP      /   /        INSTR: READ/WRITE 0128  0129  0130  0131
        3577+29    0 DRADDR   + SET DR    /   /
        3578+ 1 3611          + TR        LOOP
        3579+ 9 3631 RDTAPE   + ADD       TWO 
        3580+13 3587          + STORE A   PR1          PARM1: TAPE ADDRESS
        3581+ 9 3630          + ADD       ONE          
        3582+13 3589          + STORE A   PR2          PARM2: BUF START ADDRESS
        3583+ 9 3630          + ADD       ONE          
        3584+13 3628          + STORE A   EXIT
        3585+ 2 3586          + TR OV     CLOV1        CLEAR OV THAT MAY HAVE BEEN SET
        3586+ 8    0    CLOV1 + NOOP      0000
        3587+10    0 PR1      + R ADD     /   /        GET TAPE ADDR
        3588+13 3591          + STORE A   RTAPAD       TAPE UNITS: 0256  0257  0258  0259
        3589+10    0 PR2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        3590+13 3615          + STORE A   RWCOPY    
        3591+24    0 RTAPAD   + READ      /   /
        3592+10 3629          + R ADD     ZERO
        3593+ 1 3613          + TR        LOOP1
        3594+ 9 3631 WRTAPE   + ADD       TWO 
        3595+13 3602          + STORE A   PW1          PARM1: TAPE ADDRESS
        3596+ 9 3630          + ADD       ONE          
        3597+13 3604          + STORE A   PW2          PARM2: BUF START ADDRESS
        3598+ 9 3630          + ADD       ONE          
        3599+13 3606          + STORE A   PW3          PARM3: BUF LEN
        3600+ 9 3630          + ADD       ONE          
        3601+13 3628          + STORE A   EXIT
        3602+10    0 PW1      + R ADD     /   /        GET TAPE ADDR
        3603+13 3610          + STORE A   WTAPAD       TAPE UNITS: 0256  0257  0258  0259
        3604+10    0 PW2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        3605+13 3615          + STORE A   RWCOPY    
        3606+10    0 PW3      + R ADD     /   /        GET ADDR OF LEN 
        3607+13 3608          + STORE A   PW3A
        3608+10    0 PW3A     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        3609+12 3632          + STORE     LEN
        3610+26    0 WTAPAD   + WRITE     /   /        PREPARE TO WRITE ON TAPE
        3611+10 3632 LOOP     + R ADD     LEN
        3612+ 4 3627          + TR 0      RWOK
        3613+ 5 3631 LOOP1    + SUB       TWO
        3614+12 3632          + STORE     LEN
        3615-31    0 RWCOPY   - COPY      /   /        WRITE BUFFER TO TAPE
        3616+ 1 3619          + TR        GO 
        3617+ 1 3623          + TR        EOF          END OF FILE
        3618+ 1 3625          + TR        EOR          END OF RECORD
        3619+10 3615 GO       + R ADD     RWCOPY
        3620+ 5 3631          + SUB       TWO
        3621+13 3615          + STORE A   RWCOPY
        3622+ 1 3611          + TR        LOOP
        3623+10 3630 EOF      + R ADD     ONE          SET OV FLAG TO SIGNAL END OF FILE CONDITION
        3624+22   36          + A LEFT    36
        3625+ 6 3632 EOR      + R SUB     LEN          RETURN NUMBER OF HALF-WORDS READ
        3626+ 5 3631          + SUB       TWO
        3627+26 2052 RWOK     + WRITE     2052         INSURE THAT MQ NOT IN USE            
        3628+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        3629+ 0    0 ZERO     + STOP      0000
        3630+ 0    1 ONE      + STOP      0001         
        3631+ 0    2 TWO      + STOP      0002         
        3632+     0  LEN        RES       1
        3634+ 9 3649 CHAIN    + ADD       TWO
        3635+13 3636          + STORE A   CHP1
        3636+10    0 CHP1     + R ADD     /   /        GET TAPE NUMBER
        3637+13 3644          + STORE A   TAPELOAD
        3638+30   70          + SENSE     0070         SENSE SWITCH 2                                  
        3639+ 1 3643 CONTAD   + TR        ENDSTOP      (ON POSITION MAKES SENSE OPCODE TO SKIP NEXT INSTR)
        3640+10 3639          + R ADD     CONTAD       IF SW2 IS ON, A +STOP 4095 IS EXECUTED.  
        3641+12 4095          + STORE     4095         IF THEN USER PRESS START, EXECUTION WILL BE RESUMED 
        3642+ 0 4095          + STOP      4095         AND CHAINED PROGRAM WILL BE LOADED AND EXECUTED
        3643+ 8    0 ENDSTOP  + NOOP      0000
        3644+24    0 TAPELOAD + READ      0000         
        3645-31    0 TL0      - COPY      0000         READ 1ST WORD OF SELF-LOADER FROM TAPE
        3646+ 1    0          + TR        0000         TR TO SELF-LOADER
        3647+ 0 2221          + STOP      2221         ERROR LOADING: UNEXPECTED END OF FILE
        3648+ 0 2222          + STOP      2222         ERROR LOADING: UNEXPECTED END OF RECORD 
        3649+ 0    2 TWO      + STOP      0002         ERROR LOADING: UNEXPECTED END OF FILE
          48-     0  ROUTINE INIT
          49+ 1  120 ENTRY POINT
          50-     0  ROUTINE CHAIN
          51+ 1 3634 ENTRY POINT
          52-     0  ROUTINE CLRBUF
          53+ 1 2878 ENTRY POINT
          54-     0  ROUTINE PRTNLINE
          55+ 1 3208 ENTRY POINT
          56-     0  ROUTINE PRINTCRD
          57+ 1 2886 ENTRY POINT
          58-     0  ROUTINE PRTSTR
          59+ 1 2947 ENTRY POINT
          60-     0  ROUTINE PRTALF
          61+ 1 2970 ENTRY POINT
          62-     0  ROUTINE PRTINT
          63+ 1 3048 ENTRY POINT
          64-     0  ROUTINE PRTCHR
          65+ 1 3090 ENTRY POINT
          66-     0  ROUTINE RDTAPE
          67+ 1 3579 ENTRY POINT
          68-     0  ROUTINE WRTAPE
          69+ 1 3594 ENTRY POINT
          70-     0  ROUTINE EQTBL
          71+ 1 3406 ENTRY POINT
          72-     0  ROUTINE EQTBL2
          73+ 1 3516 ENTRY POINT
          74-     0  ROUTINE READTBL
          75+ 1 3408 ENTRY POINT
          76-     0  ROUTINE READTBL2
          77+ 1 3474 ENTRY POINT
          78-     0  ROUTINE SRCHTBL
          79+ 1 3404 ENTRY POINT
          80-     0  ROUTINE CLMEM
          81+ 1 3344 ENTRY POINT
          82-     0  ROUTINE MEMCOPY
          83+ 1 3370 ENTRY POINT
          84-     0  ROUTINE READCRD
          85+ 1 2882 ENTRY POINT
          86-     0  ROUTINE WRITECRD
          87+ 1 2884 ENTRY POINT
          88-     0  ROUTINE PRTOCT
          89+ 1 3014 ENTRY POINT
          90-     0  ROUTINE BMPAD
          91+ 1 3290 ENTRY POINT
          92-     0  ROUTINE RWDRUM
          93+ 1 3558 ENTRY POINT
        4094+    48  REGION ORIGIN TABLE LOCATION
        4095+   120  INITIAL REGION
           0+ 1  120          + TR        INIT         PROGRAM START
