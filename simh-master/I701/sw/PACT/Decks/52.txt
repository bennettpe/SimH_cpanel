        DEC
        NNNN OP ADDR COMMENTS
         100+ 9 2621 LOADCC   + ADD       TWO          LOAD PACTSCR INTO CARD IMAGE SO 
         101+13  120          + STORE A   CPCCEX       CURRENT PACT SOURCE CODE CAN BE PRINTED
         102+10 2618          + R ADD     ZERO         COPY TO LEFT SIDE OF SOURCE CODE CARD IMAGE
         103+13  107          + STORE A   CPCC1        AT 0..46 FROM PACTSCR
         104+10  123          + R ADD     CPCC2
         105+13  106          + STORE A   CPCC 
         106-10    0 CPCC     - R ADD     /   /
         107-12    0 CPCC1    - STORE     /   /
         108+10  107          + R ADD     CPCC1
         109+ 5 2621          + SUB       TWO
         110+13  112          + STORE A   CPCC1B
         111+10 2618          + R ADD     ZERO
         112-12    0 CPCC1B   - STORE     /   /
         113+10  106          + R ADD     CPCC
         114+ 5 2621          + SUB       TWO
         115+13  106          + STORE A   CPCC
         116+10  107          + R ADD     CPCC1
         117+ 5 2622          + SUB       D4
         118+13  107          + STORE A   CPCC1
         119+ 5  122          + SUB       CPCCE
         120+ 4    0 CPCCEX   + TR 0      /   /        RETURN TO CALLER
         121+ 1  106          + TR        CPCC
         122-12   48 CPCCE    - STORE     0048         LAST LOCATION TO COPY FROM 
         123+ 8 1432 CPCC2    + NOOP      PACTSRC      PACTSRC = FIRST LOCATION TO COPY FROM
         124+10  124 INIT     + R ADD     *            
         125+ 1   55          + TR        PRTNLINE     
         126+ 0  101          + STOP      0101         STRINGZ AT COL 1
         127+ 0 2732          + STOP      MSGSTART     "OPERATION EXPANSION"
         128+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         129+10 2618          + R ADD     ZERO         CLEAR CC RECORD
         130+12 1456          + STORE     REGION     
         131+12 1457          + STORE     STEP       
         132+12 1458          + STORE     OP         
         133+12 1459          + STORE     FACT       
         134+12 1460          + STORE     S1         
         135+12 1461          + STORE     S2         
         136+12 1462          + STORE     QR         
         137+12 1463          + STORE     QF         
         138-12 1464          - STORE     NUM        
         139+12 1466          + STORE     CLUE       
         140+12 1467          + STORE     STEPN      
         141+12 1468          + STORE     FACTN      
         142+12 1469          + STORE     FACTREG    
         143+12 1470          + STORE     S1N        
         144+12 1471          + STORE     S2N        
         145+12 1472          + STORE     D1N        
         146+12 1473          + STORE     D2N        
         147+12 1474          + STORE     NINST      
         148+12 1475          + STORE     NINCR 
         149+10 1676          + R ADD     CCLEN        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         150+10 1920          + R ADD     TPARSTEP     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         151+10 2160          + R ADD     TIDXSETN     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         152+10 2246          + R ADD     TREFIDX1     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         153+10 2296          + R ADD     TREFIDX2     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         154+10 2346          + R ADD     TREFSTEP     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         155+10 2396          + R ADD     TREFINCR     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         156+10 2496          + R ADD     TREFADDR     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         157+10 2446          + R ADD     TREFOP       NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         158+10 2546          + R ADD     TREFD1       NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         159+10  159          + R ADD     *            CLEAR GENERATED MACHINE CODE INSTR ON CC RECORD
         160+ 1   79          + TR        CLMEM        
         161+ 0 1476 TINSTAD  + STOP      TINST      
         162+ 0 2639          + STOP      D200         TINST (200 HALF-WORDS) = 2 * MAXNINST (MAX NUMBER OF MACHINE CODE INSTRUTIONS PER STEP)
         163+10 2618          + R ADD     ZERO
         164+12 2644          + STORE     NREGIONS     NUMBER OF REGIONS PROCESSED
         165+12 2057          + STORE     NIDXS        INIT NUMBER OF INDEXES IN THIS REGION
         166+12 1885          + STORE     NPARAMS      INIT NUMBER OF PARAMS DEFINED
         167+28  258          + REWIND    TAPEOUT      WILL READ INPUT TAPES IN BACKWARD DIRECTION FROM ITS CURRENT 
         168+10 2618 READREG  + R ADD     ZERO
         169+12 2195          + STORE     NREFS        INIT NUMBER OF REFERENCES. NIDXS AND NPARAMS ARE INIT IN BORP
         170+12 1683          + STORE     NLOCONST     NUM OF ENTRIES IN LOOP CONSTANT POOL OF REGION 
         171+12 2685          + STORE     SVNINST      SO WE CAN PRINT A LOG OF CC THAT GET GENERATED MC INSTR
         172+12 2653          + STORE     REGCSTEP     STEPN WHERE THE REG.C SITS
         173+12 2654          + STORE     PRGSTEPN     FIRST STEPN OF PROGRAM AFTER INITIAL CALL/ID/FOR (IE STEP-1 IS CALL/ID/FOR INSTR) 
         174+12 1467          + STORE     STEPN        CLEAR STEPN. WILL BE USED TO IDENTIFY START OF REGION
         175+12 2597          + STORE     NFORIDX      NUMBER OF INDEX IN "FOR I A B" INSTR BELOW A "DO/LIB" INSTR
         176+10  176 READSTEP + R ADD     *            READ PACT USER PROGRAM SOURCE CODE FROM TAPE IN
         177+ 1  316          + TR        RDCC         READING BACKWARD
         178+ 2  300          + TR OV     BOT          TR IF BEGINING OF TAPE -> ALL REGIONS PROCESSED
         179+10 1458          + R ADD     OP           OP=0 -> END OF REGION RECORD READ. AS WE ARE READING BACKWARD
         180+ 4  274          + TR 0      BORP         THIS MEANS BEGIN OF REGION PROCESSING -> TR TO READ TIDX AND TPAR TABLES FROM TAPE
         181+10  181          + R ADD     *            LOAD PACTSCR INTO CARD IMAGE SO 
         182+ 1  100          + TR        LOADCC       CURRENT PACT SOURCE CODE CAN BE PRINTED
         183+10 1474          + R ADD     NINST        SAVE CURRENT NUMBER OF MC INSTR IN THE COMPACT CODE RECORD
         184+12 2685          + STORE     SVNINST      SO WE CAN PRINT A LOG OF CC THAT GET GENERATED MC INSTR
         185+10 1458          + R ADD     OP           JUMP TABLE TO HANDLE EACH TYPE OF PACT OPERATION
         186+ 9  189          + ADD       OPTBL
         187+13  188          + STORE A   OPTBLTR
         188+ 1    0 OPTBLTR  + TR        /   /
         189+ 0  189 OPTBL    + STOP      *
         190+ 1  999          + TR        CHECKREF     OP=1   TAKE   FACTOR CANNOT BE BLANK 
         191+ 1  999          + TR        CHECKREF     OP=2   ADD    ALLOWS BLANK FACTOR 
         192+ 1  999          + TR        CHECKREF     OP=3   SUB    ALLOWS BLANK FACTOR 
         193+ 1  999          + TR        CHECKREF     OP=4   MUL    ALLOWS BLANK FACTOR
         194+ 1  999          + TR        CHECKREF     OP=5   DIV    FACTOR CANNOT BE BLANK 
         195+ 1  235          + TR        NEXT         OP=6   RES    NO FACTOR
         196+ 1  999          + TR        CHECKREF     OP=7   EQ     NEEDS VARIABLE AS FACTOR
         197+ 1  999          + TR        CHECKREF     OP=8   +ABS   ALLOWS BLANK FACTOR
         198+ 1  999          + TR        CHECKREF     OP=9   -ABS   ALLOWS BLANK FACTOR
         199+ 1  999          + TR        CHECKREF     OP=10  ABS    FACTOR CANNOT BE BLANK 
         200+ 1  235          + TR        NEXT         OP=11  T      FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         201+ 1  235          + TR        NEXT         OP=12  TZ     FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         202+ 1  235          + TR        NEXT         OP=13  TP     FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         203+ 1  235          + TR        NEXT         OP=14  TN     FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         204+ 1  235          + TR        NEXT         OP=15  TF     FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         205+ 1  235          + TR        NEXT         OP=16  HALT   FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         206+ 1  932          + TR        TEST         OP=17  TEST   
         207+ 1  439          + TR        USESET       OP=18  SET    
         208+ 1  439          + TR        USESET       OP=19  USE    
         209+ 1  872          + TR        CLNFORIX     OP=20  DO     CLEAR INDEX DEFINED BY FOR INST BELOW
         210+ 1  235          + TR        NEXT         OP=21  EXIT
         211+ 1  234          + TR        BADOP        OP=22  DUP    SHOULD NOT BE PRESENT. IT IS ALREADY PROCESSED
         212+ 1  872          + TR        CLNFORIX     OP=23  LIB    CLEAR INDEX DEFINED BY FOR INST BELOW
         213+ 1  234          + TR        BADOP        OP=24  ID     SHOULD NOT BE PRESENT. IT IS DESAMBIGUATED
         214+ 1  234          + TR        BADOP        OP=25  FOR    SHOULD NOT BE PRESENT. IT IS DESAMBIGUATED
         215+ 1  235          + TR        NEXT         OP=26  CALL   WILL BE PROCESSED IN PASS2
         216+ 1  999          + TR        CHECKREF     OP=27  SIN    ALLOWS BLANK FACTOR
         217+ 1  999          + TR        CHECKREF     OP=28  COS    ALLOWS BLANK FACTOR
         218+ 1  999          + TR        CHECKREF     OP=29  ARCT   ALLOWS BLANK FACTOR
         219+ 1  999          + TR        CHECKREF     OP=30  SQRT   ALLOWS BLANK FACTOR
         220+ 1  999          + TR        CHECKREF     OP=31  LOG    ALLOWS BLANK FACTOR
         221+ 1  999          + TR        CHECKREF     OP=32  EXP    ALLOWS BLANK FACTOR
         222+ 1  235          + TR        NEXT         OP=33  SE
         223+ 1  999          + TR        CHECKREF     OP=34  CL     NEEDS VARIABLE AS FACTOR
         224+ 1  235          + TR        NEXT         OP=35  READ
         225+ 1  235          + TR        NEXT         OP=36  LIST
         226+ 1  235          + TR        NEXT         OP=37  RES for MULT
         227+ 1  235          + TR        NEXT         OP=38  RES for DIV
         228+ 1  999          + TR        CHECKREF     OP=39  ID for LIST         FACTOR CANNOT BE BLANK 
         229+ 1  830          + TR        IDDO         OP=40  ID for DO/LIB       ONLY APPLIES INDEX IF IT IS ACTIVE
         230+ 1  235          + TR        NEXT         OP=41  ID for CALL         
         231+ 1  852          + TR        FORDO        OP=42  FOR for DO/LIB      
         232+ 1  235          + TR        NEXT         OP=43  FOR for CALL        
         233+ 1  425          + TR        LDNCONST     OP=44  OPNCONST            LOADS LOOP CONSTANTS POOL FROM TINST
         234+ 0 1111 BADOP    + STOP      1111         COMPILER ERROR
         235+ 8    0 NEXT     + NOOP      0000         CONTINUE 
         236+30   74          + SENSE     0074         SENSE SWITCH 6
         237+ 1  250          + TR        ENDLOG1      TR IF NO LOG SELECTED
         238+10 1458          + R ADD     OP
         239+ 4  250          + TR 0      ENDLOG1      DO LOG FOR OP=0 EOR 
         240+10  240          + R ADD     *            PRINT STEP JUST PROCESSED
         241+ 1   57          + TR        PRINTCRD
         242+10 1458          + R ADD     OP           IF WE ARE AT LOOP CONSTANT STEP -> DO NOT PRINT MC INSTR GENERATED
         243+ 5 2635          + SUB       OPNCONST     IN POOL. WILL BE PRINTED AFTER PROCESSING FIRST INST OF REGION
         244+ 4  250          + TR 0      ENDLOG1  
         245+10 1474          + R ADD     NINST        IF NUMBER OF MC INSTR IN THE COMPACT CODE RECORD HAS CHANGED
         246+ 5 2685          + SUB       SVNINST      -> CC GOT GENERATED MC INSTR -> PRINT MC INSTR GENERATED
         247+ 4  250          + TR 0      ENDLOG1
         248+10  248          + R ADD     *
         249+ 1 1288          + TR        PRTMC        PRINT TINST TABLE WITH MC INSTRUCTIONS GENERATED FOR THIS STEP
         250+ 8    0 ENDLOG1  + NOOP      0000 
         251+10 1458          + R ADD     OP           IF OP=SET/USE/TEST, UPDATE TINST TO CONVERT REG.C USAGE IN MC INSTR
         252+ 5 2628          + SUB       OPSET        TO THE ACTUAL REGCSTEP WHERE THE LOOP CONSTANT POOL IS
         253+ 4  261          + TR 0      SETREGC1    
         254+10 1458          + R ADD     OP
         255+ 5 2629          + SUB       OPUSE
         256+ 4  261          + TR 0      SETREGC1
         257+10 1458          + R ADD     OP
         258+ 5 2627          + SUB       OPTEST
         259+ 4  261          + TR 0      SETREGC1
         260+ 1  263          + TR        SETREGC2
         261+10  261 SETREGC1 + R ADD     *
         262+ 1 1048          + TR        SETREGCI
         263+ 8    0 SETREGC2 + NOOP      0000
         264+10  264          + R ADD     *            WRITE COMPACT CODE ON TAPEOUT
         265+ 1  339          + TR        WRCC         
         266+10 1467          + R ADD     STEPN        CHECK IF WE JUST HAVE WRITTEN TO TAPE
         267+ 5 2654          + SUB       PRGSTEPN     FIRST STEPN OF PROGRAM AFTER INITIAL CALL/ID/FOR (IE STEP-1 IS CALL/ID/FOR INSTR)
         268+ 4  270          + TR 0      EOP1         IF SO, NOW CALL EOPP TO WRITE COMPACT STEP OP=100 WITH UP-TO-DATE TLOCONST TABLE
         269+ 1  272          + TR        EOP2         NEXT CC THAT WILL BE WRITEN ARE ID/FOR/CALL THAT DEFINES THE PARAM OF THE REGION
         270+10  270 EOP1     + R ADD     *
         271+ 1  288          + TR        EOPP
         272+ 8    0 EOP2     + NOOP      0000
         273+ 1  176          + TR        READSTEP     
         274+ 8    0 BORP     + NOOP      0000         BEGIN OF REGION PROCESSING 
         275+10  275          + R ADD     *
         276+ 1  339          + TR        WRCC         WE ARE READIN INPUT TAPE BACKWARD, SO THE FIRST CC RECORD
         277+10 2618          + R ADD     ZERO        
         278+12 2057          + STORE     NIDXS        INIT NUMBER OF INDEXES IN THIS REGION
         279+12 1885          + STORE     NPARAMS      INIT NUMBER OF PARAMS DEFINED
         280+10  280          + R ADD     *            READ FROM TAPEINR THE TABLES TPAR, TIDX 
         281+ 1  400          + TR        RDEORTBL     POPULATED IN PASS 1 TO BE USED BY PASS 2
         282+10  282          + R ADD     *            WRITE TO TAPEOUT AS OP=101 THE TABLE TPAR JUST READ FROM TAPEINR
         283+ 1  373          + TR        WRPARCC      WILL BE THE NEEDED BY NEXT PASS 
         284+10 2644          + R ADD     NREGIONS     NUMBER OF REGIONS PROCESSED
         285+ 9 2620          + ADD       ONE
         286+12 2644          + STORE     NREGIONS     
         287+ 1  168          + TR        READREG      PROCESS NEXT REGION
         288+ 9 2621 EOPP     + ADD       TWO          END OF PROG PROCESSING 
         289+13  299          + STORE A   EOPPEX
         290+10  290          + R ADD     *            WRITE IN TAPEOUT AS OP=100 THE TABLE TLOCONST (LOOP CONSTANTS POOL)
         291+ 1  351          + TR        WRNCONST     THIS RECORD WILL BE PLACED BETWEED FIRST PACT PROGRAM  STEP AND LAST PACT ID/FOR/CALL STEP
         292+30   74          + SENSE     0074         SENSE SWITCH 6
         293+ 1  296          + TR        ENDLOG2      TR IF NO LOG SELECTED
         294+10  294          + R ADD     *            PRINT TINST TABLE WITH MC INSTRUCTIONS GENERATED 
         295+ 1 1288          + TR        PRTMC        IN LOOP CONSTANT POOL
         296+ 8    0 ENDLOG2  + NOOP      0000 
         297+10 2618          + R ADD     ZERO
         298+12 1467          + STORE     STEPN        MAKE SURE STEPN IS CLEARED
         299+ 1    0 EOPPEX   + TR        /   /
         300+ 8    0 BOT      + NOOP      0000         BEGIN OF INPUT TAPE
         301+27  258          + WRITE EF  TAPEOUT      WRITE EOF IN TAPE OUT (COMPACT CODE)
         302+30   74          + SENSE     0074         SENSE SWITCH 6
         303+ 1  311          + TR        ENDLOG1B     TR IF NO LOG SELECTED
         304+10  304          + R ADD     *
         305+ 1   55          + TR        PRTNLINE     
         306+ 0  101          + STOP      0101         STRINGZ AT COL 1
         307+ 0 2740          + STOP      MSGDONE      "REGIONS"
         308+ 0  210          + STOP      0210         INT AT COL 10
         309+ 0 2644          + STOP      NREGIONS     NUMBER OF REGIONS PROCESSED
         310+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         311+ 8    0 ENDLOG1B + NOOP      0000
         312+10  312          + R ADD     *
         313+ 1   51          + TR        CHAIN        IF SW2 IS ON, A +STOP 4095 IS EXECUTED 
         314+ 0  256          + STOP      PACTCOMP     CHAIN TO NEXT STAGE IN PACT COMPILER TAPE
         315+ 0 4095          + STOP      4095
         316+ 9 2621 RDCC     + ADD       TWO          READ COMPACT CODE FROM TAPE WITH LEADING RECORD
         317+13  338          + STORE A   RDCCEXIT     TO ALLOW READING BACKWARDS. 
         318+ 2  319          + TR OV     RDCC0        CLEAR OV FLAG (=CLEAR EOF CONDITION FROM ANY 
         319+ 8    0 RDCC0    + NOOP      0000         PREVIOUS TAPE READ)
         320+10  320          + R ADD     *            READ LEADING IDENTIFICATION RECORD
         321+ 1   65          + TR        RDBTAPE      (MC CODE GENERATED STEPN + NINST)
         322+ 0  257          + STOP      TAPEIN       SO TAPE CAN BE READ BACKWARDS ON PASS 2
         323+ 0 1680          + STOP      DATA         BUF TO READ FROM TAPE
         324+ 0 2621          + STOP      TWO          LEN
         325+10 1680          + R ADD     DATA
         326+12 1467          + STORE     STEPN
         327+10 1681          + R ADD     DATA2
         328+12 1474          + STORE     NINST
         329+10 1676          + R ADD     CCLEN        COMPUTE CC RECOD SIZE BASED ON 
         330+ 9 1474          + ADD       NINST        MC INSTRUCTIONS GENERATED SO FAR
         331+ 9 1474          + ADD       NINST
         332+12 1677          + STORE     N
         333+10  333          + R ADD     *
         334+ 1   65          + TR        RDBTAPE      READ MAGNETIC TAPE TAPEIN (COMPACT CODE)
         335+ 0  257          + STOP      TAPEIN
         336+ 0 1432          + STOP      CCODE        BUF TO WRITE TO TAPE
         337+ 0 1677          + STOP      N            LEN
         338+ 1    0 RDCCEXIT + TR        /   /         
         339+ 9 2621 WRCC     + ADD       TWO          WRITE COMPACT CODE ON TAPE. AS NEXT COMPILER STAGE (CALL EXPANSION PASS1)
         340+13  350          + STORE A   WRCCEXIT     WILL READ THIS TAPE FORWARD, THERE IS NO NEED TO ADD THE TRAILING IDENTIFICATION RECORD
         341+10 1676          + R ADD     CCLEN        SAVE MC INSTRUCTIONS GENERATED SO FAR
         342+ 9 1474          + ADD       NINST        ADD NINST TWICE AS EACH MC INSTR USES TWO HALF-WORDS
         343+ 9 1474          + ADD       NINST
         344+12 1677          + STORE     N
         345+10  345          + R ADD     *
         346+ 1   67          + TR        WRTAPE       WRITE MAGNETIC TAPE TAPEOUT (PACT COMPACT CODE)
         347+ 0  258          + STOP      TAPEOUT
         348+ 0 1432          + STOP      CCODE        BUF TO WRITE TO TAPE
         349+ 0 1677          + STOP      N            LEN
         350+ 1    0 WRCCEXIT + TR        /   /         
         351+ 9 2621 WRNCONST + ADD       TWO          ADD LOOP CONSTANTS POOL AS TINST ON CC RECORD                           
         352+13  372          + STORE A   WRNCONEX
         353+10  353          + R ADD     *            CLEAR CC RECORD
         354+ 1   79          + TR        CLMEM        
         355+ 0 1432          + STOP      CCODE        
         356+ 0 2640          + STOP      D244         = CCLEN + 2 * MAXNINST   
         357+10 1683          + R ADD     NLOCONST     COPY LOOP CONSTANTS POOL AS TINST  
         358+12 1474          + STORE     NINST
         359+22    1          + A LEFT    0001
         360+12 2686          + STORE     LEN
         361+10  361          + R ADD     *            
         362+ 1   81          + TR        MEMCOPY
         363+ 0 1684          + STOP      TLOCONST   
         364+ 0 1476          + STOP      TINST      
         365+ 0 2686          + STOP      LEN
         366+10 2637          + R ADD     D100         SET RECORD OP IDENTIFICATION
         367+12 1458          + STORE     OP           WILL CONTAIN THE LOOP CONSTANTS AS MC INSTR
         368+10 2653          + R ADD     REGCSTEP     THIS IS THE STEPN WHERE THE REG.C SITS
         369+12 1467          + STORE     STEPN
         370+10  370          + R ADD     *            WRITE COMPACT CODE ON TAPEOUT
         371+ 1  339          + TR        WRCC         NO LOG
         372+ 1    0 WRNCONEX + TR        /   /
         373+ 9 2621 WRPARCC  + ADD       TWO          WRITE TO TAPEOUT TABLE TPAR
         374+13  399          + STORE A   WRPAREX
         375+10  375          + R ADD     *            CLEAR CC RECORD
         376+ 1   79          + TR        CLMEM        
         377+ 0 1432          + STOP      CCODE        
         378+ 0 2640          + STOP      D244         = CCLEN + 2 * MAXNINST   
         379+ 8 1884 SVPA1    + NOOP      MAXNPAR      FIRST VAR OF TABLES TO SAVE TO TAPE
         380+ 8 2056 SVPA2    + NOOP      MAXNIDXS     VAR JUST AFTER TABLES, NOT TO SAVE 
         381+10  380          + R ADD     SVPA2
         382+ 5  379          + SUB       SVPA1        SAVE TPAR TABLE ( 2 + 5*34 HALF WORDS )
         383+12 1677          + STORE     N            = 172 HALF-WORDS
         384+10 1677          + R ADD     N            COPY AS TINST  
         385+12 2686          + STORE     LEN
         386+23    1          + A RIGHT   0001
         387+12 1474          + STORE     NINST
         388+10  388          + R ADD     *            
         389+ 1   81          + TR        MEMCOPY
         390+ 0 1884          + STOP      MAXNPAR
         391+ 0 1476          + STOP      TINST      
         392+ 0 2686          + STOP      LEN
         393+10 2638          + R ADD     D101         SET RECORD OP IDENTIFICATION
         394+12 1458          + STORE     OP           WILL CONTAIN THE LOOP CONSTANTS AS MC INSTR
         395+10 2621          + R ADD     TWO          
         396+12 1467          + STORE     STEPN
         397+10  397          + R ADD     *            WRITE COMPACT CODE ON TAPEOUT
         398+ 1  339          + TR        WRCC         NO LOG
         399+ 1    0 WRPAREX  + TR        /   /
         400+ 9 2621 RDEORTBL + ADD       TWO          READ FROM TAPEINR THE TABLES POPULATED IN PASS 1
         401+13  412          + STORE A   RDEORTEX     TO BE USED BY PASS 2
         402+ 8 1884 RDTA1    + NOOP      MAXNPAR      FIRST VAR OF TABLES TO READ FROM TAPE
         403+ 8 2194 RDTA2    + NOOP      MAXNREFS     VAR JUST AFTER TABLES, NOT TO READ
         404+10  403          + R ADD     RDTA2
         405+ 5  402          + SUB       RDTA1        READ AT ONCE TPAR TABLES ( 2 + 5*34 HALF WORDS )
         406+12 1677          + STORE     N            AND TIDX TABLES ( 2 + 4*34 HALF WORDS )
         407+10  407          + R ADD     *
         408+ 1   65          + TR        RDBTAPE      READ BACKWARDS
         409+ 0  259          + STOP      TAPEINR     
         410+ 0 1884          + STOP      MAXNPAR      BUF TO READ FROM TAPE
         411+ 0 1677          + STOP      N            LEN
         412+ 1    0 RDEORTEX + TR        /   /
         413+ 9 2621 ERROR    + ADD       TWO
         414+13  415          + STORE A   ERRP1
         415+10    0 ERRP1    + R ADD     /   /
         416+13  422          + STORE A   ERRSTRZ      SAVE ADDR OF ERROR TXT MESSAGE
         417+10  417          + R ADD     *            PRINT USER PROGRAM SOURCE CODE CARD JUST PROCESSED
         418+ 1   57          + TR        PRINTCRD
         419+10  419          + R ADD     *
         420+ 1   55          + TR        PRTNLINE     
         421+ 0  101          + STOP      0101         STRINGZ AT COL 1
         422+ 0    0 ERRSTRZ  + STOP      /   /        ERROR MESSAGE
         423+ 0    0          + STOP      0000         END OF LINE
         424+ 0  176          + STOP      READSTEP     IF USER PRESS STARTS, PROGRAM RESUMES PROCESSING NEXT SOURCE CODE STEP 
         425+10 1474 LDNCONST + R ADD     NINST        THIS COMPACT CODE RECORD HOLDS THE LOOP CONSTANTS POOL IN TINST 
         426+12 1683          + STORE     NLOCONST     COPY IT TO TLOCONST TABLE
         427+22    1          + A LEFT    0001
         428+12 2686          + STORE     LEN
         429+10  429          + R ADD     *            
         430+ 1   81          + TR        MEMCOPY
         431+ 0 1476          + STOP      TINST      
         432+ 0 1684          + STOP      TLOCONST   
         433+ 0 2686          + STOP      LEN
         434+10 1467          + R ADD     STEPN        SET THE STEP FOR REG.C
         435+12 2653          + STORE     REGCSTEP
         436+10 1468          + R ADD     FACTN
         437+12 2654          + STORE     PRGSTEPN     FIRST STEPN OF PROGRAM AFTER INITIAL CALL/ID/FOR (IE STEP-1 IS CALL/ID/FOR INSTR) 
         438+ 1  235          + TR        NEXT
         439+10  439 USESET   + R ADD     *            SET VARIABLES FOR INDEX USED IN TEST
         440+ 1  446          + TR        TSETN                      
         441+10  441          + R ADD     *            GENERATE MC INSTS TO SET START OF LOOP INDEX VALUE
         442+ 1  464          + TR        TSETLOOP
         443+10  443          + R ADD     *            GENERATE INST TO SET VECTOR/MATRIX REFERENCES THAT USES NIDX
         444+ 1  559          + TR        TMATVEC 
         445+ 1  235          + TR        NEXT         SAVE GENERATED CODE, THEN PROCEED WITH NEXT INSTR
         446+ 9 2621 TSETN    + ADD       TWO          SET VARIABLE NIDX = THE INDEX USED IN "SET" OR "USE" INSTR
         447+13  463          + STORE A   TSETEX                    ECONSTIX =ENTRY IN LOOP CONSTANT POOL FOR INDEX VALUE 
         448+10  448          + R ADD     *                         
         449+ 1   77          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         450+ 0 2058          + STOP      TIDXNAME     ... INDEX NAME TABLE
         451+ 0 2057          + STOP      NIDXS        ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
         452+ 0 1470          + STOP      S1N          ... THE VALUE TO FIND 
         453+ 4  234          + TR 0      BADOP        INDEX NOT DEFINED MUST HAVE BEEN DETECTED ON PREVIOUS PASS
         454+12 2655          + STORE     NIDX
         455+10  455          + R ADD     *            READ FROM TIDX TABLES
         456+ 1   75          + TR        READTBL2
         457+ 0 2092          + STOP      TIDXLOC      
         458+ 0 2056          + STOP      MAXNIDXS
         459+ 0 2655          + STOP      NIDX
         460+ 0 2658          + STOP      ECONSTIX     = TIDXLOC [NIDX] 
         461+ 0 2657          + STOP      IDXTYPE      = TIDXTYPE[NIDX] 
         462+ 0    0          + STOP      0000
         463+ 1    0 TSETEX   + TR        /   /
         464+ 9 2621 TSETLOOP + ADD       TWO          GENERATE MC INSTS TO SET START OF LOOP INDEX VALUE
         465+13  558          + STORE A   TSETLOEX
         466+ 6 2620          + R SUB     ONE          INIT TO -1 TO SIGNAL NOT USED  
         467+12 2660          + STORE     ECSTART      = ADDR IN REG C OF START OF LOOP VALUE
         468+10  468          + R ADD     *            AN INDEX IS SEARCHED IN PARAMETERS TABLE BY ITS NAME
         469+ 1   77          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         470+ 0 1886          + STOP      TPARNAME     ... PARAMETERS NAME TABLE
         471+ 0 1885          + STOP      NPARAMS      ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NPARAMS
         472+ 0 1470          + STOP      S1N          ... THE VALUE TO FIND 
         473+ 4  489          + TR 0      TE2          =0 -> NO PARAM MATCHES THE INDEX NAME USED IN "SET/USE" INSTR
         474+12 2668          + STORE     NPAR
         475+10  475          + R ADD     *            READ FROM TPARAMS TABLES
         476+ 1   73          + TR        READTBL
         477+ 0 1954          + STOP      TPARTYPE
         478+ 0 2668          + STOP      NPAR
         479+ 0 2684          + STOP      PTYPE        = TPARTYPE[NPAR] 
         480+10 2684          + R ADD     PTYPE        GET PARAM TYPE
         481+ 9 2621          + ADD       TWO          =-2 FOR "FOR I A B INDEX LOOP START/END"?
         482+ 4  484          + TR 0      TE1          YES -> TR
         483+ 1  489          + TR        TE2          NOT AN INDEX LOOP START/END -> CONTINUE
         484+10  484 TE1      + R ADD     *            READ FROM TPARAMS TABLES
         485+ 1   73          + TR        READTBL
         486+ 0 1988          + STOP      TPARFACT     AS TYPE=-2 (PARAM IS INDEX LOOP START/END), FACT=ENTRY IN LOOP CONSTANTS POOL THAT CONTAINS THE START OF LOOP VALUE
         487+ 0 2668          + STOP      NPAR
         488+ 0 2660          + STOP      ECSTART      = TPARFACT[NPAR] = ADDR IN REGION C OF START OF LOOP VALUE
         489+10 2620 TE2      + R ADD     ONE
         490+12 2661          + STORE     USEECIX      =1 -> INDEX START VALUE IS COMPUTED ON RUN TIME AND STORED IN 
         491+10 2657          + R ADD     IDXTYPE      =0 IF INDEX IS "ADDRESS TYPE", =1 IF INDEX IS "COUNT TYPE", 
         492+ 4  494          + TR 0      TEADDR       TR AS INDEX IS ADDRESS TYPE 
         493+ 1  507          + TR        TECOUNT      TR AS INDEX IS COUNT TYPE
         494+ 8    0 TEADDR   + NOOP      0000         HERE START OF LOOP IS A VALUE FOR COUNT INDEX (ECONSTIX). 
         495+10 2660          + R ADD     ECSTART
         496+ 3  516          + TR +      TEEPARAM     TR AS LOOP START VALUE IS A PARAM
         497+10 1471          + R ADD     S2N
         498+ 3  503          + TR +      TADCONST     TR AS LOOP START VALUE IS A CONSTANT
         499+10 1469          + R ADD     FACTREG
         500+ 5 2632          + SUB       D34          'V'
         501+ 4  519          + TR 0      TEVAR        TR AS LOOP START IS A VARIABLE
         502+ 1  527          + TR        TEINDEX      TR AS LOOP START VALUE IS ANOTHER INDEX
         503+ 8    0 TADCONST + NOOP      0000         INDEX IS "ADDRESS TYPE" AND LOOP START IS COMPUTABLE AT
         504+10 2618          + R ADD     ZERO
         505+12 2661          + STORE     USEECIX      =1 -> INDEX START VALUE IS COMPUTED ON RUN TIME AND STORED IN 
         506+ 1  558          + TR        TSETLOEX     ADDRESS INDEX DO NOT NEED TO SET THE INDEX VARIABLE
         507+ 8    0 TECOUNT  + NOOP      0000         HERE START OF LOOP IS A VALUE FOR COUNT INDEX (ECONSTIX). 
         508+10 2660          + R ADD     ECSTART
         509+ 3  516          + TR +      TEEPARAM     TR AS LOOP START VALUE IS A PARAM
         510+10 1471          + R ADD     S2N
         511+ 3  541          + TR +      TECONST      TR AS LOOP START VALUE IS A CONSTANT
         512+10 1469          + R ADD     FACTREG
         513+ 5 2632          + SUB       D34          'V'
         514+ 4  519          + TR 0      TEVAR        TR AS LOOP START IS A VARIABLE
         515+ 1  527          + TR        TEINDEX      TR AS LOOP START VALUE IS ANOTHER INDEX
         516+ 8    0 TEEPARAM + NOOP      0000         LOOP START VALUE PASSED AS PARAM (ECSTART=nnnn) IN "FOR I A B" INSTR 
         517+10 2660          + R ADD     ECSTART      GET THE LOOP POOL ENTRY THAT HAS THE LOOP START VALUE PASSED AS PARAM
         518+ 1  546          + TR        TE11
         519+ 8    0 TEVAR    + NOOP      0000         LOOP END IS A VARIABLE (FACTN=nnnn, FACTREG='V')
         520+10  520          + R ADD     *            GENERATE THE INSTRUCTIONS FOR ACC=START OF LOOP VALUE
         521+ 1 1166          + TR        GENINST     
         522+10 1001          + R ADD     CC.FACT      '+RA V nnnn'   is start of loop value 
         523+ 0    0          + STOP      0000         END OF INSTR TABLE
         524+10 1474          + R ADD     NINST        SAVE IN NINCR THE LOCATION INTO STEPN OF MC INSTR THAT ACCESS THE LOOP START
         525+12 1475          + STORE     NINCR        VARIABLE, SO IT CAN BE REPLACED LATER IF THIS VARIABLE IS A PARAM BY REFERENCE
         526+ 1  551          + TR        TESTOIDX     TR TO GENERATE INSTR TO TEST FOR START LOOP 
         527+ 8    0 TEINDEX  + NOOP      0000         LOOP START VALUE IS ANOTHER INDEX (S2N)
         528+10  528          + R ADD     *
         529+ 1   77          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         530+ 0 2058          + STOP      TIDXNAME     ... INDEX NAME TABLE
         531+ 0 2057          + STOP      NIDXS        ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
         532+ 0 1471          + STOP      S2N          ... THE VALUE TO FIND 
         533+ 4 1093          + TR 0      ERRNDIX2     ERROR: START OF LOOP INDEX NOT DEFINED (SHOULD BE DEFINED WITH SET OR USE)
         534+12 2656          + STORE     NIDX2
         535+10  535          + R ADD     *            READ FROM TIDX TABLES
         536+ 1   73          + TR        READTBL
         537+ 0 2092          + STOP      TIDXLOC      READ THE ENTRY IN LOOP CONSTANT POOL THAT CONTAINS INDEX VALUE
         538+ 0 2656          + STOP      NIDX2
         539+ 0 2659          + STOP      ECONST       = TIDXLOC [NIDX2] 
         540+ 1  547          + TR        TE12
         541+ 8    0 TECONST  + NOOP      0000         LOOP START VALUE IS A COMPILE TIME CONSTANT VALUE (S2N=nnnn)  IN "SET/USE I B" INSTR
         542+10  542          + R ADD     *
         543+ 1 1096          + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
         544+ 0 2744          + STOP      REG.A        '+H  A nnnn' -> CONSTANT VALUE = CONTENTS OF LOOP END VALUE VAR S2N
         545+ 0 1471          + STOP      S2N
         546+12 2659 TE11     + STORE     ECONST       SAVE THE ENTRY IN POOL THAT CONTAINS THE CREATED LOOP END VALUE (0000=FIRST ENTRY)
         547+10  547 TE12     + R ADD     *            GENERATE THE INSTRUCTIONS FOR ACC=END OF LOOP VALUE
         548+ 1 1166          + TR        GENINST     
         549+10 1005          + R ADD     CNN          '+RA C econst'   is start of loop value 
         550+ 0    0          + STOP      0000         END OF INSTR TABLE
         551+ 8    0 TESTOIDX + NOOP      0000         GENERATE INSTR TO TEST FOR END LOOP AND TR TO LOOP START
         552+10 2658          + R ADD     ECONSTIX     
         553+12 2659          + STORE     ECONST
         554+10  554          + R ADD     *            GENERATE THE INSTRUCTIONS FOR TEST AND TR TO START OF LOOP
         555+ 1 1166          + TR        GENINST     
         556+12 1005          + STORE     CNN          '+ST C econst'   is current index value 
         557+ 0    0          + STOP      0000         END OF INSTR TABLE
         558+ 1    0 TSETLOEX + TR        /   /
         559+ 9 2621 TMATVEC  + ADD       TWO          GENERATE INST TO INCREMENT MATRIX/VECTORS REFERENCES THAT USES NIDX
         560+13  622          + STORE A   TMATEX
         561+10 2618          + R ADD     ZERO         EXAMINE ALL REFERENCES TO MATRIX/VECTOR USING INDEX S1N
         562+12 2669          + STORE     NREF
         563+12 2671          + STORE     NLASTREF     LAST ADDR REFERENCE USED
         564+10 2669 TMLOOP1  + R ADD     NREF
         565+ 5 2195          + SUB       NREFS
         566+ 4  622          + TR 0      TMATEX       ALL REFERENCES PROCESSED -> EXIT
         567+10 2669          + R ADD     NREF
         568+ 9 2620          + ADD       ONE
         569+12 2669          + STORE     NREF
         570+10  570          + R ADD     *            READ VALUES FROM TREF TABLES
         571+ 1   75          + TR        READTBL2
         572+ 0 2196          + STOP      TREFNAME     
         573+ 0 2194          + STOP      MAXNREFS
         574+ 0 2669          + STOP      NREF
         575+ 0 2672          + STOP      RNAME        = TREFNAME[NREF]   REFERENCE NAME
         576+ 0 2673          + STOP      RIDX1        = TREFIDX1[NREF]   <0 -> INDEX1 NAME, =0 -> NO INDEX,  >0 -> CONSTANT, =*777777 -> NON ACTIVE INDEX
         577+ 0 2674          + STOP      RIDX2        = TREFIDX2[NREF]   <0 -> INDEX2 NAME, =0 -> NO INDEX,  >0 -> CONSTANT, =*777777 -> NON ACTIVE INDEX
         578+ 0 2675          + STOP      RSTEPN       = TREFSTPN[NREF]   STEPN OF INSTR WHERE THE REFERENCE IS MADE
         579+ 0 2676          + STOP      RINCRN       = TREFINCN[NREF]   INCRN OF REFERENCE IN THIS STEP
         580+ 0 1679          + STOP      VAL          = TREFOP[NREF]   
         581+ 0 2677          + STOP      RADDR        = TREFADDR[NREF]   ADDRESS OF VARIABLE/MATRIX Vnnnn
         582+ 0    0          + STOP      0000
         583+10 2672          + R ADD     RNAME        IF NAME=0 -> REFERENCE ALREADY PROCESSED. SKIP IT
         584+ 4  564          + TR 0      TMLOOP1      
         585+10 2673          + R ADD     RIDX1
         586+ 5 1470          + SUB       S1N
         587+ 4  592          + TR 0      TM2          TR IF REFERENCE IS USING SAME 1ST INDEX AS IN "TEST" INSTR 
         588+10 2674          + R ADD     RIDX2
         589+ 5 1470          + SUB       S1N
         590+ 4  592          + TR 0      TM2          TR IF REFERENCE IS USING SAME 2ND INDEX AS IN "TEST" INSTR 
         591+ 1  564          + TR        TMLOOP1      TR TO TRY NEXT REFERENCE, AS THIS ONE IS NOT USING SAME INDEX AS IN "TEST" INSTR 
         592+10 2673 TM2      + R ADD     RIDX1        CHECK IF INDEX=*777777/6. 
         593+ 5 2643          + SUB       O777K        IT IS A PLACEHOLDER IN "ID var i j" BELOW A "DO/LIB" INSTR
         594+ 4  599          + TR 0      TM2A         IF SO, INTERPRET AS CONSTANT 1 FOR THE PURPOSE OF SETTING ITS ADDRESS
         595+10 2673          + R ADD     RIDX1
         596+ 5 2642          + SUB       O776K
         597+ 4  599          + TR 0      TM2A
         598+ 1  601          + TR        TM2B
         599+10 2620 TM2A     + R ADD     ONE          
         600+12 2673          + STORE     RIDX1
         601+10 2674 TM2B     + R ADD     RIDX2
         602+ 5 2643          + SUB       O777K
         603+ 4  608          + TR 0      TM2C 
         604+10 2674          + R ADD     RIDX2
         605+ 5 2642          + SUB       O776K
         606+ 4  608          + TR 0      TM2C 
         607+ 1  610          + TR        TM2D 
         608+10 2620 TM2C     + R ADD     ONE
         609+12 2674          + STORE     RIDX2
         610+ 2  611 TM2D     + TR OV     TM2E         CLEAR OV JUST IN CASE
         611+ 8    0 TM2E     + NOOP      0000
         612+10  612          + R ADD     *            GENERATE MC CODE TO SET THE ADDR (AT RSTEPN/RINCRN) OF REFERENCE (RNAME)
         613+ 1  623          + TR        GMATVEC      ACCORDING TO ITS INDEX VALUES (RIDX1, RIDX2)
         614+10  614          + R ADD     *            
         615+ 1   69          + TR        EQTBL
         616+ 0 2196          + STOP      TREFNAME     CLEAR THE NAME OF REFERENCE TO SIGNAL IT IS ALREADY PROCESSED -> BECOMES AN EMPTY ENTRY 
         617+ 0 2669          + STOP      NREF
         618+ 0 2618          + STOP      ZERO         TREFNAME[NREF] = 0
         619+10  619          + R ADD     *            EXAMINE REMAINING REFERENCES. GENERATE '+SA ' INSTR TO SAVE THE 
         620+ 1  946          + TR        SASAME       INCREMENTED ADDR ON REFERENCES TO SAME MATRIX WITH SAME INDEXES
         621+ 1  564          + TR        TMLOOP1      NOW TRY WITH NEXT MATRIX
         622+ 1    0 TMATEX   + TR        /   /
         623+ 9 2621 GMATVEC  + ADD       TWO          GENERATE MC CODE TO INCR THE ADDR (AT RSTEN/RINCRN) OF REFERENCE (RNAME)         
         624+13  884          + STORE A   GMVEXIT      ACCORDING TO ITS INDEX VALUES (RIDX1, RIDX2)
         625+10  625          + R ADD     *            A VARIABLE IS SEARCHED IN PARAMETERS TABLE BY ITS ADDRESS
         626+ 1   77          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         627+ 0 1886          + STOP      TPARNAME     ... CALL PARAMETERS NAME TABLE
         628+ 0 1885          + STOP      NPARAMS      ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NPARAMS
         629+ 0 2677          + STOP      RADDR        ... THE VALUE TO FIND 
         630+ 4  640          + TR 0      TM5          IF NOT FOUND -> REFERENCED VECTOR/MATRIX IS NOT A PARAM -> USE STANDARD VALUE D1 
         631+12 2668          + STORE     NPAR         REFERENCED VECTOR/MATRIX IS PASSED AS PARAM -> SHOULD GET THE D1 VALUE ALSO PASSED AS PARAM
         632+10  632          + R ADD     *            READ FROM TPARAMS TABLES
         633+ 1   73          + TR        READTBL
         634+ 0 2022          + STOP      TPARLOC1     LOC1=ENTRY IN LOOP CONSTANT POOL THAT CONTAINS THE D1 VALUE PASSED AS PARAM
         635+ 0 2668          + STOP      NPAR
         636+ 0 2663          + STOP      ECONSTD1     = TPARLOC1[NPAR] ENTRY IN LOOP CONSTANT POOL THAT CONTAINS THE D1 PASSED AS PARAM
         637+ 6 2620          + R SUB     ONE          D1 IS NOT A COMPILE TIME KNOWN CONSTANT -> D1=-1
         638+12 2662          + STORE     D1
         639+ 1  653          + TR        TM6
         640+10  640 TM5      + R ADD     *            READ FROM TREFS TABLES
         641+ 1   75          + TR        READTBL2
         642+ 0 2496          + STOP      TREFADDR     READ RADDR/D1 VALUES OF VECTOR/MATRIX REFERENCED
         643+ 0 2194          + STOP      MAXNREFS
         644+ 0 2669          + STOP      NREF
         645+ 0 2677          + STOP      RADDR        = TREFADDR[NREF] = RADDR IS A COMPILE TIME CONSTANT
         646+ 0 2662          + STOP      D1           = TREFD1[NREF] = D1 IS A COMPILE TIME CONSTANT
         647+ 0    0          + STOP      0000
         648+10  648          + R ADD     *            
         649+ 1 1096          + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
         650+ 0 2744          + STOP      REG.A        '+H  A nnnn' -> CONSTANT VALUE GIVEN IN VAL VARIABLE =D1 OF REFERENCED MATRIX
         651+ 0 2662          + STOP      D1
         652+12 2663          + STORE     ECONSTD1     SAVE THE ENTRY IN POOL THAT CONTAINS THE CREATED D1 VALUE (1ST ENTRY = 0000)
         653+ 8    0 TM6      + NOOP      0000         HERE, D1 IS COMPILE-TIME CONTANT VALUE OF 1ST DIMENSION (IF IS >=0)
         654+10 2673          + R ADD     RIDX1
         655+ 5 1470          + SUB       S1N
         656+ 4  658          + TR 0      TM6A         TR IF REFERENCE RIDX1 = INDEX IN "SET/USE" INSTR 
         657+ 1  663          + TR        TM6B         TR IF REFERENCE IS USING ITS OWN 1ST INDEX 
         658+10 2658 TM6A     + R ADD     ECONSTIX     REFERENCE RIDX1 = 1ST INDEX IN "SET/USE" INSTR -> SET ...
         659+12 2665          + STORE     I1           I1=RUN-TIME VALUE OF INDEX1 (HAS THE VALUE C1 IN RUN-TIME IF INDEX SET TO A CONSTANT AS IN "SET I 2")
         660+10 1471          + R ADD     S2N
         661+12 2664          + STORE     C1           C1=COMPILE-TIME CONTANT VALUE OF INDEX1 (IF >0)
         662+ 1  690          + TR        TM6D
         663+10 2673 TM6B     + R ADD     RIDX1        REFERENCE IS USING ITS OWN 1ST INDEX 
         664+ 4  234          + TR 0      BADOP        SHOULD NOT BE EMPTY
         665+ 3  683          + TR +      TM6C         TR IF IS A COMPILE TIME CONSTANT
         666+10  666          + R ADD     *
         667+ 1   77          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         668+ 0 2058          + STOP      TIDXNAME     ... INDEX NAME TABLE
         669+ 0 2057          + STOP      NIDXS        ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
         670+ 0 2673          + STOP      RIDX1        ... THE VALUE TO FIND 
         671+ 4  234          + TR 0      BADOP        REFERENCE'S INDEX1 SHOULD BE DEFINED
         672+12 1677          + STORE     N
         673+10  673          + R ADD     *            READ FROM TIDX TABLES
         674+ 1   73          + TR        READTBL
         675+ 0 2092          + STOP      TIDXLOC      READ THE ENTRY IN LOOP CONSTANT POOL THAT CONTAINS INDEX VALUE
         676+ 0 1677          + STOP      N
         677+ 0 2659          + STOP      ECONST       = TIDXLOC [REFERENCE INDEX1] 
         678+10 2659          + R ADD     ECONST
         679+12 2665          + STORE     I1           I1=RUN-TIME VALUE OF INDEX1 OF REFERENCE
         680+ 6 2620          + R SUB     ONE
         681+12 2664          + STORE     C1           C1=-1 BECAUSE NO COMPILE-TIME CONTANT VALUE OF INDEX1 
         682+ 1  690          + TR        TM6D
         683+10 2673 TM6C     + R ADD     RIDX1
         684+12 2664          + STORE     C1           COMPILE-TIME CONTANT VALUE OF INDEX1 (AS IS >0)
         685+10  685          + R ADD     *
         686+ 1 1096          + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
         687+ 0 2744          + STOP      REG.A        '+H  A nnnn' -> CONSTANT VALUE = CONSTANT IN REFRENECE INDEX2
         688+ 0 2664          + STOP      C1
         689+12 2665          + STORE     I1           SAVE THE ENTRY IN POOL THAT CONTAINS THE CREATED CONST (0000=FIRST ENTRY)
         690+ 8    0 TM6D     + NOOP      0000         HERE, C1 IS COMPILE-TIME CONTANT VALUE OF INDEX1 (IF IS >0)
         691+10 2674          + R ADD     RIDX2
         692+ 4  721          + TR 0      TM7V         TR IF REFERENCE IS A VECTOR
         693+ 5 1470          + SUB       S1N
         694+ 4  696          + TR 0      TM7A         TR IF REFERENCE RIDX2 = INDEX IN "SET/USE" INSTR 
         695+ 1  701          + TR        TM7B         TR IF REFERENCE IS USING ITS OWN 2ND INDEX 
         696+10 2658 TM7A     + R ADD     ECONSTIX
         697+12 2667          + STORE     I2           RUN-TIME VALUE OF INDEX2 (HAS THE VALUE C2 IN RUN-TIME IF INDEX SET TO A CONSTANT AS IN "SET I 2")
         698+10 1471          + R ADD     S2N
         699+12 2666          + STORE     C2           C2=COMPILE-TIME CONTANT VALUE OF INDEX2 (IF >0)
         700+ 1  732          + TR        TM7D
         701+10 2674 TM7B     + R ADD     RIDX2        GET 2ND INDEX OF REFERENCE, 
         702+ 4  234          + TR 0      BADOP        SHOULD NOT BE EMPTY
         703+ 3  725          + TR +      TM7C         TR IF 2ND INDEX IN REFERENCE IS A CONSTANT
         704+10  704          + R ADD     *
         705+ 1   77          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         706+ 0 2058          + STOP      TIDXNAME     ... INDEX NAME TABLE
         707+ 0 2057          + STOP      NIDXS        ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
         708+ 0 2674          + STOP      RIDX2        ... THE VALUE TO FIND 
         709+ 4  234          + TR 0      BADOP        REFERENCE'S INDEX2 SHOULD BE DEFINED
         710+12 1677          + STORE     N
         711+10  711          + R ADD     *            READ FROM TIDX TABLES
         712+ 1   73          + TR        READTBL
         713+ 0 2092          + STOP      TIDXLOC      READ THE ENTRY IN LOOP CONSTANT POOL THAT CONTAINS INDEX VALUE
         714+ 0 1677          + STOP      N
         715+ 0 2659          + STOP      ECONST       = TIDXLOC [REFERENCE INDEX2] 
         716+10 2659          + R ADD     ECONST
         717+12 2667          + STORE     I2           I2=RUN-TIME VALUE OF INDEX2 Of REFERENCE
         718+ 6 2620          + R SUB     ONE
         719+12 2666          + STORE     C2           C2=-1 BECAUSE NO COMPILE-TIME CONTANT VALUE OF INDEX2 
         720+ 1  732          + TR        TM7D
         721+ 6 2620 TM7V     + R SUB     ONE
         722+12 2667          + STORE     I2           REFERENCE IS A VECTOR -> NO SECOND INDEX -> I2=-1
         723+12 2666          + STORE     C2     
         724+ 1  732          + TR        TM7D
         725+10 2674 TM7C     + R ADD     RIDX2
         726+12 2666          + STORE     C2           COMPILE-TIME CONTANT VALUE OF INDEX2 (AS IS >0)
         727+10  727          + R ADD     *
         728+ 1 1096          + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
         729+ 0 2744          + STOP      REG.A        '+H  A nnnn' -> CONSTANT VALUE = CONSTANT IN REFRENECE INDEX2
         730+ 0 2666          + STOP      C2
         731+12 2667          + STORE     I2           SAVE THE ENTRY IN POOL THAT CONTAINS THE CREATED CONST (0000=FIRST ENTRY)
         732+ 8    0 TM7D     + NOOP      0000         HERE, C2 IS COMPILE-TIME CONTANT VALUE OF INDEX2 (IF IS >0)
         733+10 2667          + R ADD     I2           CHECK IF 2ND INDEX IS TO BE USED
         734+ 3  774          + TR +      TMM0         IF I2 >=0 -> USE 2ND INDEX -> TR 
         735+10 2662          + R ADD     D1
         736+ 3  738          + TR +      TVM1         TR IF D1 DIMENSION IS A COMPILE TIME CONSTANT
         737+ 1  767          + TR        TVMGEN       TR TO GENERAL FORM: D1 DIMENSION IS A PARAM NOT KNOW AT COMPILE TIME
         738+10 2664 TVM1     + R ADD     C1           D1 DIMENSION IS KNOW AT COMPILE TIME, CHECK 1ST INDEX
         739+ 3  744          + TR +      TVMEADDR     TR TO EFFECTIVE ADDRESS FORM: D1 AND 1ST INDEX ARE COMPILE TIME CONSTANTS
         740+10 2662          + R ADD     D1
         741+ 5 2621          + SUB       TWO
         742+ 4  754          + TR 0      TVMX2        TR TO SHIFT GENERATED ADDRESS FORM: D1=2 AS COMPILE TIME CONSTANT
         743+ 1  767          + TR        TVMGEN       ANY OTHER CASE: TR TO GENERAL FORM
         744+10 2664 TVMEADDR + R ADD     C1           COMPUTE THE EFFECTIVE ADDRESS
         745+22    1          + A LEFT    0001
         746+ 5 2621          + SUB       TWO
         747+ 9 2677          + ADD       RADDR
         748+12 1679          + STORE     VAL          VAL=RADDR + C1 * 2 - 2
         749+10  749 TVRA     + R ADD     *            '+RA  C addconst=VAL'
         750+ 1  903          + TR        GPVADDR  
         751+ 0    1          + STOP      0001         =1 -> generates '+ra v addr', =0 -> generates '+a v addr'
         752+ 0 1679          + STOP      VAL
         753+ 1  875          + TR        GMVOK         
         754+10  754 TVMX2    + R ADD     *            '+RA  C addconst=RADDR'
         755+ 1  903          + TR        GPVADDR  
         756+ 0    1          + STOP      0001         =1 -> generates '+ra v addr', =0 -> generates '+a v addr'
         757+ 0 2677          + STOP      RADDR
         758+10 2665          + R ADD     I1           ENTRY IN CONSTANT POOL THAT CONTAINS THE 1ST INDEX VALUE TO BE USED
         759+12 2659          + STORE     ECONST
         760+10  760 TVMD2    + R ADD     *            USE GENERAL FORM TO GENERATE ADDRESS FOR INDEX WITH DIMENSION=2
         761+ 1 1166          + TR        GENINST     
         762+ 9 1005          + ADD       CNN          '+A  C econst=I1'
         763+ 9 1005          + ADD       CNN          '+A  C econst=I1'
         764+ 5 1007          + SUB       C02          '+S  C econst=2'
         765+ 0    0          + STOP      0000         END OF INSTR TABLE
         766+ 1  875          + TR        GMVOK
         767+10  767 TVMGEN   + R ADD     *            '+RA C econst=I1'
         768+ 1  885          + TR        GI1XD1       '+S  C econst=1'
         769+10  769          + R ADD     *            '+A  C addconst=RADDR'
         770+ 1  903          + TR        GPVADDR  
         771+ 0    0          + STOP      0000         =1 -> generates '+ra v addr', =0 -> generates '+a v addr'
         772+ 0 2677          + STOP      RADDR
         773+ 1  875          + TR        GMVOK
         774+ 8    0 TMM0     + NOOP      0000         MC INSTR TO GENERATE ADDR FOR MATRIX
         775+10 2662          + R ADD     D1
         776+ 3  778          + TR +      TMM1         TR IF D1 DIMENSION IS A COMPILE TIME CONSTANT
         777+ 1  786          + TR        TMMGEN       TR TO GENERAL FORM: D1 DIMENSION IS NOT KNOW AT COMPILE TIME
         778+10 2664 TMM1     + R ADD     C1           D1 DIMENSION IS KNOWN AT COMPILE TIME CONSTANT, CHECK 1ST AND 2ND INDEX
         779+ 3  783          + TR +      TMM2         TR IF C1 IS KNOWN AT COMPILE -> GENERATE EFFECTIVE ADDRESS
         780+10 2666          + R ADD     C2           1ST INDEX NOT KNOWN AT COMPILE TIME CONSTANT, CHECK 2ND INDEX
         781+ 3  795          + TR +      TMXD1+C      TR TO MULT RUNTIME VALUE OF 1ST INDEX x D1 CONST + CONSTANT (AS 2ND INDEX KWON AT COMPILE TIME)
         782+ 1  786          + TR        TMMGEN       TR TO GENERAL FORM: 1ST INDEX AND 2ND INDEX ARE NOT KNOW AT COMPILE TIME
         783+10 2666 TMM2     + R ADD     C2           D1 AND 1ST INDEX ARE KNOW AT COMPILE TIME, CHECK 2ND INDEX
         784+ 3  819          + TR +      TMMEADDR     TR TO EFFECTIVE ADDRESS FORM: D1, 1ST AND 2ND INDEX ARE COMPILE TIME CONSTANTS
         785+ 1  807          + TR        TMMEA+O      TR TO EFFECTIVE ADDRESS PLUS OFFSET FORM: D1 AND 1ST INDEX ARE COMPILE TIME CONSTANT, JUST ADD 2ND INDEX RUNTIME GENERATED OFFSET
         786+10  786 TMMGEN   + R ADD     *            '+RA C econst=I1'
         787+ 1  885          + TR        GI1XD1       '+S  C econst=1'
         788+10  788          + R ADD     *            '+A  C addconst=RADDR'
         789+ 1  903          + TR        GPVADDR  
         790+ 0    0          + STOP      0000         =1 -> generates '+ra vaddr', =0 -> generates '+a vaddr'
         791+ 0 2677          + STOP      RADDR
         792+10 2667 TMMD2    + R ADD     I2           ENTRY IN CONSTANT POOL THAT CONTAINS THE 2ND INDEX VALUE TO BE USED
         793+12 2659          + STORE     ECONST       
         794+ 1  760          + TR        TVMD2        TR TO ADD THIS INDEX KNOWN AT RUN-TIME (IT HAS DIMENSION = 2)
         795+10  795 TMXD1+C  + R ADD     *            '+RA C econst=I1'
         796+ 1  885          + TR        GI1XD1       '+S  C econst=1'
         797+10 2666          + R ADD     C2           COMPUTE THE EFFECTIVE ADDRESS
         798+22    1          + A LEFT    0001
         799+ 5 2621          + SUB       TWO
         800+ 9 2677          + ADD       RADDR
         801+12 1679          + STORE     VAL          VAL=RADDR + C2 * 2 - 2
         802+10  802          + R ADD     *            '+A  C addconst=VAL'
         803+ 1  903          + TR        GPVADDR  
         804+ 0    0          + STOP      0000         =1 -> generates '+ra vaddr', =0 -> generates '+a vaddr'
         805+ 0 1679          + STOP      VAL
         806+ 1  875          + TR        GMVOK
         807+10 2664 TMMEA+O  + R ADD     C1           COMPUTE THE EFFECTIVE ADDRESS
         808+ 5 2620          + SUB       ONE
         809+21   35          + L RIGHT   0035
         810+16 2662          + MPY       D1
         811+22   17          + A LEFT    0017
         812+ 9 2677          + ADD       RADDR
         813+12 1679          + STORE     VAL          VAL=RADDR + (C1 - 1) * D1
         814+10  814          + R ADD     *            '+RA  C addconst=VAL'
         815+ 1  903          + TR        GPVADDR  
         816+ 0    1          + STOP      0001         =1 -> generates '+ra vaddr', =0 -> generates '+a vaddr'
         817+ 0 1679          + STOP      VAL
         818+ 1  792          + TR        TMMD2        TR TO ADD I2 THIS INDEX KNOWN AT RUN-TIME (IT HAS DIMENSION = 2)
         819+10 2664 TMMEADDR + R ADD     C1           COMPUTE THE EFFECTIVE ADDRESS
         820+ 5 2620          + SUB       ONE
         821+21   35          + L RIGHT   0035
         822+16 2662          + MPY       D1
         823+22   17          + A LEFT    0017
         824+ 9 2666          + ADD       C2
         825+ 9 2666          + ADD       C2
         826+ 5 2621          + SUB       TWO
         827+ 9 2677          + ADD       RADDR
         828+12 1679          + STORE     VAL          VAL=RADDR + (C1 - 1) * D1 + C2 * 2 - 2
         829+ 1  749          + TR        TVRA         TR TO GENERATE '+RA add const=VAL'
         830+10 1470 IDDO     + R ADD     S1N          IF 1ST INDEX UNDEFINED?
         831+ 5 2642          + SUB       O776K
         832+ 4  834          + TR 0      CKIDDO1
         833+ 1  840          + TR        CKIDDO2
         834+10  834 CKIDDO1  + R ADD     *            YES, CHECK IF DEFINED
         835+ 1   77          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         836+ 0 2598          + STOP      TFORIDX      ... INDEX NAME TABLE
         837+ 0 2597          + STOP      NFORIDX      ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
         838+ 0 1460          + STOP      S1           ... THE VALUE TO FIND 
         839+ 4 1090          + TR 0      ERRNDIX1     TR TO ERROR IF 1ST INDEX IS NOT DEFINED BY A "FOR I A B" INSTR      
         840+10 1471 CKIDDO2  + R ADD     S2N          IF 2ND INDEX UNDEFINED?
         841+ 5 2642          + SUB       O776K
         842+ 4  844          + TR 0      CKIDDO3
         843+ 1  850          + TR        CKIDDO4
         844+10  844 CKIDDO3  + R ADD     *            YES, CHECK IF DEFINED
         845+ 1   77          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         846+ 0 2598          + STOP      TFORIDX      ... INDEX NAME TABLE
         847+ 0 2597          + STOP      NFORIDX      ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
         848+ 0 1461          + STOP      S2           ... THE VALUE TO FIND 
         849+ 4 1093          + TR 0      ERRNDIX2     TR TO ERROR IF 2ND INDEX IS NOT DEFINED BY A "FOR I A B" INSTR      
         850+ 8    0 CKIDDO4  + NOOP      0000
         851+ 1  999          + TR        CHECKREF
         852+10 1469 FORDO    + R ADD     FACTREG     
         853+ 4  855          + TR 0      FORDO1
         854+ 1  235          + TR        NEXT         FOR IS 'V','T','N' -> "FOR var" -> NOT "FOR Index A B" -> CONTINUE
         855+10 1459 FORDO1   + R ADD     FACT
         856+ 4  235          + TR 0      NEXT         FACTOR IS BLANK -> "FOR <blank>" -> CONTINUE
         857+10 2597          + R ADD     NFORIDX      CHECK IF TABLE OVERLOW
         858+ 5 2596          + SUB       MAXNFOI     
         859+ 4  869          + TR 0      ERROVFOI     
         860+10 2597          + R ADD     NFORIDX      CREATE NEW ENTRY
         861+ 9 2620          + ADD       ONE
         862+12 2597          + STORE     NFORIDX      NUMBER OF INDEX IN "FOR I A B" 
         863+10  863          + R ADD     *            
         864+ 1   69          + TR        EQTBL        
         865+ 0 2598          + STOP      TFORIDX     
         866+ 0 2597          + STOP      NFORIDX
         867+ 0 1459          + STOP      FACT         TFORIDX[NFORIDX] = FACT
         868+ 1  235          + TR        NEXT
         869+10  869 ERROVFOI + R ADD     *
         870+ 1  413          + TR        ERROR
         871+ 0 2725          + STOP      ERROVFOS     ERROR: TOO MANY "FOR I A B" (MAX 20)
         872+10 2618 CLNFORIX + R ADD     ZERO
         873+12 2597          + STORE     NFORIDX
         874+ 1  235          + TR        NEXT
         875+ 8    0 GMVOK    + NOOP      0000         GENERATE THE INSTRUCTIONS TO SAVE COMPUTED VECTOR/MATRIX ADDRESS
         876+10 2675          + R ADD     RSTEPN       
         877+12 2646          + STORE     TRANSFER     INN = addr of stepN given in var TRANSFER = stepN of reference, TRSTLOC = location in reference stepn machine code
         878+10 2676          + R ADD     RINCRN       CNN = location in region loop constants pool
         879+12 2647          + STORE     TRSTLOC
         880+10  880          + R ADD     *            
         881+ 1 1166          + TR        GENINST     
         882+13 1004          + STORE A   INN          '+SA I /  /'     store back the address of reference var incremented by D1 
         883+ 0    0          + STOP      0000         END OF INSTR TABLE
         884+ 1    0 GMVEXIT  + TR        /   /
         885+ 9 2621 GI1XD1   + ADD       TWO          
         886+13  902          + STORE A   GI1XD1EX     
         887+10 2665          + R ADD     I1           ENTRY IN CONSTANT POOL THAT CONTAINS THE 1ST INDEX VALUE TO BE USED
         888+12 2659          + STORE     ECONST
         889+10  889          + R ADD     *            USE GENERAL FORM TO GENERATE ADDRESS FOR VECTORS
         890+ 1 1166          + TR        GENINST     
         891+10 1005          + R ADD     CNN          '+RA C econst=I1'
         892+ 5 1006          + SUB       C01          '+S  C econst=1'
         893+ 0    0          + STOP      0000         END OF INSTR TABLE
         894+10 2663          + R ADD     ECONSTD1
         895+12 2659          + STORE     ECONST
         896+10  896          + R ADD     *            USE GENERAL FORM TO GENERATE ADDRESS FOR VECTORS
         897+ 1 1166          + TR        GENINST     
         898-21 1002          - L RIGHT   A35          '-LR A 0035'
         899+16 1005          + MPY       CNN          '+M  C econst=ECONSTD1'
         900+22 1003          + A LEFT    A17          '-AL A 0017'
         901+ 0    0          + STOP      0000         END OF INSTR TABLE
         902+ 1    0 GI1XD1EX + TR        /   /   
         903+ 9 2621 GPVADDR  + ADD       TWO
         904+13  909          + STORE A   GPVAP1
         905+ 9 2620          + ADD       ONE
         906+13  914          + STORE A   GPVAP2
         907+ 9 2620          + ADD       ONE
         908+13  928          + STORE A   GPVAEX      
         909+10    0 GPVAP1   + R ADD     /   /
         910+15  927          + LOAD MQ   GPVADD
         911+ 4  913          + TR 0      GPV1
         912+15  926          + LOAD MQ   GPVRADD
         913+14  923 GPV1     + STORE MQ  GPV2
         914+10    0 GPVAP2   + R ADD     /   /        GET THE ADDR OF DATA
         915+13  919          + STORE A   GPV3
         916+10  916          + R ADD     *
         917+ 1 1096          + TR        ADDCONST     ADD CONSTANT REFERENCE ADDR V nnnn TO LOOP CONSTANT POOL 
         918+ 0 2746          + STOP      REG.V        '+H  V 0002' -> THE MC INST WITH ADDR TO STORE IN LOOP COSTANT POOL
         919+ 0 2677 GPV3     + STOP      RADDR
         920+12 2659          + STORE     ECONST       SAVE THE ENTRY IN CONSTANTS POOL THAT CONTAINS THE CREATED VALUE
         921+10  921          + R ADD     *            USE GENERAL FORM TO GENERATE ADDRESS FOR VECTORS
         922+ 1 1166          + TR        GENINST     
         923+ 9 1005 GPV2     + ADD       CNN          '+A  C econst=RADDR' 
         924+ 0    0          + STOP      0000         END OF INSTR TABLE
         925+ 1  928          + TR        GPVAEX
         926+10 1005 GPVRADD  + R ADD     CNN
         927+ 9 1005 GPVADD   + ADD       CNN
         928+ 1    0 GPVAEX   + TR        /   /   
         929+10  929 ERROVLOC + R ADD     *
         930+ 1  413          + TR        ERROR
         931+ 0 2697          + STOP      ERROVLOS     ERROR: TOO MANY LOOP CONSTANTS IN POOL         
         932+10 1470 TEST     + R ADD     S1N          GET INDEX NAME
         933+10  933          + R ADD     *
         934+ 1   77          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         935+ 0 2058          + STOP      TIDXNAME     ... INDEX NAME TABLE
         936+ 0 2057          + STOP      NIDXS        ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
         937+ 0 1470          + STOP      S1N          ... THE VALUE TO FIND 
         938+ 4  234          + TR 0      BADOP        INDEX NOT DEFINED MUST HAVE BEEN DETECTED ON PREVIOUS PASS
         939+12 2655          + STORE     NIDX
         940+10  940          + R ADD     *            SET INDEX TYPE AS SAVED IN QR VAR BY PREVIOUS PASS:
         941+ 1   69          + TR        EQTBL            QR=0 IN CC RECORD TO SIGNAL INDEX IS "ADDRESS TYPE"
         942+ 0 2126          + STOP      TIDXTYPE         QR=1 IN CC RECORD TO SIGNAL INDEX IS "COUNT TYPE"
         943+ 0 2655          + STOP      NIDX
         944+ 0 1462          + STOP      QR           TIDXTYPE[NIDX] = QR 
         945+ 1  235          + TR        NEXT
         946+ 9 2621 SASAME   + ADD       TWO          EXAMINE REMAINING REFERENCES. GENERATE '+SA ' INSTR TO SAVE THE 
         947+13  998          + STORE A   SASAMEEX     ADDR ON ACC TO REFERENCES TO SAME VECTOR/MATRIX
         948+10 2669          + R ADD     NREF         EXAMINE REMAINING REFERENCES. 
         949+12 2670          + STORE     NREF2        
         950+10 2670 SALOOP2  + R ADD     NREF2
         951+ 5 2195          + SUB       NREFS        GENERATE '+SA I /  /' MC INST FOR
         952+ 4  998          + TR 0      SASAMEEX     ALL REFERENCES OF SAME VECTOR/MATRIX PROCESSED
         953+10 2670          + R ADD     NREF2
         954+ 9 2620          + ADD       ONE
         955+12 2670          + STORE     NREF2
         956+10  956          + R ADD     *            READ SEVERAL VALUES FROM TREF TABLES
         957+ 1   75          + TR        READTBL2
         958+ 0 2196          + STOP      TREFNAME     READ THE FIRST VARIABLE REFERENCE
         959+ 0 2194          + STOP      MAXNREFS
         960+ 0 2670          + STOP      NREF2
         961+ 0 2678          + STOP      R2NAME       = TREFNAME[NREF2]   REFERENCE NAME
         962+ 0 2679          + STOP      R2IDX1       = TREFIDX1[NREF2]   INDEX1 USED BY REFERENCE 
         963+ 0 2680          + STOP      R2IDX2       = TREFIDX2[NREF2]   INDEX2 USED BY REFERENCE 
         964+ 0 2681          + STOP      R2STEPN      = TREFSTPN[NREF2]   STEPN OF INSTR WHERE THE REFERENCE IS MADE
         965+ 0 2682          + STOP      R2INCRN      = TREFINCN[NREF2]   INCRN OF REFERENCE IN THIS STEP
         966+ 0 1679          + STOP      VAL          = TREFOP  [NREF2]   
         967+ 0 2683          + STOP      R2ADDR       = TREFADDR[NREF2]   ADDRESS OF VARIABLE/MATRIX Vnnnn
         968+ 0    0          + STOP      0000
         969+10 2678          + R ADD     R2NAME       CHECK IF REFERENCE ALREADY PROCESSED
         970+ 4  950          + TR 0      SALOOP2      IF SO, TRY NEXT REFERENCE 
         971+10 2683          + R ADD     R2ADDR       CHECK IF SAME MATRIX/VECTOR 
         972+ 5 2677          + SUB       RADDR        IF NOT, TRY NEXT REFERENCE 
         973+ 4  975          + TR 0      SA6A
         974+ 1  950          + TR        SALOOP2
         975+10 2679 SA6A     + R ADD     R2IDX1
         976+ 5 2673          + SUB       RIDX1
         977+ 4  979          + TR 0      SA6B
         978+ 1  950          + TR        SALOOP2
         979+10 2680 SA6B     + R ADD     R2IDX2
         980+ 5 2674          + SUB       RIDX2
         981+ 4  983          + TR 0      SA6C
         982+ 1  950          + TR        SALOOP2
         983+ 8    0 SA6C     + NOOP      0000         HERE WE HAVE ANOTHER REFERENCE TO SAME VECTOR
         984+10 2681          + R ADD     R2STEPN       
         985+12 2646          + STORE     TRANSFER     INN = addr of stepN given in var TRANSFER = stepN of reference, TRSTLOC = location in reference stepn machine code
         986+10 2682          + R ADD     R2INCRN      CNN = location in region loop constants pool
         987+12 2647          + STORE     TRSTLOC
         988+10  988          + R ADD     *            GENERATE THE INSTRUCTIONS TO INCREMENT THE SAME REFERENCED VECTOR ADDRESS 
         989+ 1 1166          + TR        GENINST     
         990+13 1004          + STORE A   INN          '+SA I /  /'     store back the address of reference var incremented by D1
         991+ 0    0          + STOP      0000         END OF INSTR TABLE
         992+10  992          + R ADD     *            
         993+ 1   69          + TR        EQTBL
         994+ 0 2196          + STOP      TREFNAME     CLEAR THE NAME OF REFERENCE TO SIGNAL IT IS ALREADY PROCESSED -> BECOMES AN EMPTY ENTRY 
         995+ 0 2670          + STOP      NREF2
         996+ 0 2618          + STOP      ZERO         TREFNAME[NREF] = 0
         997+ 1  950          + TR        SALOOP2
         998+ 1    0 SASAMEEX + TR        /   /
         999+10 1469 CHECKREF + R ADD     FACTREG
        1000+ 5 2632          + SUB       D34          'V'
        1001+ 4 1003          + TR 0      CK1
        1002+ 1  235          + TR        NEXT         STEP NOT USING A VARIABLE
        1003+10 1470 CK1      + R ADD     S1N          IF S1N <0 (ALFA BASE48 INDEX NAME) -> STORE IN REFERENCES
        1004+ 3 1006          + TR +      CK1A         IF S1N >=0 (NUMERIC CONSTANT/BLANK) -> IS NOT AN INDEX -> TR TO CHECK INDEX2
        1005+ 1 1008          + TR        CK1B
        1006+10 1471 CK1A     + R ADD     S2N          IF S1N <0 (ALFA BASE48 INDEX NAME) -> STORE IN REFERENCES
        1007+ 3  235          + TR +      NEXT         IF S1N >=0 (NUMERIC CONSTANT/BLANK) -> IS NEITHER AN INDEX 
        1008+10 2195 CK1B     + R ADD     NREFS        CREATE A NEW REFERENCE ENTRY
        1009+ 4 1018          + TR 0      CK1NEW       IF TABLE EMPTY -> TR TO CREATE A NEW ENTRY
        1010+10 1010          + R ADD     *
        1011+ 1   77          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
        1012+ 0 2196          + STOP      TREFNAME     ... INDEX NAME TABLE
        1013+ 0 2195          + STOP      NREFS        ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
        1014+ 0 2618          + STOP      ZERO         ... THE VALUE TO FIND 
        1015+ 4 1018          + TR 0      CK1NEW       NO EMPTY ENTRY FOUND -> TR TO CREATE A NEW ONE
        1016+12 2669          + STORE     NREF         EMPTY ENTRY FOUND -> TR TO USE IT
        1017+ 1 1025          + TR        CK1NEW2
        1018+10 2195 CK1NEW   + R ADD     NREFS        CHECK IF TABLE OVERLOW
        1019+ 5 2194          + SUB       MAXNREFS     
        1020+ 4 1087          + TR 0      ERROVREF     
        1021+10 2195          + R ADD     NREFS        CREATE NEW REF
        1022+ 9 2620          + ADD       ONE
        1023+12 2195          + STORE     NREFS
        1024+12 2669          + STORE     NREF
        1025+10 1475 CK1NEW2  + R ADD     NINCR        GET THE MC INSTR POINTED BY
        1026+ 4  234          + TR 0      BADOP        NINCR THAT REFERENCES THE 
        1027+ 5 2620          + SUB       ONE          FACTOR VARIABLE
        1028+22    1          + A LEFT    0001
        1029+ 9  161          + ADD       TINSTAD
        1030+13 1031          + STORE A   CK3C
        1031-10    0 CK3C     - R ADD     /   /
        1032-12 1680          - STORE     DATA         
        1033+10 1033          + R ADD     *            STORE IN TABLES
        1034+ 1   71          + TR        EQTBL2
        1035+ 0 2196          + STOP      TREFNAME     
        1036+ 0 2194          + STOP      MAXNREFS
        1037+ 0 2669          + STOP      NREF
        1038+ 0 1459          + STOP      FACT         TREFNAME[NREF] = 
        1039+ 0 1470          + STOP      S1N          TREFIDX1[NREF] <0 -> INDEX NAME, =0 -> NO INDEX,  >0 -> CONSTANT
        1040+ 0 1471          + STOP      S2N          TREFIDX2[NREF] <0 -> INDEX NAME, =0 -> NO INDEX,  >0 -> CONSTANT 
        1041+ 0 1467          + STOP      STEPN        TREFSTEP[NREF] = 
        1042+ 0 1475          + STOP      NINCR        TREFINCR[NREF] = 
        1043+ 0 1680          + STOP      DATA         TREFOP  [NREF] = 
        1044+ 0 1681          + STOP      DATA2        TREFADDR[NREF] = 
        1045+ 0 1472          + STOP      D1N          TREFD1  [NREF] = 
        1046+ 0    0          + STOP      0000
        1047+ 1  235          + TR        NEXT         
        1048+ 9 2621 SETREGCI + ADD       TWO          APPLY REGCSTEP VALUE TO UPDATE MC INSTR USING REG.C 
        1049+13 1086          + STORE A   SETCIEX      TO THE ACTUAL REG.C STEPN WHERE THE LOOP CONSTANTS ARE STORED
        1050+10 2618          + R ADD     ZERO      
        1051+12 2650          + STORE     MC.REG
        1052+12 1677          + STORE     N
        1053+10  161          + R ADD     TINSTAD
        1054+13 1062          + STORE A   SRCIRD
        1055+13 1080          + STORE A   SRCIWR
        1056+10 1677 SRCILOOP + R ADD     N
        1057+ 5 1474          + SUB       NINST
        1058+ 4 1086          + TR 0      SETCIEX      NO MORE MC INSTR
        1059+10 1677          + R ADD     N
        1060+ 9 2620          + ADD       ONE         
        1061+12 1677          + STORE     N
        1062-10    0 SRCIRD   - R ADD     /   /        GET MC INSTR FROM TINST TABLE
        1063-12 1680          - STORE     DATA
        1064+10 1680          + R ADD     DATA         GET MC.OP + REGION (0..7)
        1065+13 2650          + STORE A   MC.REG
        1066+10 2650          + R ADD     MC.REG       IS REGION C?
        1067+ 5 2749          + SUB       REG.C
        1068+ 4 1070          + TR 0      SRCI1        TR IF SO
        1069+ 1 1081          + TR        SRCINXT      NO REGION C -> TRY WITH NEXT INSTR
        1070+10 1681 SRCI1    + R ADD     DATA2        IF MC.ADDR >=0 THEN MC.REG HOLDS THE REGION FOR MC.ADDR 
        1071+ 9 2620          + ADD       ONE          IF MC.ADDR <0 THEN MC.REG VAR HOLDS THE LOCATION INTO STEPN REFERENCED BY MC.ADDR
        1072+12 2650          + STORE     MC.REG       MC.ADDR HOLDS THE STEPN (WITH MINUS SIGN)
        1073+ 6 2653          + R SUB     REGCSTEP     LOCATION INTO STEP = C0000 + 1
        1074+12 2651          + STORE     MC.ADDR   
        1075+10 2650          + R ADD     MC.REG       COMPOSE THE MC INSTR TO SAVE IN TINST, REPLACING "REG.C ADDR" REFERENCE
        1076+13 1680          + STORE A   DATA         WITH "REG.I STEPN.LOCATION" REFERENCE
        1077+10 2651          + R ADD     MC.ADDR
        1078+12 1681          + STORE     DATA2
        1079-10 1680          - R ADD     DATA         SAVE BACK TO TINST
        1080-12    0 SRCIWR   - STORE     /   /
        1081+10 1062 SRCINXT  + R ADD     SRCIRD       SELECT NEXT MC INSTR
        1082+ 5 2621          + SUB       TWO
        1083+13 1062          + STORE A   SRCIRD
        1084+13 1080          + STORE A   SRCIWR
        1085+ 1 1056          + TR        SRCILOOP
        1086+ 1    0 SETCIEX  + TR        /   /
        1087+10 1087 ERROVREF + R ADD     *
        1088+ 1  413          + TR        ERROR
        1089+ 0 2705          + STOP      ERROVRFS     ERROR: TOO MANY REFERENCES TO MATRIX/VECTOR IN REGION (MAX 50)
        1090+10 1090 ERRNDIX1 + R ADD     *
        1091+ 1  413          + TR        ERROR
        1092+ 0 2711          + STOP      ERRNDI1S     ERROR: 1ST INDEX NOT DEFINED (TO BE USED WITH VECTOR/MATRIX INDEX SHOULD BE DEFINED WITH USE/SET)
        1093+10 1093 ERRNDIX2 + R ADD     *
        1094+ 1  413          + TR        ERROR
        1095+ 0 2718          + STOP      ERRNDI2S     ERROR: 2ND INDEX NOT DEFINED (TO BE USED WITH VECTOR/MATRIX INDEX SHOULD BE DEFINED WITH USE/SET)
        1096+ 9 2621 ADDCONST + ADD       TWO          ADD CONSTANT TO LOOP CONSTANT POOL 
        1097+13 1102          + STORE A   ADDCP1       PARAMS: +OP    REG     <-- THE SIGNED OP AND REGION OF CONSTANT
        1098+ 9 2620          + ADD       ONE                   00    ADDR        THE ADDR. IF =0 -> ALLWAYS STORE A NEW CONSTANT 
        1099+13 1119          + STORE A   ADDCP2       RETURN IN ACC THE ENTRY OF ADDED CONST (FIRST ENTRY = 0000)
        1100+ 9 2620          + ADD       ONE                           
        1101+13 1165          + STORE A   ADDCONEX     SEARCH IF CONST ALREADY BEEN ADDED, IF SO RETURN ITS ENTRY
        1102+10    0 ADDCP1   + R ADD     /   /        THE OP AND REGION PART OF CONSTANT
        1103+13 1105          + STORE A   ADDCP1A      SAVE THE ADDR OF VAR THAT HOLD THE REGION NUMBER 0..7
        1104+12 1680          + STORE     DATA         SAVE OP
        1105+10    0 ADDCP1A  + R ADD     /   /        READ THE REGION NUM FROM VAR 
        1106+13 1680          + STORE A   DATA         ADD TO OP. NOW OP= +/- OPCODE AND REGION 0..7
        1107+10 1683          + R ADD     NLOCONST     GET NUMBER OF ENTRIES
        1108+ 4 1110          + TR 0      AN1A         IF EMPTY, ADD 1ST ENTRY '+H A 0002'
        1109+ 1 1117          + TR        AN1Z                       2ND ENTRY '+H A 0001'
        1110+10 2621 AN1A     + R ADD     TWO
        1111+12 1683          + STORE     NLOCONST     
        1112+23   18          + A RIGHT   0018
        1113-12 1684          - STORE     TLOCONST
        1114+10 2620          + R ADD     ONE
        1115+23   18          + A RIGHT   0018
        1116-12 1686          - STORE     TLOCONS2
        1117+10 2618 AN1Z     + R ADD     ZERO
        1118+12 1681          + STORE     DATA2
        1119+10    0 ADDCP2   + R ADD     /   /        THE ADDR OF VALUE TO STORE IN ADDR PART OF CONSTANT 
        1120+ 4 1145          + TR 0      ADDNEW       IF ZERO -> JUST ADD A NEW ENTRY IN POOL
        1121+13 1122          + STORE A   ADDCP2A
        1122+10    0 ADDCP2A  + R ADD     /   /        THE VALUE TO STORE
        1123+12 1681          + STORE     DATA2
        1124+10 1162          + R ADD     TLOCONAD     ADDR OF START OF LOOP CONSTANT TABLE
        1125+13 1130          + STORE A   ADDCLOOP 
        1126+10 1683          + R ADD     NLOCONST 
        1127+22    1          + A LEFT    0001
        1128+ 9 1162          + ADD       TLOCONAD
        1129+13 1163          + STORE A   TLOCOEND     ADDR OF END OF LOOP CONSTANT TABLE
        1130-10    0 ADDCLOOP - R ADD     /   /
        1131- 5 1680          - SUB       DATA
        1132+ 4 1139          + TR 0      ADDFND       FOUND IN LOOP CONSTANT POOL
        1133+10 1130          + R ADD     ADDCLOOP 
        1134+ 5 2621          + SUB       TWO
        1135+13 1130          + STORE A   ADDCLOOP 
        1136+ 5 1163          + SUB       TLOCOEND
        1137+ 4 1147          + TR 0      ADDNFND      NOT FOUND IN POOL -> JUST ADD A NEW ENTRY IN POOL
        1138+ 1 1130          + TR        ADDCLOOP 
        1139+ 6 1130 ADDFND   + R SUB     ADDCLOOP     COMPUTE THE ENTRY NUMBER (FIRST ENTRY = 0000)
        1140+ 5 1162          + SUB       TLOCONAD     
        1141+13 1164          + STORE A   TLOCENT  
        1142+10 1164          + R ADD     TLOCENT  
        1143+23    1          + A RIGHT   0001
        1144+ 1 1165          + TR        ADDCONEX 
        1145+10 2618 ADDNEW   + R ADD     ZERO         NEW ENTRY IS INIT TO ZERO
        1146-12 1680          - STORE     DATA
        1147+10 1683 ADDNFND  + R ADD     NLOCONST     ADD NEW ENTRY
        1148+ 5 1682          + SUB       MAXNCONS
        1149+ 4  929          + TR 0      ERROVLOC     ERROR: TOO MANY LOOP CONSTANTS IN POOL
        1150+10 1683          + R ADD     NLOCONST     ADD NEW ENTRY
        1151+12 1164          + STORE     TLOCENT      THE ENTRY (0000=1ST ENTRY) FOR NEW CONSTANT CREATED IN POOL
        1152+ 9 2620          + ADD       ONE
        1153+12 1683          + STORE     NLOCONST     
        1154+ 5 2620          + SUB       ONE
        1155+22    1          + A LEFT    0001
        1156+ 9 1162          + ADD       TLOCONAD 
        1157+13 1159          + STORE A   ADDENT
        1158-10 1680          - R ADD     DATA
        1159-12    0 ADDENT   - STORE     /   /
        1160+10 1164          + R ADD     TLOCENT      RETURN THE ENTRY
        1161+ 1 1165          + TR        ADDCONEX 
        1162+ 0 1684 TLOCONAD + STOP      TLOCONST
        1163-10    0 TLOCOEND - R ADD     0000
        1164+ 0    0 TLOCENT  + STOP      0000
        1165+ 1    0 ADDCONEX + TR        /   /
        1166+ 9 2621 GENINST  + ADD       TWO          GENERATE MACHINE CODE (MC) INSTRUCTIONS
        1167+13 2645          + STORE A   MC.TABLE     MC TABLE FOLLOWS CALL AS PARAMTERS (UNTIL -STOP 0000 INSTR)
        1168+10 1168          + R ADD     *
        1169+ 1 1177          + TR        GENTABLE
        1170+10 1181          + R ADD     GEN1
        1171+ 9 2620          + ADD       ONE
        1172+13 1173          + STORE A   GENEXIT2      
        1173+ 1    0 GENEXIT2 + TR        /   /
        1174+10 1174 GENTBOV  + R ADD     *
        1175+ 1  413          + TR        ERROR
        1176+ 0 2687          + STOP      ERROVINS     ERROR: TOO MANY INSTR IN THIS STEP
        1177+ 9 2621 GENTABLE + ADD       TWO          GENERATE MACHINE CODE (MC) INSTRUCTIONS
        1178+13 1182          + STORE A   GENEXIT      MC TABLE AT LOCATION IN MC.TABLE VAR
        1179+10 2645          + R ADD     MC.TABLE
        1180+13 1181          + STORE A   GEN1
        1181+10    0 GEN1     + R ADD     /   /        READ MACHINE CODE TABLE
        1182+ 4    0 GENEXIT  + TR 0      /   /        =0 -> END OF MC.TABLE-> RETURN TO CALLER
        1183+12 2648          + STORE     MC
        1184+23   30          + A RIGHT   0030         SAVE OPCODE ONLY
        1185+22   30          + A LEFT    0030         (WITH SIGN)
        1186+12 2649          + STORE     MC.OP        IN MC.OP
        1187+10 1474          + R ADD     NINST        INCR NUMBER OF MC INSTRUCTIONS IN CC TABLE
        1188+ 9 2620          + ADD       ONE          ERROR IF > MAXIMUN ALLOWED
        1189+12 1474          + STORE     NINST
        1190+ 5 1678          + SUB       MAXNINST
        1191+ 4 1174          + TR 0      GENTBOV      ERROR: TOO MANY INSTR IN THIS STEP
        1192+10 2618          + R ADD     ZERO
        1193+11 2648          + ADD AB    MC           EXTRACT ADDR PART OF MC 
        1194+ 7 2649          + SUB AB    MC.OP        
        1195+ 5 2641          + SUB       D1000
        1196+ 3 1198          + TR +      GEN2
        1197+ 0 1111          + STOP      1111         INVALID MC.TABLE
        1198+ 9 1203 GEN2     + ADD       ADTBL        USE THE TRANSFER TABLE TO PROCESS IT
        1199+13 1202          + STORE A   ADTBLTR
        1200+10 2618          + R ADD     ZERO
        1201+11 2649          + ADD AB    MC.OP        ON ENTRY TO ROUTINE, ACC=ABS(MC.OP). SIGN IS IN MC VARIABLE
        1202+ 1    0 ADTBLTR  + TR        /   /
        1203+ 0 1203 ADTBL    + STOP      *
        1204+ 1 1266          + TR        GEN.FACT     factor to be replaced by V 0005 (variable), T 0010 (result of a step) or N 0012 (a number)
        1205+ 1 1230          + TR        GEN.A35      A 0035  
        1206+ 1 1235          + TR        GEN.A17      A 0017  
        1207+ 1 1240          + TR        GEN.INN      transfer to location n (1..199) into stepN given in var TRANSFER = stepN, TRSTLOC = location in step machine code
        1208+ 1 1245          + TR        GEN.CNN      C nnnn  where nnnn is the value of ECONST var
        1209+ 1 1250          + TR        GEN.C01      C nnnn  where nnnn is the value ONE in LOOP CONSTANTS POOL
        1210+ 1 1258          + TR        GEN.C02      C nnnn  where nnnn is the value TWO in LOOP CONSTANTS POOL
        1211+10 2648 GENADD   + R ADD     MC           ADD A GENERATED MC INSTR TO TINST TABLE
        1212+ 3 1215          + TR +      GENADD1      TAKE THE SIGN OF MC AND PLACE IT IN MC.OP
        1213+ 6 2649          + R SUB     MC.OP
        1214+12 2649          + STORE     MC.OP
        1215+10 1474 GENADD1  + R ADD     NINST        ADD NINST TWICE AS EACH MC INSTR USES TWO HALF-WORDS
        1216+ 9 1474          + ADD       NINST
        1217+ 5 2621          + SUB       TWO          
        1218+ 9  161          + ADD       TINSTAD      TINSTAD=LOCATION OF TABLE WITH MC INSTRUCTIONS GENERATED FOR THE CURRENT STEP
        1219+13 1223          + STORE A   GENADD2      TINST[ (INST- 1)*2 ] =MC instr op and region
        1220+ 9 2620          + ADD       ONE
        1221+13 1225          + STORE A   GENADD3      TINST[ (INST- 1)*2 ] =MC instr addr
        1222+10 2649          + R ADD     MC.OP        
        1223+12    0 GENADD2  + STORE     /   /        STORE GENERATED MC INSTRUCTION MC.OP (MC.OP CAN BE >0 OR <0)
        1224+10 2651          + R ADD     MC.ADDR
        1225+12    0 GENADD3  + STORE     /   /                                       MC.ADDR (CAN BE >0 OR <0 IF HOLDS A STEPN/LOCATION PAIR)
        1226+10 1181          + R ADD     GEN1         PROCEED WITH NEXT MC INST N LIST
        1227+ 9 2620          + ADD       ONE
        1228+13 1181          + STORE A   GEN1
        1229+ 1 1181          + TR        GEN1
        1230+ 9 2744 GEN.A35  + ADD       REG.A
        1231+12 2649          + STORE     MC.OP        MC.OP   = OPCODE + REGION A
        1232+10 2633          + R ADD     D35
        1233+12 2651          + STORE     MC.ADDR      MC.ADDR = 0035
        1234+ 1 1211          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
        1235+ 9 2744 GEN.A17  + ADD       REG.A
        1236+12 2649          + STORE     MC.OP        MC.OP   = OPCODE + REGION A
        1237+10 2627          + R ADD     D17
        1238+12 2651          + STORE     MC.ADDR      MC.ADDR = 0035
        1239+ 1 1211          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
        1240+ 9 2647 GEN.INN  + ADD       TRSTLOC      TRSTLOC=LOCATION INTO STEPN NUMBER THE MC INSTR HAS TO TRANSFER TO 
        1241+12 2649          + STORE     MC.OP        MC.OP   = OPCODE + LOCATION INTO STEPN
        1242+ 6 2646          + R SUB     TRANSFER     TRANSFER=STEPN NUMBER THE MC INSTR HAS TO TRANSFER TO 
        1243+12 2651          + STORE     MC.ADDR      MC.ADDR = STEPN (WITH MINUS SIGN, TO SIGNAL ADDR POINTS TO STEPN/LOCATION IN THIS STEP PAIR)
        1244+ 1 1211          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
        1245+ 9 2749 GEN.CNN  + ADD       REG.C
        1246+12 2649          + STORE     MC.OP        MC.OP   = OPCODE + REGION C
        1247+10 2659          + R ADD     ECONST
        1248+12 2651          + STORE     MC.ADDR      MC.ADDR = ADDR IN REGION C
        1249+ 1 1211          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
        1250+ 9 2749 GEN.C01  + ADD       REG.C
        1251+12 2649          + STORE     MC.OP        MC.OP   = OPCODE + REGION C
        1252+10 1252          + R ADD     *
        1253+ 1 1096          + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
        1254+ 0 2744          + STOP      REG.A        '+H  A 0001' -> CONSTANT VALUE 1
        1255+ 0 2620          + STOP      ONE
        1256+12 2651          + STORE     MC.ADDR      MC.ADDR = ADDR IN REGION C
        1257+ 1 1211          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
        1258+ 9 2749 GEN.C02  + ADD       REG.C
        1259+12 2649          + STORE     MC.OP        MC.OP   = OPCODE + REGION C
        1260+10 1260          + R ADD     *
        1261+ 1 1096          + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
        1262+ 0 2744          + STOP      REG.A        '+H  A 0002' -> CONSTANT VALUE 2
        1263+ 0 2621          + STOP      TWO
        1264+12 2651          + STORE     MC.ADDR      MC.ADDR = ADDR IN REGION C
        1265+ 1 1211          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
        1266+15 2746 GEN.FACT + LOAD MQ   REG.V
        1267+10 1469          + R ADD     FACTREG
        1268+ 5 2632          + SUB       D34          'V'
        1269+ 4 1279          + TR 0      GEN.FA1
        1270+15 2748          + LOAD MQ   REG.N
        1271+10 1469          + R ADD     FACTREG
        1272+ 5 2630          + SUB       D26          'N'
        1273+ 4 1279          + TR 0      GEN.FA1
        1274+15 2747          + LOAD MQ   REG.T
        1275+10 1469          + R ADD     FACTREG
        1276+ 5 2631          + SUB       D32          'T'
        1277+ 4 1279          + TR 0      GEN.FA1
        1278+ 0 1111          + STOP      1111         INVALID FACT REGION
        1279+10 2618 GEN.FA1  + R ADD     ZERO
        1280+20   35          + L LEFT    0035         A=MQ
        1281+11 2649          + ADD AB    MC.OP
        1282+12 2649          + STORE     MC.OP        MC.OP   = OPCODE + REGION OF FACTOR (CAN BE V, N OR T)
        1283+10 1468          + R ADD     FACTN
        1284+12 2651          + STORE     MC.ADDR      MC.ADDR = FACTN
        1285+10 1474          + R ADD     NINST   
        1286+12 1475          + STORE     NINCR        NINCR= THE LOCATION OF FACTOR MC INSTRUCTION INTO THE STEP 
        1287+ 1 1211          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
        1288+ 9 2621 PRTMC    + ADD       TWO          PRINT TINST TABLE WITH MC INSTRUCTIONS GENERATED FOR THIS STEP
        1289+13 1431          + STORE A   PRTMCEX
        1290+10 2618          + R ADD     ZERO
        1291+12 2652          + STORE     PRTMCNUM
        1292+10 2652 PMCLOOP  + R ADD     PRTMCNUM
        1293+ 5 1474          + SUB       NINST
        1294+ 4 1431          + TR 0      PRTMCEX      EXIT IF ALL NINST INSTRUCTIONS PRINTED
        1295+10 2652          + R ADD     PRTMCNUM     INCR COUNT
        1296+ 9 2620          + ADD       ONE
        1297+12 2652          + STORE     PRTMCNUM     GET MC INSTR FROM TINST[ (PRTMCNUM-1)*2 ]
        1298+ 9 2652          + ADD       PRTMCNUM
        1299+ 5 2621          + SUB       TWO
        1300+ 9  161          + ADD       TINSTAD
        1301+13 1306          + STORE A   PMCAD1
        1302+ 9 2620          + ADD       ONE
        1303+13 1310          + STORE A   PMCAD2
        1304+10 2618          + R ADD     ZERO
        1305+12 2650          + STORE     MC.REG       INIT REGION REFERENCED BY MC
        1306+10    0 PMCAD1   + R ADD     /   /
        1307+13 2650          + STORE A   MC.REG
        1308+23   12          + A RIGHT   0012
        1309+12 2649          + STORE     MC.OP        MC.OP HAS NOW THE SIGNED OPCODE -31..31 
        1310+10    0 PMCAD2   + R ADD     /   /
        1311+12 2651          + STORE     MC.ADDR
        1312+ 3 1319          + TR +      PMC3         IF MC.ADDR >=0 THEN MC.REG HOLDS THE REGION FOR MC.ADDR 
        1313+10 2650          + R ADD     MC.REG       IF MC.ADDR <0 THEN MC.REG VAR HOLDS THE LOCATION INTO STEPN REFERENCED BY MC.ADDR
        1314+12 2647          + STORE     TRSTLOC      LOCATION IN STEP GIVEN BY MC.ADDR
        1315+ 6 2651          + R SUB     MC.ADDR      MAKES MC.ADDR POSITIVE. IT IS THE DESTINATION STEP
        1316+12 2651          + STORE     MC.ADDR
        1317+10 2745          + R ADD     REG.I
        1318+12 2650          + STORE     MC.REG       SET REGION I -> MC.ADDR=THE STEPN, TRSTLOC=THE NINST REFERENCED IN THIS STEPN
        1319+10 1319 PMC3     + R ADD     *            START NEW LINE TO PRINT
        1320+ 1   53          + TR        CLRBUF
        1321+10 2653          + R ADD     REGCSTEP     THIS IS THE STEPN WHERE THE REG.C SITS
        1322+ 5 1467          + SUB       STEPN
        1323+ 4 1325          + TR 0      PMC3C        TR TO PRINT REG "C NNNN" INSTEAD OF STEPN.MCNUM
        1324+ 1 1337          + TR        PMC3Z
        1325+15 2626 PMC3C    + LOAD MQ   D15          PRINT 'C'
        1326+10 1326          + R ADD     *
        1327+ 1   63          + TR        PRTCHR
        1328+ 0   39          + STOP      0039         AT COL 39
        1329+10 2652          + R ADD     PRTMCNUM     INST NUMBER 1..99
        1330+ 5 2620          + SUB       ONE          -1 -> IS THE ADDRESS IN REGION C
        1331+21   35          + L RIGHT   0035         ACC->MQ
        1332+10 1332          + R ADD     *
        1333+ 1   61          + TR        PRTINT
        1334+ 0   40          + STOP      0040         AT COL 40 
        1335+ 0    4          + STOP      0004         LEN=4
        1336+ 1 1357          + TR        PMC5SGN
        1337+15 1467 PMC3Z    + LOAD MQ   STEPN        PRINT STEPN
        1338+10 1338          + R ADD     *
        1339+ 1   61          + TR        PRTINT
        1340+ 0   40          + STOP      0040         AT COL 40 
        1341+ 0    4          + STOP      0004         LEN=4
        1342+15 2634          + LOAD MQ   D43          PRINT '.'
        1343+10 1343          + R ADD     *
        1344+ 1   63          + TR        PRTCHR
        1345+ 0   44          + STOP      0044         AT COL 44 
        1346+15 2621          + LOAD MQ   TWO
        1347+10 2652          + R ADD     PRTMCNUM     IF INST NUMBER < 10 PRINT IT
        1348+ 5 2623          + SUB       D10          WITH LEN=1, IF >= 10 USE LEN=2
        1349+ 3 1351          + TR +      PMC4
        1350+15 2620          + LOAD MQ   ONE
        1351+14 1356 PMC4     + STORE MQ  PMC5
        1352+15 2652          + LOAD MQ   PRTMCNUM
        1353+10 1353          + R ADD     *
        1354+ 1   61          + TR        PRTINT
        1355+ 0   45          + STOP      0045         AT COL 45 
        1356+ 0    2 PMC5     + STOP      0002         LEN=1 OR 2
        1357+15 2625 PMC5SGN  + LOAD MQ   D12          '+'
        1358+10 2649          + R ADD     MC.OP
        1359+ 3 1361          + TR +      PMC6
        1360+15 2624          + LOAD MQ   D11          '-'
        1361+10 1361 PMC6     + R ADD     *            PRINT OP SIGN
        1362+ 1   63          + TR        PRTCHR
        1363+ 0   48          + STOP      0048         AT COL 48
        1364+10 2618          + R ADD     ZERO
        1365+11 2649          + ADD AB    MC.OP
        1366+ 9 1405          + ADD       TMNEAD
        1367+13 1368          + STORE A   PMC7
        1368+15    0 PMC7     + LOAD MQ   /   /
        1369+10 1369          + R ADD     *            PRINT OP MNEMONIC
        1370+ 1   59          + TR        PRTALF
        1371+ 0   49          + STOP      0049         AT COL 49
        1372+10 2650          + R ADD     MC.REG
        1373+ 9 1406          + ADD       TREGMNEA     CHARS IN TREGMNE ARE TXT ALFA VALUES  
        1374+13 1375          + STORE A   PMC8         THUS ARE NEGATIVE
        1375+ 6    0 PMC8     + R SUB     /   /        CHANGE SIGN BEFORE STORING IT IN MQ
        1376+21   35          + L RIGHT   0035
        1377+10 1377          + R ADD     *            PRINT REGION LETTER V I S T A N
        1378+ 1   63          + TR        PRTCHR
        1379+ 0   52          + STOP      0052         AT COL 52
        1380+10 2650          + R ADD     MC.REG       IF MC.REG='I' THEN ...
        1381+ 5 2745          + SUB       REG.I        
        1382+ 4 1407          + TR 0      PMC9         TR TO PRINT STEPN.LOCATION
        1383+10 2650          + R ADD     MC.REG       IF MC.REG='S' THEN ...
        1384+ 5 2750          + SUB       REG.S
        1385+ 4 1392          + TR 0      PMC8B        TR TO PRINT ALFA SYMBOL TO TRANSFER TO
        1386+15 2651          + LOAD MQ   MC.ADDR      MC.REG IS 'V', 'T', 'A' OR 'N'
        1387+10 1387          + R ADD     *            JUST PRINT THE INST ADDRESS
        1388+ 1   61          + TR        PRTINT
        1389+ 0   53          + STOP      0053         AT COL 53 
        1390+ 0    4          + STOP      0004         LEN=4
        1391+ 1 1427          + TR        PMC12
        1392+15 2636 PMC8B    + LOAD MQ   D45          PRINT ALFA SYMBOL TO TRANSFER TO
        1393+10 1393          + R ADD     *            '/'
        1394+ 1   63          + TR        PRTCHR
        1395+ 0   54          + STOP      0054         AT COL 54
        1396+15 2636          + LOAD MQ   D45          '/'
        1397+10 1397          + R ADD     *
        1398+ 1   63          + TR        PRTCHR
        1399+ 0   58          + STOP      0058         AT COL 58
        1400+15 2651          + LOAD MQ   MC.ADDR      GET SYMBOL ALFA
        1401+10 1401          + R ADD     *            
        1402+ 1   59          + TR        PRTALF
        1403+ 0   55          + STOP      0055         AT COL 55
        1404+ 1 1427          + TR        PMC12
        1405+ 0 2759 TMNEAD   + STOP      TMNE
        1406+ 0 2751 TREGMNEA + STOP      TREGMNE
        1407+15 2651 PMC9     + LOAD MQ   MC.ADDR      PRINT STEPN.TRSTLOC 
        1408+10 1408          + R ADD     *
        1409+ 1   61          + TR        PRTINT
        1410+ 0   53          + STOP      0053         AT COL 53 
        1411+ 0    4          + STOP      0004         LEN=4
        1412+15 2634          + LOAD MQ   D43          PRINT '.'
        1413+10 1413          + R ADD     *
        1414+ 1   63          + TR        PRTCHR
        1415+ 0   57          + STOP      0057         AT COL 57 
        1416+15 2621          + LOAD MQ   TWO
        1417+10 2647          + R ADD     TRSTLOC      IF INST NUMBER < 10 PRINT IT
        1418+ 5 2623          + SUB       D10          WITH LEN=1, IF >= 10 USE LEN=2
        1419+ 3 1421          + TR +      PMC10
        1420+15 2620          + LOAD MQ   ONE
        1421+14 1426 PMC10    + STORE MQ  PMC11
        1422+15 2647          + LOAD MQ   TRSTLOC
        1423+10 1423          + R ADD     *
        1424+ 1   61          + TR        PRTINT
        1425+ 0   58          + STOP      0058         AT COL 58 
        1426+ 0    2 PMC11    + STOP      0002         LEN=1 OR 2
        1427+ 8    0 PMC12    + NOOP      0000
        1428+10 1428          + R ADD     *
        1429+ 1   57          + TR        PRINTCRD
        1430+ 1 1292          + TR        PMCLOOP    
        1431+ 1    0 PRTMCEX  + TR        /   /        RETURN TO CALLER
        1432+     0  PACTSRC    RES       24           CARD IMAGE OF PACT SOURCE CODE CARD (12 FULL WORDS)
        1456+     0  REGION     DEF       0
        1457+     0  STEP       DEF       0            REGION = ALFA (<0)
        1458+     0  OP         DEF       0            STEP   = INT (>0)
        1459+     0  FACT       DEF       0            OP     = 0..43    =0 MEANS END OF REGION
        1460+     0  S1         DEF       0            FACT   < 0 -> FACTOR IS AN ALFA SYMBOL (VAR, REGION, ...) 
        1461+     0  S2         DEF       0            FACT = 0 -> BLANK FACTOR
        1462+     0  QR         DEF       0            FACT = 0..9999 -> DESTINATION STEP FOR TRANSFER/RESULT OF STEP
        1463+     0  QF         DEF       0            CLUE = -, R OR N
        1464+     0  NUM        DEF       0            
        1465+     0             DEF       0            S1/S2 = 0 -> BLANK, >0 -> INTEGER, <0 -> ALFA 
        1466+     0  CLUE       DEF       0
        1467+     0  STEPN      DEF       0            QR = +/- INTEGER OR BLANK. 
        1468+     0  FACTN      DEF       0                 IF OP=TEST THEN IF QR=0->INDEX IN GENEATED INSTR IS INDEX IS "ADDRESS TYPE", =1->IS "COUNT TYPE" 
        1469+     0  FACTREG    DEF       0            QF = SET IF THERE IS AN INTEGER FACTOR/NUMBER IN CARD
        1470+     0  S1N        DEF       0            STEPN = SEQUENTIAL NUMBER OF STEP            
        1471+     0  S2N        DEF       0            IF OP IS TRANSFER -> FACTN=DESTINATION STEPN
        1472+     0  D1N        DEF       0            FACTN=ADDR (0, 2, 4, ..) FACTREG=' ', 'T', 'V', 'N'
        1473+     0  D2N        DEF       0            S1N/S2N=INDEX (IF <0), BLANK (IF =0), CONST (IF >0), 
        1474+     0  NINST      DEF       0                   IF OP=40 -> =*777777 if non active index   
        1475+     0  NINCR      DEF       0                               =*777776 if non defined index  
        1476+     0  TINST      RES       200          D1N/D2N=HALF-WORD SIZE OF EACH DIMENSION. D1N=-1 IF MATRIX/VECTOR WITH CONSTANT SUBSCRIPTS  
        1676+    44  CCLEN      DEF       0044         LENGTH OF COMPACT CODE RECORD 
        1677+     0  N          DEF       0            TEMP VAR (HERE TO MAKE TABLES START AT EVEN LOCATION)
        1678+   100  MAXNINST   DEF       100          MAX NUMBER OF MACHINE CODE INSTRUTIONS PER STEP
        1679+     0  VAL        DEF       0            TEMP
        1680+     0  DATA       DEF       0            EVEN ALIGNED TEMP VAT
        1681+     0  DATA2      DEF       0
        1682+   100  MAXNCONS   DEF       100          MAX NUMBER OF ENTRIES IN LOOP CONSTANT POOL OF REGION
        1683+     0  NLOCONST   DEF       0            NUM OF ENTRIES IN LOOP CONSTANT POOL OF REGION
        1684+     0  TLOCONST   RES       2
        1686+     0  TLOCONS2   RES       198          MACHINE CODE: 1ST HALF-WORD OPCODE + REGION
        1884+    34  MAXNPAR    DEF       34           MAX (34) NUMBER OF CALL PARAMETERS
        1885+     0  NPARAMS    DEF        0           NUMBER OF PARAMS DEFINED
        1886+     0  TPARNAME   RES       34           PARAM NAME (ALFA BASE48 <0). >0 IF VARIABLE (IS THE ADDR). =4096 IF NUMBER
        1920+     0  TPARSTEP   RES       34           STEPN WHERE PARAM IS DEFINED
        1954+     0  TPARTYPE   RES       34           PARAM TYPE: 
        1988+     0  TPARFACT   RES       34           
        2022+     0  TPARLOC1   RES       34           PACT       TYPE  FACT   LOC1   NAME       DESCR
        2056+    34  MAXNIDXS   DEF       34           MAX (34) INDEXS ACTIVE AT SAME TIME
        2057+     0  NIDXS      DEF       0            NUMBER OF INDEXES IN THIS REGION
        2058+     0  TIDXNAME   RES       34           NAME OF ACTIVE INDEX (ALFA <0). >0 IF ENTRY IS NO LONGER IN USE
        2092+     0  TIDXLOC    RES       34           = ENTRY IN LOOP CONSTANT POOL THAT HAS THE CURRENT INDEX VALUE
        2126+     0  TIDXTYPE   RES       34           = 0 -> "ADDRESS INDEX" TYPE, =1 -> "COUNT INDEX" TYPE
        2160+     0  TIDXSETN   RES       34           = 0 -> DEFINED INDEX, >0 -> ACTIVE INDEX = STEPN WHERE WHERE THE INDEX IS SET (USED TO COMPUTE START OF LOOP)
        2194+    50  MAXNREFS   DEF       50           MAX (50) NUMBER OF VECTOR/MATRIX REFERENCES SIMULATEOUSLY ACTIVE AT A GIVEN MOMENT
        2195+     0  NREFS      DEF       0            NUMBER OF REFERENCES IN REGION
        2196+     0  TREFNAME   RES       50           NAME OF VECTOR/MATRIX. =0 IS ENTRY IS NOT USED       
        2246+     0  TREFIDX1   RES       50           NAME OF INDEX1. <0->INDEX NAME,=0->NO INDEX,>0->CONSTANT
        2296+     0  TREFIDX2   RES       50           NAME OF INDEX2. IF OP=40 -> =*777777 if non active index
        2346+     0  TREFSTEP   RES       50           STEPN WHERE THIS VECTOR/MATRIX IS USED               TINST 0:  ...                        
        2396+     0  TREFINCR   RES       50           INCRN ON PREVIOUS STEPN TO ACCESS THE VAR LOCATION   STEPN  :  ... VAR I  J                
        2446+     0  TREFOP     RES       50           THE OPCODE THAT APPLIES ON VECT/MATRIX                     2:  ...                         
        2496+     0  TREFADDR   RES       50           THE ADDR OF VECT/MATRIX (Vnnnn)                            4:  +RA V 0003  <-- INCR VALUE  
        2546+     0  TREFD1     RES       50           D1 VALUE IF REF IS A MATRIX                                    ^^^   ^^^^                  
        2596+    20  MAXNFOI    DEF       20           MAX NUMBER OF INDEX IN "FOR I A B" BELLOW A DO/LIB INSTR
        2597+     0  NFORIDX    DEF       0            NUMBER OF INDEX IN "FOR I A B" 
        2598+     0  TFORIDX    RES       20           INDEXS DEFINED BY "FOR I A B" 
        2618+     0  ZERO       DEF       0
        2619+     0             DEF       0
        2620+     1  ONE        DEF       1
        2621+     2  TWO        DEF       2
        2622+     4  D4         DEF       4
        2623+    10  D10        DEF       10
        2624+    11  D11        DEF       11
        2625+    12  D12        DEF       12
        2626+    15  D15        DEF       15
        2627+    17  D17        DEF       17
        2628+    18  D18        DEF       18
        2629+    19  D19        DEF       19
        2630+    26  D26        DEF       26
        2631+    32  D32        DEF       32
        2632+    34  D34        DEF       34
        2633+    35  D35        DEF       35
        2634+    43  D43        DEF       43
        2635+    44  D44        DEF       44
        2636+    45  D45        DEF       45
        2637+   100  D100       DEF       100
        2638+   101  D101       DEF       101
        2639+   200  D200       DEF       200
        2640+   244  D244       DEF       244
        2641+  1000  D1000      DEF       1000
        2642-131070  O776K      DEF       *777776      OCTAL ALL ONES
        2643-131071  O777K      DEF       *777777      OCTAL ALL ONES
        2644+     0  NREGIONS   DEF       0            NUMBER OF REGIONS PROCESSED
        2645+     0  MC.TABLE   DEF       0            ADDRESS TO MACHINE CODE GENERATION TABLE TO USE 
        2646+     0  TRANSFER   DEF       0            STEPN NUMBER THE MC INSTR HAS TO TRANSFER TO 
        2647+     0  TRSTLOC    DEF       0            LOCATION INTO STEPN NUMBER THE MC INSTR HAS TO TRANSFER TO 
        2648+     0  MC         DEF       0            MACHINE CODE INSTR TO GENERATE FROM MC TABLE
        2649+     0  MC.OP      DEF       0            MC OPCODE GENERATED
        2650+     0  MC.REG     DEF       0            REGION REFERENCED BY MC OPCODE GENERATED
        2651+     0  MC.ADDR    DEF       0            MC ADDR GENERATED. BOTH WILL BE STORED IN TINST TABLE IN COMPCAT CODE RECORD
        2652+     0  PRTMCNUM   DEF       0            NEXT INSTR TO PRINT WITH PRTMC
        2653+     0  REGCSTEP   DEF       0            STEPN WHERE THE REG.C SITS
        2654+     0  PRGSTEPN   DEF       0            FIRST STEPN OF PROGRAM AFTER INITIAL CALL/ID/FOR (IE STEP-1 IS CALL/ID/FOR INSTR)
        2655+     0  NIDX       DEF       0            CURRENT INDEX NUMBER
        2656+     0  NIDX2      DEF       0            
        2657+     0  IDXTYPE    DEF       0            =0 -> INDEX IS "ADDRESS TYPE", =1 -> IS "COUNT INDEX"
        2658+     0  ECONSTIX   DEF       0            =0 IF INDEX IS "ADDRESS INDEX" TYPE, >0 IF INDEX IS "COUNT INDEX" TYPE, =ENTRY IN LOOP CONSTANT POOL FOR INDEX VALUE
        2659+     0  ECONST     DEF       0
        2660+     0  ECSTART    DEF       0            ADDR IN REG C OF START OF LOOP VALUE
        2661+     0  USEECIX    DEF       0            =1 -> INDEX START VALUE IS COMPUTED ON RUN TIME (STORED IN LOOP CONSTANT POOL AT ENTRY ECONSTIX)
        2662+     0  D1         DEF       0            COMPILE-TIME COMPUTED D1 DIMENSION1 VALUE
        2663+     0  ECONSTD1   DEF       0            ENTRY IN LOOP CONSTANT POOL THAT CONTAINS THE D1 PASSED AS PARAM TO BE USED AT RUN-TIME
        2664+     0  C1         DEF       0            COMPILE-TIME COMPUTED 1ST CONSTANT VALUE
        2665+     0  I1         DEF       0            ENTRY IN LOOP CONSTANT POOL THAT CONTAINS THE 1ST INDEX TO BE USED AT RUN-TIME
        2666+     0  C2         DEF       0            COMPILE-TIME COMPUTED 2ND CONSTANT VALUE
        2667+     0  I2         DEF       0            ENTRY IN LOOP CONSTANT POOL THAT CONTAINS THE 2ND INDEX TO BE USED AT RUN-TIME
        2668+     0  NPAR       DEF       0            PARAM BEING EXAMINED
        2669+     0  NREF       DEF       0            CURRENT REFERENCE ENTRY. REFERENCES = STEPN OF INSTR THAT USES VARS WITH INDEX. 
        2670+     0  NREF2      DEF       0            THE ADDR OF VAR IN THSE STEPN SHOULD BE MODIFIED BY "TEST" INSTR
        2671+     0  NLASTREF   DEF       0            
        2672+     0  RNAME      DEF       0            REFERENCE NAME
        2673+     0  RIDX1      DEF       0            INDEX1 USED BY REFERENCE 
        2674+     0  RIDX2      DEF       0            INDEX2 USED BY REFERENCE 
        2675+     0  RSTEPN     DEF       0            STEPN OF INSTR WHERE THE REFERENCE IS MADE
        2676+     0  RINCRN     DEF       0            INCRN OF REFERENCE IN THIS STEP
        2677+     0  RADDR      DEF       0
        2678+     0  R2NAME     DEF       0            REFERENCE NAME
        2679+     0  R2IDX1     DEF       0            INDEX1 USED BY REFERENCE 
        2680+     0  R2IDX2     DEF       0            INDEX2 USED BY REFERENCE 
        2681+     0  R2STEPN    DEF       0            STEPN OF INSTR WHERE THE REFERENCE IS MADE
        2682+     0  R2INCRN    DEF       0            INCRN OF REFERENCE IN THIS STEP
        2683+     0  R2ADDR     DEF       0
        2684+     0  PTYPE      DEF       0            PARAMETER TYPE
        2685+     0  SVNINST    DEF       0            SAVE CURRENT NUMBER OF MC INSTR IN THE COMPACT CODE RECORD AT START OF STEP PROCESSING
        2686+     0  LEN        DEF       0
        2687- 75051  ERROVINS   TXT       "TOO MANY INSTR IN THIS STEP",0   ERROR: MAX 100
        2688-  1213  
        2689- 61680  
        2690- 49663  
        2691- 75168  
        2692- 49632  
        2693- 74709  
        2694- 71455  
        2695- 74572  
        2696+     0  
        2697- 56619  ERROVLOS   TXT       "LOOP CONST OVERFLOW",0           ERROR: TOO MANY LOOP CONSTANTS IN POOL         
        2698- 64527  
        2699- 63487  
        2700- 73755  
        2701- 79182  
        2702- 42651  
        2703- 80640  
        2704+     0  
        2705- 75051  ERROVRFS   TXT       "TOO MANY REFS",0                 ERROR: TOO MANY REFERENCES TO MATRIX/VECTOR IN REGION (MAX 50)
        2706-  1213  
        2707- 61680  
        2708- 69954  
        2709- 71424  
        2710+     0  
        2711-  3824  ERRNDI1S   TXT       "1ST INDEX NOT DEF",0             ERROR: 1ST INDEX NOT DEFINED 
        2712-  1034  
        2713- 37716  
        2714-  1275  
        2715- 73744  
        2716- 40032  
        2717+     0  
        2718-  5872  ERRNDI2S   TXT       "2ND INDEX NOT DEF",0             ERROR: 2ND INDEX NOT DEFINED 
        2719-  1034  
        2720- 37716  
        2721-  1275  
        2722- 73744  
        2723- 40032  
        2724+     0  
        2725- 75051  ERROVFOS   TXT       "TOO MANY FOR INDEX",0            ERROR: TOO MANY "FOR I A B" (MAX 20)
        2726-  1213  
        2727- 61680  
        2728- 42798  
        2729-  1034  
        2730- 37716  
        2731+     0  
        2732- 56619  MSGSTART   TXT       "LOOP EXPANSION PASS 2",0
        2733- 64529  
        2734- 84301  
        2735- 61413  
        2736- 63456  
        2737- 65167  
        2738- 71426  
        2739+     0  
        2740- 69955  MSGDONE    TXT       "REGIONS",0
        2741- 49706  
        2742- 71424  
        2743+     0  
        2744+     0  REG.A      DEF       0            ABSOLUTE A 0000
        2745+     1  REG.I      DEF       1            INSTRUCTIONS CODE I 0000
        2746+     2  REG.V      DEF       2            VARIABLES V 0000
        2747+     3  REG.T      DEF       3            TEMPORARY T 0000
        2748+     4  REG.N      DEF       4            NUMBER N 0000
        2749+     6  REG.C      DEF       6            ENTRY IN LOOP CONSTANTS POOL C 0000
        2750+     7  REG.S      DEF       7            SYMBOL S 0000
        2751-    13  TREGMNE    TXT       '  A'
        2752-    21             TXT       '  I'
        2753-    34             TXT       '  V'
        2754-    32             TXT       '  T'
        2755-    26             TXT       '  N'
        2756-    28             TXT       '  P'        PERISHABLE STORAGE (=LIB LOCAL VARS/CONSTANTS)
        2757-    15             TXT       '  C'        LOOP CONSTANTS
        2758-    31             TXT       '  S'
        2759- 46080  TMNE       TXT       'H  '        STOP/HALT
        2760- 73728             TXT       'T  '        TRANSFER
        2761- 74592             TXT       'TF '        TRANSFER ON OVERLOF
        2762- 75072             TXT       'TP '        TRANSFER ON PLUS
        2763- 75552             TXT       'TZ '        TRANSFER ON ZERO
        2764- 71424             TXT       'S  '        SUBTRACT
        2765- 70608             TXT       'RS '        RESET AND SUBTRACT
        2766- 73056             TXT       'SV '        SUBTRACT ABSOLUTE VALUE
        2767- 59904             TXT       'N  '        NO OPERATION
        2768- 29952             TXT       'A  '        ADD
        2769- 69744             TXT       'RA '        RESET AND ADD
        2770- 31584             TXT       'AV '        ADD ABSOLUTE VALUE
        2771- 72960             TXT       'ST '        STORE
        2772- 72048             TXT       'SA '        STORE ADDRESS
        2773- 72624             TXT       'SM '        STORE MQ
        2774- 56496             TXT       'LM '        LOAD MQ
        2775- 57600             TXT       'M  '        MULTIPLY
        2776- 59040             TXT       'MR '        MULTIPLY AND ROUND
        2777- 36864             TXT       'D  '        DIVIDE
        2778- 69120             TXT       'R  '        ROUND
        2779- 56448             TXT       'LL '        LONG LEFT SHIFT
        2780- 56736             TXT       'LR '        LONG RIGHT SHIFT
        2781- 31104             TXT       'AL '        ACCUMULATOR LEFT SHIFT
        2782- 31392             TXT       'AR '        ACCUMULATOR RIGHT SHIFT
        2783- 69888             TXT       'RD '        READ
        2784- 69792             TXT       'RB '        READ BACKWARDs
        2785- 80640             TXT       'W  '        WRITE
        2786- 81456             TXT       'WE '        WRITE END OF FILE
        2787- 70800             TXT       'RW '        REWIND TAPE
        2788- 72192             TXT       'SD '        SET DRUM DDR
        2789- 72240             TXT       'SE '        SENSE
        2790- 34560             TXT       'C  '        COPY
        2792+15 2806 CLRBUF   + LOAD MQ   IOCL
        2793+14 2811          + STORE MQ  BUFIO
        2794+15 2832          + LOAD MQ   IOSTORE         
        2795+ 1 2803          + TR        INIT2
        2796+15 2828 READCRD  + LOAD MQ   IORDCRD
        2797+ 1 2801          + TR        INIT1
        2798+15 2830 WRITECRD + LOAD MQ   IOWRCRD
        2799+ 1 2801          + TR        INIT1
        2800+15 2831 PRINTCRD + LOAD MQ   IOPRCRD
        2801+14 2811 INIT1    + STORE MQ  BUFIO
        2802+15 2829          + LOAD MQ   IOCOPY         
        2803+14 2812 INIT2    + STORE MQ  BUFROW
        2804+ 9 2838          + ADD       TWO          
        2805+13 2827          + STORE A   EXIT
        2806+10 2834 IOCL     + R ADD     ZERO         RESET TO INITIAL COPY LOOP ADDRESS     
        2807+13 2812          + STORE A   BUFROW       FOR BUFFER
        2808+10 2812          + R ADD     BUFROW       X .*echo Print
        2809+ 5 2839          + SUB       D48          X 
        2810+12 2836          + STORE     ENDLP        X LOOP END VALUE
        2811- 0    0   BUFIO  - STOP      /   /        READ OR WRITE
        2812-31    0   BUFROW - COPY      /   /        COPY WORD TO/FROM PRINTER/CARDREADER
        2813+ 1 2817          + TR        BUFOK2       NORMAL PROCESSING 
        2814+ 1 2824          + TR        EODECK       FOR COPY READING END OF REG (=END OF DECK BEING READ)
        2815+ 6 2838          + R SUB     TWO          END OF FILE -> NO CARD TO READ -> STOP with Acc=-2
        2816+ 0 2811          + STOP      BUFIO        ON PRESSING START RETRY CARD READ
        2817+10 2812   BUFOK2 + R ADD     BUFROW       X
        2818+ 5 2838          + SUB       TWO          INCR BUF ADDR
        2819+13 2812          + STORE A   BUFROW       X
        2820+ 5 2836          + SUB       ENDLP        CHECK FOR END
        2821+ 4 2826          + TR 0      ENDIO
        2822+10 2834          + R ADD     ZERO         CLEAR ACC IN CASE WE ARE CLEANING THE BUFFER
        2823+ 1 2812          + TR        BUFROW
        2824+10 2837 EODECK   + R ADD     ONE          SET OV FLAG TO SIGNAL END OF DECK CONDITION
        2825+22   36          + A LEFT    36
        2826+26 2052 ENDIO    + WRITE     2052         END OF I/O: INSURE THAT MQ NOT IN USE            
        2827+ 1    0 EXIT     + TR        /   /
        2828+24 2048 IORDCRD  + READ      2048         PREPARE TO READ FROM CARD READER
        2829-31    0 IOCOPY   - COPY      /   /   
        2830+26 1024 IOWRCRD  + WRITE     1024         PREPARE TO PUNCH CARD 
        2831+26  512 IOPRCRD  + WRITE     0512         PREPARE WRITE PRTBUF ON PRINTER
        2832-12    0 IOSTORE  - STORE     /   /        CLEAR BUFFER
        2833+     0             ORG       EVEN           
        2834+     0  ZERO       DEF       0            
        2835+     0             DEF       0            
        2836+     0  ENDLP      DEF       0            LOOP END VALUE
        2837+     1  ONE        DEF       1
        2838+     2  TWO        DEF       2
        2839+    48  D48        DEF       48
        2840+ 9 3111 PRTPARM2 + ADD       TWO          GET 2 PARAMS: LEN AND COL (EITHER VALUE OR VAR ADDR)
        2841+13 2860          + STORE A   PRTPRMEX
        2842+10 2850          + R ADD     PRTP1
        2843+ 9 3111          + ADD       TWO          PRINT PACKED TEXT FROM FULL-WORD VALUE IN MQ REGISTER 
        2844+13 2850          + STORE A   PRTP1        STORE ADDR OF FIRST PARAM (LEN)
        2845+ 9 3110          + ADD       ONE
        2846+13 2852          + STORE A   PRTP2        STORE ADDR OF SECOND PARAM (COL)
        2847+ 9 3110          + ADD       ONE
        2848+13 2927          + STORE A   EXIT
        2849-14 3100          - STORE MQ  NUM          SAVE VALUE TO PRINT PARAM MQ (NUM IS ALIASED TO TXT)
        2850+10    0   PRTP1  + R ADD     /   /        GET LEN: NUMBER OF CHARS TO PRINT (1..6)
        2851+12 3104          + STORE     LEN
        2852+10    0   PRTP2  + R ADD     /   /        GET COLUMN PARAM 1..72
        2853+ 3 2856          + TR +      PRTP4
        2854+13 2855          + STORE A   PRTP3        COL<0 -> INTERPRET COL AS LOC(COL) = ADDR OF COL VAR
        2855+10    0   PRTP3  + R ADD     /   /        READ VAR COL PASED AS PARAM
        2856+ 4 2927   PRTP4  + TR 0      EXIT         COL=0 -> EXIT
        2857+ 3 2859          + TR +      PRTP5
        2858+ 1 2927          + TR        EXIT         COL<0 -> EXIT
        2859+12 2910   PRTP5  + STORE     COL
        2860+ 1    0 PRTPRMEX + TR        /   /        RETURN TO CALLER
        2861+13 2850 PRTSTR   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2862+10 2862          + R ADD     *            FOR PRINT STRINGZ FROM MEM
        2863+ 1 2840          + TR        PRTPARM2
        2864+12 2874          + STORE     COLSZ
        2865+10 3104          + R ADD     LEN          LEN IS IN FACT THE LOCATION WHERE THE STRING STARTS
        2866+13 2869          + STORE A   STRZAD
        2867+10 2927          + R ADD     EXIT
        2868+13 2882          + STORE A   STRZEX
        2869+10    0 STRZAD   + R ADD     /   /        GET HALF-WORD WITH NEXT 3 CHARS TO PRINT
        2870+ 4 2882          + TR 0      STRZEX       IF +0 -> END OF STRING (-0 DOES NOT TERMINATES THE STRING)
        2871+21   35          + L RIGHT   0035         MQ=3-CHARS TO PRINT
        2872+10 2872          + R ADD     *            
        2873+ 1 2884          + TR        PRTALF       PRINT 3 CHARS
        2874+ 0    0 COLSZ    + STOP      0000         COL 
        2875+10 2869 STRZ1    + R ADD     STRZAD       INCR STRING ADDRESS
        2876+ 9 3110          + ADD       ONE
        2877+13 2869          + STORE A   STRZAD
        2878+10 2874          + R ADD     COLSZ        INCR COLUMN
        2879+ 9 3112          + ADD       D3
        2880+13 2874          + STORE A   COLSZ
        2881+ 1 2869          + TR        STRZAD
        2882+ 3    0 STRZEX   + TR +      /   /        IF ZERO -> END OF STRING
        2883+ 1 2875          + TR        STRZ1
        2884+ 9 3111 PRTALF   + ADD       TWO          PRINT 3-PACKED CHARS IN MQ REGISTER 
        2885+14 3106          + STORE MQ  TXT          SAVE TEXT TO PRINT (IN LEFT HALF WORD)
        2886+13 2889          + STORE A   PRTAP2       STORE ADDR OF PARAM (COL)
        2887+ 9 3110          + ADD       ONE
        2888+13 2927          + STORE A   EXIT
        2889+10    0   PRTAP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        2890+ 3 2893          + TR +      PRTAP4
        2891+13 2892          + STORE A   PRTAP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        2892+10    0   PRTAP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        2893+12 2910   PRTAP4 + STORE     COL
        2894+10 3112          + R ADD     D3
        2895+12 3104          + STORE     LEN
        2896+10 3094 PRT1     + R ADD     ZERO         UNPACK LEFTMOST CHAR 
        2897+11 3106          + ADD AB    TXT          GET TEXT DISCARD SIGN
        2898+21   35          + L RIGHT   0035         MQ=Acc
        2899+10 3094          + R ADD     ZERO
        2900+18 3119          + DIV       D48X48
        2901+12 3106          + STORE     TXT          remainder=char to print, mq=c2 * 48 + c3 in right half-word
        2902+10 3094          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        2903+20   18          + L LEFT    0018         put c2 and c3 in left half-word of MQ to be saved in CHAR half word
        2904+14 3105          + STORE MQ  CHAR         CHAR TO PRINT
        2905+10 3105          + R ADD     CHAR 
        2906+ 4 2911          + TR 0      NXTCHR       IF BLANK PROCEED TO NEXT COL
        2907+21   35          + L RIGHT   0035         MQ=CHAR TO PRINT
        2908+10 2908          + R ADD     *            PRINT CHAR
        2909+ 1 3004          + TR        PRTCHR
        2910+ 0    0 COL      + STOP      0000         COL: COLUMN NUMBER TO PRINT (1..72)
        2911+10 3104 NXTCHR   + R ADD     LEN          DECR LEN COUNT
        2912+ 5 3110          + SUB       ONE
        2913+12 3104          + STORE     LEN
        2914+ 4 2927          + TR 0      EXIT         IF NO MORE CHARS TO PRINT EXIT
        2915+10 2910          + R ADD     COL          INCR COL POSITION
        2916+ 9 3110          + ADD       ONE
        2917+12 2910          + STORE     COL
        2918+ 5 3118          + SUB       D72          IF COL > 72 RETURN TO CALLER
        2919+ 4 2921          + TR 0      GNXTCHR      ELSE PROCEED WITH NEXT CHAR
        2920+ 3 2927          + TR +      EXIT
        2921+10 3094 GNXTCHR  + R ADD     ZERO         GET NEXT CHAR 
        2922+15 3106          + LOAD MQ   TXT
        2923+16 3117          + MPY       D48
        2924+22   17          + A LEFT    0017         GET RESULT IN LEFT HALF-WORD OF ACC
        2925+12 3106          + STORE     TXT
        2926+ 1 2896          + TR        PRT1         PROCEED TO PRINT CHAR
        2927+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        2928+13 2850 PRTOCT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2929+10 2929          + R ADD     *            FOR PRINT OCTIONARY VALUE
        2930+ 1 2840          + TR        PRTPARM2
        2931+10 3104          + R ADD     LEN          LEN = OCTAL DIGITS TO PRINT
        2932+ 9 2910          + ADD       COL
        2933+ 5 3110          + SUB       ONE
        2934+12 2946          + STORE     COLN         COL POINTS TO LEAST SIGNIFICANT DIGIT
        2935+10 3100 PRTIOCG  + R ADD     NUM          GENERATE OCTINARY DIGIT
        2936+15 3094          + LOAD MQ   ZERO         CLEAR MQ
        2937+21   21          + L RIGHT   0021         3 LSB BITS OF LEFT HALF-WORD OF ACC TO MQ
        2938+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 3 BIT)
        2939+12 3100          + STORE     NUM          SAVE BACK NUM WITH RIGHTMOST OCTIONARY DIGIY EXTRACTED (NUM'=NUM/8)
        2940+10 3094          + R ADD     ZERO
        2941+20   21          + L LEFT    0021         LEFT HALF-WORD OF ACC IS NOW RIGHTMOST OCTINARY DIGIT EXTRACTED FROM NUM 
        2942+ 4 2960          + TR 0      PRTIOZ       TR IF THIS DIGIT IS ZERO TO PRINT A '0' (BASE48 CODE = 10) INSTEAD OF A BLANK (BASE48 CODE = 0)
        2943+21   35          + L RIGHT   0035         PUT DIGIT 1..9 TO PRINT IN MQ
        2944+10 2944 PRTOCTD  + R ADD     *            PRINT OCTINARY DIGIT
        2945+ 1 3004          + TR        PRTCHR
        2946+ 0    0 COLN     + STOP      0000
        2947+10 2946          + R ADD     COLN        DECR COL NUMBER TO PRINT NEXT DIGIT
        2948+ 5 3110          + SUB       ONE
        2949+12 2946          + STORE     COLN
        2950+10 3104          + R ADD     LEN          DECR COL NUMBER TO PRINT NEXT DIGIT
        2951+ 5 3110          + SUB       ONE
        2952+ 4 2927          + TR 0      EXIT         PRINTED LEN OCTINARY DIGITS -> EXIT
        2953+12 3104          + STORE     LEN
        2954+10 3100          + R ADD     NUM          IF NUM < 0, ADD SIGN BIT TO LEFTMOST DIGIT
        2955+ 3 2935          + TR +      PRTIOCG
        2956+10 3120          + R ADD     OCT04K       
        2957+ 5 3100          + SUB       NUM
        2958+12 3100          + STORE     NUM
        2959+ 1 2935          + TR        PRTIOCG
        2960+15 3113   PRTIOZ + LOAD MQ   D10          ACC=BASE48 CODE FOR '0'
        2961+ 1 2944          + TR        PRTOCTD      TR TO PRINT IT
        2962+13 2850 PRTINT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2963+10 2963          + R ADD     *            FOR PRINT OCTIONARY VALUE
        2964+ 1 2840          + TR        PRTPARM2
        2965+10 2910          + R ADD     COL          PRINT DECIMAL NUMBER. VALUE OF LEN = DIGITS TO PRINT, NOT INCLUDING SIGN
        2966+ 9 3104          + ADD       LEN
        2967+ 5 3110          + SUB       ONE          
        2968+12 2989          + STORE     COLNI        COL POINTS TO END OF NUMBER
        2969+10 3094          + R ADD     ZERO
        2970+12 3103          + STORE     SGN          SIGN IS POSITIVE
        2971+10 3100          + R ADD     NUM
        2972+ 3 2977          + TR +      PRTINTG
        2973+ 6 3100          + R SUB     NUM          NUM IS NEGATIVE. CONVERT TO POSITIVE
        2974+12 3100          + STORE     NUM          AND SET SGN=1
        2975+10 3110          + R ADD     ONE
        2976+12 3103          + STORE     SGN          
        2977+10 3100 PRTINTG  + R ADD     NUM          GENERATE DECIMAL DIGIT
        2978+21   35          + L RIGHT   0035         MQ=Acc
        2979+10 3094          + R ADD     ZERO
        2980+18 3113          + DIV       D10
        2981+ 4 3002          + TR 0      PRTINZ
        2982+12 3105 PRTINTG2 + STORE     CHAR         acc=remainder=digit to print, mq=num/10
        2983+10 3094          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        2984+20   18          + L LEFT    0018         digit in left half-word of MQ to be saved in CHAR half word
        2985+14 3100          + STORE MQ  NUM 
        2986+15 3105          + LOAD MQ   CHAR 
        2987+10 2987 PRTINTD  + R ADD     *            PRINT DECIMAL DIGIT
        2988+ 1 3004          + TR        PRTCHR
        2989+ 0    0 COLNI    + STOP      0000
        2990+10 2989          + R ADD     COLNI        DECR COL NUMBER TO PRINT NEXT DIGIT
        2991+ 5 3110          + SUB       ONE
        2992+12 2989          + STORE     COLNI
        2993+10 3100          + R ADD     NUM          DO NOT CARE ABOUT LEN, JUST CHECK IF NUM=0 
        2994+ 4 2996          + TR 0      PRTINS       (SO NO MORE DIGITS REMAINS TO BE PRINTED)
        2995+ 1 2977          + TR        PRTINTG      NUM NOT FINISHED, PROCEED WITH NEXT DIGIT
        2996+10 3103 PRTINS   + R ADD     SGN
        2997+ 4 2927          + TR 0      EXIT         NO SIGN -> NUM FINISHED
        2998+10 3094          + R ADD     ZERO
        2999+12 3103          + STORE     SGN          CLEAR SGN FLAG
        3000+15 3114          + LOAD MQ   D11          BASE48 CODE FOR '-' (MINUS) CHAR
        3001+ 1 2987          + TR        PRTINTD      GO TO PRINT IT
        3002+10 3113   PRTINZ + R ADD     D10          ACC=BASE48 CODE FOR '0'
        3003+ 1 2982          + TR        PRTINTG2     TR TO PRINT IT
        3004+ 9 3111 PRTCHR   + ADD       TWO          PRINT CHAR IN MQ REGISTER 
        3005+14 3105          + STORE MQ  CHAR         SAVE CHAR TO PRINT (IN LEFT HALF WORD)
        3006+13 3010          + STORE A   PRTCP2       STORE ADDR OF PARAM (COL)
        3007+ 9 3110          + ADD       ONE
        3008+13 3088          + STORE A   PRTCEX
        3009+ 2 3010          + TR OV     PRTCP2       CLEAR OV JUST IN CASE
        3010+10    0   PRTCP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        3011+ 3 3014          + TR +      PRTCP4
        3012+13 3013          + STORE A   PRTCP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        3013+10    0   PRTCP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        3014+ 5 3110   PRTCP4 + SUB       ONE
        3015+12 3108          + STORE     N            N=COL-1 -> IN RANGE 0..71
        3016+ 3 3018          + TR +      PRTSA        IF N >= 0 PROCEED WITH BASE BUFFER ADDR CALCULATION
        3017+ 1 3088          + TR        PRTCEX       IF N<0 EXIT
        3018+10 3094    PRTSA + R ADD     ZERO         CARD BUFFER USES LOCATION 0..47
        3019+13 3107          + STORE A   PRTROWAD     DETERMINE ADDRESS OF LOWER ROW TO PRINT
        3020+10 3108          + R ADD     N
        3021+ 5 3116          + SUB       D36
        3022+ 3 3024          + TR +      PRTC0
        3023+ 1 3030          + TR        PRTC1
        3024+12 3108    PRTC0 + STORE     N            COL NOW 0..35 
        3025+ 5 3116          + SUB       D36
        3026+ 3 3088          + TR +      PRTCEX       IF COL >= 36 (IE COL PASSED AS PARAM > 72) THEN EXIT
        3027+10 3107          + R ADD     PRTROWAD
        3028+ 9 3111          + ADD       TWO
        3029+13 3107          + STORE A   PRTROWAD     SET BASE BUFFER ADDR 
        3030+10 3110    PRTC1 + R ADD     ONE          DETERMINE MASKCOL WITH MASK TO SET IN CARD BUFFER
        3031+21   53          + L RIGHT   53           SET RIGHTMOST BIT OF MQ TO 1 (SHIFT 35+18=53)
        3032+10 3115          + R ADD     D35
        3033+ 5 3108          + SUB       N
        3034+13 3036          + STORE A   PRTC2
        3035+10 3094          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW
        3036+20    0    PRTC2 + L LEFT    /   /        SHIFT MQ LEFT N PLACES
        3037+ 4 3040          + TR 0      PRTC3        IF ACC STILL ZERO -> MASKCOL VALID
        3038+ 6 3110          + R SUB     ONE          ACC NOT ZERO -> SHOULD GENERATE -0 TO SET SIGN BIT ON
        3039+21   72          + L RIGHT   0072         NOW MQ = -0 -> LEFTMOST BIT OF MQ SET
        3040-14 3096    PRTC3 - STORE MQ  MASKCOL
        3041+10 3094          + R ADD     ZERO         READ THE BITMAP OF CHAR 
        3042+11 3105          + ADD AB    CHAR         DISCARD SIGN OF CHAR, IF ANY
        3043+12 3105          + STORE     CHAR
        3044+ 5 3117          + SUB       D48
        3045+ 3 3088          + TR +      PRTCEX       IF CHAR >= 48 EXIT
        3046+10 3102          + R ADD     BITMAPAD     IF ADDR OF BASE48 BITMAP NOT COMPUTED
        3047+ 4 3089          + TR 0      GETBMP1      TR TO LOAD IT
        3048+ 9 3105  GETBMP2 + ADD       CHAR         READ THE BITMAP OF CHAR 
        3049+13 3050          + STORE A   PRTC4        INDICATES THE BITS TO SET IN SELECTED 
        3050+10    0    PRTC4 + R ADD     /   /        COLUMN OF CARD BUFFER 
        3051+12 3109          + STORE     BITS
        3052+ 6 3110          + R SUB     ONE
        3053+12 3108          + STORE     N            SET TO -1
        3054+10 3108    LOOP1 + R ADD     N            CURRENT ROW (STARTS AT ZERO) = OFFSET ON PRTROWAD     
        3055+ 9 3110          + ADD       ONE
        3056+12 3108          + STORE     N
        3057+10 3109          + R ADD     BITS         EXTRACT RIGHTMOST BIT OF LEFT HALF OF ACC TO MQ
        3058+ 4 3088          + TR 0      PRTCEX       NO MORE BITS -> EXIT
        3059+21   19          + L RIGHT   0019         LSB BIT OF LEFT HALF-WORD OF ACC TO MQ
        3060+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 1 BIT)
        3061+12 3109          + STORE     BITS         SAVE BACK BITS. LSB HAS BEEN EXTACTED, CONTENTS SHIFTED RIGHT ONE PLACE
        3062+10 3094          + R ADD     ZERO
        3063+20    1          + L LEFT    0001         PUT EXTACTED BIT BACK INTO ACC
        3064+ 4 3054          + TR 0      LOOP1        NO BIT 
        3065+10 3108          + R ADD     N            READ THE ROW N AT CARD BUFFER 
        3066+22    2          + A LEFT    0002         MULT N BY 4 AS THERE ARE 4 HALF WORDS PER ROW
        3067+ 9 3107          + ADD       PRTROWAD     
        3068+13 3070          + STORE A   PRTROWR
        3069+13 3086          + STORE A   PRTROWW
        3070-10    0  PRTROWR - R ADD     /   /        
        3071-12 3098          - STORE     ROW          CURRENT CONTENTS OF ROW
        3072-10 3096          - R ADD     MASKCOL      "OR" MASKCOL IN SELECTED ROW
        3073+ 3 3081          + TR +      PRTW2
        3074-10 3098          - R ADD     ROW 
        3075+ 4 3079          + TR 0      PRTW1         
        3076+10 3094          + R ADD     ZERO         MASKCOL IS MINUS ZERO AND ROW IS NOT-EMPTY (EITHER POSITIVE OR NEGATIVE) -> SET ROW AS NEGATIVE
        3077- 7 3098          - SUB AB    ROW 
        3078+ 1 3086          + TR        PRTROWW
        3079-10 3096    PRTW1 - R ADD     MASKCOL      MASKCOL IS MINUS ZERO AND ROW IS EMPTY -> SET ROW = MASKCOL = MINUS ZERO
        3080+ 1 3086          + TR        PRTROWW
        3081-10 3098    PRTW2 - R ADD     ROW          
        3082+ 3 3085          + TR +      PRTW3              
        3083- 5 3096          - SUB       MASKCOL      MASKCOL IS POSITIVE AND ROW IS NEGATIVE -> SUB MASKCOL FROM ROW
        3084+ 1 3086          + TR        PRTROWW
        3085- 9 3096    PRTW3 - ADD       MASKCOL      MASKCOL IS POSITIVE AND ROW IS POSITIVE OR EMPTY -> ADD MASKCOL TO ROW         
        3086-12    0  PRTROWW - STORE     /   /        ROW UPDTATE
        3087+ 1 3054          + TR        LOOP1        PROCEED TO NEXT ROW
        3088+ 1    0 PRTCEX   + TR        /   /
        3089+10 3089 GETBMP1  + R ADD     *
        3090+ 1   91          + TR        BMPAD        GET BASE48 CHARS BITMAP ADDRESS
        3091+12 3102          + STORE     BITMAPAD     
        3092+ 1 3048          + TR        GETBMP2      RETURN
        3093+     0             ORG       EVEN
        3094+     0  ZERO       DEF       0            
        3095+     0             DEF       0            
        3096+     0  MASKCOL    DEF       0
        3097+     0             DEF       0
        3098+     0  ROW        DEF       0
        3099+     0             DEF       0
        3100+     0  NUM        DEF       0
        3101+     0             DEF       0
        3102+     0  BITMAPAD   DEF       0
        3103+     0  SGN        DEF       0
        3104+     0  LEN        DEF       0
        3105+     0  CHAR       DEF       0
        3106+     0  TXT        DEF       0
        3107+     0  PRTROWAD   DEF       0
        3108+     0  N          DEF       0
        3109+     0  BITS       DEF       0
        3110+     1  ONE        DEF       1
        3111+     2  TWO        DEF       2
        3112+     3  D3         DEF       3
        3113+    10  D10        DEF       10
        3114+    11  D11        DEF       11
        3115+    35  D35        DEF       35
        3116+    36  D36        DEF       36
        3117+    48  D48        DEF       48
        3118+    72  D72        DEF       72
        3119+  2304  D48X48     DEF       2304
        3120+ 16384  OCT04K     DEF       *040000      BIT SIGN ON 5TH OCTINARY DIGIT
        3122+ 9 3197 PRTNLINE + ADD       TWO          PRINT A NEW LINE OF DATA
        3123+12 3200          + STORE     PARAM        SAVE PARAM LIST ADDR
        3124+10 3124          + R ADD     *            CLEAR CARD BUFFER
        3125+ 1   53          + TR        CLRBUF 
        3126+10 3200 GPARAM   + R ADD     PARAM        GET PARAM PAIR FMT/DATA
        3127+13 3132          + STORE A   P1
        3128+ 9 3196          + ADD       ONE
        3129+13 3136          + STORE A   P2
        3130+ 9 3196          + ADD       ONE
        3131+12 3200          + STORE     PARAM
        3132+10    0 P1       + R ADD     /   /
        3133+12 3202          + STORE     FMT
        3134+ 3 3136          + TR +      P2           IF FMT < 0 THEM SKIP THIS PAIR FMT/DATA
        3135+ 1 3126          + TR        GPARAM
        3136+10    0 P2       + R ADD     /   /
        3137+12 3162          + STORE     DATALOC      GET DATA ADDRESS PASED AS PARAM
        3138+13 3139          + STORE A   P2A
        3139+10    0 P2A      + R ADD     /   /
        3140+12 3201          + STORE     DATA         GET EFFECTIVE DATA
        3141+10 3195          + R ADD     ZERO
        3142+15 3202          + LOAD MQ   FMT
        3143+18 3199          + DIV       D100         ACC=REMAINDER=COL NUMBER, MQ=QUOTIEN=TYPE OF DATA
        3144+12 3203          + STORE     COL
        3145+10 3195          + R ADD     ZERO
        3146+20   18          + L LEFT    0018
        3147+14 3202          + STORE MQ  FMT
        3148+15 3201          + LOAD MQ   DATA
        3149+10 3153          + R ADD     TYPETRAD
        3150+ 9 3202          + ADD       FMT
        3151+13 3152          + STORE A   TYPETR
        3152+ 1    0 TYPETR   + TR        /   /        TR SELECTED ROUTINE
        3153+ 0 3154 TYPETRAD + STOP      TYPETRT      TYPE TRANSFER TABLE ADDRESS
        3154+ 1 3183 TYPETRT  + TR        EOL          FMT=0..6 (IE <100) -> END OF PARAM LIST -> END OF LINE 
        3155+ 1 3160          + TR        TYSTR        FMT=1 -> PRINT A STRINGZ
        3156+ 1 3165          + TR        TYINT        FMT=2 -> PRINT AN INT
        3157+ 1 3170          + TR        TYOCT        FMT=3 -> PRINT AN OCT
        3158+ 1 3175          + TR        TYCHR        FMT=4 -> PRINT A CHAR
        3159+ 1 3179          + TR        TYALF        FMT=5 -> PRINT A 3-CHR PACKED ALFA STRING
        3160+10 3160 TYSTR    + R ADD     *            PRINT STRINGZ
        3161+ 1   87          + TR        PRTSTR
        3162+ 0    0 DATALOC  + STOP      /   /
        3163- 0 3203          - STOP      COL          COLUMN WHERE TXT STARTS
        3164+ 1 3126          + TR        GPARAM
        3165+10 3165 TYINT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        3166+ 1   61          + TR        PRTINT
        3167+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        3168- 0 3203          - STOP      COL          COLUMN WHERE TXT STARTS
        3169+ 1 3126          + TR        GPARAM
        3170+10 3170 TYOCT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        3171+ 1   89          + TR        PRTOCT
        3172+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        3173- 0 3203          - STOP      COL          COLUMN WHERE TXT STARTS
        3174+ 1 3126          + TR        GPARAM
        3175+10 3175 TYCHR    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        3176+ 1   63          + TR        PRTCHR
        3177- 0 3203          - STOP      COL          COLUMN WHERE TXT STARTS
        3178+ 1 3126          + TR        GPARAM
        3179+10 3179 TYALF    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        3180+ 1   59          + TR        PRTALF
        3181- 0 3203          - STOP      COL          COLUMN WHERE TXT STARTS
        3182+ 1 3126          + TR        GPARAM
        3183+10 3203 EOL      + R ADD     COL          SEND CARD BUFFER TO PRINTER AND RETURN TO CALLER
        3184+ 4 3189          + TR 0      DOPRINT      =0 -> PRINT ALLWAYS (NO SENSE SW CHECK)
        3185+ 9 3198          + ADD       D68          =1..6 -> SENSE 69..74 = OPERATOR'S PANEL SENSE SWITCH 1..6
        3186+13 3187          + STORE A   CHKSW
        3187+30    0 CHKSW    + SENSE     /   /         
        3188+ 1 3191          + TR        RETURN       SW NOT AT ON POSITION
        3189+10 3189 DOPRINT  + R ADD     *            PRINT CARD BUFFER
        3190+ 1   57          + TR        PRINTCRD
        3191+10 3200 RETURN   + R ADD     PARAM        PARAM-1 IS THE RETURN ADDR      
        3192+ 5 3196          + SUB       ONE
        3193+13 3194          + STORE A   EXIT
        3194+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        3195+ 0    0 ZERO     + STOP      0000
        3196+ 0    1 ONE      + STOP      0001
        3197+ 0    2 TWO      + STOP      0002
        3198+ 0   68 D68      + STOP      0068
        3199+ 0  100 D100     + STOP      100
        3200+ 0    0 PARAM    + STOP      0000
        3201+ 0    0 DATA     + STOP      0000
        3202+ 0    0 FMT      + STOP      0000
        3203+ 0    0 COL      + STOP      0000
        3204+ 9 3218 BMPAD    + ADD       TWO
        3205+13 3207          + STORE A   EXIT
        3206+10 3208          + R ADD     BITMAPAD
        3207+ 1    0 EXIT     + TR        /   /
        3208+ 0 3210 BITMAPAD + STOP      BITMAP
        3209+     0             ORG       EVEN
        3210+     0  BITMAP     DEF       0              <blank>     0     <none>
        3211+   256             DEF       256               1        1       1        256          =  256   
        3212+   128             DEF       128               2        2       2        128          =  128   
        3213+    64             DEF       64                3        3       3         64          =   64   
        3214+    32             DEF       32                4        4       4         32          =   32   
        3215+    16             DEF       16                5        5       5         16          =   16   
        3216+     8             DEF       8                 6        6       6          8          =    8   
        3217+     4             DEF       4                 7        7       7          4          =    4   
        3218+     2  TWO        DEF       2                 8        8       8          2          =    2   
        3219+     1             DEF       1                 9        9       9          1          =    1   
        3220+   512             DEF       512               0       10       0        512          =  512   
        3221+  1024             DEF       1024              -       11       X       1024          = 1024   
        3222+  2048             DEF       2048              +       12       Y       2048          = 2048   
        3223+  2304             DEF       2304              A       13      Y-1        256+2048    = 2304   
        3224+  2176             DEF       2176              B       14      Y-2        128+2048    = 2176   
        3225+  2112             DEF       2112              C       15      Y-3         64+2048    = 2112   
        3226+  2080             DEF       2080              D       16      Y-4         32+2048    = 2080   
        3227+  2064             DEF       2064              E       17      Y-5         16+2048    = 2064   
        3228+  2056             DEF       2056              F       18      Y-6          8+2048    = 2056   
        3229+  2052             DEF       2052              G       19      Y-7          4+2048    = 2052   
        3230+  2050             DEF       2050              H       20      Y-8          2+2048    = 2050   
        3231+  2049             DEF       2049              I       21      Y-9          1+2048    = 2049   
        3232+  1280             DEF       1280              J       22      X-1        256+1024    = 1280   
        3233+  1152             DEF       1152              K       23      X-2        128+1024    = 1152   
        3234+  1088             DEF       1088              L       24      X-3         64+1024    = 1088   
        3235+  1056             DEF       1056              M       25      X-4         32+1024    = 1056   
        3236+  1040             DEF       1040              N       26      X-5         16+1024    = 1040   
        3237+  1032             DEF       1032              O       27      X-6          8+1024    = 1032   
        3238+  1028             DEF       1028              P       28      X-7          4+1024    = 1028   
        3239+  1026             DEF       1026              Q       29      X-8          2+1024    = 1026   
        3240+  1025             DEF       1025              R       30      X-9          1+1024    = 1025   
        3241+   640             DEF       640               S       31      0-2        128+512     = 640    
        3242+   576             DEF       576               T       32      0-3         64+512     = 576    
        3243+   544             DEF       544               U       33      0-4         32+512     = 544    
        3244+   528             DEF       528               V       34      0-5         16+512     = 528    
        3245+   520             DEF       520               W       35      0-6          8+512     = 520    
        3246+   516             DEF       516               X       36      0-7          4+512     = 516    
        3247+   514             DEF       514               Y       37      0-8          2+512     = 514    
        3248+   513             DEF       513               Z       38      0-9          1+512     = 513    
        3249+   578             DEF       578               ,       39      8-3-0        2+64+512  = 578    
        3250+   546             DEF       546               %       40      8-4-0        2+32+512  = 546    
        3251+  1090             DEF       1090              $       41      8-3-X        2+64+1024 = 1090   
        3252+  1058             DEF       1058              *       42      8-4-X        2+32+1024 = 1058   
        3253+  2114             DEF       2114              .       43      8-3-Y        2+64+2048 = 2114   
        3254+  2082             DEF       2082              #       44      8-4-Y        2+32+2048 = 2082   
        3255+   768             DEF       768               /       45      0-1          512+256   = 768    
        3256+    66             DEF       66                +       46      8-3          2+64      = 66     
        3257+    34             DEF       34                -       47      8-4          2+32      = 34    This is the non-minus-sign separator
        3258+ 9 3282 CLMEM    + ADD       TWO 
        3259+13 3264          + STORE A   P1           PARM: ADDR 
        3260+ 9 3281          + ADD       ONE          
        3261+13 3266          + STORE A   P2           PARM: LOCATION OF LEN=NUMBER OF HALF-WORDS TO CLEAR 
        3262+ 9 3281          + ADD       ONE          
        3263+13 3272          + STORE A   EXIT
        3264+10    0 P1       + R ADD     /   /        GET ADDR TO CLEAR
        3265+13 3275          + STORE A   MEM
        3266+10    0 P2       + R ADD     /   /        GET LEN ADDR
        3267+13 3268          + STORE A   P2A
        3268+10    0 P2A      + R ADD     /   /        GET LEN 
        3269+12 3283          + STORE     LEN
        3270+15 3280          + LOAD MQ   ZERO
        3271+10 3283 LOOP     + R ADD     LEN
        3272+ 4    0 EXIT     + TR 0      /   /
        3273+ 5 3281          + SUB       ONE
        3274+12 3283          + STORE     LEN
        3275+14    0 MEM      + STORE MQ  /   /        
        3276+10 3275          + R ADD     MEM
        3277+ 9 3281          + ADD       ONE
        3278+13 3275          + STORE A   MEM
        3279+ 1 3271          + TR        LOOP
        3280+ 0    0 ZERO     + STOP      0000
        3281+ 0    1 ONE      + STOP      0001         constant 1
        3282+ 0    2 TWO      + STOP      0002         constant 2
        3283+ 0    0 LEN      + STOP      0000
        3284+ 9 3316 MEMCOPY  + ADD       TWO 
        3285+13 3292          + STORE A   P1           PARM: SRCADDR 
        3286+ 9 3315          + ADD       ONE          
        3287+13 3294          + STORE A   P2           PARM: DESTADDR
        3288+ 9 3315          + ADD       ONE          
        3289+13 3296          + STORE A   P3           PARM: LEN: LOCATION OF LEN=NUMBER OF HALF-WORDS TO CLEAR
        3290+ 9 3315          + ADD       ONE          
        3291+13 3302          + STORE A   EXIT
        3292+10    0 P1       + R ADD     /   /        GET SOURCE ADDR 
        3293+13 3305          + STORE A   MEMS
        3294+10    0 P2       + R ADD     /   /        GET DESTINATION ADDR 
        3295+13 3306          + STORE A   MEMD
        3296+10    0 P3       + R ADD     /   /        GET LEN ADDR
        3297+13 3298          + STORE A   P3A
        3298+10    0 P3A      + R ADD     /   /        GET LEN           
        3299+12 3317          + STORE     LEN
        3300+15 3314          + LOAD MQ   ZERO
        3301+10 3317 LOOP     + R ADD     LEN
        3302+ 4    0 EXIT     + TR 0      /   /
        3303+ 5 3315          + SUB       ONE
        3304+12 3317          + STORE     LEN
        3305+10    0 MEMS     + R ADD     /   /        
        3306+12    0 MEMD     + STORE     /   /        
        3307+10 3305          + R ADD     MEMS
        3308+ 9 3315          + ADD       ONE
        3309+13 3305          + STORE A   MEMS
        3310+10 3306          + R ADD     MEMD
        3311+ 9 3315          + ADD       ONE
        3312+13 3306          + STORE A   MEMD
        3313+ 1 3301          + TR        LOOP
        3314+ 0    0 ZERO     + STOP      0000
        3315+ 0    1 ONE      + STOP      0001         constant 1
        3316+ 0    2 TWO      + STOP      0002         constant 2
        3317+ 0    0 LEN      + STOP      0000
        3318+15 3385 SRCHTBL  + LOAD MQ   ZERO
        3319+ 1 3323          + TR        START
        3320+15 3386 EQTBL    + LOAD MQ   ONE
        3321+ 1 3323          + TR        START
        3322+15 3387 READTBL  + LOAD MQ   TWO
        3323+ 9 3387 START    + ADD       TWO 
        3324+13 3331          + STORE A   P1           PARM: ADDR OF TABLE
        3325+ 9 3386          + ADD       ONE          
        3326+13 3333          + STORE A   P2           PARM: LEN OF TABLE
        3327+ 9 3386          + ADD       ONE          
        3328+13 3338          + STORE A   P3           PARM: VAL TO FIND
        3329+ 9 3386          + ADD       ONE          
        3330+13 3379          + STORE A   EXIT
        3331+10    0 P1       + R ADD     /   /        GET ADDR OF TABLE
        3332+13 3382          + STORE A   TBL
        3333+10    0 P2       + R ADD     /   /        GET ADDR OF LEN OF TABLE/ENTRY ON TABLE
        3334+13 3335          + STORE A   P2A
        3335+10    0 P2A      + R ADD     /   /        DERREFERENCE -> ACC=LEN/ENTRY (1..LEN)
        3336+12 3380          + STORE     N
        3337+ 4 3379          + TR 0      EXIT         EXIT, CANNOT READ/STORE ON ENTRY 0, SEARCH ON EMPTY TABLE
        3338+10    0 P3       + R ADD     /   /        GET ADDR OF VAL TO FIND
        3339+13 3355          + STORE A   WRVAL
        3340+13 3341          + STORE A   P3A
        3341+10    0 P3A      + R ADD     /   /        DERREFERENCE -> ACC=VAL
        3342+12 3381          + STORE     VAL
        3343+14 3384          + STORE MQ  TEMP         JUMP TABLE DISPATCH
        3344+10 3384          + R ADD     TEMP
        3345+ 4 3360          + TR 0      LOOP0        TR TO SEARCH TABLE
        3346+10 3380          + R ADD     N            SUB ONE AS FIRST ENTRY ON TABLE IS "1"
        3347+ 5 3386          + SUB       ONE          
        3348+ 9 3382          + ADD       TBL          TABLE BASE ADDR
        3349+13 3358          + STORE A   WRTBL
        3350+13 3354          + STORE A   RDTBL2
        3351+10 3384          + R ADD     TEMP
        3352+ 5 3386          + SUB       ONE
        3353+ 4 3357          + TR 0      STORETBL 
        3354+10    0 RDTBL2   + R ADD     /   /        VAL=TBL[ENT]
        3355+12    0 WRVAL    + STORE     /   /
        3356+ 1 3379          + TR        EXIT
        3357+10 3381 STORETBL + R ADD     VAL          TBL[ENT]=VAL
        3358+12    0 WRTBL    + STORE     /   /    
        3359+ 1 3379          + TR        EXIT
        3360+10 3382 LOOP0    + R ADD     TBL
        3361+13 3367          + STORE A   RDTBL
        3362+10 3367          + R ADD     RDTBL
        3363+12 3383          + STORE     TBL0
        3364+ 9 3380          + ADD       N
        3365+12 3384          + STORE     TEMP         THE END ADDR OF TABLE
        3366+10 3381 LOOP     + R ADD     VAL          ACC=THE SEARCHED VALUE
        3367+ 5    0 RDTBL    + SUB       /   /    
        3368+ 2 3369          + TR OV     OVOK         CLEAR OV JUST IN CASE
        3369+ 4 3376 OVOK     + TR 0      FOUND        TR IF VAL FOUND IN ENTRY N
        3370+10 3367          + R ADD     RDTBL
        3371+ 9 3386          + ADD       ONE
        3372+13 3367          + STORE A   RDTBL
        3373+ 5 3384          + SUB       TEMP
        3374+ 4 3379          + TR 0      EXIT         NOT FOUND -> RETURN ZERO
        3375+ 1 3366          + TR        LOOP
        3376+10 3367 FOUND    + R ADD     RDTBL        RETURN ENTRY FOUND
        3377+ 5 3383          + SUB       TBL0
        3378+ 9 3386          + ADD       ONE
        3379+ 1    0 EXIT     + TR        /   /
        3380+ 0    0 N        + STOP      0000
        3381+ 0    0 VAL      + STOP      0000
        3382+ 0    0 TBL      + STOP      0000
        3383+ 0    0 TBL0     + STOP      0000
        3384+ 0    0 TEMP     + STOP      0000
        3385+ 0    0 ZERO     + STOP      0000
        3386+ 0    1 ONE      + STOP      0001         constant 1
        3387+ 0    2 TWO      + STOP      0002         constant 2
        3388+ 9 3429 READTBL2 + ADD       TWO 
        3389+13 3396          + STORE A   P1           PARM: ADDR OF TABLE
        3390+ 9 3428          + ADD       ONE          
        3391+13 3398          + STORE A   P2           PARM: MAX LEN OF TABLE
        3392+ 9 3428          + ADD       ONE          
        3393+13 3402          + STORE A   P3           PARM: ENT TO GET
        3394+ 9 3428          + ADD       ONE          
        3395+13 3409          + STORE A   PVAL         PARM: VAL TO GET
        3396+10    0 P1       + R ADD     /   /        GET ADDR OF TABLE
        3397+13 3427          + STORE A   TBL
        3398+10    0 P2       + R ADD     /   /        GET ADDR OF MAX LEN OF TABLE
        3399+13 3400          + STORE A   P2A
        3400+10    0 P2A      + R ADD     /   /        DERREFERENCE -> ACC=MAX
        3401+12 3426          + STORE     MAX
        3402+10    0 P3       + R ADD     /   /        GET ADDR OF ENTRY TO GET
        3403+13 3404          + STORE A   P3A
        3404+10    0 P3A      + R ADD     /   /        DERREFERENCE -> ACC=ENT
        3405+ 4 3421          + TR 0      ENT0         EXIT, CANNOT READ ON ENTRY 0
        3406+ 5 3428          + SUB       ONE          
        3407+ 9 3427          + ADD       TBL          TABLE BASE ADDR
        3408+13 3412          + STORE A   RDTBL        TBL[ENT] ADDRESS
        3409+10    0 PVAL     + R ADD     /   /        GET ADDR OF VAL TO FIND
        3410+ 4 3422          + TR 0      PARAMEND     END OF PARAM LIST
        3411+13 3413          + STORE A   WRVAL
        3412+10    0 RDTBL    + R ADD     /   /        VAL=TBL[ENT]
        3413+12    0 WRVAL    + STORE     /   /
        3414+10 3409          + R ADD     PVAL         SELECT NEXT PARAM FROM LIST
        3415+ 9 3428          + ADD       ONE
        3416+13 3409          + STORE A   PVAL
        3417+10 3412          + R ADD     RDTBL
        3418+ 9 3426          + ADD       MAX
        3419+13 3412          + STORE A   RDTBL
        3420+ 1 3409          + TR        PVAL     
        3421+ 0 2222 ENT0     + STOP      2222         CANNOT READTBL ON ENTRY 0
        3422+10 3409 PARAMEND + R ADD     PVAL         GET RETURN ADDR AND EXIT
        3423+ 9 3428          + ADD       ONE
        3424+13 3425          + STORE A   EXIT
        3425+ 1    0 EXIT     + TR        /   /
        3426+ 0    0 MAX      + STOP      0000
        3427+ 0    0 TBL      + STOP      0000
        3428+ 0    1 ONE      + STOP      0001         constant 1
        3429+ 0    2 TWO      + STOP      0002         constant 2
        3430+ 9 3471 EQTBL2   + ADD       TWO 
        3431+13 3438          + STORE A   P1           PARM: ADDR OF TABLE
        3432+ 9 3470          + ADD       ONE          
        3433+13 3440          + STORE A   P2           PARM: MAX LEN OF TABLE
        3434+ 9 3470          + ADD       ONE          
        3435+13 3444          + STORE A   P3           PARM: ENT TO SET
        3436+ 9 3470          + ADD       ONE          
        3437+13 3451          + STORE A   PVAL         PARM: VAL TO SET
        3438+10    0 P1       + R ADD     /   /        GET ADDR OF TABLE
        3439+13 3469          + STORE A   TBL
        3440+10    0 P2       + R ADD     /   /        GET ADDR OF MAX LEN OF TABLE
        3441+13 3442          + STORE A   P2A
        3442+10    0 P2A      + R ADD     /   /        DERREFERENCE -> ACC=MAX
        3443+12 3468          + STORE     MAX
        3444+10    0 P3       + R ADD     /   /        GET ADDR OF ENTRY TO SET
        3445+13 3446          + STORE A   P3A
        3446+10    0 P3A      + R ADD     /   /        DERREFERENCE -> ACC=ENT
        3447+ 4 3463          + TR 0      ENT0         EXIT, CANNOT READ ON ENTRY 0
        3448+ 5 3470          + SUB       ONE          
        3449+ 9 3469          + ADD       TBL          TABLE BASE ADDR
        3450+13 3455          + STORE A   WRTBL        TBL[ENT] ADDRESS
        3451+10    0 PVAL     + R ADD     /   /        GET ADDR OF VAL TO SET
        3452+ 4 3464          + TR 0      PARAMEND     END OF PARAM LIST
        3453+13 3454          + STORE A   RDVAL
        3454+10    0 RDVAL    + R ADD     /   /        TBL[ENT]=VAL
        3455+12    0 WRTBL    + STORE     /   /
        3456+10 3451          + R ADD     PVAL         SELECT NEXT PARAM FROM LIST
        3457+ 9 3470          + ADD       ONE
        3458+13 3451          + STORE A   PVAL
        3459+10 3455          + R ADD     WRTBL
        3460+ 9 3468          + ADD       MAX
        3461+13 3455          + STORE A   WRTBL
        3462+ 1 3451          + TR        PVAL     
        3463+ 0 2222 ENT0     + STOP      2222         CANNOT EQTBL ON ENTRY 0
        3464+10 3451 PARAMEND + R ADD     PVAL         GET RETURN ADDR AND EXIT
        3465+ 9 3470          + ADD       ONE
        3466+13 3467          + STORE A   EXIT
        3467+ 1    0 EXIT     + TR        /   /
        3468+ 0    0 MAX      + STOP      0000
        3469+ 0    0 TBL      + STOP      0000
        3470+ 0    1 ONE      + STOP      0001         constant 1
        3471+ 0    2 TWO      + STOP      0002         constant 2
        3472+ 9 3545 RWDRUM   + ADD       TWO 
        3473+13 3482          + STORE A   PDR1         PARM1: DRUM INSTR: READ/WRITE 0128  0129  0130  0131
        3474+ 9 3544          + ADD       ONE          
        3475+13 3484          + STORE A   PDR2         PARM2: DRUM ADDRESS (0..4094)
        3476+ 9 3544          + ADD       ONE          
        3477+13 3486          + STORE A   PDR3         PARM3: BUF START ADDRESS
        3478+ 9 3544          + ADD       ONE          
        3479+13 3488          + STORE A   PDR4         PARM4: LEN: NUMBER OF HALF-WORDS (MUST BE EVEN)
        3480+ 9 3544          + ADD       ONE          
        3481+13 3542          + STORE A   EXIT               
        3482+10    0 PDR1     + R ADD     /   /        GET DRUM INSTR
        3483+12 3490          + STORE     DRIO
        3484+10    0 PDR2     + R ADD     /   /        GET DRUM ADDR
        3485+13 3491          + STORE A   DRADDR
        3486+10    0 PDR3     + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        3487+13 3529          + STORE A   RWCOPY    
        3488+10    0 PDR4     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        3489+12 3546          + STORE     LEN
        3490+ 0    0 DRIO     + STOP      /   /        INSTR: READ/WRITE 0128  0129  0130  0131
        3491+29    0 DRADDR   + SET DR    /   /
        3492+ 1 3525          + TR        LOOP
        3493+ 9 3545 RDTAPE   + ADD       TWO 
        3494+13 3501          + STORE A   PR1          PARM1: TAPE ADDRESS
        3495+ 9 3544          + ADD       ONE          
        3496+13 3503          + STORE A   PR2          PARM2: BUF START ADDRESS
        3497+ 9 3544          + ADD       ONE          
        3498+13 3542          + STORE A   EXIT
        3499+ 2 3500          + TR OV     CLOV1        CLEAR OV THAT MAY HAVE BEEN SET
        3500+ 8    0    CLOV1 + NOOP      0000
        3501+10    0 PR1      + R ADD     /   /        GET TAPE ADDR
        3502+13 3505          + STORE A   RTAPAD       TAPE UNITS: 0256  0257  0258  0259
        3503+10    0 PR2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        3504+13 3529          + STORE A   RWCOPY    
        3505+24    0 RTAPAD   + READ      /   /
        3506+10 3543          + R ADD     ZERO
        3507+ 1 3527          + TR        LOOP1
        3508+ 9 3545 WRTAPE   + ADD       TWO 
        3509+13 3516          + STORE A   PW1          PARM1: TAPE ADDRESS
        3510+ 9 3544          + ADD       ONE          
        3511+13 3518          + STORE A   PW2          PARM2: BUF START ADDRESS
        3512+ 9 3544          + ADD       ONE          
        3513+13 3520          + STORE A   PW3          PARM3: BUF LEN
        3514+ 9 3544          + ADD       ONE          
        3515+13 3542          + STORE A   EXIT
        3516+10    0 PW1      + R ADD     /   /        GET TAPE ADDR
        3517+13 3524          + STORE A   WTAPAD       TAPE UNITS: 0256  0257  0258  0259
        3518+10    0 PW2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        3519+13 3529          + STORE A   RWCOPY    
        3520+10    0 PW3      + R ADD     /   /        GET ADDR OF LEN 
        3521+13 3522          + STORE A   PW3A
        3522+10    0 PW3A     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        3523+12 3546          + STORE     LEN
        3524+26    0 WTAPAD   + WRITE     /   /        PREPARE TO WRITE ON TAPE
        3525+10 3546 LOOP     + R ADD     LEN
        3526+ 4 3541          + TR 0      RWOK
        3527+ 5 3545 LOOP1    + SUB       TWO
        3528+12 3546          + STORE     LEN
        3529-31    0 RWCOPY   - COPY      /   /        WRITE BUFFER TO TAPE
        3530+ 1 3533          + TR        GO 
        3531+ 1 3537          + TR        EOF          END OF FILE
        3532+ 1 3539          + TR        EOR          END OF RECORD
        3533+10 3529 GO       + R ADD     RWCOPY
        3534+ 5 3545          + SUB       TWO
        3535+13 3529          + STORE A   RWCOPY
        3536+ 1 3525          + TR        LOOP
        3537+10 3544 EOF      + R ADD     ONE          SET OV FLAG TO SIGNAL END OF FILE CONDITION
        3538+22   36          + A LEFT    36
        3539+ 6 3546 EOR      + R SUB     LEN          RETURN NUMBER OF HALF-WORDS READ
        3540+ 5 3545          + SUB       TWO
        3541+26 2052 RWOK     + WRITE     2052         INSURE THAT MQ NOT IN USE            
        3542+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        3543+ 0    0 ZERO     + STOP      0000
        3544+ 0    1 ONE      + STOP      0001         
        3545+ 0    2 TWO      + STOP      0002         
        3546+     0  LEN        RES       1
        3548+12 3624 RDBTAPE  + STORE     DUMMY
        3549+10 3618          + R ADD     RDBKW        SET THE TAPE I/O INSTRUCTION
        3550+12 3588          + STORE     RTAPAD
        3551+10 3619          + R ADD     ADD2         SET TO DECREMENT RWCOPY ADDRESS
        3552+12 3598          + STORE     INCR         (INSTR IS -COPY -> NEGATIVE -> DECREMENT BY ADDING TWO)
        3553+15 3622          + LOAD MQ   ONE          FLAG OF COMPUTE: ADD=ADD+LEN-2
        3554+ 1 3561          + TR        READ
        3555+12 3624 RDFTAPE  + STORE     DUMMY
        3556+10 3617          + R ADD     RDFWD        SET THE TAPE I/O INSTRUCTION
        3557+12 3588          + STORE     RTAPAD
        3558+10 3620          + R ADD     SUB2         SET TO INCREMENT RWCOPY ADDRESS
        3559+12 3598          + STORE     INCR         (INSTR IS -COPY -> NEGATIVE -> INCREMENT BY SUBSTRACTING TWO)
        3560+15 3621          + LOAD MQ   ZERO
        3561+10 3624 READ     + R ADD     DUMMY        PROCEED
        3562+ 9 3623          + ADD       TWO 
        3563+13 3570          + STORE A   PR1          PARM1: TAPE ADDRESS
        3564+ 9 3622          + ADD       ONE          
        3565+13 3573          + STORE A   PR2          PARM2: BUF START ADDRESS
        3566+ 9 3622          + ADD       ONE          
        3567+13 3575          + STORE A   PR3          PARM2: BUF LEN ADDRESS
        3568+ 9 3622          + ADD       ONE          
        3569+13 3616          + STORE A   EXIT
        3570+10    0 PR1      + R ADD     /   /        GET TAPE ADDR
        3571+13 3588          + STORE A   RTAPAD       TAPE UNITS: 0256  0257  0258  0259
        3572+ 2 3573          + TR OV     PR2          CLEAR OVERFLOW FLAG
        3573+10    0 PR2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        3574+13 3593          + STORE A   RWCOPY    
        3575+10    0 PR3      + R ADD     /   /        GET ADDR OF LEN 
        3576+13 3577          + STORE A   PR3A
        3577+10    0 PR3A     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        3578+12 3625          + STORE     LEN
        3579+10 3621          + R ADD     ZERO
        3580+20   35          + L LEFT    0035         ACC=MQ
        3581+ 4 3586          + TR 0      PR4          IF MQ=0 -> READ FWD -> TR TO PR4
        3582+10 3593          + R ADD     RWCOPY       HERE READ BKW -> SET BUFFER START AT ADD+LEN-2
        3583+ 5 3625          + SUB       LEN
        3584+ 9 3623          + ADD       TWO
        3585+13 3593          + STORE A   RWCOPY
        3586+10 3621 PR4      + R ADD     ZERO
        3587+12 3626          + STORE     RECLEN
        3588+ 0    0 RTAPAD   + STOP      /   /        WILL BE REPLACED BY RDFWD OR RDBKW
        3589+10 3625 LOOP     + R ADD     LEN
        3590+ 4 3604          + TR 0      SKIP
        3591+ 5 3623          + SUB       TWO
        3592+12 3625          + STORE     LEN
        3593-31    0 RWCOPY   - COPY      /   /        WRITE BUFFER TO TAPE
        3594+ 1 3597          + TR        GO 
        3595+ 1 3612          + TR        EOF          END OF FILE
        3596+ 1 3614          + TR        EOR          END OF RECORD
        3597+10 3593 GO       + R ADD     RWCOPY
        3598+ 5 3623 INCR     + SUB       TWO
        3599+13 3593          + STORE A   RWCOPY
        3600+10 3626          + R ADD     RECLEN
        3601+ 9 3623          + ADD       TWO
        3602+12 3626          + STORE     RECLEN
        3603+ 1 3589          + TR        LOOP
        3604-31 3624 SKIP     - COPY      DUMMY
        3605+ 1 3608          + TR        GO2 
        3606+ 1 3612          + TR        EOF          END OF FILE
        3607+ 1 3614          + TR        EOR          END OF RECORD
        3608+10 3626 GO2      + R ADD     RECLEN
        3609+ 9 3623          + ADD       TWO
        3610+12 3626          + STORE     RECLEN
        3611+ 1 3604          + TR        SKIP
        3612+10 3622 EOF      + R ADD     ONE          SET OV FLAG TO SIGNAL END OF FILE CONDITION
        3613+22   36          + A LEFT    36
        3614+10 3626 EOR      + R ADD     RECLEN       RETURN NUMBER OF HALF-WORDS IN TAPE RECORD
        3615+26 2052          + WRITE     2052         INSURE THAT MQ NOT IN USE            
        3616+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        3617+24    0 RDFWD    + READ      0000         TAPE I/O INSTRUCTIONS 
        3618+25    0 RDBKW    + READ B    0000
        3619+ 9 3623 ADD2     + ADD       TWO
        3620+ 5 3623 SUB2     + SUB       TWO
        3621+ 0    0 ZERO     + STOP      0000
        3622+ 0    1 ONE      + STOP      0001         
        3623+ 0    2 TWO      + STOP      0002         
        3624+     0  DUMMY      RES       1
        3625+     0  LEN        RES       1
        3626+     0  RECLEN     RES       1
        3628+ 9 3643 CHAIN    + ADD       TWO
        3629+13 3630          + STORE A   CHP1
        3630+10    0 CHP1     + R ADD     /   /        GET TAPE NUMBER
        3631+13 3638          + STORE A   TAPELOAD
        3632+30   70          + SENSE     0070         SENSE SWITCH 2                                  
        3633+ 1 3637 CONTAD   + TR        ENDSTOP      (ON POSITION MAKES SENSE OPCODE TO SKIP NEXT INSTR)
        3634+10 3633          + R ADD     CONTAD       IF SW2 IS ON, A +STOP 4095 IS EXECUTED.  
        3635+12 4095          + STORE     4095         IF THEN USER PRESS START, EXECUTION WILL BE RESUMED 
        3636+ 0 4095          + STOP      4095         AND CHAINED PROGRAM WILL BE LOADED AND EXECUTED
        3637+ 8    0 ENDSTOP  + NOOP      0000
        3638+24    0 TAPELOAD + READ      0000         
        3639-31    0 TL0      - COPY      0000         READ 1ST WORD OF SELF-LOADER FROM TAPE
        3640+ 1    0          + TR        0000         TR TO SELF-LOADER
        3641+ 0 2221          + STOP      2221         ERROR LOADING: UNEXPECTED END OF FILE
        3642+ 0 2222          + STOP      2222         ERROR LOADING: UNEXPECTED END OF RECORD 
        3643+ 0    2 TWO      + STOP      0002         ERROR LOADING: UNEXPECTED END OF FILE
          48-     0  ROUTINE INIT
          49+ 1  124 ENTRY POINT
          50-     0  ROUTINE CHAIN
          51+ 1 3628 ENTRY POINT
          52-     0  ROUTINE CLRBUF
          53+ 1 2792 ENTRY POINT
          54-     0  ROUTINE PRTNLINE
          55+ 1 3122 ENTRY POINT
          56-     0  ROUTINE PRINTCRD
          57+ 1 2800 ENTRY POINT
          58-     0  ROUTINE PRTALF
          59+ 1 2884 ENTRY POINT
          60-     0  ROUTINE PRTINT
          61+ 1 2962 ENTRY POINT
          62-     0  ROUTINE PRTCHR
          63+ 1 3004 ENTRY POINT
          64-     0  ROUTINE RDBTAPE
          65+ 1 3548 ENTRY POINT
          66-     0  ROUTINE WRTAPE
          67+ 1 3508 ENTRY POINT
          68-     0  ROUTINE EQTBL
          69+ 1 3320 ENTRY POINT
          70-     0  ROUTINE EQTBL2
          71+ 1 3430 ENTRY POINT
          72-     0  ROUTINE READTBL
          73+ 1 3322 ENTRY POINT
          74-     0  ROUTINE READTBL2
          75+ 1 3388 ENTRY POINT
          76-     0  ROUTINE SRCHTBL
          77+ 1 3318 ENTRY POINT
          78-     0  ROUTINE CLMEM
          79+ 1 3258 ENTRY POINT
          80-     0  ROUTINE MEMCOPY
          81+ 1 3284 ENTRY POINT
          82-     0  ROUTINE READCRD
          83+ 1 2796 ENTRY POINT
          84-     0  ROUTINE WRITECRD
          85+ 1 2798 ENTRY POINT
          86-     0  ROUTINE PRTSTR
          87+ 1 2861 ENTRY POINT
          88-     0  ROUTINE PRTOCT
          89+ 1 2928 ENTRY POINT
          90-     0  ROUTINE BMPAD
          91+ 1 3204 ENTRY POINT
          92-     0  ROUTINE RDTAPE
          93+ 1 3493 ENTRY POINT
          94-     0  ROUTINE RWDRUM
          95+ 1 3472 ENTRY POINT
          96-     0  ROUTINE RDFTAPE
          97+ 1 3555 ENTRY POINT
        4094+    48  REGION ORIGIN TABLE LOCATION
        4095+   124  INITIAL REGION
           0+ 1  124          + TR        INIT         PROGRAM START
