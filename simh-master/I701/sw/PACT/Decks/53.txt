        DEC
        NNNN OP ADDR COMMENTS
          96+ 9 2359 LOADCC   + ADD       TWO          LOAD PACTSCR INTO CARD IMAGE SO 
          97+13  116          + STORE A   CPCCEX       CURRENT PACT SOURCE CODE CAN BE PRINTED
          98+10 2356          + R ADD     ZERO         COPY TO LEFT SIDE OF SOURCE CODE CARD IMAGE
          99+13  103          + STORE A   CPCC1        AT 0..46 FROM PACTSCR
         100+10  119          + R ADD     CPCC2
         101+13  102          + STORE A   CPCC 
         102-10    0 CPCC     - R ADD     /   /
         103-12    0 CPCC1    - STORE     /   /
         104+10  103          + R ADD     CPCC1
         105+ 5 2359          + SUB       TWO
         106+13  108          + STORE A   CPCC1B
         107+10 2356          + R ADD     ZERO
         108-12    0 CPCC1B   - STORE     /   /
         109+10  102          + R ADD     CPCC
         110+ 5 2359          + SUB       TWO
         111+13  102          + STORE A   CPCC
         112+10  103          + R ADD     CPCC1
         113+ 5 2361          + SUB       D4
         114+13  103          + STORE A   CPCC1
         115+ 5  118          + SUB       CPCCE
         116+ 4    0 CPCCEX   + TR 0      /   /        RETURN TO CALLER
         117+ 1  102          + TR        CPCC
         118-12   48 CPCCE    - STORE     0048         LAST LOCATION TO COPY FROM 
         119+ 8 1130 CPCC2    + NOOP      PACTSRC      PACTSRC = FIRST LOCATION TO COPY FROM
         120+10  120 INIT     + R ADD     *            
         121+ 1   55          + TR        PRTNLINE     
         122+ 0  101          + STOP      0101         STRINGZ AT COL 1
         123+ 0 2433          + STOP      MSGSTART     "CALL EXPANSION"
         124+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         125+10 2356          + R ADD     ZERO         CLEAR CC RECORD
         126+12 1154          + STORE     REGION     
         127+12 1155          + STORE     STEP       
         128+12 1156          + STORE     OP         
         129+12 1157          + STORE     FACT       
         130+12 1158          + STORE     S1         
         131+12 1159          + STORE     S2         
         132+12 1160          + STORE     QR         
         133+12 1161          + STORE     QF         
         134-12 1162          - STORE     NUM        
         135+12 1164          + STORE     CLUE       
         136+12 1165          + STORE     STEPN      
         137+12 1166          + STORE     FACTN      
         138+12 1167          + STORE     FACTREG    
         139+12 1168          + STORE     S1N        
         140+12 1169          + STORE     S2N        
         141+12 1170          + STORE     D1N        
         142+12 1171          + STORE     D2N        
         143+12 1172          + STORE     NINST      
         144+12 1173          + STORE     NINCR 
         145+10 1374          + R ADD     CCLEN        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         146+10 1384          + R ADD     TPARNAME     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         147+10 1418          + R ADD     TPARSTEP     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         148+10 1520          + R ADD     TPARLOC1     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         149+10 1756          + R ADD     TREFADDR     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         150+10 1956          + R ADD     TREFSTEP     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         151+10  151          + R ADD     *            CLEAR GENERATED MACHINE CODE INSTR ON CC RECORD
         152+ 1   79          + TR        CLMEM        
         153+ 0 1174 TINSTAD  + STOP      TINST      
         154+ 0 2374          + STOP      D200         TINST (200 HALF-WORDS) = 2 * MAXNINST (MAX NUMBER OF MACHINE CODE INSTRUTIONS PER STEP)
         155+10 2356          + R ADD     ZERO
         156+12 2378          + STORE     NREGIONS     NUMBER OF REGIONS PROCESSED
         157+28  258          + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE)
         158+28  257          + REWIND    TAPEOUT      REWIND TAPE OUT WITH UPDATED PACT COMPACT CODE
         159+10 2356 READREG  + R ADD     ZERO
         160+12 1555          + STORE     NREFS        INIT NUMBER OF REFERENCES
         161+12 2407          + STORE     SVNINST      SO WE CAN PRINT A LOG OF CC THAT GET GENERATED MC INSTR
         162+12 2388          + STORE     REGCSTEP     STEPN WHERE THE REG.C SITS
         163+10  163 READSTEP + R ADD     *            READ PACT USER PROGRAM SOURCE CODE FROM TAPE IN
         164+ 1   65          + TR        RDTAPE
         165+ 0  258          + STOP      TAPEIN
         166+ 0 1130          + STOP      CCODE        BUF TO READ IN FROM TAPE
         167+ 2  240          + TR OV     EOF          TR IF END OF FILE
         168+10 1156          + R ADD     OP
         169+ 4  231          + TR 0      EOR          TR IF END OF REGION
         170+10  170          + R ADD     *            LOAD PACTSCR INTO CARD IMAGE SO 
         171+ 1   96          + TR        LOADCC       CURRENT PACT SOURCE CODE CAN BE PRINTED
         172+10 1172          + R ADD     NINST        SAVE CURRENT NUMBER OF MC INSTR IN THE COMPACT CODE RECORD
         173+12 2407          + STORE     SVNINST      SO WE CAN PRINT A LOG OF CC THAT GET GENERATED MC INSTR
         174+10 1156          + R ADD     OP
         175+ 5 2372          + SUB       D100
         176+ 4  313          + TR 0      WRNCONST     IF OP=100 TR TO SAVE TO TAPE OP=100 CC RECORD
         177+10 1156          + R ADD     OP           JUMP TABLE TO HANDLE EACH TYPE OF PACT OPERATION
         178+ 9  181          + ADD       OPTBL
         179+13  180          + STORE A   OPTBLTR
         180+ 1    0 OPTBLTR  + TR        /   /
         181+ 0  181 OPTBL    + STOP      *
         182+ 1  808          + TR        CHECKREF     OP=1   TAKE   FACTOR CANNOT BE BLANK 
         183+ 1  808          + TR        CHECKREF     OP=2   ADD    ALLOWS BLANK FACTOR 
         184+ 1  808          + TR        CHECKREF     OP=3   SUB    ALLOWS BLANK FACTOR 
         185+ 1  808          + TR        CHECKREF     OP=4   MUL    ALLOWS BLANK FACTOR
         186+ 1  808          + TR        CHECKREF     OP=5   DIV    FACTOR CANNOT BE BLANK 
         187+ 1  227          + TR        NEXT         OP=6   RES    NO FACTOR
         188+ 1  808          + TR        CHECKREF     OP=7   EQ     NEEDS VARIABLE AS FACTOR
         189+ 1  808          + TR        CHECKREF     OP=8   +ABS   ALLOWS BLANK FACTOR
         190+ 1  808          + TR        CHECKREF     OP=9   -ABS   ALLOWS BLANK FACTOR
         191+ 1  808          + TR        CHECKREF     OP=10  ABS    FACTOR CANNOT BE BLANK 
         192+ 1  227          + TR        NEXT         OP=11  T      FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         193+ 1  227          + TR        NEXT         OP=12  TZ     FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         194+ 1  227          + TR        NEXT         OP=13  TP     FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         195+ 1  227          + TR        NEXT         OP=14  TN     FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         196+ 1  227          + TR        NEXT         OP=15  TF     FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         197+ 1  227          + TR        NEXT         OP=16  HALT   FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         198+ 1  808          + TR        CHECKREF     OP=17  TEST   
         199+ 1  808          + TR        CHECKREF     OP=18  SET    
         200+ 1  808          + TR        CHECKREF     OP=19  USE    
         201+ 1  227          + TR        NEXT         OP=20  DO     ALREADY PROCESSED IN OPERATION EXPANSION
         202+ 1  227          + TR        NEXT         OP=21  EXIT
         203+ 1  226          + TR        BADOP        OP=22  DUP    SHOULD NOT BE PRESENT. IT IS ALREADY PROCESSED
         204+ 1  227          + TR        NEXT         OP=23  LIB    
         205+ 1  226          + TR        BADOP        OP=24  ID     SHOULD NOT BE PRESENT. IT IS DESAMBIGUATED
         206+ 1  226          + TR        BADOP        OP=25  FOR    SHOULD NOT BE PRESENT. IT IS DESAMBIGUATED
         207+ 1  687          + TR        CALL         OP=26  CALL   
         208+ 1  808          + TR        CHECKREF     OP=27  SIN    ALLOWS BLANK FACTOR
         209+ 1  808          + TR        CHECKREF     OP=28  COS    ALLOWS BLANK FACTOR
         210+ 1  808          + TR        CHECKREF     OP=29  ARCT   ALLOWS BLANK FACTOR
         211+ 1  808          + TR        CHECKREF     OP=30  SQRT   ALLOWS BLANK FACTOR
         212+ 1  808          + TR        CHECKREF     OP=31  LOG    ALLOWS BLANK FACTOR
         213+ 1  808          + TR        CHECKREF     OP=32  EXP    ALLOWS BLANK FACTOR
         214+ 1  227          + TR        NEXT         OP=33  SE
         215+ 1  808          + TR        CHECKREF     OP=34  CL     NEEDS VARIABLE AS FACTOR
         216+ 1  227          + TR        NEXT         OP=35  READ
         217+ 1  227          + TR        NEXT         OP=36  LIST
         218+ 1  227          + TR        NEXT         OP=37  RES for MULT
         219+ 1  227          + TR        NEXT         OP=38  RES for DIV
         220+ 1  808          + TR        CHECKREF     OP=39  ID for LIST         FACTOR CANNOT BE BLANK 
         221+ 1  363          + TR        IDDO         OP=40  ID for DO/LIB       
         222+ 1  511          + TR        CALLPARM     OP=41  ID for CALL         
         223+ 1  452          + TR        FORDO        OP=42  FOR for DO/LIB      
         224+ 1  511          + TR        CALLPARM     OP=43  FOR for CALL        
         225+ 1  347          + TR        LDNCONST     OP=44  OPNCONST            LOADS LOOP CONSTANTS POOL FROM TINST
         226+ 0 1111 BADOP    + STOP      1111         INTERNAL COMPILER ERROR: SHOULD NOT BE PRESENT. IT SHOULD HAVE BEEN DESAMBIGUATED
         227+ 8    0 NEXT     + NOOP      0000         CONTINUE 
         228+10  228          + R ADD     *            WRITE COMPACT CODE ON TAPEOUT
         229+ 1  256          + TR        WRCC         WITH LOG
         230+ 1  163          + TR        READSTEP     
         231+ 8    0 EOR      + NOOP      0000         END OF REGION RECORD. JUST AFTER THIS RECORD COMES CC OP=101
         232+10  232          + R ADD     *            WRITE COMPACT CODE OP=0 EOR ON TAPEOUT
         233+ 1  256          + TR        WRCC         
         234+10  234          + R ADD     *            READ CALL PARAMETER TABLE 
         235+ 1  291          + TR        RDPARCC
         236+10 2378          + R ADD     NREGIONS     NUMBER OF REGIONS PROCESSED
         237+ 9 2358          + ADD       ONE
         238+12 2378          + STORE     NREGIONS     
         239+ 1  159          + TR        READREG      PROCESS NEXT REGION
         240+ 8    0 EOF      + NOOP      0000         END OF FILE
         241+27  257          + WRITE EF  TAPEOUT      WRITE EOF IN TAPE OUT (COMPACT CODE)
         242+30   74          + SENSE     0074         SENSE SWITCH 6
         243+ 1  251          + TR        ENDLOG1B     TR IF NO LOG SELECTED
         244+10  244          + R ADD     *
         245+ 1   55          + TR        PRTNLINE     
         246+ 0  101          + STOP      0101         STRINGZ AT COL 1
         247+ 0 2439          + STOP      MSGDONE      "REGIONS"
         248+ 0  210          + STOP      0210         INT AT COL 10
         249+ 0 2378          + STOP      NREGIONS     NUMBER OF REGIONS PROCESSED
         250+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         251+ 8    0 ENDLOG1B + NOOP      0000
         252+10  252          + R ADD     *
         253+ 1   51          + TR        CHAIN        IF SW2 IS ON, A +STOP 4095 IS EXECUTED 
         254+ 0  256          + STOP      PACTCOMP     CHAIN TO NEXT STAGE IN PACT COMPILER TAPE
         255+ 0 4095          + STOP      4095
         256+ 9 2359 WRCC     + ADD       TWO          WRITE COMPACT CODE ON TAPE WITH TRAILING RECORD
         257+13  290          + STORE A   WRCCEXIT     TO ALLOW READING BACKWARDS. IF SW6 ON PRINT LOG
         258+10 1374          + R ADD     CCLEN        SAVE MC INSTRUCTIONS GENERATED SO FAR
         259+ 9 1172          + ADD       NINST        ADD NINST TWICE AS EACH MC INSTR USES TWO HALF-WORDS
         260+ 9 1172          + ADD       NINST
         261+12 1375          + STORE     N
         262+10  262          + R ADD     *
         263+ 1   67          + TR        WRTAPE       WRITE MAGNETIC TAPE TAPEOUT (PACT COMPACT CODE)
         264+ 0  257          + STOP      TAPEOUT
         265+ 0 1130          + STOP      CCODE        BUF TO WRITE TO TAPE
         266+ 0 1375          + STOP      N            LEN
         267+10 1165          + R ADD     STEPN
         268+12 1378          + STORE     DATA
         269+10 1172          + R ADD     NINST
         270+12 1379          + STORE     DATA2
         271+10  271          + R ADD     *            WRITE TRAILING IDENTIFICATION RECORD
         272+ 1   67          + TR        WRTAPE       (MC CODE GENERATED STEPN + NINST)
         273+ 0  257          + STOP      TAPEOUT      SO TAPE CAN BE READ BACKWARDS ON NEXT COMPILATION STAGE
         274+ 0 1378          + STOP      DATA         BUF TO WRITE TO TAPE
         275+ 0 2359          + STOP      TWO          LEN
         276+30   74          + SENSE     0074         SENSE SWITCH 6
         277+ 1  289          + TR        ENDLOG1      TR IF NO LOG SELECTED
         278+10 1156          + R ADD     OP
         279+ 4  289          + TR 0      ENDLOG1      DO NOT PRINT EOR 
         280+ 5 2372          + SUB       D100
         281+ 4  289          + TR 0      ENDLOG1      Do NOT PRINT RECORD OP=100 
         282+10  282          + R ADD     *            PRINT STEP JUST PROCESSED
         283+ 1   57          + TR        PRINTCRD
         284+10 1172          + R ADD     NINST        IF NUMBER OF MC INSTR IN THE COMPACT CODE RECORD HAS CHANGED
         285+ 5 2407          + SUB       SVNINST      -> CC GOT GENERATED MC INSTR -> PRINT MC INSTR GENERATED
         286+ 4  289          + TR 0      ENDLOG1
         287+10  287          + R ADD     *
         288+ 1  986          + TR        PRTMC        PRINT TINST TABLE WITH MC INSTRUCTIONS GENERATED FOR THIS STEP
         289+ 8    0 ENDLOG1  + NOOP      0000 
         290+ 1    0 WRCCEXIT + TR        /   /         
         291+ 9 2359 RDPARCC  + ADD       TWO          READ TABLE TPAR (REGION PARAMETERS TABLE)
         292+13  312          + STORE A   RDPAREX
         293+10  293          + R ADD     *            READ PACT USER PROGRAM SOURCE CODE FROM TAPE IN
         294+ 1   65          + TR        RDTAPE
         295+ 0  258          + STOP      TAPEIN
         296+ 0 1130          + STOP      CCODE        BUF TO READ IN FROM TAPE
         297+ 2  226          + TR OV     BADOP        UNEXPECTED END OF FILE
         298+10 1156          + R ADD     OP
         299+ 5 2373          + SUB       D101         CHECK RECORD OP IDENTIFICATION
         300+ 4  302          + TR 0      SVPA1
         301+ 1  226          + TR        BADOP        EXPECTED OP=101 TO GET TPAR
         302+ 8 1382 SVPA1    + NOOP      MAXNPAR      FIRST VAR OF TABLES TO SAVE TO TAPE
         303+ 8 1554 SVPA2    + NOOP      MAXNREFS     VAR JUST AFTER TABLES, NOT TO SAVE 
         304+10  303          + R ADD     SVPA2
         305+ 5  302          + SUB       SVPA1        SAVE TPAR TABLE ( 2 + 5*34 HALF WORDS )
         306+12 2408          + STORE     LEN          = 172 HALF-WORDS = 86 FULLWORDS
         307+10  307          + R ADD     *            
         308+ 1   81          + TR        MEMCOPY
         309+ 0 1174          + STOP      TINST      
         310+ 0 1382          + STOP      MAXNPAR
         311+ 0 2408          + STOP      LEN
         312+ 1    0 RDPAREX  + TR        /   /
         313+ 8    0 WRNCONST + NOOP      0000         JUST READ A OP=100 COMPACT CODE RECORD. 
         314+10  314          + R ADD     *            NOW WRITE CC RECOD WITH OP=100
         315+ 1  256          + TR        WRCC         THIS RECODS HAS TLOCONST TABLE STORED IN TINST
         316+10 2356          + R ADD     ZERO         PREPARE DATA TO SAVE IN TREF TABLE
         317+12 1170          + STORE     D1N
         318+12 1157          + STORE     FACT
         319+10 2388          + R ADD     REGCSTEP
         320+12 1165          + STORE     STEPN
         321+10 2356          + R ADD     ZERO         
         322+12 1173          + STORE     NINCR
         323+12 2384          + STORE     MC.REG
         324+10  153          + R ADD     TINSTAD
         325+13  332          + STORE A   WRNCRD
         326+10 1173 WRNCLOOP + R ADD     NINCR
         327+ 5 1172          + SUB       NINST
         328+ 4  346          + TR 0      WRNCONEX     END OF CONSTS -> EXIT LOOP
         329+10 1173          + R ADD     NINCR
         330+ 9 2358          + ADD       ONE
         331+12 1173          + STORE     NINCR
         332-10    0 WRNCRD   - R ADD     /   /        READ ENTRY FROM LOOP CONSTANT POOL
         333-12 1378          - STORE     DATA
         334+13 2384          + STORE A   MC.REG
         335+10 2384          + R ADD     MC.REG       IS THIS CONSTANT A VARIABLE ADDRESS?
         336+ 5 2445          + SUB       REG.V
         337+ 4  342          + TR 0      WRNCVAR      YES! -> TR TO PROCESS
         338+10  332 WRNCNXT  + R ADD     WRNCRD       SELECT NEXT ENTRY
         339+ 5 2359          + SUB       TWO
         340+13  332          + STORE A   WRNCRD   
         341+ 1  326          + TR        WRNCLOOP 
         342+10  342 WRNCVAR  + R ADD     *            CHECK IF MUST ADD THE VAR TO REFERENCES 
         343+ 1  816          + TR        CHKREF       RETURN ACC=NREF CREATED, =0 IF NO REFERENCE ADDED
         344+ 0 1379          + STOP      DATA2        <- THE ADDRESS ON LOOP CONSTANT POOL ENTRY SELECTED
         345+ 1  338          + TR        WRNCNXT      PROCESS NEXT ENTRY
         346+ 1  163 WRNCONEX + TR        READSTEP
         347+ 8    0 LDNCONST + NOOP      0000         THIS COMPACT CODE RECORD HOLDS THE LOOP CONSTANTS POOL IN TINST 
         348+10 1165          + R ADD     STEPN        SET THE STEP FOR REG.C
         349+12 2388          + STORE     REGCSTEP
         350+ 1  227          + TR        NEXT
         351+ 9 2359 ERROR    + ADD       TWO
         352+13  353          + STORE A   ERRP1
         353+10    0 ERRP1    + R ADD     /   /
         354+13  360          + STORE A   ERRSTRZ      SAVE ADDR OF ERROR TXT MESSAGE
         355+10  355          + R ADD     *            PRINT USER PROGRAM SOURCE CODE CARD JUST PROCESSED
         356+ 1   57          + TR        PRINTCRD
         357+10  357          + R ADD     *
         358+ 1   55          + TR        PRTNLINE     
         359+ 0  101          + STOP      0101         STRINGZ AT COL 1
         360+ 0    0 ERRSTRZ  + STOP      /   /        ERROR MESSAGE
         361+ 0    0          + STOP      0000         END OF LINE
         362+ 0  163          + STOP      READSTEP     IF USER PRESS STARTS, PROGRAM RESUMES PROCESSING NEXT SOURCE CODE STEP 
         363+10 1167 IDDO     + R ADD     FACTREG                  ID with DO INSTR
         364+ 5 2369          + SUB       D34          'V'
         365+ 4  388          + TR 0      IDDOADDR
         366+10 1167          + R ADD     FACTREG 
         367+ 5 2368          + SUB       D32          'T'
         368+ 4  388          + TR 0      IDDOADDR
         369+10 1162          + R ADD     NUM
         370+ 4  379          + TR 0      IDDO1        IF BLANK FACTOR IN ID, ASSUME =0 WITH Q=17
         371+ 1  375          + TR        IDDONUM
         372+10  372 ERRPAR   + R ADD     *
         373+ 1  351          + TR        ERROR         
         374+ 0 2429          + STOP      ERRNOPAR     ERROR: ID/FOR PARAM MUST BE A VAR/TEMP/INTEGER NUMBER
         375+10 1161 IDDONUM  + R ADD     QF
         376+ 5 2366          + SUB       D17
         377+ 4  379          + TR 0      IDDO1
         378+ 1  372          + TR        ERRPAR
         379+10  379 IDDO1    + R ADD     *            GENERATE THE INSTRUCTIONS FOR CALLER'S PARAMETERS
         380+ 1  431          + TR        GENNUM       ID num   
         381+ 0 1162          + STOP      NUM          '+H  A nnnn'  (OR '-H  A nnnn' IF NUM IS NEGATIVE)
         382+10 1160 IDQ      + R ADD     QR           IS THERE ANY QR VALUE IN THE INSTR?
         383+ 4  387          + TR 0      IDQ1         TR IF NOT
         384+10  384          + R ADD     *            GENERATE THE INSTRUCTIONS FOR CALLER'S Q PARAMETER
         385+ 1  431          + TR        GENNUM       ID Q
         386+ 0 1160          + STOP      QR           '+H  A nnnn'  (OR '-H  A nnnn' IF Q IS NEGATIVE)
         387+ 1  227 IDQ1     + TR        NEXT
         388+10 1173 IDDOADDR + R ADD     NINCR        IF NINCT=0 -> NO INSTR GENERATED IN OPERATION EXPANSION 
         389+ 4  391          + TR 0      IDDOINS1     STAGE -> GENERATE IT NOW
         390+ 1  397          + TR        IDDOINS2     IF NINST>0 -> SKIP INST GENERATION
         391+10  391 IDDOINS1 + R ADD     *            GENERATE THE INSTRUCTIONS FOR CALLER'S PARAMETERS
         392+ 1  868          + TR        GENINST     
         393- 0 1003          - STOP      CC.FACT      '-H  V nnnn'  OR '-H  T nnnn'
         394+ 0    0          + STOP      0000         END OF INSTR TABLE
         395+10 1172          + R ADD     NINST        SAVE IN NINCR THE LOCATION INTO STEPN OF MC INSTR WITH VAR ADDR 
         396+12 1173          + STORE     NINCR        SO IT CAN BE REPLACED LATER IF THIS VARIABLE IS A PARAM BY REFERENCE
         397+10  397 IDDOINS2 + R ADD     *            CHECK IF MUST ADD THE VAR TO REFERENCES 
         398+ 1  816          + TR        CHKREF       RETURN ACC=NREF CREATED, =0 IF NO REFERENCE ADDED
         399+ 0 1166          + STOP      FACTN
         400+12 2392          + STORE     NREF
         401+10 1168          + R ADD     S1N          IF S1N IS A NON ACTIVE INDEX, THEN ADD THE DIMENSION AS PARAM
         402+ 5 2377          + SUB       O777K
         403+ 4  408          + TR 0      IDDO1A
         404+10 1168          + R ADD     S1N          IF S1N IS A FOR-DEFINED INDEX, THEN ADD THE DIMENSION AS PARAM
         405+ 5 2376          + SUB       O776K
         406+ 4  408          + TR 0      IDDO1A
         407+ 1  420          + TR        IDDO2
         408+10  408 IDDO1A   + R ADD     *            GENERATE THE INSTRUCTIONS FOR CALLER'S DIMENSION D1
         409+ 1  431          + TR        GENNUM       
         410+ 0 1170          + STOP      D1N          '+H  A nnnn'  
         411+10 2392          + R ADD     NREF         CHECK IF THE VECTOR/MATRIX PASSED AS PARAM IS ALSO A PARAM IN THIS REGION
         412+ 4  420          + TR 0      IDDO2        IN THIS CASE (NREF>0), SIGNAL THAT D1 VALUE MUST BE ALSO REPLACED WITH 
         413+ 6 1173          + R SUB     NINCR
         414+12 1173          + STORE     NINCR        
         415+10  415          + R ADD     *            
         416+ 1   69          + TR        EQTBL
         417+ 0 2156          + STOP      TREFINCR     
         418+ 0 2392          + STOP      NREF
         419+ 0 1173          + STOP      NINCR        TREFINCR[NREF] = -NINCR
         420+10 1169 IDDO2    + R ADD     S2N          IF S1N IS A NON ACTIVE INDEX, THEN ADD THE DIMENSION AS PARAM
         421+ 5 2377          + SUB       O777K
         422+ 4  427          + TR 0      IDDO2A
         423+10 1169          + R ADD     S2N          IF S2N IS A FOR-DEFINED INDEX, THEN ADD THE DIMENSION AS PARAM
         424+ 5 2376          + SUB       O776K
         425+ 4  427          + TR 0      IDDO2A
         426+ 1  430          + TR        IDDO3
         427+10  427 IDDO2A   + R ADD     *            GENERATE THE INSTRUCTIONS FOR CALLER'S DIMENSION D2
         428+ 1  431          + TR        GENNUM       (IS ALLWAYS 2) 
         429+ 0 2359          + STOP      TWO          '+H  A 0002'  
         430+ 1  382 IDDO3    + TR        IDQ          TR TO ADD PARAM FOR Q IF Q IS NOT ZERO
         431+ 9 2359 GENNUM   + ADD       TWO          GENERATES MC INSTR '+H A nnnn' 
         432+13  435          + STORE A   GNP1         PARAM: THE VAR THAT CONTAINS nnnn
         433+ 9 2358          + ADD       ONE
         434+13  451          + STORE A   GENNUMEX
         435+10    0 GNP1     + R ADD     /   /
         436+13  437          + STORE A   GNP1A
         437+10    0 GNP1A    + R ADD     /   /
         438+12 2386          + STORE     SHIFT1
         439+ 3  447          + TR +      GNP2         IF NUM >= 0 -> PROCEED
         440+ 6 2386          + R SUB     SHIFT1       IF NUM <0 -> CHANGE SIGN OF NUMBER (SO IT BE >0) AND MAKES INSTR NEGATIVE
         441+12 2386          + STORE     SHIFT1
         442+10  442          + R ADD     *            GENERATE THE INSTRUCTIONS FOR CALLER'S PARAMETERS - DIMENSION D2 (ALLWAYS=2)
         443+ 1  868          + TR        GENINST     
         444- 0 1001          - STOP      ANN          '-H  A nnnn'  
         445+ 0    0          + STOP      0000         END OF INSTR TABLE
         446+ 1  451          + TR        GENNUMEX
         447+10  447 GNP2     + R ADD     *            GENERATE THE INSTRUCTIONS FOR CALLER'S PARAMETERS - DIMENSION D2 (ALLWAYS=2)
         448+ 1  868          + TR        GENINST     
         449+ 0 1001          + STOP      ANN          '+H  A nnnn'  
         450+ 0    0          + STOP      0000         END OF INSTR TABLE
         451+ 1    0 GENNUMEX + TR        /   /
         452+10 1167 FORDO    + R ADD     FACTREG     
         453+ 5 2369          + SUB       D34          'V'
         454+ 4  472          + TR 0      FORDOADD
         455+10 1167          + R ADD     FACTREG 
         456+ 5 2368          + SUB       D32          'T'
         457+ 4  472          + TR 0      FORDOADD
         458+10 1162          + R ADD     NUM
         459+ 4  461          + TR 0      FORDO0
         460+ 1  464          + TR        FORDONUM
         461+10 1157 FORDO0   + R ADD     FACT
         462+ 4  468          + TR 0      FORDO1       FACTOR IS BLANK -> GENERATE A ZERO
         463+ 1  481          + TR        FORDO2       HERE, INSTR IS "FOR I 3 4" -> TR TO PROCESS NUMBERS ON S1 S2
         464+10 1161 FORDONUM + R ADD     QF
         465+ 5 2366          + SUB       D17
         466+ 4  468          + TR 0      FORDO1
         467+ 1  372          + TR        ERRPAR
         468+10  468 FORDO1   + R ADD     *            GENERATE THE INSTRUCTIONS FOR CALLER'S PARAMETERS
         469+ 1  431          + TR        GENNUM       FOR num   
         470+ 0 1162          + STOP      NUM          '+H  A nnnn'  (OR '-H  A nnnn' IF NUM IS NEGATIVE)
         471+ 1  481          + TR        FORDO2
         472+10  472 FORDOADD + R ADD     *            GENERATE THE INSTRUCTIONS FOR CALLER'S PARAMETERS
         473+ 1  868          + TR        GENINST     
         474- 0 1003          - STOP      CC.FACT      '-H  V nnnn'  OR '-H  T nnnn'
         475+ 0    0          + STOP      0000         END OF INSTR TABLE
         476+10 1172          + R ADD     NINST        SAVE IN NINCR THE LOCATION INTO STEPN OF MC INSTR WITH VAR ADDR 
         477+12 1173          + STORE     NINCR        SO IT CAN BE REPLACED LATER IF THIS VARIABLE IS A PARAM BY REFERENCE
         478+10  478          + R ADD     *            CHECK IF MUST ADD THE VAR TO REFERENCES 
         479+ 1  816          + TR        CHKREF       RETURN ACC=NREF CREATED, =0 IF NO REFERENCE ADDED
         480+ 0 1166          + STOP      FACTN
         481+10 1158 FORDO2   + R ADD     S1           PREPARE S1N AND S2N 
         482+ 3  484          + TR +      FORDOS1
         483+ 6 1168          + R SUB     S1N          MAKES VAR ADDR NEGATIVE
         484+12 1380 FORDOS1  + STORE     S1S2         HERE: >0 -> IS A NUMBER, <0 -> IS A VAR ADDR, =0 -> BLANK
         485+10 1159          + R ADD     S2
         486+ 3  488          + TR +      FORDOS2
         487+ 6 1169          + R SUB     S2N          MAKES VAR ADDR NEGATIVE
         488+12 1381 FORDOS2  + STORE     S1S2B
         489+10 1380          + R ADD     S1S2         GET S1N
         490+ 4  227          + TR 0      NEXT         EMPTY S1/S2 FIELD -> PROCEED TO NEXT INSTR
         491+ 3  504          + TR +      FORDO3       >0 -> IS A NUMBER
         492+ 6 1380          + R SUB     S1S2         MAKE VAR ADDR POSITIVE
         493+12 2389          + STORE     ECONST
         494+10  494          + R ADD     *            GENERATE THE INSTRUCTIONS FOR CALLER'S PARAMETERS - DIMENSION D2 (ALLWAYS=2)
         495+ 1  868          + TR        GENINST      FOR ... var ...
         496- 0 1006          - STOP      VNN          '-H  V nnnn'  
         497+ 0    0          + STOP      0000         END OF INSTR TABLE
         498+10 1172          + R ADD     NINST        SAVE IN NINCR THE LOCATION INTO STEPN OF MC INSTR WITH VAR ADDR 
         499+12 1173          + STORE     NINCR        SO IT CAN BE REPLACED LATER IF THIS VARIABLE IS A PARAM BY REFERENCE
         500+10  500          + R ADD     *            CHECK IF MUST ADD THE VAR TO REFERENCES 
         501+ 1  816          + TR        CHKREF       RETURN ACC=NREF CREATED, =0 IF NO REFERENCE ADDED
         502+ 0 2389          + STOP      ECONST
         503+ 1  507          + TR        FORDO4
         504+10  504 FORDO3   + R ADD     *            GENERATE THE INSTRUCTIONS FOR CALLER'S PARAMETERS
         505+ 1  431          + TR        GENNUM       FOR ... num ...
         506+ 0 1380          + STOP      S1S2         '+H  A nnnn'
         507+10 1381 FORDO4   + R ADD     S1S2B        SHIFT S1 <- S2 <- 0
         508+12 1380          + STORE     S1S2
         509+10 2356          + R ADD     ZERO
         510+ 1  488          + TR        FORDOS2
         511+ 8    0 CALLPARM + NOOP      0000         PROCESS CALL PARAMETERS: GENERATE MC INSTR TO READ THE PARAMETERS
         512+10  512          + R ADD     *            SELECT PARAM FOR THIS STEP
         513+ 1   77          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         514+ 0 1418          + STOP      TPARSTEP     ... INDEX NAME TABLE
         515+ 0 1383          + STOP      NPARAMS      ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
         516+ 0 1165          + STOP      STEPN        ... THE VALUE TO FIND 
         517+ 4  227          + TR 0      NEXT         NO MORE PARAMS IN THIS STEPN -> TR TO PROCESS NEXT INSTR
         518+12 2391          + STORE     NPAR
         519+ 6 1165          + R SUB     STEPN
         520+12 1375          + STORE     N
         521+10  521          + R ADD     *            MAKES STEPN AS NEGATIVE TO SIGNAL  
         522+ 1   69          + TR        EQTBL        THE PARAM HAS BEEN PROCESSED
         523+ 0 1418          + STOP      TPARSTEP
         524+ 0 2391          + STOP      NPAR
         525+ 0 1375          + STOP      N            TPARSTEP[NPAR] = -STEPN
         526+10  526          + R ADD     *            READ THE PARAM
         527+ 1   75          + TR        READTBL2
         528+ 0 1452          + STOP      TPARTYPE
         529+ 0 1382          + STOP      MAXNPAR
         530+ 0 2391          + STOP      NPAR
         531+ 0 2397          + STOP      PTYPE        = TPARTYPE[NPAR]  
         532+ 0 2394          + STOP      PFACTN       = TPARFACT[NPAR]  
         533+ 0 2398          + STOP      PLOC1        = TPARLOC1[NPAR] 
         534+ 0    0          + STOP      0000
         535+10 2356          + R ADD     ZERO         INIT MC INST IN THE STEP WHERE THE ARGUENT IS RETRIEVED
         536+12 2399          + STORE     P1P2         (=NINST INTO STEP OF '+RA /  /' INSTR)
         537+10 2358          + R ADD     ONE
         538+12 2390          + STORE     NARGS        NUMP=NUMBER OF ARGUMENT TO RECEIVE FROM CALLER FOR THIS PACT PARAM
         539+10  539          + R ADD     *
         540+ 1  632          + TR        GENRA        GENERATE '+RA /  /' INSTR TO RETRIEVE ARGUMENT OF PARAM
         541+10 2397          + R ADD     PTYPE
         542+ 9 2361          + ADD       D4
         543+ 9  546          + ADD       TRPTYPET
         544+13  545          + STORE A   TRPTYPE
         545+ 1    0 TRPTYPE  + TR        /   /
         546+ 1  546 TRPTYPET + TR        *
         547+ 1  553          + TR        PTYPESV      TR TO PROCESS PARAM TYPE -3 (1 ARGUMENT)  SCALAR VAR ADDR (VAR PASSED BY VALUE)
         548+ 1  563          + TR        PTYPEAB      TR TO PROCESS PARAM TYPE -2 (2 ARGUMENTS) INDEX LOOP START AND END VALUES (PARAM BY VALUE)
         549+ 1  585          + TR        PTYPEC       TR TO PROCESS PARAM TYPE -1 (1 ARGUMENT)  CONSTANT VALUE PASED AS PARAM STORED IN TEMP VAR (PARAM BY VALUE)
         550+ 1  594          + TR        PTYPEVAR     TR TO PROCESS PARAM TYPE  0 (1 ARGUMENT)  SCALAR VAR ADDRESS (VAR PASSED BY REFERENCE)
         551+ 1  602          + TR        PTYPEVEC     TR TO PROCESS PARAM TYPE  1 (2 ARGUMENTS) VECTOR ADDRESS AND D1 DIMENSION (VECTOR PASSED BY REFERENCE)
         552+ 1  599          + TR        PTYPEMAT     TR TO PROCESS PARAM TYPE  2 (3 ARGUMENTS) MATRIX ADDRESS, D1 AND D2 DIMENSIONS (MATRIX PASSED BY REFERENCE)
         553+ 8    0 PTYPESV  + NOOP      0000         PROCESS PARAM TYPE -3 = SCALAR VAR ADDR (VAR PASSED BY VALUE)
         554+10 2394          + R ADD     PFACTN
         555+12 2389          + STORE     ECONST
         556+10  556          + R ADD     *            GENERATE THE INSTRUCTIONS TO STORE ARGUMENT IN DESTINATION VAR
         557+ 1  868          + TR        GENINST   
         558+13 1004          + STORE A   STAR+1       '+SA *+1   ' store the param addr passed from caller
         559+10 1002          + R ADD     A00          '+RA /   / ' derreference param var to get its value
         560-12 1006          - STORE     VNN          '-ST V nnnn' store param value (nnnn=econst)
         561+ 0    0          + STOP      0000         END OF INSTR TABLE
         562+ 1  622          + TR        NXTPARAM 
         563+ 8    0 PTYPEAB  + NOOP      0000         PROCESS PARAM TYPE -2 = INDEX LOOP START AND END VALUES (PARAM BY VALUE)
         564+10 2388          + R ADD     REGCSTEP     WILL SAVE THE ARGUMENT IN LOOP CONTANT POOL (AT REGCSTEP STEPN)
         565+12 2380          + STORE     TRANSFER     WILL SAVE IN LOOP CONTANT POOL ENTRY PFACTN (1ST ENTRY=0000, BUT 1ST LOC IN STEP=1 -> LOC=ENTRY+1)
         566+10 2394          + R ADD     PFACTN       INN = addr of stepN given in var TRANSFER = stepN of reference, TRSTLOC = location in reference stepn machine code
         567+ 9 2358          + ADD       ONE
         568+12 2381          + STORE     TRSTLOC
         569+10  569          + R ADD     *            GENERATE THE INSTRUCTIONS TO STORE ARGUMENT AS LOOP START VALUE
         570+ 1  868          + TR        GENINST     7
         571+12 1005          + STORE     INN          '+S  C econst'   save loop start value
         572+ 0    0          + STOP      0000         END OF INSTR TABLE
         573+10  573          + R ADD     *
         574+ 1  632          + TR        GENRA        GENERATE '+RA /  /' INSTR TO RECEIVE SECOND ARGUMENT 
         575+10 2398          + R ADD     PLOC1
         576+ 9 2358          + ADD       ONE
         577+12 2381          + STORE     TRSTLOC
         578+10  578          + R ADD     *            GENERATE THE INSTRUCTIONS TO STORE ARGUMENT AS LOOP END VALUE
         579+ 1  868          + TR        GENINST     
         580+12 1005          + STORE     INN          '+S  C econst'   save loop end value
         581+ 0    0          + STOP      0000         END OF INSTR TABLE
         582+10 2359          + R ADD     TWO          PARAM "FOR I A B" HAS TWO ARGUMENTS (A AND B VALUES)
         583+12 2390          + STORE     NARGS        NUMP=NUMBER OF ARGUMENT TO RECEIVE FROM CALLER FOR THIS PACT PARAM
         584+ 1  622          + TR        NXTPARAM 
         585+ 8    0 PTYPEC   + NOOP      0000         PROCESS PARAM TYPE -1 = CONSTANT VALUE PASED AS PARAM STORED IN TEMP VAR (PARAM BY VALUE)
         586+10 2394          + R ADD     PFACTN       THE TEMP VAR NUMBER TO STORE TO
         587+22    1          + A LEFT    0001
         588+12 2389          + STORE     ECONST
         589+10  589          + R ADD     *            GENERATE THE INSTRUCTIONS TO STORE ARGUMENT VALUE AS TEMP VAR
         590+ 1  868          + TR        GENINST      
         591-12 1007          - STORE     TNN          '-ST T nnnn' where nnnn=econst
         592+ 0    0          + STOP      0000         END OF INSTR TABLE
         593+ 1  622          + TR        NXTPARAM 
         594+ 8    0 PTYPEVAR + NOOP      0000         PROCESS PARAM TYPE  0 = SCALAR VAR ADDRESS (VAR PASSED BY REFERENCE)
         595+10  595          + R ADD     *            GENERATE '+SA I  TREFSTEP.ABS(TREFINCR)' FOR ALL REFERENCES WHERE 
         596+ 1  643          + TR        SASAME       TREFADDR=PFACTN 
         597+ 0    0          + STOP      0000
         598+ 1  622          + TR        NXTPARAM 
         599+ 8    0 PTYPEMAT + NOOP      0000         PROCESS PARAM TYPE  2 = MATRIX ADDRESS, D1 AND D2 DIMENSIONS (MATRIX PASSED BY REFERENCE)
         600+10 2360          + R ADD     D3           PARAM "ID MAT  I J" HAS 3 ARGUMENTS (MAT ADDR AND D1, D2 DIMENSION VALUES)
         601+ 1  604          + TR        PTYPEMV
         602+ 8    0 PTYPEVEC + NOOP      0000         PROCESS PARAM TYPE  1 = VECTOR ADDRESS AND D1 DIMENSION (VECTOR PASSED BY REFERENCE)
         603+10 2359          + R ADD     TWO          PARAM "ID VECT I" HAS TWO ARGUMENTS (VECT ADDR AND D1 DIMENSION VALUE)
         604+12 2390 PTYPEMV  + STORE     NARGS        =NUMBER OF ARGUMENT TO RECEIVE FROM CALLER FOR THIS PACT PARAM
         605+10  605          + R ADD     *            GENERATE '+SA I  TREFSTEP.ABS(TREFINCR)' FOR ALL REFERENCES WHERE 
         606+ 1  643          + TR        SASAME       TREFADDR=PFACTN  
         607+ 0    0          + STOP      0000
         608+10  608          + R ADD     *
         609+ 1  632          + TR        GENRA        GENERATE '+RA /  /' INSTR TO RECEIVE SECOND ARGUMENT 
         610+10 2388          + R ADD     REGCSTEP     WILL SAVE THE ARGUMENT IN LOOP CONTANT POOL (AT REGCSTEP STEPN)
         611+12 2380          + STORE     TRANSFER     WILL SAVE IN LOOP CONTANT POOL ENTRY PLOC1 
         612+10 2398          + R ADD     PLOC1
         613+ 9 2358          + ADD       ONE
         614+12 2381          + STORE     TRSTLOC
         615+10  615          + R ADD     *            GENERATE THE INSTRUCTIONS TO STORE ARGUMENT AS D1 DIMENSION VALUE
         616+ 1  868          + TR        GENINST     
         617+12 1005          + STORE     INN          '+S  C econst'   save loop end value
         618+ 0    0          + STOP      0000         END OF INSTR TABLE
         619+10  619          + R ADD     *            GENERATE '+SA I  TREFSTEP.ABS(TREFINCR)+1' FOR ALL REFERENCES WHERE 
         620+ 1  643          + TR        SASAME       TREFADDR=PFACTN AND TREFINCR<0
         621+ 0    1          + STOP      0001
         622+ 8    0 NXTPARAM + NOOP      0000         SAVE IN TPAR THE VARS P1P2 WITH NINST '+RA /  /' THAT RETRIEVES THE ARGUMENT
         623+10  623          + R ADD     *            SAVE THE PARAM
         624+ 1   71          + TR        EQTBL2
         625+ 0 1486          + STOP      TPARFACT
         626+ 0 1382          + STOP      MAXNPAR
         627+ 0 2391          + STOP      NPAR
         628+ 0 2399          + STOP      P1P2         TPARFACT[NPAR] = P1P2
         629+ 0 2390          + STOP      NARGS        TPARLOC1[NPAR] = NARGS
         630+ 0    0          + STOP      0000
         631+ 1  511          + TR        CALLPARM     TR TO PROCESS NEXT PARAM IN THIS STEP
         632+ 9 2359 GENRA    + ADD       TWO
         633+13  642          + STORE A   GENRAEX
         634+10  634          + R ADD     *            GENERATE THE INSTRUCTIONS TO GET ARGUMENT 
         635+ 1  868          + TR        GENINST      
         636+10 1002          + R ADD     A00          '+RA  /   /'
         637+ 0    0          + STOP      0000         END OF INSTR TABLE
         638+10 2399          + R ADD     P1P2
         639+22    8          + A LEFT    0008
         640+ 9 1172          + ADD       NINST        SAVE THE MC INSTRUCTION NUMBER WHERE THE ARGUMENT IS RETRIEVED
         641+12 2399          + STORE     P1P2         TO GENERATE '+STORE A  P1P2' IN CALL INSTR
         642+ 1    0 GENRAEX  + TR        /   /
         643+ 9 2359 SASAME   + ADD       TWO          EXAMINE REFERENCES. GENERATE '+SA ' INSTR TO SAVE THE ADDR PASSED AS PARAMETER 
         644+13  647          + STORE A   SASAMEP1     ON ACC ON REFERENCES TO SAME VECTOR/MATRIX
         645+ 9 2358          + ADD       ONE          PARAM: =0 -> GENERATE '+SA I  TREFSTEP.ABS(TREFINCR)' FOR ALL REFERENCES 
         646+13  686          + STORE A   SASAMEEX                  WHERE TREFADDR=PFACTN  
         647+10    0 SASAMEP1 + R ADD     /   /
         648+12 2400          + STORE     NGEN
         649+10 2356          + R ADD     ZERO         EXAMINE REFERENCES. 
         650+12 2392          + STORE     NREF        
         651+10 2392 SALOOP   + R ADD     NREF
         652+ 5 1555          + SUB       NREFS        GENERATE '+SA I /  /' MC INST FOR
         653+ 4  686          + TR 0      SASAMEEX     ALL REFERENCES OF SAME VARIABLE PROCESSED
         654+10 2392          + R ADD     NREF
         655+ 9 2358          + ADD       ONE
         656+12 2392          + STORE     NREF
         657+10  657          + R ADD     *            READ SEVERAL VALUES FROM TREF TABLES
         658+ 1   75          + TR        READTBL2
         659+ 0 1756          + STOP      TREFADDR     READ THE FIRST VARIABLE REFERENCE
         660+ 0 1554          + STOP      MAXNREFS
         661+ 0 2392          + STOP      NREF
         662+ 0 2404          + STOP      RADDR        = TREFADDR[NREF]   ADDR OF VARIABLE TO BE REPLACED 
         663+ 0 2405          + STOP      RSTEPN       = TREFSTEP[NREF]   STEPN WHERE THE VARIABLE IS REFERENCED
         664+ 0 2406          + STOP      RINCR        = TREFINCR[NREF]   INCR IN STEPN
         665+ 0    0          + STOP      0000
         666+10 2404          + R ADD     RADDR        CHECK IF REFERENCE TO THE PARAMETER VARIABLE (=VAR TO REPLACE BY ADDR SENT FROM CALLER)
         667+ 5 2394          + SUB       PFACTN      
         668+ 4  670          + TR 0      SA6A
         669+ 1  651          + TR        SALOOP
         670+10 2400 SA6A     + R ADD     NGEN         IF NGEN=0 -> NO MORE CONDITIONS TO CHECK
         671+ 4  674          + TR 0      SA6C
         672+10 2406          + R ADD     RINCR
         673+ 3  651          + TR +      SALOOP       IF RINCR >= 0 TRY NEXT REFEENCE
         674+ 8    0 SA6C     + NOOP      0000         HERE WE HAVE A REFERENCE TO PROCESS
         675+10 2405          + R ADD     RSTEPN       
         676+12 2380          + STORE     TRANSFER     INN = addr of stepN given in var TRANSFER = stepN of reference, TRSTLOC = location in reference stepn machine code
         677+10 2356          + R ADD     ZERO         
         678+11 2406          + ADD AB    RINCR
         679+ 9 2400          + ADD       NGEN         IF NGEN=1 -> ADD ONE
         680+12 2381          + STORE     TRSTLOC
         681+10  681          + R ADD     *            GENERATE THE INSTRUCTIONS TO INCREMENT THE SAME REFERENCED VECTOR ADDRESS 
         682+ 1  868          + TR        GENINST     
         683+13 1005          + STORE A   INN          '+SA I /  /'     store back the address of reference var incremented by D1
         684+ 0    0          + STOP      0000         END OF INSTR TABLE
         685+ 1  651          + TR        SALOOP
         686+ 1    0 SASAMEEX + TR        /   /
         687+ 8    0 CALL     + NOOP      0000         GENERATE THE REGION PROLOGUE. GET PARAMS SENT BY CALLER, STORE THEM, 
         688+10 2358          + R ADD     ONE 
         689+12 2380          + STORE     TRANSFER     REGION PRLOGUE GENERATED IN STEP ONE
         690+10 2360          + R ADD     D3
         691+12 2381          + STORE     TRSTLOC
         692+10  692          + R ADD     *            
         693+ 1  868          + TR        GENINST      GENERATE TR TO SKIP THE EXIT TRANSFER
         694+ 1 1005          + TR        INN          '+T  I 1.3'   
         695+ 0    0          + STOP      0000         END OF INSTR TABLE
         696+10  696          + R ADD     *            GENERATE THE EXIT TRANSFER
         697+ 1  868          + TR        GENINST      
         698+ 1 1002          + TR        A00          '+T  /   /' 
         699+ 0    0          + STOP      0000         END OF INSTR TABLE
         700+10 2358          + R ADD     ONE
         701+12 2401          + STORE     USETWO       FLAG TO INDICATE CONSTANT 2 HAS TO BE USED (TO SKIP CALLER'S TRANSFER AND SELECT FIRST CALLER ARG)
         702+ 6 2358          + R SUB     ONE
         703+12 2402          + STORE     N1GEN        MC INSTR NUMBER WHERE CONSTANT ONE AND TWO ARE STORED
         704+12 2403          + STORE     N2GEN        -1 -> NOT GENERATED YET
         705+10 2356          + R ADD     ZERO         ITERATE ON TPAR TABLE
         706+12 2391          + STORE     NPAR
         707+10 2391 CALOOP   + R ADD     NPAR
         708+ 5 1383          + SUB       NPARAMS
         709+ 4  728          + TR 0      CALOEND      NO MORE PARAMS, TR TO STORE THE RETURN TO CALLER ADDRESS
         710+10 2391          + R ADD     NPAR
         711+ 9 2358          + ADD       ONE 
         712+12 2391          + STORE     NPAR
         713+10  713          + R ADD     *            READ THE PARAM
         714+ 1   75          + TR        READTBL2
         715+ 0 1418          + STOP      TPARSTEP
         716+ 0 1382          + STOP      MAXNPAR
         717+ 0 2391          + STOP      NPAR
         718+ 0 2395          + STOP      PSTEPN       = TPARSTEP[NPAR]    STEPN OF THIS PARAMETER
         719+ 0 1375          + STOP      N            = TPARTYPE[NPAR]    TYPE THIS PARAMETER (TO TEMP VAR AS NOT NEEDED NOW)
         720+ 0 1380          + STOP      S1S2         = TPARFACT[NPAR]    MC INSTR NUMBER INTO THIS STEP WHERE THE ARGUMENT IS RETRIEVED WITH '+RA /  /'
         721+ 0 2390          + STOP      NARGS        = TPARLOC1[NPAR]    NUMBER OR ARGUMENTS NEEDED BY THIS PARAM
         722+ 0    0          + STOP      0000
         723+ 6 2395          + R SUB     PSTEPN       MAKE PSTEPN POSITIVE AGAIN (WAS SET TO NEGATIVE WHEN 
         724+12 2395          + STORE     PSTEPN       PARAM WAS PROCESSED IN CALLPARM ROUTINE)
         725+10  725          + R ADD     *
         726+ 1  736          + TR        GENSA2       GENERATE '+SA /  /' INSTR TO SELECT ARGUMENT(s) FROM CALLER
         727+ 1  707          + TR        CALOOP
         728+10 2358 CALOEND  + R ADD     ONE          THE RETURN ADDRESS IS LAST ARGUMENT 
         729+12 2390          + STORE     NARGS
         730+12 2395          + STORE     PSTEPN       STORE IN EXIT TRANSFER
         731+10 2359          + R ADD     TWO
         732+12 2396          + STORE     PINCR
         733+10  733          + R ADD     *            GENERATE '+SA /  /' INSTR TO STORE RETURN ADDRESS IN EXIT TRANSFER
         734+ 1  760          + TR        GENSA        
         735+ 1  227          + TR        NEXT
         736+ 9 2359 GENSA2   + ADD       TWO          GENERATE '+A two/one'      IF S1>0  
         737+13  759          + STORE A   GENSA2EX              '+SA PSTEPN.S1'   IF S1>0
         738+10 1380          + R ADD     S1S2         EXTRACT S1 FROM S1S2 -> STORE IT IN PINCR
         739+23    8          + A RIGHT   0008         
         740+23   18          + A RIGHT   0018         
         741+ 4  746          + TR 0      GSB1         S1=0 -> ONLY ONE CALLER ARG IN S2
         742+22   18          + A LEFT    0018
         743+12 2396          + STORE     PINCR
         744+10  744          + R ADD     *
         745+ 1  760          + TR        GENSA        GENERATE '+SA PSTEPN.S1' 
         746+10 1380 GSB1     + R ADD     S1S2         EXTRACT S2 FROM S1S2 -> STORE IT IN PINCR
         747+23    8          + A RIGHT   0008         
         748+12 1377          + STORE     VAL
         749+ 5 1377          + SUB       VAL
         750+22    8          + A LEFT    0008
         751+12 2396          + STORE     PINCR
         752+10  752          + R ADD     *
         753+ 1  760          + TR        GENSA        GENERATE '+SA PSTEPN.S2' 
         754+10 2359          + R ADD     TWO          IF NARGS > 2 THEN USETWO=1 TO SKIP 3RD ARG FROM CALLER
         755+ 5 2390          + SUB       NARGS
         756+ 3  759          + TR +      GENSA2EX    
         757+10 2358          + R ADD     ONE
         758+12 2401          + STORE     USETWO       SET USETWO=1
         759+ 1    0 GENSA2EX + TR        /   /
         760+ 9 2359 GENSA    + ADD       TWO          GENERATE '+SA /  /' INSTR TO SELECT ARGUMENT FROM CALLER
         761+13  807          + STORE A   GENSAEX                                       
         762+15 2402          + LOAD MQ   N1GEN
         763+10 2401          + R ADD     USETWO      USE CONSTANT 2? 
         764+ 4  766          + TR 0      GSA1
         765+15 2403          + LOAD MQ   N2GEN
         766+14 2400 GSA1     + STORE MQ  NGEN        -1 -> SHOULD CREATE NOW
         767+14 2381          + STORE MQ  TRSTLOC     = NINST WHERE THE CONSTANT TO USE IS GENERATED 
         768+10 2381          + R ADD     TRSTLOC     
         769+ 3  773          + TR +      GSA2
         770+10 1172          + R ADD     NINST       WILL CREATE IT TWO INSTR BELOW CURRENT ONE
         771+ 9 2360          + ADD       D3
         772+12 2381          + STORE     TRSTLOC     
         773+ 8    0 GSA2     + NOOP      0000        HERE: TRSTLOC=MC INSTR WITH CONSTANT (ALLWAYS >0), IF NGEN<0 -> SHOULD CREATE THE CONST
         774+10 2358          + R ADD     ONE          CONSTANT TWO IS SETTLED IN CALL STEPN
         775+12 2380          + STORE     TRANSFER     INSTR GENERATED IN STEP ONE
         776+10  776          + R ADD     *            GENERATE THE INSTRUCTION 'ADD ONE/TWO'
         777+ 1  868          + TR        GENINST     
         778+ 9 1005          + ADD       INN          '+A  I 1.NGEN'   
         779+ 0    0          + STOP      0000         END OF INSTR TABLE
         780+10 2395          + R ADD     PSTEPN       CONSTANT TWO IS SETTLED IN CALL STEPN
         781+12 2380          + STORE     TRANSFER     INSTR GENERATED IN STEP ONE
         782+10 2396          + R ADD     PINCR
         783+12 2381          + STORE     TRSTLOC
         784+10  784          + R ADD     *            GENERATE THE INSTRUCTION 'ADD ONE/TWO'
         785+ 1  868          + TR        GENINST     
         786+13 1005          + STORE A   INN          '+SA I PSTEPN.PINCR'   
         787+ 0    0          + STOP      0000         END OF INSTR TABLE
         788+10 2400          + R ADD     NGEN         IF -1 -> SHOULD CREATE NOW
         789+ 3  805          + TR +      GSA4         TR IF CONST ONE/TWO ALREADY CREATED
         790+10 1172          + R ADD     NINST        COMPUTE MC INSTR WHERE CONST IS TO BE CREATED
         791+ 9 2358          + ADD       ONE          AND SAVE IT IN MQ
         792+21   35          + L RIGHT   0035         MQ=MC INSTR WHERE CONST IS TO BE CREATED
         793+10 2401          + R ADD     USETWO       USE CONSTANT 2? 
         794+ 4  798          + TR 0      GSA3A        TR IF NOT (IE USING CONST 1)
         795+14 2403          + STORE MQ  N2GEN
         796+10 2359          + R ADD     TWO
         797+ 1  800          + TR        GSA3B
         798+14 2402 GSA3A    + STORE MQ  N1GEN
         799+10 2358          + R ADD     ONE
         800+12 2386 GSA3B    + STORE     SHIFT1       THE VALUE OF CONST TO BE CREATED
         801+10  801          + R ADD     *            GENERATE THE INSTRUCTION FOR CONSTANT ONE
         802+ 1  868          + TR        GENINST      
         803+ 8 1001          + NOOP      ANN          '-N  A nnnn' where nnnn=1 or 2
         804+ 0    0          + STOP      0000         END OF INSTR TABLE
         805+10 2356 GSA4     + R ADD     ZERO         FROM NOW USE CONSTANT 1
         806+12 2401          + STORE     USETWO
         807+ 1    0 GENSAEX  + TR        /   /
         808+10 1167 CHECKREF + R ADD     FACTREG
         809+ 5 2369          + SUB       D34          'V'
         810+ 4  812          + TR 0      CK1
         811+ 1  227          + TR        NEXT         STEP NOT USING A VARIABLE
         812+10  812 CK1      + R ADD     *            ADD VAR TO REFERENCES IS IT IS A PARAMETER 
         813+ 1  816          + TR        CHKREF
         814+ 0 1166          + STOP      FACTN
         815+ 1  227          + TR        NEXT         TR TO PROCESS NEXT STEP
         816+ 9 2359 CHKREF   + ADD       TWO          ADD A REFERENCE TO A VAR THAT SHOULD BE REPLACED BY PARAM BY REFERENCE
         817+13  820          + STORE A   CHKRP1       PARAM: ADDR OF FACTN  
         818+ 9 2358          + ADD       ONE          RETURN ACC=NREF CREATED, =0 IF NO REFERENCE ADDED
         819+13  861          + STORE A   CHKREFEX
         820+10    0 CHKRP1   + R ADD     /   /        GET ADDR OF FACTN  
         821+13  822          + STORE A   CHKRP1A
         822+10    0 CHKRP1A  + R ADD     /   /        DERREFERENCE: ACC=ADDR OF VAR
         823+12 2393          + STORE     PADDR
         824+10  824          + R ADD     *            A VARIABLE IS SEARCHED IN PARAMETERS TABLE BY ITS ADDRESS
         825+ 1   77          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         826+ 0 1384          + STOP      TPARNAME     ... CALL PARAMETERS NAME TABLE
         827+ 0 1383          + STOP      NPARAMS      ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NPARAMS
         828+ 0 2393          + STOP      PADDR        ... THE VALUE TO FIND 
         829+ 4  861          + TR 0      CHKREFEX     IF NOT FOUND -> THIS VAR IS NOT A PARAM -> EXIT WITH ACC=0
         830+12 2391          + STORE     NPAR
         831+10  831          + R ADD     *            READ FROM TPARAMS TABLES
         832+ 1   73          + TR        READTBL
         833+ 0 1452          + STOP      TPARTYPE
         834+ 0 2391          + STOP      NPAR
         835+ 0 2397          + STOP      PTYPE        = TPARTYPE[NPAR] 
         836+10 2397          + R ADD     PTYPE
         837+ 3  840          + TR +      CK1B         IF TYPE >=0 -> PARAM PASSED TO REGION BY REFERENCE -> TR TO ADD VAR TO TREF TABLE
         838+10 2356          + R ADD     ZERO
         839+ 1  861          + TR        CHKREFEX     THIS VAR IS NOT PASSED BY REFERENCE -> EXIT WITH ACC=0
         840+10 1170 CK1B     + R ADD     D1N          IF D1N=-1 -> THIS IS A MATRIX/VECTOR WITH CONSTANT SUBSCRIPTS -> FACTN IS NOT 
         841+ 9 2358          + ADD       ONE          THE START OF MATRIX/VECTOR, FACTN IS THE EFFECTIVE ADDRESS FOR VECT[CONST] OR
         842+ 4  862          + TR 0      ERREAVM      MATRIX[CONST,CONT] -> IT CANNOT BE A PARAM PASSED BY REF (THE ADDR COMPUTATION 
         843+10 1555          + R ADD     NREFS        CHECK IF TABLE OVERLOW
         844+ 5 1554          + SUB       MAXNREFS     
         845+ 4  865          + TR 0      ERROVREF     
         846+10 1555          + R ADD     NREFS        CREATE NEW REF
         847+ 9 2358          + ADD       ONE
         848+12 1555          + STORE     NREFS
         849+12 2392          + STORE     NREF
         850+10  850          + R ADD     *            STORE IN TABLES
         851+ 1   71          + TR        EQTBL2
         852+ 0 1556          + STOP      TREFNAME     
         853+ 0 1554          + STOP      MAXNREFS
         854+ 0 2392          + STOP      NREF
         855+ 0 1157          + STOP      FACT         TREFNAME[NREF] = THE ALF NAME 
         856+ 0 2393          + STOP      PADDR        TREFADDR[NREF] = THE VAR ADDR
         857+ 0 1165          + STOP      STEPN        TREFSTEP[NREF] = THE STEPN WHERE IT IS REFERENCED
         858+ 0 1173          + STOP      NINCR        TREFINCR[NREF] = THE LOC INTO STEPN WHERE MC INSTR THAT USES VAR IS 
         859+ 0    0          + STOP      0000
         860+10 2392          + R ADD     NREF
         861+ 1    0 CHKREFEX + TR        /   /   
         862+10  862 ERREAVM  + R ADD     *
         863+ 1  351          + TR        ERROR
         864+ 0 2425          + STOP      ERREAVMS     ERROR: VECT[CONST] OR MATRIX[CONST,CONT] CANNOT BE A PARAM PASSED BY REF
         865+10  865 ERROVREF + R ADD     *
         866+ 1  351          + TR        ERROR
         867+ 0 2419          + STOP      ERROVRFS     ERROR: TOO MANY REFERENCES TO VARIABLES IN REGION (MAX 200)
         868+ 9 2359 GENINST  + ADD       TWO          GENERATE MACHINE CODE (MC) INSTRUCTIONS
         869+13 2379          + STORE A   MC.TABLE     MC TABLE FOLLOWS CALL AS PARAMTERS (UNTIL -STOP 0000 INSTR)
         870+10  870          + R ADD     *
         871+ 1  879          + TR        GENTABLE
         872+10  883          + R ADD     GEN1
         873+ 9 2358          + ADD       ONE
         874+13  875          + STORE A   GENEXIT2      
         875+ 1    0 GENEXIT2 + TR        /   /
         876+10  876 GENTBOV  + R ADD     *
         877+ 1  351          + TR        ERROR
         878+ 0 2409          + STOP      ERROVINS     ERROR: TOO MANY INSTR IN THIS STEP
         879+ 9 2359 GENTABLE + ADD       TWO          GENERATE MACHINE CODE (MC) INSTRUCTIONS
         880+13  884          + STORE A   GENEXIT      MC TABLE AT LOCATION IN MC.TABLE VAR
         881+10 2379          + R ADD     MC.TABLE
         882+13  883          + STORE A   GEN1
         883+10    0 GEN1     + R ADD     /   /        READ MACHINE CODE TABLE
         884+ 4    0 GENEXIT  + TR 0      /   /        =0 -> END OF MC.TABLE-> RETURN TO CALLER
         885+12 2382          + STORE     MC
         886+23   30          + A RIGHT   0030         SAVE OPCODE ONLY
         887+22   30          + A LEFT    0030         (WITH SIGN)
         888+12 2383          + STORE     MC.OP        IN MC.OP
         889+10 1172          + R ADD     NINST        INCR NUMBER OF MC INSTRUCTIONS IN CC TABLE
         890+ 9 2358          + ADD       ONE          ERROR IF > MAXIMUN ALLOWED
         891+12 1172          + STORE     NINST
         892+ 5 1376          + SUB       MAXNINST
         893+ 4  876          + TR 0      GENTBOV      ERROR: TOO MANY INSTR IN THIS STEP
         894+10 2356          + R ADD     ZERO
         895+11 2382          + ADD AB    MC           EXTRACT ADDR PART OF MC 
         896+ 7 2383          + SUB AB    MC.OP        
         897+ 5 2375          + SUB       D1000
         898+ 3  900          + TR +      GEN2
         899+ 0 1111          + STOP      1111         INVALID MC.TABLE
         900+ 9  905 GEN2     + ADD       ADTBL        USE THE TRANSFER TABLE TO PROCESS IT
         901+13  904          + STORE A   ADTBLTR
         902+10 2356          + R ADD     ZERO
         903+11 2383          + ADD AB    MC.OP        ON ENTRY TO ROUTINE, ACC=ABS(MC.OP). SIGN IS IN MC VARIABLE
         904+ 1    0 ADTBLTR  + TR        /   /
         905+ 0  905 ADTBL    + STOP      *
         906+ 1  932          + TR        GEN.ANN      A nnnn  where nnnn is the value of SHIFT1 var
         907+ 1  938          + TR        GEN.A00      A 0000  where nnnn is the value of SHIFT1 var
         908+ 1  964          + TR        GEN.FACT     factor to be replaced by V 0005 (variable), T 0010 (result of a step) or N 0012 (a number)
         909+ 1  948          + TR        GEN.ST+1     *+1 will be filled with final own instruction location + 1
         910+ 1  943          + TR        GEN.INN      transfer to location n (1..199) into stepN given in var TRANSFER = stepN, TRSTLOC = location in step machine code
         911+ 1  954          + TR        GEN.VNN      V nnnn  where nnnn is the value of ECONST var
         912+ 1  959          + TR        GEN.TNN      T nnnn  where nnnn is the value of ECONST var
         913+10 2382 GENADD   + R ADD     MC           ADD A GENERATED MC INSTR TO TINST TABLE
         914+ 3  917          + TR +      GENADD1      TAKE THE SIGN OF MC AND PLACE IT IN MC.OP
         915+ 6 2383          + R SUB     MC.OP
         916+12 2383          + STORE     MC.OP
         917+10 1172 GENADD1  + R ADD     NINST        ADD NINST TWICE AS EACH MC INSTR USES TWO HALF-WORDS
         918+ 9 1172          + ADD       NINST
         919+ 5 2359          + SUB       TWO          
         920+ 9  153          + ADD       TINSTAD      TINSTAD=LOCATION OF TABLE WITH MC INSTRUCTIONS GENERATED FOR THE CURRENT STEP
         921+13  925          + STORE A   GENADD2      TINST[ (INST- 1)*2 ] =MC instr op and region
         922+ 9 2358          + ADD       ONE
         923+13  927          + STORE A   GENADD3      TINST[ (INST- 1)*2 ] =MC instr addr
         924+10 2383          + R ADD     MC.OP        
         925+12    0 GENADD2  + STORE     /   /        STORE GENERATED MC INSTRUCTION MC.OP (MC.OP CAN BE >0 OR <0)
         926+10 2385          + R ADD     MC.ADDR
         927+12    0 GENADD3  + STORE     /   /                                       MC.ADDR (CAN BE >0 OR <0 IF HOLDS A STEPN/LOCATION PAIR)
         928+10  883          + R ADD     GEN1         PROCEED WITH NEXT MC INST N LIST
         929+ 9 2358          + ADD       ONE
         930+13  883          + STORE A   GEN1
         931+ 1  883          + TR        GEN1
         932+ 9 2443 GEN.ANN  + ADD       REG.A
         933+12 2383          + STORE     MC.OP        MC.OP   = OPCODE + REGION A
         934+10 2356          + R ADD     ZERO
         935+11 2386          + ADD AB    SHIFT1
         936+12 2385          + STORE     MC.ADDR      MC.ADDR = ABS(SHIFT1) VARIABLE
         937+ 1  913          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
         938+ 9 2443 GEN.A00  + ADD       REG.A
         939+12 2383          + STORE     MC.OP        MC.OP   = OPCODE + REGION A
         940+10 2356          + R ADD     ZERO
         941+12 2385          + STORE     MC.ADDR      MC.ADDR = 0000
         942+ 1  913          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
         943+ 9 2381 GEN.INN  + ADD       TRSTLOC      TRSTLOC=LOCATION INTO STEPN NUMBER THE MC INSTR HAS TO TRANSFER TO 
         944+12 2383          + STORE     MC.OP        MC.OP   = OPCODE + LOCATION INTO STEPN
         945+ 6 2380          + R SUB     TRANSFER     TRANSFER=STEPN NUMBER THE MC INSTR HAS TO TRANSFER TO 
         946+12 2385          + STORE     MC.ADDR      MC.ADDR = STEPN (WITH MINUS SIGN, TO SIGNAL ADDR POINTS TO STEPN/LOCATION IN THIS STEP PAIR)
         947+ 1  913          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
         948+ 9 2358 GEN.ST+1 + ADD       ONE
         949+ 9 1172          + ADD       NINST      
         950+12 2383          + STORE     MC.OP        MC.OP   = OPCODE + CURRENT OWN LOCATION INTO STEPN
         951+ 6 1165          + R SUB     STEPN
         952+12 2385          + STORE     MC.ADDR      MC.ADDR = STEPN (WITH MINUS SIGN, TO SIGNAL ADDR POINTS TO STEPN/LOCATION IN THIS STEP PAIR)
         953+ 1  913          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
         954+ 9 2445 GEN.VNN  + ADD       REG.V
         955+12 2383          + STORE     MC.OP        MC.OP   = OPCODE + REGION V
         956+10 2389          + R ADD     ECONST
         957+12 2385          + STORE     MC.ADDR      MC.ADDR = ADDR IN REGION C
         958+ 1  913          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
         959+ 9 2446 GEN.TNN  + ADD       REG.T
         960+12 2383          + STORE     MC.OP        MC.OP   = OPCODE + REGION T
         961+10 2389          + R ADD     ECONST
         962+12 2385          + STORE     MC.ADDR      MC.ADDR = ADDR IN REGION C
         963+ 1  913          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
         964+15 2445 GEN.FACT + LOAD MQ   REG.V
         965+10 1167          + R ADD     FACTREG
         966+ 5 2369          + SUB       D34          'V'
         967+ 4  977          + TR 0      GEN.FA1
         968+15 2447          + LOAD MQ   REG.N
         969+10 1167          + R ADD     FACTREG
         970+ 5 2367          + SUB       D26          'N'
         971+ 4  977          + TR 0      GEN.FA1
         972+15 2446          + LOAD MQ   REG.T
         973+10 1167          + R ADD     FACTREG
         974+ 5 2368          + SUB       D32          'T'
         975+ 4  977          + TR 0      GEN.FA1
         976+ 0 1111          + STOP      1111         INTERNAL COMPILER ERROR: INVALID FACT REGION
         977+10 2356 GEN.FA1  + R ADD     ZERO
         978+20   35          + L LEFT    0035         A=MQ
         979+11 2383          + ADD AB    MC.OP
         980+12 2383          + STORE     MC.OP        MC.OP   = OPCODE + REGION OF FACTOR (CAN BE V, N OR T)
         981+10 1166          + R ADD     FACTN
         982+12 2385          + STORE     MC.ADDR      MC.ADDR = FACTN
         983+10 1172          + R ADD     NINST   
         984+12 1173          + STORE     NINCR        NINCR= THE LOCATION OF FACTOR MC INSTRUCTION INTO THE STEP 
         985+ 1  913          + TR        GENADD       TR TO ADD INSTR TO CC TABLES
         986+ 9 2359 PRTMC    + ADD       TWO          PRINT TINST TABLE WITH MC INSTRUCTIONS GENERATED FOR THIS STEP
         987+13 1129          + STORE A   PRTMCEX
         988+10 2356          + R ADD     ZERO
         989+12 2387          + STORE     PRTMCNUM
         990+10 2387 PMCLOOP  + R ADD     PRTMCNUM
         991+ 5 1172          + SUB       NINST
         992+ 4 1129          + TR 0      PRTMCEX      EXIT IF ALL NINST INSTRUCTIONS PRINTED
         993+10 2387          + R ADD     PRTMCNUM     INCR COUNT
         994+ 9 2358          + ADD       ONE
         995+12 2387          + STORE     PRTMCNUM     GET MC INSTR FROM TINST[ (PRTMCNUM-1)*2 ]
         996+ 9 2387          + ADD       PRTMCNUM
         997+ 5 2359          + SUB       TWO
         998+ 9  153          + ADD       TINSTAD
         999+13 1004          + STORE A   PMCAD1
        1000+ 9 2358          + ADD       ONE
        1001+13 1008          + STORE A   PMCAD2
        1002+10 2356          + R ADD     ZERO
        1003+12 2384          + STORE     MC.REG       INIT REGION REFERENCED BY MC
        1004+10    0 PMCAD1   + R ADD     /   /
        1005+13 2384          + STORE A   MC.REG
        1006+23   12          + A RIGHT   0012
        1007+12 2383          + STORE     MC.OP        MC.OP HAS NOW THE SIGNED OPCODE -31..31 
        1008+10    0 PMCAD2   + R ADD     /   /
        1009+12 2385          + STORE     MC.ADDR
        1010+ 3 1017          + TR +      PMC3         IF MC.ADDR >=0 THEN MC.REG HOLDS THE REGION FOR MC.ADDR 
        1011+10 2384          + R ADD     MC.REG       IF MC.ADDR <0 THEN MC.REG VAR HOLDS THE LOCATION INTO STEPN REFERENCED BY MC.ADDR
        1012+12 2381          + STORE     TRSTLOC      LOCATION IN STEP GIVEN BY MC.ADDR
        1013+ 6 2385          + R SUB     MC.ADDR      MAKES MC.ADDR POSITIVE. IT IS THE DESTINATION STEP
        1014+12 2385          + STORE     MC.ADDR
        1015+10 2444          + R ADD     REG.I
        1016+12 2384          + STORE     MC.REG       SET REGION I -> MC.ADDR=THE STEPN, TRSTLOC=THE NINST REFERENCED IN THIS STEPN
        1017+10 1017 PMC3     + R ADD     *            START NEW LINE TO PRINT
        1018+ 1   53          + TR        CLRBUF
        1019+10 2388          + R ADD     REGCSTEP     THIS IS THE STEPN WHERE THE REG.C SITS
        1020+ 5 1165          + SUB       STEPN
        1021+ 4 1023          + TR 0      PMC3C        TR TO PRINT REG "C NNNN" INSTEAD OF STEPN.MCNUM
        1022+ 1 1035          + TR        PMC3Z
        1023+15 2365 PMC3C    + LOAD MQ   D15          PRINT 'C'
        1024+10 1024          + R ADD     *
        1025+ 1   63          + TR        PRTCHR
        1026+ 0   39          + STOP      0039         AT COL 39
        1027+10 2387          + R ADD     PRTMCNUM     INST NUMBER 1..99
        1028+ 5 2358          + SUB       ONE          -1 -> IS THE ADDRESS IN REGION C
        1029+21   35          + L RIGHT   0035         ACC->MQ
        1030+10 1030          + R ADD     *
        1031+ 1   61          + TR        PRTINT
        1032+ 0   40          + STOP      0040         AT COL 40 
        1033+ 0    4          + STOP      0004         LEN=4
        1034+ 1 1055          + TR        PMC5SGN
        1035+15 1165 PMC3Z    + LOAD MQ   STEPN        PRINT STEPN
        1036+10 1036          + R ADD     *
        1037+ 1   61          + TR        PRTINT
        1038+ 0   40          + STOP      0040         AT COL 40 
        1039+ 0    4          + STOP      0004         LEN=4
        1040+15 2370          + LOAD MQ   D43          PRINT '.'
        1041+10 1041          + R ADD     *
        1042+ 1   63          + TR        PRTCHR
        1043+ 0   44          + STOP      0044         AT COL 44 
        1044+15 2359          + LOAD MQ   TWO
        1045+10 2387          + R ADD     PRTMCNUM     IF INST NUMBER < 10 PRINT IT
        1046+ 5 2362          + SUB       D10          WITH LEN=1, IF >= 10 USE LEN=2
        1047+ 3 1049          + TR +      PMC4
        1048+15 2358          + LOAD MQ   ONE
        1049+14 1054 PMC4     + STORE MQ  PMC5
        1050+15 2387          + LOAD MQ   PRTMCNUM
        1051+10 1051          + R ADD     *
        1052+ 1   61          + TR        PRTINT
        1053+ 0   45          + STOP      0045         AT COL 45 
        1054+ 0    2 PMC5     + STOP      0002         LEN=1 OR 2
        1055+15 2364 PMC5SGN  + LOAD MQ   D12          '+'
        1056+10 2383          + R ADD     MC.OP
        1057+ 3 1059          + TR +      PMC6
        1058+15 2363          + LOAD MQ   D11          '-'
        1059+10 1059 PMC6     + R ADD     *            PRINT OP SIGN
        1060+ 1   63          + TR        PRTCHR
        1061+ 0   48          + STOP      0048         AT COL 48
        1062+10 2356          + R ADD     ZERO
        1063+11 2383          + ADD AB    MC.OP
        1064+ 9 1103          + ADD       TMNEAD
        1065+13 1066          + STORE A   PMC7
        1066+15    0 PMC7     + LOAD MQ   /   /
        1067+10 1067          + R ADD     *            PRINT OP MNEMONIC
        1068+ 1   59          + TR        PRTALF
        1069+ 0   49          + STOP      0049         AT COL 49
        1070+10 2384          + R ADD     MC.REG
        1071+ 9 1104          + ADD       TREGMNEA     CHARS IN TREGMNE ARE TXT ALFA VALUES  
        1072+13 1073          + STORE A   PMC8         THUS ARE NEGATIVE
        1073+ 6    0 PMC8     + R SUB     /   /        CHANGE SIGN BEFORE STORING IT IN MQ
        1074+21   35          + L RIGHT   0035
        1075+10 1075          + R ADD     *            PRINT REGION LETTER V I S T A N
        1076+ 1   63          + TR        PRTCHR
        1077+ 0   52          + STOP      0052         AT COL 52
        1078+10 2384          + R ADD     MC.REG       IF MC.REG='I' THEN ...
        1079+ 5 2444          + SUB       REG.I        
        1080+ 4 1105          + TR 0      PMC9         TR TO PRINT STEPN.LOCATION
        1081+10 2384          + R ADD     MC.REG       IF MC.REG='S' THEN ...
        1082+ 5 2448          + SUB       REG.S
        1083+ 4 1090          + TR 0      PMC8B        TR TO PRINT ALFA SYMBOL TO TRANSFER TO
        1084+15 2385          + LOAD MQ   MC.ADDR      MC.REG IS 'V', 'T', 'A' OR 'N'
        1085+10 1085          + R ADD     *            JUST PRINT THE INST ADDRESS
        1086+ 1   61          + TR        PRTINT
        1087+ 0   53          + STOP      0053         AT COL 53 
        1088+ 0    4          + STOP      0004         LEN=4
        1089+ 1 1125          + TR        PMC12
        1090+15 2371 PMC8B    + LOAD MQ   D45          PRINT ALFA SYMBOL TO TRANSFER TO
        1091+10 1091          + R ADD     *            '/'
        1092+ 1   63          + TR        PRTCHR
        1093+ 0   54          + STOP      0054         AT COL 54
        1094+15 2371          + LOAD MQ   D45          '/'
        1095+10 1095          + R ADD     *
        1096+ 1   63          + TR        PRTCHR
        1097+ 0   58          + STOP      0058         AT COL 58
        1098+15 2385          + LOAD MQ   MC.ADDR      GET SYMBOL ALFA
        1099+10 1099          + R ADD     *            
        1100+ 1   59          + TR        PRTALF
        1101+ 0   55          + STOP      0055         AT COL 55
        1102+ 1 1125          + TR        PMC12
        1103+ 0 2457 TMNEAD   + STOP      TMNE
        1104+ 0 2449 TREGMNEA + STOP      TREGMNE
        1105+15 2385 PMC9     + LOAD MQ   MC.ADDR      PRINT STEPN.TRSTLOC 
        1106+10 1106          + R ADD     *
        1107+ 1   61          + TR        PRTINT
        1108+ 0   53          + STOP      0053         AT COL 53 
        1109+ 0    4          + STOP      0004         LEN=4
        1110+15 2370          + LOAD MQ   D43          PRINT '.'
        1111+10 1111          + R ADD     *
        1112+ 1   63          + TR        PRTCHR
        1113+ 0   57          + STOP      0057         AT COL 57 
        1114+15 2359          + LOAD MQ   TWO
        1115+10 2381          + R ADD     TRSTLOC      IF INST NUMBER < 10 PRINT IT
        1116+ 5 2362          + SUB       D10          WITH LEN=1, IF >= 10 USE LEN=2
        1117+ 3 1119          + TR +      PMC10
        1118+15 2358          + LOAD MQ   ONE
        1119+14 1124 PMC10    + STORE MQ  PMC11
        1120+15 2381          + LOAD MQ   TRSTLOC
        1121+10 1121          + R ADD     *
        1122+ 1   61          + TR        PRTINT
        1123+ 0   58          + STOP      0058         AT COL 58 
        1124+ 0    2 PMC11    + STOP      0002         LEN=1 OR 2
        1125+ 8    0 PMC12    + NOOP      0000
        1126+10 1126          + R ADD     *
        1127+ 1   57          + TR        PRINTCRD
        1128+ 1  990          + TR        PMCLOOP    
        1129+ 1    0 PRTMCEX  + TR        /   /        RETURN TO CALLER
        1130+     0  PACTSRC    RES       24           CARD IMAGE OF PACT SOURCE CODE CARD (12 FULL WORDS)
        1154+     0  REGION     DEF       0
        1155+     0  STEP       DEF       0            REGION = ALFA (<0)
        1156+     0  OP         DEF       0            STEP   = INT (>0)
        1157+     0  FACT       DEF       0            OP     = 0..43    =0 MEANS END OF REGION
        1158+     0  S1         DEF       0            FACT   < 0 -> FACTOR IS AN ALFA SYMBOL (VAR, REGION, ...) 
        1159+     0  S2         DEF       0            FACT = 0 -> BLANK FACTOR
        1160+     0  QR         DEF       0            FACT = 0..9999 -> DESTINATION STEP FOR TRANSFER/RESULT OF STEP
        1161+     0  QF         DEF       0            CLUE = -, R OR N
        1162+     0  NUM        DEF       0            
        1163+     0             DEF       0            S1/S2 = 0 -> BLANK, >0 -> INTEGER, <0 -> ALFA 
        1164+     0  CLUE       DEF       0
        1165+     0  STEPN      DEF       0            QR = +/- INTEGER OR BLANK. 
        1166+     0  FACTN      DEF       0                 IF OP=TEST THEN IF QR=0->INDEX IN GENEATED INSTR IS INDEX IS "ADDRESS TYPE", =1->IS "COUNT TYPE" 
        1167+     0  FACTREG    DEF       0            QF = SET IF THERE IS AN INTEGER FACTOR/NUMBER IN CARD
        1168+     0  S1N        DEF       0            STEPN = SEQUENTIAL NUMBER OF STEP            
        1169+     0  S2N        DEF       0            IF OP IS TRANSFER -> FACTN=DESTINATION STEPN
        1170+     0  D1N        DEF       0            FACTN=ADDR (0, 2, 4, ..) FACTREG=' ', 'T', 'V', 'N'
        1171+     0  D2N        DEF       0            S1N/S2N=INDEX (IF <0), BLANK (IF =0), CONST (IF >0), 
        1172+     0  NINST      DEF       0                   =*777777 if non active index with OP=40 
        1173+     0  NINCR      DEF       0            D1N/D2N=HALF-WORD SIZE OF EACH DIMENSION
        1174+     0  TINST      RES       200          MACHINE CODE: 1ST HALF-WORD OPCODE + REGION/LOCATION INTO STEP (FOR TRANSFERS)
        1374+    44  CCLEN      DEF       0044         LENGTH OF COMPACT CODE RECORD 
        1375+     0  N          DEF       0            TEMP VAR (HERE TO MAKE TABLES START AT EVEN LOCATION)
        1376+   100  MAXNINST   DEF       100          MAX NUMBER OF MACHINE CODE INSTRUTIONS PER STEP
        1377+     0  VAL        DEF       0            TEMP
        1378+     0  DATA       DEF       0            EVEN ALIGNED TEMP VAT
        1379+     0  DATA2      DEF       0
        1380+     0  S1S2       DEF       0
        1381+     0  S1S2B      DEF       0
        1382+    34  MAXNPAR    DEF       34           MAX (34) NUMBER OF CALL PARAMETERS
        1383+     0  NPARAMS    DEF        0           NUMBER OF PARAMS DEFINED
        1384+     0  TPARNAME   RES       34           PARAM NAME (ALFA BASE48 <0). >0 IF VARIABLE (IS THE ADDR). =4096 IF NUMBER
        1418+     0  TPARSTEP   RES       34           STEPN WHERE PARAM IS DEFINED
        1452+     0  TPARTYPE   RES       34           PARAM TYPE: 
        1486+     0  TPARFACT   RES       34           
        1520+     0  TPARLOC1   RES       34           PACT       TYPE  FACT   LOC1   NAME       DESCR
        1554+   200  MAXNREFS   DEF       200          MAX (200) NUMBER OF VARIABLE REFERENCES SIMULATEOUSLY ACTIVE AT A GIVEN MOMENT
        1555+     0  NREFS      DEF       0            NUMBER OF REFERENCES IN REGION
        1556+     0  TREFNAME   RES       200          NAME OF VARIABLE. =0 IS ENTRY IS NOT USED       
        1756+     0  TREFADDR   RES       200          THE ADDR (FACTN) OF VARIABLE 
        1956+     0  TREFSTEP   RES       200          STEPN WHERE THIS VECTOR/MATRIX IS USED               TINST 0:  ...                        
        2156+     0  TREFINCR   RES       200          INCRN ON PREVIOUS STEPN TO ACCESS THE VAR LOCATION   STEPN  :  ... VAR I  J                
        2356+     0  ZERO       DEF       0
        2357+     0             DEF       0
        2358+     1  ONE        DEF       1
        2359+     2  TWO        DEF       2
        2360+     3  D3         DEF       3
        2361+     4  D4         DEF       4
        2362+    10  D10        DEF       10
        2363+    11  D11        DEF       11
        2364+    12  D12        DEF       12
        2365+    15  D15        DEF       15
        2366+    17  D17        DEF       17
        2367+    26  D26        DEF       26
        2368+    32  D32        DEF       32
        2369+    34  D34        DEF       34
        2370+    43  D43        DEF       43
        2371+    45  D45        DEF       45
        2372+   100  D100       DEF       100
        2373+   101  D101       DEF       101
        2374+   200  D200       DEF       200
        2375+  1000  D1000      DEF       1000
        2376-131070  O776K      DEF       *777776      OCTAL ALL ONES
        2377-131071  O777K      DEF       *777777      OCTAL ALL ONES
        2378+     0  NREGIONS   DEF       0            NUMBER OF REGIONS PROCESSED
        2379+     0  MC.TABLE   DEF       0            ADDRESS TO MACHINE CODE GENERATION TABLE TO USE 
        2380+     0  TRANSFER   DEF       0            STEPN NUMBER THE MC INSTR HAS TO TRANSFER TO 
        2381+     0  TRSTLOC    DEF       0            LOCATION INTO STEPN NUMBER THE MC INSTR HAS TO TRANSFER TO 
        2382+     0  MC         DEF       0            MACHINE CODE INSTR TO GENERATE FROM MC TABLE
        2383+     0  MC.OP      DEF       0            MC OPCODE GENERATED
        2384+     0  MC.REG     DEF       0            REGION REFERENCED BY MC OPCODE GENERATED
        2385+     0  MC.ADDR    DEF       0            MC ADDR GENERATED. BOTH WILL BE STORED IN TINST TABLE IN COMPCAT CODE RECORD
        2386+     0  SHIFT1     DEF       0
        2387+     0  PRTMCNUM   DEF       0            NEXT INSTR TO PRINT WITH PRTMC
        2388+     0  REGCSTEP   DEF       0            STEPN WHERE THE REG.C SITS
        2389+     0  ECONST     DEF       0
        2390+     0  NARGS      DEF       0
        2391+     0  NPAR       DEF       0            PARAM BEING EXAMINED
        2392+     0  NREF       DEF       0            CURRENT REFERENCE ENTRY. REFERENCES = STEPN OF INSTR THAT USES VARS WITH INDEX. 
        2393+     0  PADDR      DEF       0            
        2394+     0  PFACTN     DEF       0            
        2395+     0  PSTEPN     DEF       0            
        2396+     0  PINCR      DEF       0            
        2397+     0  PTYPE      DEF       0            PARAMETER TYPE
        2398+     0  PLOC1      DEF       0            
        2399+     0  P1P2       DEF       0            
        2400+     0  NGEN       DEF       0            
        2401+     0  USETWO     DEF       0            
        2402+     0  N1GEN      DEF       0            
        2403+     0  N2GEN      DEF       0            
        2404+     0  RADDR      DEF       0            
        2405+     0  RSTEPN     DEF       0            
        2406+     0  RINCR      DEF       0            
        2407+     0  SVNINST    DEF       0            SAVE CURRENT NUMBER OF MC INSTR IN THE COMPACT CODE RECORD AT START OF STEP PROCESSING
        2408+     0  LEN        DEF       0
        2409- 75051  ERROVINS   TXT       "TOO MANY INSTR IN THIS STEP",0   ERROR: MAX 100
        2410-  1213  
        2411- 61680  
        2412- 49663  
        2413- 75168  
        2414- 49632  
        2415- 74709  
        2416- 71455  
        2417- 74572  
        2418+     0  
        2419- 75051  ERROVRFS   TXT       "TOO MANY REFS",0                 ERROR: TOO MANY REFERENCES TO MATRIX/VECTOR IN REGION (MAX 50)
        2420-  1213  
        2421- 61680  
        2422- 69954  
        2423- 71424  
        2424+     0  
        2425- 61200  ERREAVMS   TXT       "NO CONST",0                      ERROR: VECT[CONST] OR MATRIX[CONST,CONT] CANNOT BE A PARAM PASSED BY REF. VECTOR/MATRIX PASSED AS PARAM NEEDS TO HAVE ALT LEAST ONE NON-CONTANT SUBSCRIPT
        2426- 35882  
        2427- 72960  
        2428+     0  
        2429- 61200  ERRNOPAR   TXT       "NO PARAM",0                      ERROR: FOR PARAM MUST BE A VAR/TEMP/INTEGER NUMBER
        2430- 65166  
        2431- 31152  
        2432+     0  
        2433- 35208  MSGSTART   TXT       "CALL EXPANSION",0
        2434- 55313  
        2435- 84301  
        2436- 61413  
        2437- 63456  
        2438+     0  
        2439- 69955  MSGDONE    TXT       "REGIONS",0
        2440- 49706  
        2441- 71424  
        2442+     0  
        2443+     0  REG.A      DEF       0            ABSOLUTE A 0000
        2444+     1  REG.I      DEF       1            INSTRUCTIONS CODE I 0000
        2445+     2  REG.V      DEF       2            VARIABLES V 0000
        2446+     3  REG.T      DEF       3            TEMPORARY T 0000
        2447+     4  REG.N      DEF       4            NUMBER N 0000
        2448+     7  REG.S      DEF       7            SYMBOL S 0000
        2449-    13  TREGMNE    TXT       '  A'
        2450-    21             TXT       '  I'
        2451-    34             TXT       '  V'
        2452-    32             TXT       '  T'
        2453-    26             TXT       '  N'
        2454-    28             TXT       '  P'        PERISHABLE STORAGE (=LIB LOCAL VARS/CONSTANTS)
        2455-    15             TXT       '  C'        LOOP CONSTANTS
        2456-    31             TXT       '  S'
        2457- 46080  TMNE       TXT       'H  '        STOP/HALT
        2458- 73728             TXT       'T  '        TRANSFER
        2459- 74592             TXT       'TF '        TRANSFER ON OVERLOF
        2460- 75072             TXT       'TP '        TRANSFER ON PLUS
        2461- 75552             TXT       'TZ '        TRANSFER ON ZERO
        2462- 71424             TXT       'S  '        SUBTRACT
        2463- 70608             TXT       'RS '        RESET AND SUBTRACT
        2464- 73056             TXT       'SV '        SUBTRACT ABSOLUTE VALUE
        2465- 59904             TXT       'N  '        NO OPERATION
        2466- 29952             TXT       'A  '        ADD
        2467- 69744             TXT       'RA '        RESET AND ADD
        2468- 31584             TXT       'AV '        ADD ABSOLUTE VALUE
        2469- 72960             TXT       'ST '        STORE
        2470- 72048             TXT       'SA '        STORE ADDRESS
        2471- 72624             TXT       'SM '        STORE MQ
        2472- 56496             TXT       'LM '        LOAD MQ
        2473- 57600             TXT       'M  '        MULTIPLY
        2474- 59040             TXT       'MR '        MULTIPLY AND ROUND
        2475- 36864             TXT       'D  '        DIVIDE
        2476- 69120             TXT       'R  '        ROUND
        2477- 56448             TXT       'LL '        LONG LEFT SHIFT
        2478- 56736             TXT       'LR '        LONG RIGHT SHIFT
        2479- 31104             TXT       'AL '        ACCUMULATOR LEFT SHIFT
        2480- 31392             TXT       'AR '        ACCUMULATOR RIGHT SHIFT
        2481- 69888             TXT       'RD '        READ
        2482- 69792             TXT       'RB '        READ BACKWARDs
        2483- 80640             TXT       'W  '        WRITE
        2484- 81456             TXT       'WE '        WRITE END OF FILE
        2485- 70800             TXT       'RW '        REWIND TAPE
        2486- 72192             TXT       'SD '        SET DRUM DDR
        2487- 72240             TXT       'SE '        SENSE
        2488- 34560             TXT       'C  '        COPY
        2490+15 2504 CLRBUF   + LOAD MQ   IOCL
        2491+14 2509          + STORE MQ  BUFIO
        2492+15 2530          + LOAD MQ   IOSTORE         
        2493+ 1 2501          + TR        INIT2
        2494+15 2526 READCRD  + LOAD MQ   IORDCRD
        2495+ 1 2499          + TR        INIT1
        2496+15 2528 WRITECRD + LOAD MQ   IOWRCRD
        2497+ 1 2499          + TR        INIT1
        2498+15 2529 PRINTCRD + LOAD MQ   IOPRCRD
        2499+14 2509 INIT1    + STORE MQ  BUFIO
        2500+15 2527          + LOAD MQ   IOCOPY         
        2501+14 2510 INIT2    + STORE MQ  BUFROW
        2502+ 9 2536          + ADD       TWO          
        2503+13 2525          + STORE A   EXIT
        2504+10 2532 IOCL     + R ADD     ZERO         RESET TO INITIAL COPY LOOP ADDRESS     
        2505+13 2510          + STORE A   BUFROW       FOR BUFFER
        2506+10 2510          + R ADD     BUFROW       X .*echo Print
        2507+ 5 2537          + SUB       D48          X 
        2508+12 2534          + STORE     ENDLP        X LOOP END VALUE
        2509- 0    0   BUFIO  - STOP      /   /        READ OR WRITE
        2510-31    0   BUFROW - COPY      /   /        COPY WORD TO/FROM PRINTER/CARDREADER
        2511+ 1 2515          + TR        BUFOK2       NORMAL PROCESSING 
        2512+ 1 2522          + TR        EODECK       FOR COPY READING END OF REG (=END OF DECK BEING READ)
        2513+ 6 2536          + R SUB     TWO          END OF FILE -> NO CARD TO READ -> STOP with Acc=-2
        2514+ 0 2509          + STOP      BUFIO        ON PRESSING START RETRY CARD READ
        2515+10 2510   BUFOK2 + R ADD     BUFROW       X
        2516+ 5 2536          + SUB       TWO          INCR BUF ADDR
        2517+13 2510          + STORE A   BUFROW       X
        2518+ 5 2534          + SUB       ENDLP        CHECK FOR END
        2519+ 4 2524          + TR 0      ENDIO
        2520+10 2532          + R ADD     ZERO         CLEAR ACC IN CASE WE ARE CLEANING THE BUFFER
        2521+ 1 2510          + TR        BUFROW
        2522+10 2535 EODECK   + R ADD     ONE          SET OV FLAG TO SIGNAL END OF DECK CONDITION
        2523+22   36          + A LEFT    36
        2524+26 2052 ENDIO    + WRITE     2052         END OF I/O: INSURE THAT MQ NOT IN USE            
        2525+ 1    0 EXIT     + TR        /   /
        2526+24 2048 IORDCRD  + READ      2048         PREPARE TO READ FROM CARD READER
        2527-31    0 IOCOPY   - COPY      /   /   
        2528+26 1024 IOWRCRD  + WRITE     1024         PREPARE TO PUNCH CARD 
        2529+26  512 IOPRCRD  + WRITE     0512         PREPARE WRITE PRTBUF ON PRINTER
        2530-12    0 IOSTORE  - STORE     /   /        CLEAR BUFFER
        2531+     0             ORG       EVEN           
        2532+     0  ZERO       DEF       0            
        2533+     0             DEF       0            
        2534+     0  ENDLP      DEF       0            LOOP END VALUE
        2535+     1  ONE        DEF       1
        2536+     2  TWO        DEF       2
        2537+    48  D48        DEF       48
        2538+ 9 2809 PRTPARM2 + ADD       TWO          GET 2 PARAMS: LEN AND COL (EITHER VALUE OR VAR ADDR)
        2539+13 2558          + STORE A   PRTPRMEX
        2540+10 2548          + R ADD     PRTP1
        2541+ 9 2809          + ADD       TWO          PRINT PACKED TEXT FROM FULL-WORD VALUE IN MQ REGISTER 
        2542+13 2548          + STORE A   PRTP1        STORE ADDR OF FIRST PARAM (LEN)
        2543+ 9 2808          + ADD       ONE
        2544+13 2550          + STORE A   PRTP2        STORE ADDR OF SECOND PARAM (COL)
        2545+ 9 2808          + ADD       ONE
        2546+13 2625          + STORE A   EXIT
        2547-14 2798          - STORE MQ  NUM          SAVE VALUE TO PRINT PARAM MQ (NUM IS ALIASED TO TXT)
        2548+10    0   PRTP1  + R ADD     /   /        GET LEN: NUMBER OF CHARS TO PRINT (1..6)
        2549+12 2802          + STORE     LEN
        2550+10    0   PRTP2  + R ADD     /   /        GET COLUMN PARAM 1..72
        2551+ 3 2554          + TR +      PRTP4
        2552+13 2553          + STORE A   PRTP3        COL<0 -> INTERPRET COL AS LOC(COL) = ADDR OF COL VAR
        2553+10    0   PRTP3  + R ADD     /   /        READ VAR COL PASED AS PARAM
        2554+ 4 2625   PRTP4  + TR 0      EXIT         COL=0 -> EXIT
        2555+ 3 2557          + TR +      PRTP5
        2556+ 1 2625          + TR        EXIT         COL<0 -> EXIT
        2557+12 2608   PRTP5  + STORE     COL
        2558+ 1    0 PRTPRMEX + TR        /   /        RETURN TO CALLER
        2559+13 2548 PRTSTR   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2560+10 2560          + R ADD     *            FOR PRINT STRINGZ FROM MEM
        2561+ 1 2538          + TR        PRTPARM2
        2562+12 2572          + STORE     COLSZ
        2563+10 2802          + R ADD     LEN          LEN IS IN FACT THE LOCATION WHERE THE STRING STARTS
        2564+13 2567          + STORE A   STRZAD
        2565+10 2625          + R ADD     EXIT
        2566+13 2580          + STORE A   STRZEX
        2567+10    0 STRZAD   + R ADD     /   /        GET HALF-WORD WITH NEXT 3 CHARS TO PRINT
        2568+ 4 2580          + TR 0      STRZEX       IF +0 -> END OF STRING (-0 DOES NOT TERMINATES THE STRING)
        2569+21   35          + L RIGHT   0035         MQ=3-CHARS TO PRINT
        2570+10 2570          + R ADD     *            
        2571+ 1 2582          + TR        PRTALF       PRINT 3 CHARS
        2572+ 0    0 COLSZ    + STOP      0000         COL 
        2573+10 2567 STRZ1    + R ADD     STRZAD       INCR STRING ADDRESS
        2574+ 9 2808          + ADD       ONE
        2575+13 2567          + STORE A   STRZAD
        2576+10 2572          + R ADD     COLSZ        INCR COLUMN
        2577+ 9 2810          + ADD       D3
        2578+13 2572          + STORE A   COLSZ
        2579+ 1 2567          + TR        STRZAD
        2580+ 3    0 STRZEX   + TR +      /   /        IF ZERO -> END OF STRING
        2581+ 1 2573          + TR        STRZ1
        2582+ 9 2809 PRTALF   + ADD       TWO          PRINT 3-PACKED CHARS IN MQ REGISTER 
        2583+14 2804          + STORE MQ  TXT          SAVE TEXT TO PRINT (IN LEFT HALF WORD)
        2584+13 2587          + STORE A   PRTAP2       STORE ADDR OF PARAM (COL)
        2585+ 9 2808          + ADD       ONE
        2586+13 2625          + STORE A   EXIT
        2587+10    0   PRTAP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        2588+ 3 2591          + TR +      PRTAP4
        2589+13 2590          + STORE A   PRTAP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        2590+10    0   PRTAP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        2591+12 2608   PRTAP4 + STORE     COL
        2592+10 2810          + R ADD     D3
        2593+12 2802          + STORE     LEN
        2594+10 2792 PRT1     + R ADD     ZERO         UNPACK LEFTMOST CHAR 
        2595+11 2804          + ADD AB    TXT          GET TEXT DISCARD SIGN
        2596+21   35          + L RIGHT   0035         MQ=Acc
        2597+10 2792          + R ADD     ZERO
        2598+18 2817          + DIV       D48X48
        2599+12 2804          + STORE     TXT          remainder=char to print, mq=c2 * 48 + c3 in right half-word
        2600+10 2792          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        2601+20   18          + L LEFT    0018         put c2 and c3 in left half-word of MQ to be saved in CHAR half word
        2602+14 2803          + STORE MQ  CHAR         CHAR TO PRINT
        2603+10 2803          + R ADD     CHAR 
        2604+ 4 2609          + TR 0      NXTCHR       IF BLANK PROCEED TO NEXT COL
        2605+21   35          + L RIGHT   0035         MQ=CHAR TO PRINT
        2606+10 2606          + R ADD     *            PRINT CHAR
        2607+ 1 2702          + TR        PRTCHR
        2608+ 0    0 COL      + STOP      0000         COL: COLUMN NUMBER TO PRINT (1..72)
        2609+10 2802 NXTCHR   + R ADD     LEN          DECR LEN COUNT
        2610+ 5 2808          + SUB       ONE
        2611+12 2802          + STORE     LEN
        2612+ 4 2625          + TR 0      EXIT         IF NO MORE CHARS TO PRINT EXIT
        2613+10 2608          + R ADD     COL          INCR COL POSITION
        2614+ 9 2808          + ADD       ONE
        2615+12 2608          + STORE     COL
        2616+ 5 2816          + SUB       D72          IF COL > 72 RETURN TO CALLER
        2617+ 4 2619          + TR 0      GNXTCHR      ELSE PROCEED WITH NEXT CHAR
        2618+ 3 2625          + TR +      EXIT
        2619+10 2792 GNXTCHR  + R ADD     ZERO         GET NEXT CHAR 
        2620+15 2804          + LOAD MQ   TXT
        2621+16 2815          + MPY       D48
        2622+22   17          + A LEFT    0017         GET RESULT IN LEFT HALF-WORD OF ACC
        2623+12 2804          + STORE     TXT
        2624+ 1 2594          + TR        PRT1         PROCEED TO PRINT CHAR
        2625+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        2626+13 2548 PRTOCT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2627+10 2627          + R ADD     *            FOR PRINT OCTIONARY VALUE
        2628+ 1 2538          + TR        PRTPARM2
        2629+10 2802          + R ADD     LEN          LEN = OCTAL DIGITS TO PRINT
        2630+ 9 2608          + ADD       COL
        2631+ 5 2808          + SUB       ONE
        2632+12 2644          + STORE     COLN         COL POINTS TO LEAST SIGNIFICANT DIGIT
        2633+10 2798 PRTIOCG  + R ADD     NUM          GENERATE OCTINARY DIGIT
        2634+15 2792          + LOAD MQ   ZERO         CLEAR MQ
        2635+21   21          + L RIGHT   0021         3 LSB BITS OF LEFT HALF-WORD OF ACC TO MQ
        2636+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 3 BIT)
        2637+12 2798          + STORE     NUM          SAVE BACK NUM WITH RIGHTMOST OCTIONARY DIGIY EXTRACTED (NUM'=NUM/8)
        2638+10 2792          + R ADD     ZERO
        2639+20   21          + L LEFT    0021         LEFT HALF-WORD OF ACC IS NOW RIGHTMOST OCTINARY DIGIT EXTRACTED FROM NUM 
        2640+ 4 2658          + TR 0      PRTIOZ       TR IF THIS DIGIT IS ZERO TO PRINT A '0' (BASE48 CODE = 10) INSTEAD OF A BLANK (BASE48 CODE = 0)
        2641+21   35          + L RIGHT   0035         PUT DIGIT 1..9 TO PRINT IN MQ
        2642+10 2642 PRTOCTD  + R ADD     *            PRINT OCTINARY DIGIT
        2643+ 1 2702          + TR        PRTCHR
        2644+ 0    0 COLN     + STOP      0000
        2645+10 2644          + R ADD     COLN        DECR COL NUMBER TO PRINT NEXT DIGIT
        2646+ 5 2808          + SUB       ONE
        2647+12 2644          + STORE     COLN
        2648+10 2802          + R ADD     LEN          DECR COL NUMBER TO PRINT NEXT DIGIT
        2649+ 5 2808          + SUB       ONE
        2650+ 4 2625          + TR 0      EXIT         PRINTED LEN OCTINARY DIGITS -> EXIT
        2651+12 2802          + STORE     LEN
        2652+10 2798          + R ADD     NUM          IF NUM < 0, ADD SIGN BIT TO LEFTMOST DIGIT
        2653+ 3 2633          + TR +      PRTIOCG
        2654+10 2818          + R ADD     OCT04K       
        2655+ 5 2798          + SUB       NUM
        2656+12 2798          + STORE     NUM
        2657+ 1 2633          + TR        PRTIOCG
        2658+15 2811   PRTIOZ + LOAD MQ   D10          ACC=BASE48 CODE FOR '0'
        2659+ 1 2642          + TR        PRTOCTD      TR TO PRINT IT
        2660+13 2548 PRTINT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2661+10 2661          + R ADD     *            FOR PRINT OCTIONARY VALUE
        2662+ 1 2538          + TR        PRTPARM2
        2663+10 2608          + R ADD     COL          PRINT DECIMAL NUMBER. VALUE OF LEN = DIGITS TO PRINT, NOT INCLUDING SIGN
        2664+ 9 2802          + ADD       LEN
        2665+ 5 2808          + SUB       ONE          
        2666+12 2687          + STORE     COLNI        COL POINTS TO END OF NUMBER
        2667+10 2792          + R ADD     ZERO
        2668+12 2801          + STORE     SGN          SIGN IS POSITIVE
        2669+10 2798          + R ADD     NUM
        2670+ 3 2675          + TR +      PRTINTG
        2671+ 6 2798          + R SUB     NUM          NUM IS NEGATIVE. CONVERT TO POSITIVE
        2672+12 2798          + STORE     NUM          AND SET SGN=1
        2673+10 2808          + R ADD     ONE
        2674+12 2801          + STORE     SGN          
        2675+10 2798 PRTINTG  + R ADD     NUM          GENERATE DECIMAL DIGIT
        2676+21   35          + L RIGHT   0035         MQ=Acc
        2677+10 2792          + R ADD     ZERO
        2678+18 2811          + DIV       D10
        2679+ 4 2700          + TR 0      PRTINZ
        2680+12 2803 PRTINTG2 + STORE     CHAR         acc=remainder=digit to print, mq=num/10
        2681+10 2792          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        2682+20   18          + L LEFT    0018         digit in left half-word of MQ to be saved in CHAR half word
        2683+14 2798          + STORE MQ  NUM 
        2684+15 2803          + LOAD MQ   CHAR 
        2685+10 2685 PRTINTD  + R ADD     *            PRINT DECIMAL DIGIT
        2686+ 1 2702          + TR        PRTCHR
        2687+ 0    0 COLNI    + STOP      0000
        2688+10 2687          + R ADD     COLNI        DECR COL NUMBER TO PRINT NEXT DIGIT
        2689+ 5 2808          + SUB       ONE
        2690+12 2687          + STORE     COLNI
        2691+10 2798          + R ADD     NUM          DO NOT CARE ABOUT LEN, JUST CHECK IF NUM=0 
        2692+ 4 2694          + TR 0      PRTINS       (SO NO MORE DIGITS REMAINS TO BE PRINTED)
        2693+ 1 2675          + TR        PRTINTG      NUM NOT FINISHED, PROCEED WITH NEXT DIGIT
        2694+10 2801 PRTINS   + R ADD     SGN
        2695+ 4 2625          + TR 0      EXIT         NO SIGN -> NUM FINISHED
        2696+10 2792          + R ADD     ZERO
        2697+12 2801          + STORE     SGN          CLEAR SGN FLAG
        2698+15 2812          + LOAD MQ   D11          BASE48 CODE FOR '-' (MINUS) CHAR
        2699+ 1 2685          + TR        PRTINTD      GO TO PRINT IT
        2700+10 2811   PRTINZ + R ADD     D10          ACC=BASE48 CODE FOR '0'
        2701+ 1 2680          + TR        PRTINTG2     TR TO PRINT IT
        2702+ 9 2809 PRTCHR   + ADD       TWO          PRINT CHAR IN MQ REGISTER 
        2703+14 2803          + STORE MQ  CHAR         SAVE CHAR TO PRINT (IN LEFT HALF WORD)
        2704+13 2708          + STORE A   PRTCP2       STORE ADDR OF PARAM (COL)
        2705+ 9 2808          + ADD       ONE
        2706+13 2786          + STORE A   PRTCEX
        2707+ 2 2708          + TR OV     PRTCP2       CLEAR OV JUST IN CASE
        2708+10    0   PRTCP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        2709+ 3 2712          + TR +      PRTCP4
        2710+13 2711          + STORE A   PRTCP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        2711+10    0   PRTCP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        2712+ 5 2808   PRTCP4 + SUB       ONE
        2713+12 2806          + STORE     N            N=COL-1 -> IN RANGE 0..71
        2714+ 3 2716          + TR +      PRTSA        IF N >= 0 PROCEED WITH BASE BUFFER ADDR CALCULATION
        2715+ 1 2786          + TR        PRTCEX       IF N<0 EXIT
        2716+10 2792    PRTSA + R ADD     ZERO         CARD BUFFER USES LOCATION 0..47
        2717+13 2805          + STORE A   PRTROWAD     DETERMINE ADDRESS OF LOWER ROW TO PRINT
        2718+10 2806          + R ADD     N
        2719+ 5 2814          + SUB       D36
        2720+ 3 2722          + TR +      PRTC0
        2721+ 1 2728          + TR        PRTC1
        2722+12 2806    PRTC0 + STORE     N            COL NOW 0..35 
        2723+ 5 2814          + SUB       D36
        2724+ 3 2786          + TR +      PRTCEX       IF COL >= 36 (IE COL PASSED AS PARAM > 72) THEN EXIT
        2725+10 2805          + R ADD     PRTROWAD
        2726+ 9 2809          + ADD       TWO
        2727+13 2805          + STORE A   PRTROWAD     SET BASE BUFFER ADDR 
        2728+10 2808    PRTC1 + R ADD     ONE          DETERMINE MASKCOL WITH MASK TO SET IN CARD BUFFER
        2729+21   53          + L RIGHT   53           SET RIGHTMOST BIT OF MQ TO 1 (SHIFT 35+18=53)
        2730+10 2813          + R ADD     D35
        2731+ 5 2806          + SUB       N
        2732+13 2734          + STORE A   PRTC2
        2733+10 2792          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW
        2734+20    0    PRTC2 + L LEFT    /   /        SHIFT MQ LEFT N PLACES
        2735+ 4 2738          + TR 0      PRTC3        IF ACC STILL ZERO -> MASKCOL VALID
        2736+ 6 2808          + R SUB     ONE          ACC NOT ZERO -> SHOULD GENERATE -0 TO SET SIGN BIT ON
        2737+21   72          + L RIGHT   0072         NOW MQ = -0 -> LEFTMOST BIT OF MQ SET
        2738-14 2794    PRTC3 - STORE MQ  MASKCOL
        2739+10 2792          + R ADD     ZERO         READ THE BITMAP OF CHAR 
        2740+11 2803          + ADD AB    CHAR         DISCARD SIGN OF CHAR, IF ANY
        2741+12 2803          + STORE     CHAR
        2742+ 5 2815          + SUB       D48
        2743+ 3 2786          + TR +      PRTCEX       IF CHAR >= 48 EXIT
        2744+10 2800          + R ADD     BITMAPAD     IF ADDR OF BASE48 BITMAP NOT COMPUTED
        2745+ 4 2787          + TR 0      GETBMP1      TR TO LOAD IT
        2746+ 9 2803  GETBMP2 + ADD       CHAR         READ THE BITMAP OF CHAR 
        2747+13 2748          + STORE A   PRTC4        INDICATES THE BITS TO SET IN SELECTED 
        2748+10    0    PRTC4 + R ADD     /   /        COLUMN OF CARD BUFFER 
        2749+12 2807          + STORE     BITS
        2750+ 6 2808          + R SUB     ONE
        2751+12 2806          + STORE     N            SET TO -1
        2752+10 2806    LOOP1 + R ADD     N            CURRENT ROW (STARTS AT ZERO) = OFFSET ON PRTROWAD     
        2753+ 9 2808          + ADD       ONE
        2754+12 2806          + STORE     N
        2755+10 2807          + R ADD     BITS         EXTRACT RIGHTMOST BIT OF LEFT HALF OF ACC TO MQ
        2756+ 4 2786          + TR 0      PRTCEX       NO MORE BITS -> EXIT
        2757+21   19          + L RIGHT   0019         LSB BIT OF LEFT HALF-WORD OF ACC TO MQ
        2758+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 1 BIT)
        2759+12 2807          + STORE     BITS         SAVE BACK BITS. LSB HAS BEEN EXTACTED, CONTENTS SHIFTED RIGHT ONE PLACE
        2760+10 2792          + R ADD     ZERO
        2761+20    1          + L LEFT    0001         PUT EXTACTED BIT BACK INTO ACC
        2762+ 4 2752          + TR 0      LOOP1        NO BIT 
        2763+10 2806          + R ADD     N            READ THE ROW N AT CARD BUFFER 
        2764+22    2          + A LEFT    0002         MULT N BY 4 AS THERE ARE 4 HALF WORDS PER ROW
        2765+ 9 2805          + ADD       PRTROWAD     
        2766+13 2768          + STORE A   PRTROWR
        2767+13 2784          + STORE A   PRTROWW
        2768-10    0  PRTROWR - R ADD     /   /        
        2769-12 2796          - STORE     ROW          CURRENT CONTENTS OF ROW
        2770-10 2794          - R ADD     MASKCOL      "OR" MASKCOL IN SELECTED ROW
        2771+ 3 2779          + TR +      PRTW2
        2772-10 2796          - R ADD     ROW 
        2773+ 4 2777          + TR 0      PRTW1         
        2774+10 2792          + R ADD     ZERO         MASKCOL IS MINUS ZERO AND ROW IS NOT-EMPTY (EITHER POSITIVE OR NEGATIVE) -> SET ROW AS NEGATIVE
        2775- 7 2796          - SUB AB    ROW 
        2776+ 1 2784          + TR        PRTROWW
        2777-10 2794    PRTW1 - R ADD     MASKCOL      MASKCOL IS MINUS ZERO AND ROW IS EMPTY -> SET ROW = MASKCOL = MINUS ZERO
        2778+ 1 2784          + TR        PRTROWW
        2779-10 2796    PRTW2 - R ADD     ROW          
        2780+ 3 2783          + TR +      PRTW3              
        2781- 5 2794          - SUB       MASKCOL      MASKCOL IS POSITIVE AND ROW IS NEGATIVE -> SUB MASKCOL FROM ROW
        2782+ 1 2784          + TR        PRTROWW
        2783- 9 2794    PRTW3 - ADD       MASKCOL      MASKCOL IS POSITIVE AND ROW IS POSITIVE OR EMPTY -> ADD MASKCOL TO ROW         
        2784-12    0  PRTROWW - STORE     /   /        ROW UPDTATE
        2785+ 1 2752          + TR        LOOP1        PROCEED TO NEXT ROW
        2786+ 1    0 PRTCEX   + TR        /   /
        2787+10 2787 GETBMP1  + R ADD     *
        2788+ 1   91          + TR        BMPAD        GET BASE48 CHARS BITMAP ADDRESS
        2789+12 2800          + STORE     BITMAPAD     
        2790+ 1 2746          + TR        GETBMP2      RETURN
        2791+     0             ORG       EVEN
        2792+     0  ZERO       DEF       0            
        2793+     0             DEF       0            
        2794+     0  MASKCOL    DEF       0
        2795+     0             DEF       0
        2796+     0  ROW        DEF       0
        2797+     0             DEF       0
        2798+     0  NUM        DEF       0
        2799+     0             DEF       0
        2800+     0  BITMAPAD   DEF       0
        2801+     0  SGN        DEF       0
        2802+     0  LEN        DEF       0
        2803+     0  CHAR       DEF       0
        2804+     0  TXT        DEF       0
        2805+     0  PRTROWAD   DEF       0
        2806+     0  N          DEF       0
        2807+     0  BITS       DEF       0
        2808+     1  ONE        DEF       1
        2809+     2  TWO        DEF       2
        2810+     3  D3         DEF       3
        2811+    10  D10        DEF       10
        2812+    11  D11        DEF       11
        2813+    35  D35        DEF       35
        2814+    36  D36        DEF       36
        2815+    48  D48        DEF       48
        2816+    72  D72        DEF       72
        2817+  2304  D48X48     DEF       2304
        2818+ 16384  OCT04K     DEF       *040000      BIT SIGN ON 5TH OCTINARY DIGIT
        2820+ 9 2895 PRTNLINE + ADD       TWO          PRINT A NEW LINE OF DATA
        2821+12 2898          + STORE     PARAM        SAVE PARAM LIST ADDR
        2822+10 2822          + R ADD     *            CLEAR CARD BUFFER
        2823+ 1   53          + TR        CLRBUF 
        2824+10 2898 GPARAM   + R ADD     PARAM        GET PARAM PAIR FMT/DATA
        2825+13 2830          + STORE A   P1
        2826+ 9 2894          + ADD       ONE
        2827+13 2834          + STORE A   P2
        2828+ 9 2894          + ADD       ONE
        2829+12 2898          + STORE     PARAM
        2830+10    0 P1       + R ADD     /   /
        2831+12 2900          + STORE     FMT
        2832+ 3 2834          + TR +      P2           IF FMT < 0 THEM SKIP THIS PAIR FMT/DATA
        2833+ 1 2824          + TR        GPARAM
        2834+10    0 P2       + R ADD     /   /
        2835+12 2860          + STORE     DATALOC      GET DATA ADDRESS PASED AS PARAM
        2836+13 2837          + STORE A   P2A
        2837+10    0 P2A      + R ADD     /   /
        2838+12 2899          + STORE     DATA         GET EFFECTIVE DATA
        2839+10 2893          + R ADD     ZERO
        2840+15 2900          + LOAD MQ   FMT
        2841+18 2897          + DIV       D100         ACC=REMAINDER=COL NUMBER, MQ=QUOTIEN=TYPE OF DATA
        2842+12 2901          + STORE     COL
        2843+10 2893          + R ADD     ZERO
        2844+20   18          + L LEFT    0018
        2845+14 2900          + STORE MQ  FMT
        2846+15 2899          + LOAD MQ   DATA
        2847+10 2851          + R ADD     TYPETRAD
        2848+ 9 2900          + ADD       FMT
        2849+13 2850          + STORE A   TYPETR
        2850+ 1    0 TYPETR   + TR        /   /        TR SELECTED ROUTINE
        2851+ 0 2852 TYPETRAD + STOP      TYPETRT      TYPE TRANSFER TABLE ADDRESS
        2852+ 1 2881 TYPETRT  + TR        EOL          FMT=0..6 (IE <100) -> END OF PARAM LIST -> END OF LINE 
        2853+ 1 2858          + TR        TYSTR        FMT=1 -> PRINT A STRINGZ
        2854+ 1 2863          + TR        TYINT        FMT=2 -> PRINT AN INT
        2855+ 1 2868          + TR        TYOCT        FMT=3 -> PRINT AN OCT
        2856+ 1 2873          + TR        TYCHR        FMT=4 -> PRINT A CHAR
        2857+ 1 2877          + TR        TYALF        FMT=5 -> PRINT A 3-CHR PACKED ALFA STRING
        2858+10 2858 TYSTR    + R ADD     *            PRINT STRINGZ
        2859+ 1   87          + TR        PRTSTR
        2860+ 0    0 DATALOC  + STOP      /   /
        2861- 0 2901          - STOP      COL          COLUMN WHERE TXT STARTS
        2862+ 1 2824          + TR        GPARAM
        2863+10 2863 TYINT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2864+ 1   61          + TR        PRTINT
        2865+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        2866- 0 2901          - STOP      COL          COLUMN WHERE TXT STARTS
        2867+ 1 2824          + TR        GPARAM
        2868+10 2868 TYOCT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2869+ 1   89          + TR        PRTOCT
        2870+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        2871- 0 2901          - STOP      COL          COLUMN WHERE TXT STARTS
        2872+ 1 2824          + TR        GPARAM
        2873+10 2873 TYCHR    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2874+ 1   63          + TR        PRTCHR
        2875- 0 2901          - STOP      COL          COLUMN WHERE TXT STARTS
        2876+ 1 2824          + TR        GPARAM
        2877+10 2877 TYALF    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2878+ 1   59          + TR        PRTALF
        2879- 0 2901          - STOP      COL          COLUMN WHERE TXT STARTS
        2880+ 1 2824          + TR        GPARAM
        2881+10 2901 EOL      + R ADD     COL          SEND CARD BUFFER TO PRINTER AND RETURN TO CALLER
        2882+ 4 2887          + TR 0      DOPRINT      =0 -> PRINT ALLWAYS (NO SENSE SW CHECK)
        2883+ 9 2896          + ADD       D68          =1..6 -> SENSE 69..74 = OPERATOR'S PANEL SENSE SWITCH 1..6
        2884+13 2885          + STORE A   CHKSW
        2885+30    0 CHKSW    + SENSE     /   /         
        2886+ 1 2889          + TR        RETURN       SW NOT AT ON POSITION
        2887+10 2887 DOPRINT  + R ADD     *            PRINT CARD BUFFER
        2888+ 1   57          + TR        PRINTCRD
        2889+10 2898 RETURN   + R ADD     PARAM        PARAM-1 IS THE RETURN ADDR      
        2890+ 5 2894          + SUB       ONE
        2891+13 2892          + STORE A   EXIT
        2892+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        2893+ 0    0 ZERO     + STOP      0000
        2894+ 0    1 ONE      + STOP      0001
        2895+ 0    2 TWO      + STOP      0002
        2896+ 0   68 D68      + STOP      0068
        2897+ 0  100 D100     + STOP      100
        2898+ 0    0 PARAM    + STOP      0000
        2899+ 0    0 DATA     + STOP      0000
        2900+ 0    0 FMT      + STOP      0000
        2901+ 0    0 COL      + STOP      0000
        2902+ 9 2916 BMPAD    + ADD       TWO
        2903+13 2905          + STORE A   EXIT
        2904+10 2906          + R ADD     BITMAPAD
        2905+ 1    0 EXIT     + TR        /   /
        2906+ 0 2908 BITMAPAD + STOP      BITMAP
        2907+     0             ORG       EVEN
        2908+     0  BITMAP     DEF       0              <blank>     0     <none>
        2909+   256             DEF       256               1        1       1        256          =  256   
        2910+   128             DEF       128               2        2       2        128          =  128   
        2911+    64             DEF       64                3        3       3         64          =   64   
        2912+    32             DEF       32                4        4       4         32          =   32   
        2913+    16             DEF       16                5        5       5         16          =   16   
        2914+     8             DEF       8                 6        6       6          8          =    8   
        2915+     4             DEF       4                 7        7       7          4          =    4   
        2916+     2  TWO        DEF       2                 8        8       8          2          =    2   
        2917+     1             DEF       1                 9        9       9          1          =    1   
        2918+   512             DEF       512               0       10       0        512          =  512   
        2919+  1024             DEF       1024              -       11       X       1024          = 1024   
        2920+  2048             DEF       2048              +       12       Y       2048          = 2048   
        2921+  2304             DEF       2304              A       13      Y-1        256+2048    = 2304   
        2922+  2176             DEF       2176              B       14      Y-2        128+2048    = 2176   
        2923+  2112             DEF       2112              C       15      Y-3         64+2048    = 2112   
        2924+  2080             DEF       2080              D       16      Y-4         32+2048    = 2080   
        2925+  2064             DEF       2064              E       17      Y-5         16+2048    = 2064   
        2926+  2056             DEF       2056              F       18      Y-6          8+2048    = 2056   
        2927+  2052             DEF       2052              G       19      Y-7          4+2048    = 2052   
        2928+  2050             DEF       2050              H       20      Y-8          2+2048    = 2050   
        2929+  2049             DEF       2049              I       21      Y-9          1+2048    = 2049   
        2930+  1280             DEF       1280              J       22      X-1        256+1024    = 1280   
        2931+  1152             DEF       1152              K       23      X-2        128+1024    = 1152   
        2932+  1088             DEF       1088              L       24      X-3         64+1024    = 1088   
        2933+  1056             DEF       1056              M       25      X-4         32+1024    = 1056   
        2934+  1040             DEF       1040              N       26      X-5         16+1024    = 1040   
        2935+  1032             DEF       1032              O       27      X-6          8+1024    = 1032   
        2936+  1028             DEF       1028              P       28      X-7          4+1024    = 1028   
        2937+  1026             DEF       1026              Q       29      X-8          2+1024    = 1026   
        2938+  1025             DEF       1025              R       30      X-9          1+1024    = 1025   
        2939+   640             DEF       640               S       31      0-2        128+512     = 640    
        2940+   576             DEF       576               T       32      0-3         64+512     = 576    
        2941+   544             DEF       544               U       33      0-4         32+512     = 544    
        2942+   528             DEF       528               V       34      0-5         16+512     = 528    
        2943+   520             DEF       520               W       35      0-6          8+512     = 520    
        2944+   516             DEF       516               X       36      0-7          4+512     = 516    
        2945+   514             DEF       514               Y       37      0-8          2+512     = 514    
        2946+   513             DEF       513               Z       38      0-9          1+512     = 513    
        2947+   578             DEF       578               ,       39      8-3-0        2+64+512  = 578    
        2948+   546             DEF       546               %       40      8-4-0        2+32+512  = 546    
        2949+  1090             DEF       1090              $       41      8-3-X        2+64+1024 = 1090   
        2950+  1058             DEF       1058              *       42      8-4-X        2+32+1024 = 1058   
        2951+  2114             DEF       2114              .       43      8-3-Y        2+64+2048 = 2114   
        2952+  2082             DEF       2082              #       44      8-4-Y        2+32+2048 = 2082   
        2953+   768             DEF       768               /       45      0-1          512+256   = 768    
        2954+    66             DEF       66                +       46      8-3          2+64      = 66     
        2955+    34             DEF       34                -       47      8-4          2+32      = 34    This is the non-minus-sign separator
        2956+ 9 2980 CLMEM    + ADD       TWO 
        2957+13 2962          + STORE A   P1           PARM: ADDR 
        2958+ 9 2979          + ADD       ONE          
        2959+13 2964          + STORE A   P2           PARM: LOCATION OF LEN=NUMBER OF HALF-WORDS TO CLEAR 
        2960+ 9 2979          + ADD       ONE          
        2961+13 2970          + STORE A   EXIT
        2962+10    0 P1       + R ADD     /   /        GET ADDR TO CLEAR
        2963+13 2973          + STORE A   MEM
        2964+10    0 P2       + R ADD     /   /        GET LEN ADDR
        2965+13 2966          + STORE A   P2A
        2966+10    0 P2A      + R ADD     /   /        GET LEN 
        2967+12 2981          + STORE     LEN
        2968+15 2978          + LOAD MQ   ZERO
        2969+10 2981 LOOP     + R ADD     LEN
        2970+ 4    0 EXIT     + TR 0      /   /
        2971+ 5 2979          + SUB       ONE
        2972+12 2981          + STORE     LEN
        2973+14    0 MEM      + STORE MQ  /   /        
        2974+10 2973          + R ADD     MEM
        2975+ 9 2979          + ADD       ONE
        2976+13 2973          + STORE A   MEM
        2977+ 1 2969          + TR        LOOP
        2978+ 0    0 ZERO     + STOP      0000
        2979+ 0    1 ONE      + STOP      0001         constant 1
        2980+ 0    2 TWO      + STOP      0002         constant 2
        2981+ 0    0 LEN      + STOP      0000
        2982+ 9 3014 MEMCOPY  + ADD       TWO 
        2983+13 2990          + STORE A   P1           PARM: SRCADDR 
        2984+ 9 3013          + ADD       ONE          
        2985+13 2992          + STORE A   P2           PARM: DESTADDR
        2986+ 9 3013          + ADD       ONE          
        2987+13 2994          + STORE A   P3           PARM: LEN: LOCATION OF LEN=NUMBER OF HALF-WORDS TO CLEAR
        2988+ 9 3013          + ADD       ONE          
        2989+13 3000          + STORE A   EXIT
        2990+10    0 P1       + R ADD     /   /        GET SOURCE ADDR 
        2991+13 3003          + STORE A   MEMS
        2992+10    0 P2       + R ADD     /   /        GET DESTINATION ADDR 
        2993+13 3004          + STORE A   MEMD
        2994+10    0 P3       + R ADD     /   /        GET LEN ADDR
        2995+13 2996          + STORE A   P3A
        2996+10    0 P3A      + R ADD     /   /        GET LEN           
        2997+12 3015          + STORE     LEN
        2998+15 3012          + LOAD MQ   ZERO
        2999+10 3015 LOOP     + R ADD     LEN
        3000+ 4    0 EXIT     + TR 0      /   /
        3001+ 5 3013          + SUB       ONE
        3002+12 3015          + STORE     LEN
        3003+10    0 MEMS     + R ADD     /   /        
        3004+12    0 MEMD     + STORE     /   /        
        3005+10 3003          + R ADD     MEMS
        3006+ 9 3013          + ADD       ONE
        3007+13 3003          + STORE A   MEMS
        3008+10 3004          + R ADD     MEMD
        3009+ 9 3013          + ADD       ONE
        3010+13 3004          + STORE A   MEMD
        3011+ 1 2999          + TR        LOOP
        3012+ 0    0 ZERO     + STOP      0000
        3013+ 0    1 ONE      + STOP      0001         constant 1
        3014+ 0    2 TWO      + STOP      0002         constant 2
        3015+ 0    0 LEN      + STOP      0000
        3016+15 3083 SRCHTBL  + LOAD MQ   ZERO
        3017+ 1 3021          + TR        START
        3018+15 3084 EQTBL    + LOAD MQ   ONE
        3019+ 1 3021          + TR        START
        3020+15 3085 READTBL  + LOAD MQ   TWO
        3021+ 9 3085 START    + ADD       TWO 
        3022+13 3029          + STORE A   P1           PARM: ADDR OF TABLE
        3023+ 9 3084          + ADD       ONE          
        3024+13 3031          + STORE A   P2           PARM: LEN OF TABLE
        3025+ 9 3084          + ADD       ONE          
        3026+13 3036          + STORE A   P3           PARM: VAL TO FIND
        3027+ 9 3084          + ADD       ONE          
        3028+13 3077          + STORE A   EXIT
        3029+10    0 P1       + R ADD     /   /        GET ADDR OF TABLE
        3030+13 3080          + STORE A   TBL
        3031+10    0 P2       + R ADD     /   /        GET ADDR OF LEN OF TABLE/ENTRY ON TABLE
        3032+13 3033          + STORE A   P2A
        3033+10    0 P2A      + R ADD     /   /        DERREFERENCE -> ACC=LEN/ENTRY (1..LEN)
        3034+12 3078          + STORE     N
        3035+ 4 3077          + TR 0      EXIT         EXIT, CANNOT READ/STORE ON ENTRY 0, SEARCH ON EMPTY TABLE
        3036+10    0 P3       + R ADD     /   /        GET ADDR OF VAL TO FIND
        3037+13 3053          + STORE A   WRVAL
        3038+13 3039          + STORE A   P3A
        3039+10    0 P3A      + R ADD     /   /        DERREFERENCE -> ACC=VAL
        3040+12 3079          + STORE     VAL
        3041+14 3082          + STORE MQ  TEMP         JUMP TABLE DISPATCH
        3042+10 3082          + R ADD     TEMP
        3043+ 4 3058          + TR 0      LOOP0        TR TO SEARCH TABLE
        3044+10 3078          + R ADD     N            SUB ONE AS FIRST ENTRY ON TABLE IS "1"
        3045+ 5 3084          + SUB       ONE          
        3046+ 9 3080          + ADD       TBL          TABLE BASE ADDR
        3047+13 3056          + STORE A   WRTBL
        3048+13 3052          + STORE A   RDTBL2
        3049+10 3082          + R ADD     TEMP
        3050+ 5 3084          + SUB       ONE
        3051+ 4 3055          + TR 0      STORETBL 
        3052+10    0 RDTBL2   + R ADD     /   /        VAL=TBL[ENT]
        3053+12    0 WRVAL    + STORE     /   /
        3054+ 1 3077          + TR        EXIT
        3055+10 3079 STORETBL + R ADD     VAL          TBL[ENT]=VAL
        3056+12    0 WRTBL    + STORE     /   /    
        3057+ 1 3077          + TR        EXIT
        3058+10 3080 LOOP0    + R ADD     TBL
        3059+13 3065          + STORE A   RDTBL
        3060+10 3065          + R ADD     RDTBL
        3061+12 3081          + STORE     TBL0
        3062+ 9 3078          + ADD       N
        3063+12 3082          + STORE     TEMP         THE END ADDR OF TABLE
        3064+10 3079 LOOP     + R ADD     VAL          ACC=THE SEARCHED VALUE
        3065+ 5    0 RDTBL    + SUB       /   /    
        3066+ 2 3067          + TR OV     OVOK         CLEAR OV JUST IN CASE
        3067+ 4 3074 OVOK     + TR 0      FOUND        TR IF VAL FOUND IN ENTRY N
        3068+10 3065          + R ADD     RDTBL
        3069+ 9 3084          + ADD       ONE
        3070+13 3065          + STORE A   RDTBL
        3071+ 5 3082          + SUB       TEMP
        3072+ 4 3077          + TR 0      EXIT         NOT FOUND -> RETURN ZERO
        3073+ 1 3064          + TR        LOOP
        3074+10 3065 FOUND    + R ADD     RDTBL        RETURN ENTRY FOUND
        3075+ 5 3081          + SUB       TBL0
        3076+ 9 3084          + ADD       ONE
        3077+ 1    0 EXIT     + TR        /   /
        3078+ 0    0 N        + STOP      0000
        3079+ 0    0 VAL      + STOP      0000
        3080+ 0    0 TBL      + STOP      0000
        3081+ 0    0 TBL0     + STOP      0000
        3082+ 0    0 TEMP     + STOP      0000
        3083+ 0    0 ZERO     + STOP      0000
        3084+ 0    1 ONE      + STOP      0001         constant 1
        3085+ 0    2 TWO      + STOP      0002         constant 2
        3086+ 9 3127 READTBL2 + ADD       TWO 
        3087+13 3094          + STORE A   P1           PARM: ADDR OF TABLE
        3088+ 9 3126          + ADD       ONE          
        3089+13 3096          + STORE A   P2           PARM: MAX LEN OF TABLE
        3090+ 9 3126          + ADD       ONE          
        3091+13 3100          + STORE A   P3           PARM: ENT TO GET
        3092+ 9 3126          + ADD       ONE          
        3093+13 3107          + STORE A   PVAL         PARM: VAL TO GET
        3094+10    0 P1       + R ADD     /   /        GET ADDR OF TABLE
        3095+13 3125          + STORE A   TBL
        3096+10    0 P2       + R ADD     /   /        GET ADDR OF MAX LEN OF TABLE
        3097+13 3098          + STORE A   P2A
        3098+10    0 P2A      + R ADD     /   /        DERREFERENCE -> ACC=MAX
        3099+12 3124          + STORE     MAX
        3100+10    0 P3       + R ADD     /   /        GET ADDR OF ENTRY TO GET
        3101+13 3102          + STORE A   P3A
        3102+10    0 P3A      + R ADD     /   /        DERREFERENCE -> ACC=ENT
        3103+ 4 3119          + TR 0      ENT0         EXIT, CANNOT READ ON ENTRY 0
        3104+ 5 3126          + SUB       ONE          
        3105+ 9 3125          + ADD       TBL          TABLE BASE ADDR
        3106+13 3110          + STORE A   RDTBL        TBL[ENT] ADDRESS
        3107+10    0 PVAL     + R ADD     /   /        GET ADDR OF VAL TO FIND
        3108+ 4 3120          + TR 0      PARAMEND     END OF PARAM LIST
        3109+13 3111          + STORE A   WRVAL
        3110+10    0 RDTBL    + R ADD     /   /        VAL=TBL[ENT]
        3111+12    0 WRVAL    + STORE     /   /
        3112+10 3107          + R ADD     PVAL         SELECT NEXT PARAM FROM LIST
        3113+ 9 3126          + ADD       ONE
        3114+13 3107          + STORE A   PVAL
        3115+10 3110          + R ADD     RDTBL
        3116+ 9 3124          + ADD       MAX
        3117+13 3110          + STORE A   RDTBL
        3118+ 1 3107          + TR        PVAL     
        3119+ 0 2222 ENT0     + STOP      2222         CANNOT READTBL ON ENTRY 0
        3120+10 3107 PARAMEND + R ADD     PVAL         GET RETURN ADDR AND EXIT
        3121+ 9 3126          + ADD       ONE
        3122+13 3123          + STORE A   EXIT
        3123+ 1    0 EXIT     + TR        /   /
        3124+ 0    0 MAX      + STOP      0000
        3125+ 0    0 TBL      + STOP      0000
        3126+ 0    1 ONE      + STOP      0001         constant 1
        3127+ 0    2 TWO      + STOP      0002         constant 2
        3128+ 9 3169 EQTBL2   + ADD       TWO 
        3129+13 3136          + STORE A   P1           PARM: ADDR OF TABLE
        3130+ 9 3168          + ADD       ONE          
        3131+13 3138          + STORE A   P2           PARM: MAX LEN OF TABLE
        3132+ 9 3168          + ADD       ONE          
        3133+13 3142          + STORE A   P3           PARM: ENT TO SET
        3134+ 9 3168          + ADD       ONE          
        3135+13 3149          + STORE A   PVAL         PARM: VAL TO SET
        3136+10    0 P1       + R ADD     /   /        GET ADDR OF TABLE
        3137+13 3167          + STORE A   TBL
        3138+10    0 P2       + R ADD     /   /        GET ADDR OF MAX LEN OF TABLE
        3139+13 3140          + STORE A   P2A
        3140+10    0 P2A      + R ADD     /   /        DERREFERENCE -> ACC=MAX
        3141+12 3166          + STORE     MAX
        3142+10    0 P3       + R ADD     /   /        GET ADDR OF ENTRY TO SET
        3143+13 3144          + STORE A   P3A
        3144+10    0 P3A      + R ADD     /   /        DERREFERENCE -> ACC=ENT
        3145+ 4 3161          + TR 0      ENT0         EXIT, CANNOT READ ON ENTRY 0
        3146+ 5 3168          + SUB       ONE          
        3147+ 9 3167          + ADD       TBL          TABLE BASE ADDR
        3148+13 3153          + STORE A   WRTBL        TBL[ENT] ADDRESS
        3149+10    0 PVAL     + R ADD     /   /        GET ADDR OF VAL TO SET
        3150+ 4 3162          + TR 0      PARAMEND     END OF PARAM LIST
        3151+13 3152          + STORE A   RDVAL
        3152+10    0 RDVAL    + R ADD     /   /        TBL[ENT]=VAL
        3153+12    0 WRTBL    + STORE     /   /
        3154+10 3149          + R ADD     PVAL         SELECT NEXT PARAM FROM LIST
        3155+ 9 3168          + ADD       ONE
        3156+13 3149          + STORE A   PVAL
        3157+10 3153          + R ADD     WRTBL
        3158+ 9 3166          + ADD       MAX
        3159+13 3153          + STORE A   WRTBL
        3160+ 1 3149          + TR        PVAL     
        3161+ 0 2222 ENT0     + STOP      2222         CANNOT EQTBL ON ENTRY 0
        3162+10 3149 PARAMEND + R ADD     PVAL         GET RETURN ADDR AND EXIT
        3163+ 9 3168          + ADD       ONE
        3164+13 3165          + STORE A   EXIT
        3165+ 1    0 EXIT     + TR        /   /
        3166+ 0    0 MAX      + STOP      0000
        3167+ 0    0 TBL      + STOP      0000
        3168+ 0    1 ONE      + STOP      0001         constant 1
        3169+ 0    2 TWO      + STOP      0002         constant 2
        3170+ 9 3243 RWDRUM   + ADD       TWO 
        3171+13 3180          + STORE A   PDR1         PARM1: DRUM INSTR: READ/WRITE 0128  0129  0130  0131
        3172+ 9 3242          + ADD       ONE          
        3173+13 3182          + STORE A   PDR2         PARM2: DRUM ADDRESS (0..4094)
        3174+ 9 3242          + ADD       ONE          
        3175+13 3184          + STORE A   PDR3         PARM3: BUF START ADDRESS
        3176+ 9 3242          + ADD       ONE          
        3177+13 3186          + STORE A   PDR4         PARM4: LEN: NUMBER OF HALF-WORDS (MUST BE EVEN)
        3178+ 9 3242          + ADD       ONE          
        3179+13 3240          + STORE A   EXIT               
        3180+10    0 PDR1     + R ADD     /   /        GET DRUM INSTR
        3181+12 3188          + STORE     DRIO
        3182+10    0 PDR2     + R ADD     /   /        GET DRUM ADDR
        3183+13 3189          + STORE A   DRADDR
        3184+10    0 PDR3     + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        3185+13 3227          + STORE A   RWCOPY    
        3186+10    0 PDR4     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        3187+12 3244          + STORE     LEN
        3188+ 0    0 DRIO     + STOP      /   /        INSTR: READ/WRITE 0128  0129  0130  0131
        3189+29    0 DRADDR   + SET DR    /   /
        3190+ 1 3223          + TR        LOOP
        3191+ 9 3243 RDTAPE   + ADD       TWO 
        3192+13 3199          + STORE A   PR1          PARM1: TAPE ADDRESS
        3193+ 9 3242          + ADD       ONE          
        3194+13 3201          + STORE A   PR2          PARM2: BUF START ADDRESS
        3195+ 9 3242          + ADD       ONE          
        3196+13 3240          + STORE A   EXIT
        3197+ 2 3198          + TR OV     CLOV1        CLEAR OV THAT MAY HAVE BEEN SET
        3198+ 8    0    CLOV1 + NOOP      0000
        3199+10    0 PR1      + R ADD     /   /        GET TAPE ADDR
        3200+13 3203          + STORE A   RTAPAD       TAPE UNITS: 0256  0257  0258  0259
        3201+10    0 PR2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        3202+13 3227          + STORE A   RWCOPY    
        3203+24    0 RTAPAD   + READ      /   /
        3204+10 3241          + R ADD     ZERO
        3205+ 1 3225          + TR        LOOP1
        3206+ 9 3243 WRTAPE   + ADD       TWO 
        3207+13 3214          + STORE A   PW1          PARM1: TAPE ADDRESS
        3208+ 9 3242          + ADD       ONE          
        3209+13 3216          + STORE A   PW2          PARM2: BUF START ADDRESS
        3210+ 9 3242          + ADD       ONE          
        3211+13 3218          + STORE A   PW3          PARM3: BUF LEN
        3212+ 9 3242          + ADD       ONE          
        3213+13 3240          + STORE A   EXIT
        3214+10    0 PW1      + R ADD     /   /        GET TAPE ADDR
        3215+13 3222          + STORE A   WTAPAD       TAPE UNITS: 0256  0257  0258  0259
        3216+10    0 PW2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        3217+13 3227          + STORE A   RWCOPY    
        3218+10    0 PW3      + R ADD     /   /        GET ADDR OF LEN 
        3219+13 3220          + STORE A   PW3A
        3220+10    0 PW3A     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        3221+12 3244          + STORE     LEN
        3222+26    0 WTAPAD   + WRITE     /   /        PREPARE TO WRITE ON TAPE
        3223+10 3244 LOOP     + R ADD     LEN
        3224+ 4 3239          + TR 0      RWOK
        3225+ 5 3243 LOOP1    + SUB       TWO
        3226+12 3244          + STORE     LEN
        3227-31    0 RWCOPY   - COPY      /   /        WRITE BUFFER TO TAPE
        3228+ 1 3231          + TR        GO 
        3229+ 1 3235          + TR        EOF          END OF FILE
        3230+ 1 3237          + TR        EOR          END OF RECORD
        3231+10 3227 GO       + R ADD     RWCOPY
        3232+ 5 3243          + SUB       TWO
        3233+13 3227          + STORE A   RWCOPY
        3234+ 1 3223          + TR        LOOP
        3235+10 3242 EOF      + R ADD     ONE          SET OV FLAG TO SIGNAL END OF FILE CONDITION
        3236+22   36          + A LEFT    36
        3237+ 6 3244 EOR      + R SUB     LEN          RETURN NUMBER OF HALF-WORDS READ
        3238+ 5 3243          + SUB       TWO
        3239+26 2052 RWOK     + WRITE     2052         INSURE THAT MQ NOT IN USE            
        3240+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        3241+ 0    0 ZERO     + STOP      0000
        3242+ 0    1 ONE      + STOP      0001         
        3243+ 0    2 TWO      + STOP      0002         
        3244+     0  LEN        RES       1
        3246+ 9 3261 CHAIN    + ADD       TWO
        3247+13 3248          + STORE A   CHP1
        3248+10    0 CHP1     + R ADD     /   /        GET TAPE NUMBER
        3249+13 3256          + STORE A   TAPELOAD
        3250+30   70          + SENSE     0070         SENSE SWITCH 2                                  
        3251+ 1 3255 CONTAD   + TR        ENDSTOP      (ON POSITION MAKES SENSE OPCODE TO SKIP NEXT INSTR)
        3252+10 3251          + R ADD     CONTAD       IF SW2 IS ON, A +STOP 4095 IS EXECUTED.  
        3253+12 4095          + STORE     4095         IF THEN USER PRESS START, EXECUTION WILL BE RESUMED 
        3254+ 0 4095          + STOP      4095         AND CHAINED PROGRAM WILL BE LOADED AND EXECUTED
        3255+ 8    0 ENDSTOP  + NOOP      0000
        3256+24    0 TAPELOAD + READ      0000         
        3257-31    0 TL0      - COPY      0000         READ 1ST WORD OF SELF-LOADER FROM TAPE
        3258+ 1    0          + TR        0000         TR TO SELF-LOADER
        3259+ 0 2221          + STOP      2221         ERROR LOADING: UNEXPECTED END OF FILE
        3260+ 0 2222          + STOP      2222         ERROR LOADING: UNEXPECTED END OF RECORD 
        3261+ 0    2 TWO      + STOP      0002         ERROR LOADING: UNEXPECTED END OF FILE
          48-     0  ROUTINE INIT
          49+ 1  120 ENTRY POINT
          50-     0  ROUTINE CHAIN
          51+ 1 3246 ENTRY POINT
          52-     0  ROUTINE CLRBUF
          53+ 1 2490 ENTRY POINT
          54-     0  ROUTINE PRTNLINE
          55+ 1 2820 ENTRY POINT
          56-     0  ROUTINE PRINTCRD
          57+ 1 2498 ENTRY POINT
          58-     0  ROUTINE PRTALF
          59+ 1 2582 ENTRY POINT
          60-     0  ROUTINE PRTINT
          61+ 1 2660 ENTRY POINT
          62-     0  ROUTINE PRTCHR
          63+ 1 2702 ENTRY POINT
          64-     0  ROUTINE RDTAPE
          65+ 1 3191 ENTRY POINT
          66-     0  ROUTINE WRTAPE
          67+ 1 3206 ENTRY POINT
          68-     0  ROUTINE EQTBL
          69+ 1 3018 ENTRY POINT
          70-     0  ROUTINE EQTBL2
          71+ 1 3128 ENTRY POINT
          72-     0  ROUTINE READTBL
          73+ 1 3020 ENTRY POINT
          74-     0  ROUTINE READTBL2
          75+ 1 3086 ENTRY POINT
          76-     0  ROUTINE SRCHTBL
          77+ 1 3016 ENTRY POINT
          78-     0  ROUTINE CLMEM
          79+ 1 2956 ENTRY POINT
          80-     0  ROUTINE MEMCOPY
          81+ 1 2982 ENTRY POINT
          82-     0  ROUTINE READCRD
          83+ 1 2494 ENTRY POINT
          84-     0  ROUTINE WRITECRD
          85+ 1 2496 ENTRY POINT
          86-     0  ROUTINE PRTSTR
          87+ 1 2559 ENTRY POINT
          88-     0  ROUTINE PRTOCT
          89+ 1 2626 ENTRY POINT
          90-     0  ROUTINE BMPAD
          91+ 1 2902 ENTRY POINT
          92-     0  ROUTINE RWDRUM
          93+ 1 3170 ENTRY POINT
        4094+    48  REGION ORIGIN TABLE LOCATION
        4095+   120  INITIAL REGION
           0+ 1  120          + TR        INIT         PROGRAM START
