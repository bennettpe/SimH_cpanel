        DEC
        NNNN OP ADDR COMMENTS
          98+ 9 2548 ADDREF   + ADD       TWO          ADD STEP REFERENCE/SYMBOL IF DOES NOT EXISTS
          99+13  102          + STORE A   ADREP1       PARAMS: REF (<0 -> IS THE ALFA NAME OF A SYMBOL REFERENCED, >0 IS A STEPN REFERENCED)
         100+ 9 2547          + ADD       ONE          IF REFERENCE ALREADY EXITS -> DO NOT ADD TO TABLE
         101+13  156          + STORE A   ADDREFEX     IF REFERENCE DOES NOT EXISTS -> ADD IT
         102+10    0 ADREP1   + R ADD     /   /
         103+13  104          + STORE A   ADREP1B
         104+10    0 ADREP1B  + R ADD     /   /
         105+12 2562          + STORE     REF          THE REFERENCE TO ADD
         106+ 3  136          + TR +      ADDSTEP      IF >= 0 -> ADD A STEPN REFERENCED
         107+10  107          + R ADD     *            
         108+ 1   73          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         109+ 0 1344 TSYMBAD  + STOP      TSYMBREF     ... REFERENCES TABLE
         110+ 0 1343          + STOP      NSYMBS       ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NREGIONS 
         111+ 0 2562          + STOP      REF          ... THE VALUE TO FIND 
         112+ 4  117          + TR 0      ADDNEWRF     REF IS NOT FOUND -> TR TO ADD IT
         113+ 1  156          + TR        ADDREFEX     REF IS ALREADY IN LIST -> JUST EXIT. ACC=THE ENTRY FOUND
         114+10  114 ERRORSOV + R ADD     *            
         115+ 1  478          + TR        ERROR
         116+ 0 2584          + STOP      ERRSOV       TOO MANY SYMBOL REFERENCES IN THE WHOLE PROGRAM
         117+10 1343 ADDNEWRF + R ADD     NSYMBS       INCR NUM OF SYMBOLS DEFINED
         118+ 9 2547          + ADD       ONE
         119+12 1343          + STORE     NSYMBS       
         120+ 5 1342          + SUB       MAXNSYMB
         121+ 3  114          + TR +      ERRORSOV     ERROR IF > TABLE SIZE
         122+10  122          + R ADD     *            STORE REF IN SYMBOL TABLE
         123+ 1   75          + TR        EQTBL
         124+ 0 1344          + STOP      TSYMBREF     
         125+ 0 1343          + STOP      NSYMBS       
         126+ 0 2562          + STOP      REF          TSYMBREF[NSYMBS] = 
         127+ 6 2547          + R SUB     ONE
         128+12 2562          + STORE     REF
         129+10  129          + R ADD     *            INIT SYMBOL EXTENSION
         130+ 1   75          + TR        EQTBL
         131+ 0 1944          + STOP      TSYMBEXT
         132+ 0 1343          + STOP      NSYMBS       
         133+ 0 2562          + STOP      REF          TSYMBEXT[NSYMBS] = -1
         134+10 1343          + R ADD     NSYMBS       ACC=NSYMB=ENTRY JUST CREATED
         135+ 1  156          + TR        ADDREFEX     RETURN TO CALLER
         136+10  136 ADDSTEP  + R ADD     *            
         137+ 1   73          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         138+ 0  942          + STOP      TSTEPREF     ... REFERENCES TABLE
         139+ 0  941          + STOP      NREFS        ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NREGIONS 
         140+ 0 2562          + STOP      REF          ... THE VALUE TO FIND 
         141+ 4  146          + TR 0      ADDREF4      REF IS NOT TO NOT FOUND -> TR TO ADD IT
         142+ 1  156          + TR        ADDREFEX     REF IS ALREADY IN LIST -> JUST EXIT
         143+10  143 ERRORROV + R ADD     *            
         144+ 1  478          + TR        ERROR
         145+ 0 2571          + STOP      ERRROV       TOO MANY STEP REFERENCES IN THIS REGION 
         146+10  941 ADDREF4  + R ADD     NREFS        INCR NUM OF REFERENCED STEPS
         147+ 9 2547          + ADD       ONE
         148+12  941          + STORE     NREFS     
         149+ 5  940          + SUB       MAXNREFS
         150+ 3  143          + TR +      ERRORROV     ERROR IF > TABLE SIZE
         151+10  151          + R ADD     *            STORE FIELDS TO TREF TABLES
         152+ 1   75          + TR        EQTBL
         153+ 0  942          + STOP      TSTEPREF     
         154+ 0  941          + STOP      NREFS     
         155+ 0 2562          + STOP      REF          TSTEPREF[NREFS] = 
         156+ 1    0 ADDREFEX + TR        /   /        RETURN TO CALLER
         157+ 9 2548 LOADCC   + ADD       TWO          LOAD PACTSCR INTO CARD IMAGE SO 
         158+13  177          + STORE A   CPCCEX       CURRENT PACT SOURCE CODE CAN BE PRINTED
         159+10 2545          + R ADD     ZERO         COPY TO LEFT SIDE OF SOURCE CODE CARD IMAGE
         160+13  164          + STORE A   CPCC1        AT 0..46 FROM PACTSCR
         161+10  180          + R ADD     CPCC2
         162+13  163          + STORE A   CPCC 
         163-10    0 CPCC     - R ADD     /   /
         164-12    0 CPCC1    - STORE     /   /
         165+10  164          + R ADD     CPCC1
         166+ 5 2548          + SUB       TWO
         167+13  169          + STORE A   CPCC1B
         168+10 2545          + R ADD     ZERO
         169-12    0 CPCC1B   - STORE     /   /
         170+10  163          + R ADD     CPCC
         171+ 5 2548          + SUB       TWO
         172+13  163          + STORE A   CPCC
         173+10  164          + R ADD     CPCC1
         174+ 5 2549          + SUB       D4
         175+13  164          + STORE A   CPCC1
         176+ 5  179          + SUB       CPCCE
         177+ 4    0 CPCCEX   + TR 0      /   /        RETURN TO CALLER
         178+ 1  163          + TR        CPCC
         179-12   48 CPCCE    - STORE     0048         LAST LOCATION TO COPY FROM 
         180+ 8  490 CPCC2    + NOOP      PACTSRC      PACTSRC = FIRST LOCATION TO COPY FROM
         181+10  181 INIT     + R ADD     *            
         182+ 1   53          + TR        PRTNLINE     
         183+ 0  101          + STOP      0101         STRINGZ AT COL 1
         184+ 0 2599          + STOP      MSGSTART     "FINAL ASSEMBLY PASS 1"
         185+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         186+10 2545          + R ADD     ZERO         CLEAR CC RECORD
         187+12  514          + STORE     REGION     
         188+12  515          + STORE     STEP       
         189+12  516          + STORE     OP         
         190+12  517          + STORE     FACT       
         191+12  518          + STORE     S1         
         192+12  519          + STORE     S2         
         193+12  520          + STORE     QR         
         194+12  521          + STORE     QF         
         195-12  522          - STORE     NUM        
         196+12  524          + STORE     CLUE       
         197+12  525          + STORE     STEPN      
         198+12  526          + STORE     FACTN      
         199+12  527          + STORE     FACTREG    
         200+12  528          + STORE     S1N        
         201+12  529          + STORE     S2N        
         202+12  530          + STORE     D1N        
         203+12  531          + STORE     D2N        
         204+12  532          + STORE     NINST      
         205+12  533          + STORE     NINCR 
         206+10  734          + R ADD     CCLEN        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         207+10 2544          + R ADD     MAXNINST     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         208+10  738          + R ADD     MAXNCONS     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         209+10  209          + R ADD     *            CLEAR TABLES
         210+ 1   67          + TR        CLMEM        
         211+ 0 1944          + STOP      TSYMBEXT     EXTENSION (=SIZE) FOR DEFINED SYMBOLS
         212+ 0 1342          + STOP      MAXNSYMB
         213+10 2545          + R ADD     ZERO
         214+12 1343          + STORE     NSYMBS       NUMBER OF ENTRIES IN TSYMBREF GLOBAL SYMBOL TABLE
         215+28  259          + REWIND    TAPEOUTR     WILL READ INPUT TAPE IN BACKWARD DIRECTION FROM ITS CURRENT 
         216+28  258          + REWIND    TAPEOUT      POSITION-> DO NOT REWIND IT. JUST REWIND TAPE OUT WITH 
         217+10 2545 READREG  + R ADD     ZERO
         218+12  941          + STORE     NREFS        INIT STEP REFERENCES FOR THIS REGION
         219+10 2545          + R ADD     ZERO
         220+12 2561          + STORE     IRELADDR     I RELATIVE LOCATION OF THIS STEP
         221+12  739          + STORE     NLOCONST
         222+10  222 READSTEP + R ADD     *            READ PACT USER PROGRAM SOURCE CODE FROM TAPE IN
         223+ 1  428          + TR        RDCC
         224+ 2  375          + TR OV     EOF          TR IF END OF FILE
         225+10  516          + R ADD     OP
         226+ 4  328          + TR 0      EOR          TR IF END OF REGION
         227+10  227          + R ADD     *            LOAD PACTSCR INTO CARD IMAGE SO 
         228+ 1  157          + TR        LOADCC       CURRENT PACT SOURCE CODE CAN BE PRINTED
         229+10  516          + R ADD     OP
         230+ 5 2551          + SUB       D100
         231+ 4  455          + TR 0      RDNCONST     IF OP=100 TR TO READ FROM TAPE OP=100 CC RECORD, 
         232+10  941          + R ADD     NREFS
         233+ 9 1343          + ADD       NSYMBS
         234+12 2560          + STORE     SVNREFS      SAVE NUMBER OF WHOLE REFS BEFORE PROCESSING THIS STEP
         235+10  516          + R ADD     OP
         236+ 5 2550          + SUB       OPNCONST     OP=44 -> LOADS LOOP CONSTANTS POOL FROM TINST
         237+ 4  239          + TR 0      LDN1
         238+ 1  241          + TR        LDN2
         239+10  239 LDN1     + R ADD     *
         240+ 1  466          + TR        LDNCONST
         241+ 8  241 LDN2     + NOOP      *
         242+10 2561          + R ADD     IRELADDR     IF FIRST INSTR OF REGION BODY THEN ...
         243+ 5 2547          + SUB       ONE
         244+ 3  249          + TR +      MC0
         245+10  245          + R ADD     *            ADD THIS REGION TO TSYMBREF IF NOT YET IN THE TABLE
         246+ 1   98          + TR        ADDREF      
         247+ 0  514          + STOP      REGION       THE DEFINED REGION (REGION<0 -> IS A SYMBOL ALFA NAME)
         248+12 2553          + STORE     NREGION      NREGION  = THE ENTRY IN TSYMBREF FOR THIS REGION
         249+10 2561 MC0      + R ADD     IRELADDR     INCR I RELATIVE LOCATION 
         250+ 9  532          + ADD       NINST        NUMBER OF INST IN THIS STEP
         251+12 2561          + STORE     IRELADDR     
         252+ 5 2552          + SUB       D4094
         253+ 3  325          + TR +      ERRTOOBI     ERROR: REGION TOO BIG
         254+10 2545          + R ADD     ZERO         CHECK INSTR GENERATED IN THIS STEP 
         255+12 2557          + STORE     MCNUM        ADD TO TREFS TABLE THE STEPN REFERENCED
         256+10 2557 MCLOOP   + R ADD     MCNUM
         257+ 5  532          + SUB       NINST
         258+ 4  296          + TR 0      NEXT         TR TO PROCESS NEXT STEP IF ALL NINST INSTRUCTIONS PRINTED
         259+10 2557          + R ADD     MCNUM        INCR COUNT
         260+ 9 2547          + ADD       ONE
         261+12 2557          + STORE     MCNUM        GET MC INSTR FROM TINST[ (PRTMCNUM-1)*2 ]
         262+ 9 2557          + ADD       MCNUM
         263+ 5 2548          + SUB       TWO
         264+ 9  284          + ADD       TINSTAD
         265+13  270          + STORE A   MCAD1
         266+ 9 2547          + ADD       ONE
         267+13  274          + STORE A   MCAD2
         268+10 2545          + R ADD     ZERO
         269+12 2555          + STORE     MC.REG       INIT REGION REFERENCED BY MC
         270+10    0 MCAD1    + R ADD     /   /
         271+13 2555          + STORE A   MC.REG
         272+23   12          + A RIGHT   0012
         273+12 2554          + STORE     MC.OP        MC.OP HAS NOW THE SIGNED OPCODE -31..31 
         274+10    0 MCAD2    + R ADD     /   /
         275+12 2556          + STORE     MC.ADDR
         276+ 3  286          + TR +      MC3          IF MC.ADDR >=0 THEN MC.REG HOLDS THE REGION FOR MC.ADDR 
         277+ 6 2556          + R SUB     MC.ADDR      LOCATION IN STEP GIVEN BY MC.ADDR. 
         278+ 4  285          + TR 0      BADREF       INTERNAL COMPILER ERROR: CANNOT REFERENCE STEP ZERO
         279+12 2558          + STORE     TRSTEPN      MAKES MC.ADDR POSITIVE. IT IS THE DESTINATION STEP
         280+10  280          + R ADD     *            PROCESS A STEPN REFERENCE
         281+ 1   98          + TR        ADDREF
         282+ 0 2558          + STOP      TRSTEPN      THE REFERENCED STEPN (TRSTEPN>0 -> IS A STEPN NUMBER)
         283+ 1  295          + TR        MC9
         284+ 0  534 TINSTAD  + STOP      TINST  
         285+ 0 1111 BADREF   + STOP      1111    
         286+10 2555 MC3      + R ADD     MC.REG       IF MS.REG='S' THEN ...
         287+ 5 2623          + SUB       REG.S
         288+ 4  290          + TR 0      MC4          ... TR TO PROCESS A SYMBOL REFERENCE
         289+ 1  295          + TR        MC9
         290+ 6 2556 MC4      + R SUB     MC.ADDR      PROCESS A SYMBOL REFERENCE
         291+12 2559          + STORE     TRSYMBOL     MAKES MC.ADDR NEGATIVE. IT IS THE DESTINATION ALFA SYMBOL
         292+10  292          + R ADD     *
         293+ 1   98          + TR        ADDREF
         294+ 0 2559          + STOP      TRSYMBOL     THE REFERENCED SYMBOL (TRSYMBOL<0 -> IS A SYMBOL ALFA NAME)
         295+ 1  256 MC9      + TR        MCLOOP
         296+ 8    0 NEXT     + NOOP      0000         SAVE COMPACT CODE RECORD IN TAPE
         297+10  734          + R ADD     CCLEN        SAVE MC INSTRUCTIONS GENERATED SO FAR
         298+ 9  532          + ADD       NINST        ADD NINST TWICE AS EACH MC INSTR USES TWO HALF-WORDS
         299+ 9  532          + ADD       NINST
         300+12  735          + STORE     N
         301+10  301          + R ADD     *
         302+ 1   63          + TR        WRTAPE       WRITE MAGNETIC TAPE TAPEOUT (PACT COMPACT CODE)
         303+ 0  258          + STOP      TAPEOUT
         304+ 0  490          + STOP      CCODE        BUF TO WRITE TO TAPE
         305+ 0  735          + STOP      N            LEN
         306+30   74          + SENSE     0074         SENSE SWITCH 6
         307+ 1  323          + TR        ENDLOG1      TR IF NO LOG SELECTED
         308+10  941          + R ADD     NREFS        GET NUMBER OF REFS BEFORE PROCESSING THIS STEP
         309+ 9 1343          + ADD       NSYMBS
         310+ 5 2560          + SUB       SVNREFS
         311+ 4  321          + TR 0      EL1A
         312+21   35          + L RIGHT   0035         MQ=ACC=NUMBER OF REFERENCES ADDED IN THIS STEP
         313+10  313          + R ADD     *
         314+ 1   59          + TR        PRTINT
         315+ 0    2          + STOP      0002         LEN=2
         316+ 0   40          + STOP      0040         COL 40
         317+10  317          + R ADD     *
         318+ 1   57          + TR        PRTSTR
         319+ 0 2618          + STOP      MSGREF       "REF"
         320+ 0   43          + STOP      0043         COL 43
         321+10  321 EL1A     + R ADD     *            PRINT STEP JUST PROCESSED
         322+ 1   55          + TR        PRINTCRD
         323+ 8    0 ENDLOG1  + NOOP      0000 
         324+ 1  222          + TR        READSTEP
         325+10  325 ERRTOOBI + R ADD     *
         326+ 1  478          + TR        ERROR
         327+ 0 2565          + STOP      ERRTOOBG     ERROR: REGION TOO BIG
         328+ 8    0 EOR      + NOOP      0000         END OF REGION  
         329+10  329          + R ADD     *            WRITE THE OP=0 EOR RECORD
         330+ 1   63          + TR        WRTAPE       WRITE MAGNETIC TAPE TAPEOUT (PACT COMPACT CODE)
         331+ 0  258          + STOP      TAPEOUT
         332+ 0  490          + STOP      CCODE        BUF TO WRITE TO TAPE
         333+ 0  734          + STOP      CCLEN        LEN
         334+10 2561          + R ADD     IRELADDR     SAVE IRELADDR = EXTENSION (=SIZE) OF REGION
         335+ 9 2547          + ADD       ONE          MAKE EVEN
         336+23   19          + A RIGHT   0019
         337+22   19          + A LEFT    0019
         338+12 2563          + STORE     EXT          ALL EXTENSION IN TSYMBEXT ARE EVEN
         339+10  339          + R ADD     *            
         340+ 1   75          + TR        EQTBL
         341+ 0 1944          + STOP      TSYMBEXT     EXTENSION (=SIZE) FOR THIS REGION
         342+ 0 2553          + STOP      NREGION      NREGION = ENTRY IN TABLE FOR THIS REGION 
         343+ 0 2563          + STOP      EXT          TSYMBEXT[NREGION] = 
         344+10  344          + R ADD     *
         345+ 1   53          + TR        PRTNLINE     
         346+ 0  101          + STOP      0101         STRINGZ AT COL 1
         347+ 0 2607          + STOP      MSGNREFS     "REFERENCES"
         348+ 0  210          + STOP      0210         INT AT COL 10
         349+ 0  941          + STOP      NREFS        NUMBER OF REFERENCES IN REGION
         350+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         351+10  351          + R ADD     *
         352+ 1   71          + TR        SORTTBL      SORT STEPN REFERENCES TABLE
         353+ 0  942          + STOP      TSTEPREF     THE TABLE TO SORT 
         354+ 0  941          + STOP      NREFS        ENTRIES IN TABLE
         355+10  941          + R ADD     NREFS        NUMBER OF HALF-WORDS TO SAVE ON TAPE
         356+ 9 2547          + ADD       ONE          
         357+21   19          + L RIGHT   0019         MAKE IT EVEN ((NREFS + 1) AND OCT 7776) 
         358+22   19          + A LEFT    0019         
         359+12  735          + STORE     N
         360+ 5 2547          + SUB       ONE          IF =0 SET =2 TO AVOID SAVING EMPTY RECORDS ON TAPE
         361+ 3  364          + TR +      SVREFS
         362+10 2548          + R ADD     TWO
         363+12  735          + STORE     N
         364+10  364 SVREFS   + R ADD     *            
         365+ 1   63          + TR        WRTAPE       WRITE MAGNETIC TAPE (REFERENCES TABLE)
         366+ 0  259          + STOP      TAPEOUTR
         367+ 0  940          + STOP      MAXNREFS     SAVE MAXREFS (1 HW) + NREFS (1 HW)
         368+ 0 2548          + STOP      TWO          NUM OF HALF-WORDS TO SAVE (MUST BE EVEN)
         369+10  369          + R ADD     *            
         370+ 1   63          + TR        WRTAPE       WRITE MAGNETIC TAPE (REFERENCES TABLE)
         371+ 0  259          + STOP      TAPEOUTR
         372+ 0  942          + STOP      TSTEPREF     BUF TO WRITE TO TAPE
         373+ 0  735          + STOP      N            NUM OF HALF-WORDS TO SAVE (MUST BE EVEN)
         374+ 1  217          + TR        READREG      PROCEED WITH NEXT REGION
         375+ 8    0 EOF      + NOOP      0000         END OF FILE
         376+10  376          + R ADD     *
         377+ 1   65          + TR        RWDRUM       SAVE TSYMBREF TABLE (SYMBOLS USED BY ALL REGIONS) TO DRUM 
         378+26  128          + WRITE     0128         DRUM INSTR
         379+ 0    0          + STOP      0000         DRUM ADDR 
         380+ 0 1342          + STOP      MAXNSYMB     ADDR OF START OF TABLES
         381+ 0 1202          + STOP      1202         MAXNSYMB (1 HALF-WORD) + NSYMBS (1 HW) 
         382+27  259          + WRITE EF  TAPEOUTR     WRITE EOF IN TAPE OUT 
         383+27  258          + WRITE EF  TAPEOUT      WRITE EOF IN TAPE OUT (COMPACT CODE)
         384+30   74          + SENSE     0074         SENSE SWITCH 6
         385+ 1  420          + TR        ENDLOG1B     TR IF NO LOG SELECTED
         386+10  386          + R ADD     *
         387+ 1   53          + TR        PRTNLINE     
         388+ 0  101          + STOP      0101         STRINGZ AT COL 1
         389+ 0 2611          + STOP      MSGNSYMB     "SYMBOLS REFERENCED"
         390+ 0    0          + STOP      0000         END OF LINE
         391+10 2545          + R ADD     ZERO
         392+12  735          + STORE     N
         393+10  109          + R ADD     TSYMBAD
         394+13  410          + STORE A   NAME
         395+ 9 1342          + ADD       MAXNSYMB
         396+13  412          + STORE A   SYMBEXT
         397+10  735 PSYMB0   + R ADD     N
         398+ 5 1343          + SUB       NSYMBS
         399+ 4  420          + TR 0      ENDLOG1B 
         400+10  735          + R ADD     N
         401+ 9 2547          + ADD       ONE
         402+12  735          + STORE     N
         403+10  403          + R ADD     *            
         404+ 1   53          + TR        PRTNLINE     
         405+ 0  201          + STOP      0201         INT AT COL 1
         406+ 0  735          + STOP      N
         407+ 0  108          + STOP      0108         STRINGZ AT COL 8
         408+ 0 2620          + STOP      MSGALFA      "/   /"
         409+ 0  509          + STOP      0509         ALFA AT COL 9
         410+ 0    0 NAME     + STOP      /   /        POINTS TO THE SYMBOL NAME
         411+ 0  212          + STOP      0212         INT AT COL 12
         412+ 0    0 SYMBEXT  + STOP      /   /        POINTS TO ITS EXTENSION (SIZE). -1 -> UNRESOLVED
         413+ 0    0          + STOP      0000         END OF LINE
         414+10  410          + R ADD     NAME
         415+ 9 2547          + ADD       ONE
         416+13  410          + STORE A   NAME
         417+ 9 1342          + ADD       MAXNSYMB
         418+13  412          + STORE A   SYMBEXT
         419+ 1  397          + TR        PSYMB0
         420+ 8    0 ENDLOG1B + NOOP      0000
         421+28  257          + REWIND    TAPEIN       INPUT PACT COMPACT CODE FROM TAPE 2 (READ TAPE IN BACKWARD DIRECTION BEACUSE STEPS WRITTEN IN DESCENDING ORDER)
         422+28  258          + REWIND    TAPEOUT      OUTPUT PACT COMPACT CODE TO TAPE 3 (STEPS WRITTEN IN REGULAR ASCNEDING ORDER)
         423+28  259          + REWIND    TAPEOUTR     OUTPUT TO TAPE 4 (STEPN REFERENCED TO RESOLVE)
         424+10  424          + R ADD     *
         425+ 1   51          + TR        CHAIN        IF SW2 IS ON, A +STOP 4095 IS EXECUTED 
         426+ 0  256          + STOP      PACTCOMP     CHAIN TO NEXT STAGE IN PACT COMPILER TAPE
         427+ 0 4095          + STOP      4095
         428+ 9 2548 RDCC     + ADD       TWO          READ COMPACT CODE FROM TAPE WITH LEADING RECORD
         429+13  451          + STORE A   RDCCEXIT     TO ALLOW READING BACKWARDS. 
         430+ 2  431          + TR OV     RDCC0        CLEAR OV FLAG (=CLEAR EOF CONDITION FROM ANY 
         431+ 8    0 RDCC0    + NOOP      0000         PREVIOUS TAPE READ)
         432+10  432          + R ADD     *            READ LEADING IDENTIFICATION RECORD
         433+ 1   61          + TR        RDBTAPE      (MC CODE GENERATED STEPN + NINST)
         434+ 0  257          + STOP      TAPEIN       SO TAPE CAN BE READ BACKWARDS ON PASS 2
         435+ 0  736          + STOP      DATA         BUF TO READ FROM TAPE
         436+ 0 2548          + STOP      TWO          LEN
         437+ 2  452          + TR OV     RDCCEOF      IF EOF -> TERMINATE READ TAPE
         438+10  736          + R ADD     DATA
         439+12  525          + STORE     STEPN
         440+10  737          + R ADD     DATA2
         441+12  532          + STORE     NINST
         442+10  734          + R ADD     CCLEN        COMPUTE CC RECOD SIZE BASED ON 
         443+ 9  532          + ADD       NINST        MC INSTRUCTIONS GENERATED SO FAR
         444+ 9  532          + ADD       NINST
         445+12  735          + STORE     N
         446+10  446          + R ADD     *
         447+ 1   61          + TR        RDBTAPE      READ MAGNETIC TAPE TAPEIN (COMPACT CODE)
         448+ 0  257          + STOP      TAPEIN
         449+ 0  490          + STOP      CCODE        BUF TO WRITE TO TAPE
         450+ 0  735          + STOP      N            LEN
         451+ 1    0 RDCCEXIT + TR        /   /        
         452+10 2547 RDCCEOF  + R ADD     ONE          IF EOF, SET OV=1 AGAIN AND EXIT
         453+22   36          + A LEFT    0036
         454+ 1  451          + TR        RDCCEXIT 
         455+ 8    0 RDNCONST + NOOP      0000         PROCESS READ OP=100 COMPACT CODE RECORD. 
         456+10  532          + R ADD     NINST        THIS COMPACT CODE RECORD HOLDS THE LOOP CONSTANTS POOL IN TINST 
         457+12  739          + STORE     NLOCONST     COPY IT TO TLOCONST TABLE
         458+22    1          + A LEFT    0001
         459+12 2564          + STORE     LEN
         460+10  460          + R ADD     *            
         461+ 1   69          + TR        MEMCOPY
         462+ 0  534          + STOP      TINST      
         463+ 0  740          + STOP      TLOCONST   
         464+ 0 2564          + STOP      LEN          THIS CC RECORD IS NOW SAVED TO TAPEOUT. ITS DATA (TLOCONST) WILL
         465+ 1  222          + TR        READSTEP
         466+ 9 2548 LDNCONST + ADD       TWO          THIS COMPACT CODE RECORD HOLDS THE LOOP CONSTANTS POOL IN TINST 
         467+13  477          + STORE A   LDNCONEX     BUT THIS STEP HAS NOT THE FINAL DATA (DO NOT HAVE THE ENTRIES
         468+10  739          + R ADD     NLOCONST     THIS COMPACT CODE RECORD HOLDS THE LOOP CONSTANTS POOL IN TINST 
         469+12  532          + STORE     NINST        COPY FROM TLOCONST TABLE
         470+22    1          + A LEFT    0001
         471+12 2564          + STORE     LEN
         472+10  472          + R ADD     *            
         473+ 1   69          + TR        MEMCOPY
         474+ 0  740          + STOP      TLOCONST   
         475+ 0  534          + STOP      TINST      
         476+ 0 2564          + STOP      LEN
         477+ 1    0 LDNCONEX + TR        /   /
         478+ 9 2548 ERROR    + ADD       TWO
         479+13  480          + STORE A   ERRP1
         480+10    0 ERRP1    + R ADD     /   /
         481+13  487          + STORE A   ERRSTRZ      SAVE ADDR OF ERROR TXT MESSAGE
         482+10  482          + R ADD     *            PRINT USER PROGRAM SOURCE CODE CARD JUST PROCESSED
         483+ 1   55          + TR        PRINTCRD
         484+10  484          + R ADD     *
         485+ 1   53          + TR        PRTNLINE     
         486+ 0  101          + STOP      0101         STRINGZ AT COL 1
         487+ 0    0 ERRSTRZ  + STOP      /   /        ERROR MESSAGE
         488+ 0    0          + STOP      0000         END OF LINE
         489+ 0  222          + STOP      READSTEP     IF USER PRESS STARTS, PROGRAM RESUMES PROCESSING NEXT SOURCE CODE STEP 
         490+     0  PACTSRC    RES       24           CARD IMAGE OF PACT SOURCE CODE CARD (12 FULL WORDS)
         514+     0  REGION     DEF       0
         515+     0  STEP       DEF       0            REGION = ALFA (<0)
         516+     0  OP         DEF       0            STEP   = INT (>0)
         517+     0  FACT       DEF       0            OP     = 0..43    =0 MEANS END OF REGION
         518+     0  S1         DEF       0            FACT   < 0 -> FACTOR IS AN ALFA SYMBOL (VAR, REGION, ...) 
         519+     0  S2         DEF       0            FACT = 0 -> BLANK FACTOR
         520+     0  QR         DEF       0            FACT = 0..9999 -> DESTINATION STEP FOR TRANSFER/RESULT OF STEP
         521+     0  QF         DEF       0            CLUE = -, R OR N
         522+     0  NUM        DEF       0            
         523+     0             DEF       0            S1/S2 = 0 -> BLANK, >0 -> INTEGER, <0 -> ALFA 
         524+     0  CLUE       DEF       0
         525+     0  STEPN      DEF       0            QR = +/- INTEGER OR BLANK. 
         526+     0  FACTN      DEF       0            QF = SET IF THERE IS AN INTEGER FACTOR/NUMBER IN CARD
         527+     0  FACTREG    DEF       0
         528+     0  S1N        DEF       0            STEPN = SEQUENTIAL NUMBER OF STEP            
         529+     0  S2N        DEF       0            IF OP IS TRANSFER -> FACTN=DESTINATION STEPN
         530+     0  D1N        DEF       0            FACTN=ADDR (0, 2, 4, ..) FACTREG=' ', 'T', 'V', 'N'
         531+     0  D2N        DEF       0            S1N/S2N=INDEX (IF <0), BLANK (IF =0), CONST (IF >0)
         532+     0  NINST      DEF       0            D1N/D2N=HALF-WORD SIZE OF EACH DIMENSION. D1N=-1 IF MATRIX/VECTOR WITH CONSTANT SUBSCRIPTS
         533+     0  NINCR      DEF       0
         534+     0  TINST      RES       200          MACHINE CODE: 1ST HALF-WORD OPCODE + REGION/LOCATION INTO STEP (FOR TRANSFERS)
         734+    44  CCLEN      DEF       0044         LENGTH OF COMPACT CODE RECORD 
         735+     0  N          DEF       0            TEMP VAR (HERE TO MAKE TABLES START AT EVEN LOCATION)
         736+     0  DATA       DEF       0            EVEN ALIGNED TEMP VAR
         737+     0  DATA2      DEF       0
         738+   100  MAXNCONS   DEF       100          MAX NUMBER OF ENTRIES IN LOOP CONSTANT POOL OF REGION
         739+     0  NLOCONST   DEF       0            NUM OF ENTRIES IN LOOP CONSTANT POOL OF REGION
         740+     0  TLOCONST   RES       200          MACHINE CODE: 1ST HALF-WORD OPCODE + REGION
         940+   400  MAXNREFS   DEF       400          MAX 400 STEPN REFERENCES CAN DE DEFINED IN ONE REGION
         941+     0  NREFS      DEF       0            NUMBER OF ENTRIES IN TSTEPREF TABLE
         942+     0  TSTEPREF   RES       400          LOCAL STEP REFERENCES TABLE: STEPN REFERENCED BY A TR STEPN MC INSTR IN CURRENT REGION
        1342+   600  MAXNSYMB   DEF       600          MAX 600 SYMBOL (LIBRARIES/REGION) REFERENCES CAN DE DEFINED IN THE WHOLE PROGRAM
        1343+     0  NSYMBS     DEF       0            NUMBER OF ENTRIES IN TSYMBREF GLOBAL SYMBOL TABLE
        1344+     0  TSYMBREF   RES       600          GLOBAL SYMBOL TABLE: ALFA VALUE (NEGATIVE) OF SYMBOLS REFERENCED BY A TR SYMBOL MC INSTR IN ALL PROGRAM
        1944+     0  TSYMBEXT   RES       600          EXTENSION (=SIZE) FOR DEFINED SYMBOLS. =-1 IF SYMBOL NOT DEFINED
        2544+   100  MAXNINST   DEF       100          MAX NUMBER OF MACHINE CODE INSTRUTIONS PER STEP
        2545+     0  ZERO       DEF       0
        2546+     0             DEF       0
        2547+     1  ONE        DEF       1
        2548+     2  TWO        DEF       2
        2549+     4  D4         DEF       4
        2550+    44  D44        DEF       44
        2551+   100  D100       DEF       100
        2552+  4094  D4094      DEF       4094
        2553+     0  NREGION    DEF       0            ENRTY NUMBER OF THIS REGION IN TSYMBREF TABLE
        2554+     0  MC.OP      DEF       0            MC OPCODE GENERATED
        2555+     0  MC.REG     DEF       0            REGION REFERENCED BY MC OPCODE GENERATED
        2556+     0  MC.ADDR    DEF       0            MC ADDR GENERATED. BOTH WILL BE STORED IN TINST TABLE IN COMPCAT CODE RECORD
        2557+     0  MCNUM      DEF       0            NEXT INSTR TO PROCESS
        2558+     0  TRSTEPN    DEF       0            THE DESTINATION STEP
        2559+     0  TRSYMBOL   DEF       0            THE SYMBOL DEFINED
        2560+     0  SVNREFS    DEF       0            SAVE NUMBER OF ENTRIES IN TREFS TABLE
        2561+     0  IRELADDR   DEF       0            I REGION RELATIVE LOCATION OF THIS STEP
        2562+     0  REF        DEF       0            TEMP
        2563+     0  EXT        DEF       0            SIZE OF REGION (IS EVEN)
        2564+     0  LEN        DEF       0
        2565- 69955  ERRTOOBG   TXT       "REGION TOO BIG",0                              REGION CODE SIZE > 4094 HALF-WORDS
        2566- 49706  
        2567-  1563  
        2568- 62222  
        2569- 49296  
        2570+     0  
        2571- 75051  ERRROV     TXT       "TOO MANY STEP REFERENCES IN REGION",0          TOO MANY STEP REFERENCES IN THIS REGION 
        2572-  1213  
        2573- 61680  
        2574- 72977  
        2575- 64542  
        2576- 40049  
        2577- 69962  
        2578- 35407  
        2579-  1034  
        2580-  1457  
        2581- 44811  
        2582- 59904  
        2583+     0  
        2584- 75051  ERRSOV     TXT       "TOO MANY REGION/LIB REFERENCES IN PROGRAM",0   TOO MANY SYMBOL REFERENCES IN THE WHOLE PROGRAM
        2585-  1213  
        2586- 61680  
        2587- 69955  
        2588- 49706  
        2589-104853  
        2590- 32286  
        2591- 40049  
        2592- 69962  
        2593- 35407  
        2594-  1034  
        2595-  1374  
        2596- 63150  
        2597- 31152  
        2598+     0  
        2599- 42506  MSGSTART   TXT       "FINAL ASSEMBLY PASS 1",0
        2600- 31104  
        2601- 31471  
        2602- 40382  
        2603- 57072  
        2604- 65167  
        2605- 71425  
        2606+     0  
        2607- 72977  MSGNREFS   TXT       "STEP REFS",0
        2608- 64542  
        2609- 40063  
        2610+     0  
        2611- 73225  MSGNSYMB   TXT       "SYMBOLS REFERENCED",0
        2612- 33576  
        2613- 71454  
        2614- 40049  
        2615- 69962  
        2616- 35392  
        2617+     0  
        2618- 69954  MSGREF     TXT       "REF",0
        2619+     0  
        2620-103680  MSGALFA    TXT       "/   /",0
        2621-  2160  
        2622+     0  
        2623+     7  REG.S      DEF       7            SYMBOL S 0000
        2624+15 2638 CLRBUF   + LOAD MQ   IOCL
        2625+14 2643          + STORE MQ  BUFIO
        2626+15 2664          + LOAD MQ   IOSTORE         
        2627+ 1 2635          + TR        INIT2
        2628+15 2660 READCRD  + LOAD MQ   IORDCRD
        2629+ 1 2633          + TR        INIT1
        2630+15 2662 WRITECRD + LOAD MQ   IOWRCRD
        2631+ 1 2633          + TR        INIT1
        2632+15 2663 PRINTCRD + LOAD MQ   IOPRCRD
        2633+14 2643 INIT1    + STORE MQ  BUFIO
        2634+15 2661          + LOAD MQ   IOCOPY         
        2635+14 2644 INIT2    + STORE MQ  BUFROW
        2636+ 9 2670          + ADD       TWO          
        2637+13 2659          + STORE A   EXIT
        2638+10 2666 IOCL     + R ADD     ZERO         RESET TO INITIAL COPY LOOP ADDRESS     
        2639+13 2644          + STORE A   BUFROW       FOR BUFFER
        2640+10 2644          + R ADD     BUFROW       X .*echo Print
        2641+ 5 2671          + SUB       D48          X 
        2642+12 2668          + STORE     ENDLP        X LOOP END VALUE
        2643- 0    0   BUFIO  - STOP      /   /        READ OR WRITE
        2644-31    0   BUFROW - COPY      /   /        COPY WORD TO/FROM PRINTER/CARDREADER
        2645+ 1 2649          + TR        BUFOK2       NORMAL PROCESSING 
        2646+ 1 2656          + TR        EODECK       FOR COPY READING END OF REG (=END OF DECK BEING READ)
        2647+ 6 2670          + R SUB     TWO          END OF FILE -> NO CARD TO READ -> STOP with Acc=-2
        2648+ 0 2643          + STOP      BUFIO        ON PRESSING START RETRY CARD READ
        2649+10 2644   BUFOK2 + R ADD     BUFROW       X
        2650+ 5 2670          + SUB       TWO          INCR BUF ADDR
        2651+13 2644          + STORE A   BUFROW       X
        2652+ 5 2668          + SUB       ENDLP        CHECK FOR END
        2653+ 4 2658          + TR 0      ENDIO
        2654+10 2666          + R ADD     ZERO         CLEAR ACC IN CASE WE ARE CLEANING THE BUFFER
        2655+ 1 2644          + TR        BUFROW
        2656+10 2669 EODECK   + R ADD     ONE          SET OV FLAG TO SIGNAL END OF DECK CONDITION
        2657+22   36          + A LEFT    36
        2658+26 2052 ENDIO    + WRITE     2052         END OF I/O: INSURE THAT MQ NOT IN USE            
        2659+ 1    0 EXIT     + TR        /   /
        2660+24 2048 IORDCRD  + READ      2048         PREPARE TO READ FROM CARD READER
        2661-31    0 IOCOPY   - COPY      /   /   
        2662+26 1024 IOWRCRD  + WRITE     1024         PREPARE TO PUNCH CARD 
        2663+26  512 IOPRCRD  + WRITE     0512         PREPARE WRITE PRTBUF ON PRINTER
        2664-12    0 IOSTORE  - STORE     /   /        CLEAR BUFFER
        2665+     0             ORG       EVEN           
        2666+     0  ZERO       DEF       0            
        2667+     0             DEF       0            
        2668+     0  ENDLP      DEF       0            LOOP END VALUE
        2669+     1  ONE        DEF       1
        2670+     2  TWO        DEF       2
        2671+    48  D48        DEF       48
        2672+ 9 2943 PRTPARM2 + ADD       TWO          GET 2 PARAMS: LEN AND COL (EITHER VALUE OR VAR ADDR)
        2673+13 2692          + STORE A   PRTPRMEX
        2674+10 2682          + R ADD     PRTP1
        2675+ 9 2943          + ADD       TWO          PRINT PACKED TEXT FROM FULL-WORD VALUE IN MQ REGISTER 
        2676+13 2682          + STORE A   PRTP1        STORE ADDR OF FIRST PARAM (LEN)
        2677+ 9 2942          + ADD       ONE
        2678+13 2684          + STORE A   PRTP2        STORE ADDR OF SECOND PARAM (COL)
        2679+ 9 2942          + ADD       ONE
        2680+13 2759          + STORE A   EXIT
        2681-14 2932          - STORE MQ  NUM          SAVE VALUE TO PRINT PARAM MQ (NUM IS ALIASED TO TXT)
        2682+10    0   PRTP1  + R ADD     /   /        GET LEN: NUMBER OF CHARS TO PRINT (1..6)
        2683+12 2936          + STORE     LEN
        2684+10    0   PRTP2  + R ADD     /   /        GET COLUMN PARAM 1..72
        2685+ 3 2688          + TR +      PRTP4
        2686+13 2687          + STORE A   PRTP3        COL<0 -> INTERPRET COL AS LOC(COL) = ADDR OF COL VAR
        2687+10    0   PRTP3  + R ADD     /   /        READ VAR COL PASED AS PARAM
        2688+ 4 2759   PRTP4  + TR 0      EXIT         COL=0 -> EXIT
        2689+ 3 2691          + TR +      PRTP5
        2690+ 1 2759          + TR        EXIT         COL<0 -> EXIT
        2691+12 2742   PRTP5  + STORE     COL
        2692+ 1    0 PRTPRMEX + TR        /   /        RETURN TO CALLER
        2693+13 2682 PRTSTR   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2694+10 2694          + R ADD     *            FOR PRINT STRINGZ FROM MEM
        2695+ 1 2672          + TR        PRTPARM2
        2696+12 2706          + STORE     COLSZ
        2697+10 2936          + R ADD     LEN          LEN IS IN FACT THE LOCATION WHERE THE STRING STARTS
        2698+13 2701          + STORE A   STRZAD
        2699+10 2759          + R ADD     EXIT
        2700+13 2714          + STORE A   STRZEX
        2701+10    0 STRZAD   + R ADD     /   /        GET HALF-WORD WITH NEXT 3 CHARS TO PRINT
        2702+ 4 2714          + TR 0      STRZEX       IF +0 -> END OF STRING (-0 DOES NOT TERMINATES THE STRING)
        2703+21   35          + L RIGHT   0035         MQ=3-CHARS TO PRINT
        2704+10 2704          + R ADD     *            
        2705+ 1 2716          + TR        PRTALF       PRINT 3 CHARS
        2706+ 0    0 COLSZ    + STOP      0000         COL 
        2707+10 2701 STRZ1    + R ADD     STRZAD       INCR STRING ADDRESS
        2708+ 9 2942          + ADD       ONE
        2709+13 2701          + STORE A   STRZAD
        2710+10 2706          + R ADD     COLSZ        INCR COLUMN
        2711+ 9 2944          + ADD       D3
        2712+13 2706          + STORE A   COLSZ
        2713+ 1 2701          + TR        STRZAD
        2714+ 3    0 STRZEX   + TR +      /   /        IF ZERO -> END OF STRING
        2715+ 1 2707          + TR        STRZ1
        2716+ 9 2943 PRTALF   + ADD       TWO          PRINT 3-PACKED CHARS IN MQ REGISTER 
        2717+14 2938          + STORE MQ  TXT          SAVE TEXT TO PRINT (IN LEFT HALF WORD)
        2718+13 2721          + STORE A   PRTAP2       STORE ADDR OF PARAM (COL)
        2719+ 9 2942          + ADD       ONE
        2720+13 2759          + STORE A   EXIT
        2721+10    0   PRTAP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        2722+ 3 2725          + TR +      PRTAP4
        2723+13 2724          + STORE A   PRTAP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        2724+10    0   PRTAP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        2725+12 2742   PRTAP4 + STORE     COL
        2726+10 2944          + R ADD     D3
        2727+12 2936          + STORE     LEN
        2728+10 2926 PRT1     + R ADD     ZERO         UNPACK LEFTMOST CHAR 
        2729+11 2938          + ADD AB    TXT          GET TEXT DISCARD SIGN
        2730+21   35          + L RIGHT   0035         MQ=Acc
        2731+10 2926          + R ADD     ZERO
        2732+18 2951          + DIV       D48X48
        2733+12 2938          + STORE     TXT          remainder=char to print, mq=c2 * 48 + c3 in right half-word
        2734+10 2926          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        2735+20   18          + L LEFT    0018         put c2 and c3 in left half-word of MQ to be saved in CHAR half word
        2736+14 2937          + STORE MQ  CHAR         CHAR TO PRINT
        2737+10 2937          + R ADD     CHAR 
        2738+ 4 2743          + TR 0      NXTCHR       IF BLANK PROCEED TO NEXT COL
        2739+21   35          + L RIGHT   0035         MQ=CHAR TO PRINT
        2740+10 2740          + R ADD     *            PRINT CHAR
        2741+ 1 2836          + TR        PRTCHR
        2742+ 0    0 COL      + STOP      0000         COL: COLUMN NUMBER TO PRINT (1..72)
        2743+10 2936 NXTCHR   + R ADD     LEN          DECR LEN COUNT
        2744+ 5 2942          + SUB       ONE
        2745+12 2936          + STORE     LEN
        2746+ 4 2759          + TR 0      EXIT         IF NO MORE CHARS TO PRINT EXIT
        2747+10 2742          + R ADD     COL          INCR COL POSITION
        2748+ 9 2942          + ADD       ONE
        2749+12 2742          + STORE     COL
        2750+ 5 2950          + SUB       D72          IF COL > 72 RETURN TO CALLER
        2751+ 4 2753          + TR 0      GNXTCHR      ELSE PROCEED WITH NEXT CHAR
        2752+ 3 2759          + TR +      EXIT
        2753+10 2926 GNXTCHR  + R ADD     ZERO         GET NEXT CHAR 
        2754+15 2938          + LOAD MQ   TXT
        2755+16 2949          + MPY       D48
        2756+22   17          + A LEFT    0017         GET RESULT IN LEFT HALF-WORD OF ACC
        2757+12 2938          + STORE     TXT
        2758+ 1 2728          + TR        PRT1         PROCEED TO PRINT CHAR
        2759+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        2760+13 2682 PRTOCT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2761+10 2761          + R ADD     *            FOR PRINT OCTIONARY VALUE
        2762+ 1 2672          + TR        PRTPARM2
        2763+10 2936          + R ADD     LEN          LEN = OCTAL DIGITS TO PRINT
        2764+ 9 2742          + ADD       COL
        2765+ 5 2942          + SUB       ONE
        2766+12 2778          + STORE     COLN         COL POINTS TO LEAST SIGNIFICANT DIGIT
        2767+10 2932 PRTIOCG  + R ADD     NUM          GENERATE OCTINARY DIGIT
        2768+15 2926          + LOAD MQ   ZERO         CLEAR MQ
        2769+21   21          + L RIGHT   0021         3 LSB BITS OF LEFT HALF-WORD OF ACC TO MQ
        2770+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 3 BIT)
        2771+12 2932          + STORE     NUM          SAVE BACK NUM WITH RIGHTMOST OCTIONARY DIGIY EXTRACTED (NUM'=NUM/8)
        2772+10 2926          + R ADD     ZERO
        2773+20   21          + L LEFT    0021         LEFT HALF-WORD OF ACC IS NOW RIGHTMOST OCTINARY DIGIT EXTRACTED FROM NUM 
        2774+ 4 2792          + TR 0      PRTIOZ       TR IF THIS DIGIT IS ZERO TO PRINT A '0' (BASE48 CODE = 10) INSTEAD OF A BLANK (BASE48 CODE = 0)
        2775+21   35          + L RIGHT   0035         PUT DIGIT 1..9 TO PRINT IN MQ
        2776+10 2776 PRTOCTD  + R ADD     *            PRINT OCTINARY DIGIT
        2777+ 1 2836          + TR        PRTCHR
        2778+ 0    0 COLN     + STOP      0000
        2779+10 2778          + R ADD     COLN        DECR COL NUMBER TO PRINT NEXT DIGIT
        2780+ 5 2942          + SUB       ONE
        2781+12 2778          + STORE     COLN
        2782+10 2936          + R ADD     LEN          DECR COL NUMBER TO PRINT NEXT DIGIT
        2783+ 5 2942          + SUB       ONE
        2784+ 4 2759          + TR 0      EXIT         PRINTED LEN OCTINARY DIGITS -> EXIT
        2785+12 2936          + STORE     LEN
        2786+10 2932          + R ADD     NUM          IF NUM < 0, ADD SIGN BIT TO LEFTMOST DIGIT
        2787+ 3 2767          + TR +      PRTIOCG
        2788+10 2952          + R ADD     OCT04K       
        2789+ 5 2932          + SUB       NUM
        2790+12 2932          + STORE     NUM
        2791+ 1 2767          + TR        PRTIOCG
        2792+15 2945   PRTIOZ + LOAD MQ   D10          ACC=BASE48 CODE FOR '0'
        2793+ 1 2776          + TR        PRTOCTD      TR TO PRINT IT
        2794+13 2682 PRTINT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2795+10 2795          + R ADD     *            FOR PRINT OCTIONARY VALUE
        2796+ 1 2672          + TR        PRTPARM2
        2797+10 2742          + R ADD     COL          PRINT DECIMAL NUMBER. VALUE OF LEN = DIGITS TO PRINT, NOT INCLUDING SIGN
        2798+ 9 2936          + ADD       LEN
        2799+ 5 2942          + SUB       ONE          
        2800+12 2821          + STORE     COLNI        COL POINTS TO END OF NUMBER
        2801+10 2926          + R ADD     ZERO
        2802+12 2935          + STORE     SGN          SIGN IS POSITIVE
        2803+10 2932          + R ADD     NUM
        2804+ 3 2809          + TR +      PRTINTG
        2805+ 6 2932          + R SUB     NUM          NUM IS NEGATIVE. CONVERT TO POSITIVE
        2806+12 2932          + STORE     NUM          AND SET SGN=1
        2807+10 2942          + R ADD     ONE
        2808+12 2935          + STORE     SGN          
        2809+10 2932 PRTINTG  + R ADD     NUM          GENERATE DECIMAL DIGIT
        2810+21   35          + L RIGHT   0035         MQ=Acc
        2811+10 2926          + R ADD     ZERO
        2812+18 2945          + DIV       D10
        2813+ 4 2834          + TR 0      PRTINZ
        2814+12 2937 PRTINTG2 + STORE     CHAR         acc=remainder=digit to print, mq=num/10
        2815+10 2926          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        2816+20   18          + L LEFT    0018         digit in left half-word of MQ to be saved in CHAR half word
        2817+14 2932          + STORE MQ  NUM 
        2818+15 2937          + LOAD MQ   CHAR 
        2819+10 2819 PRTINTD  + R ADD     *            PRINT DECIMAL DIGIT
        2820+ 1 2836          + TR        PRTCHR
        2821+ 0    0 COLNI    + STOP      0000
        2822+10 2821          + R ADD     COLNI        DECR COL NUMBER TO PRINT NEXT DIGIT
        2823+ 5 2942          + SUB       ONE
        2824+12 2821          + STORE     COLNI
        2825+10 2932          + R ADD     NUM          DO NOT CARE ABOUT LEN, JUST CHECK IF NUM=0 
        2826+ 4 2828          + TR 0      PRTINS       (SO NO MORE DIGITS REMAINS TO BE PRINTED)
        2827+ 1 2809          + TR        PRTINTG      NUM NOT FINISHED, PROCEED WITH NEXT DIGIT
        2828+10 2935 PRTINS   + R ADD     SGN
        2829+ 4 2759          + TR 0      EXIT         NO SIGN -> NUM FINISHED
        2830+10 2926          + R ADD     ZERO
        2831+12 2935          + STORE     SGN          CLEAR SGN FLAG
        2832+15 2946          + LOAD MQ   D11          BASE48 CODE FOR '-' (MINUS) CHAR
        2833+ 1 2819          + TR        PRTINTD      GO TO PRINT IT
        2834+10 2945   PRTINZ + R ADD     D10          ACC=BASE48 CODE FOR '0'
        2835+ 1 2814          + TR        PRTINTG2     TR TO PRINT IT
        2836+ 9 2943 PRTCHR   + ADD       TWO          PRINT CHAR IN MQ REGISTER 
        2837+14 2937          + STORE MQ  CHAR         SAVE CHAR TO PRINT (IN LEFT HALF WORD)
        2838+13 2842          + STORE A   PRTCP2       STORE ADDR OF PARAM (COL)
        2839+ 9 2942          + ADD       ONE
        2840+13 2920          + STORE A   PRTCEX
        2841+ 2 2842          + TR OV     PRTCP2       CLEAR OV JUST IN CASE
        2842+10    0   PRTCP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        2843+ 3 2846          + TR +      PRTCP4
        2844+13 2845          + STORE A   PRTCP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        2845+10    0   PRTCP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        2846+ 5 2942   PRTCP4 + SUB       ONE
        2847+12 2940          + STORE     N            N=COL-1 -> IN RANGE 0..71
        2848+ 3 2850          + TR +      PRTSA        IF N >= 0 PROCEED WITH BASE BUFFER ADDR CALCULATION
        2849+ 1 2920          + TR        PRTCEX       IF N<0 EXIT
        2850+10 2926    PRTSA + R ADD     ZERO         CARD BUFFER USES LOCATION 0..47
        2851+13 2939          + STORE A   PRTROWAD     DETERMINE ADDRESS OF LOWER ROW TO PRINT
        2852+10 2940          + R ADD     N
        2853+ 5 2948          + SUB       D36
        2854+ 3 2856          + TR +      PRTC0
        2855+ 1 2862          + TR        PRTC1
        2856+12 2940    PRTC0 + STORE     N            COL NOW 0..35 
        2857+ 5 2948          + SUB       D36
        2858+ 3 2920          + TR +      PRTCEX       IF COL >= 36 (IE COL PASSED AS PARAM > 72) THEN EXIT
        2859+10 2939          + R ADD     PRTROWAD
        2860+ 9 2943          + ADD       TWO
        2861+13 2939          + STORE A   PRTROWAD     SET BASE BUFFER ADDR 
        2862+10 2942    PRTC1 + R ADD     ONE          DETERMINE MASKCOL WITH MASK TO SET IN CARD BUFFER
        2863+21   53          + L RIGHT   53           SET RIGHTMOST BIT OF MQ TO 1 (SHIFT 35+18=53)
        2864+10 2947          + R ADD     D35
        2865+ 5 2940          + SUB       N
        2866+13 2868          + STORE A   PRTC2
        2867+10 2926          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW
        2868+20    0    PRTC2 + L LEFT    /   /        SHIFT MQ LEFT N PLACES
        2869+ 4 2872          + TR 0      PRTC3        IF ACC STILL ZERO -> MASKCOL VALID
        2870+ 6 2942          + R SUB     ONE          ACC NOT ZERO -> SHOULD GENERATE -0 TO SET SIGN BIT ON
        2871+21   72          + L RIGHT   0072         NOW MQ = -0 -> LEFTMOST BIT OF MQ SET
        2872-14 2928    PRTC3 - STORE MQ  MASKCOL
        2873+10 2926          + R ADD     ZERO         READ THE BITMAP OF CHAR 
        2874+11 2937          + ADD AB    CHAR         DISCARD SIGN OF CHAR, IF ANY
        2875+12 2937          + STORE     CHAR
        2876+ 5 2949          + SUB       D48
        2877+ 3 2920          + TR +      PRTCEX       IF CHAR >= 48 EXIT
        2878+10 2934          + R ADD     BITMAPAD     IF ADDR OF BASE48 BITMAP NOT COMPUTED
        2879+ 4 2921          + TR 0      GETBMP1      TR TO LOAD IT
        2880+ 9 2937  GETBMP2 + ADD       CHAR         READ THE BITMAP OF CHAR 
        2881+13 2882          + STORE A   PRTC4        INDICATES THE BITS TO SET IN SELECTED 
        2882+10    0    PRTC4 + R ADD     /   /        COLUMN OF CARD BUFFER 
        2883+12 2941          + STORE     BITS
        2884+ 6 2942          + R SUB     ONE
        2885+12 2940          + STORE     N            SET TO -1
        2886+10 2940    LOOP1 + R ADD     N            CURRENT ROW (STARTS AT ZERO) = OFFSET ON PRTROWAD     
        2887+ 9 2942          + ADD       ONE
        2888+12 2940          + STORE     N
        2889+10 2941          + R ADD     BITS         EXTRACT RIGHTMOST BIT OF LEFT HALF OF ACC TO MQ
        2890+ 4 2920          + TR 0      PRTCEX       NO MORE BITS -> EXIT
        2891+21   19          + L RIGHT   0019         LSB BIT OF LEFT HALF-WORD OF ACC TO MQ
        2892+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 1 BIT)
        2893+12 2941          + STORE     BITS         SAVE BACK BITS. LSB HAS BEEN EXTACTED, CONTENTS SHIFTED RIGHT ONE PLACE
        2894+10 2926          + R ADD     ZERO
        2895+20    1          + L LEFT    0001         PUT EXTACTED BIT BACK INTO ACC
        2896+ 4 2886          + TR 0      LOOP1        NO BIT 
        2897+10 2940          + R ADD     N            READ THE ROW N AT CARD BUFFER 
        2898+22    2          + A LEFT    0002         MULT N BY 4 AS THERE ARE 4 HALF WORDS PER ROW
        2899+ 9 2939          + ADD       PRTROWAD     
        2900+13 2902          + STORE A   PRTROWR
        2901+13 2918          + STORE A   PRTROWW
        2902-10    0  PRTROWR - R ADD     /   /        
        2903-12 2930          - STORE     ROW          CURRENT CONTENTS OF ROW
        2904-10 2928          - R ADD     MASKCOL      "OR" MASKCOL IN SELECTED ROW
        2905+ 3 2913          + TR +      PRTW2
        2906-10 2930          - R ADD     ROW 
        2907+ 4 2911          + TR 0      PRTW1         
        2908+10 2926          + R ADD     ZERO         MASKCOL IS MINUS ZERO AND ROW IS NOT-EMPTY (EITHER POSITIVE OR NEGATIVE) -> SET ROW AS NEGATIVE
        2909- 7 2930          - SUB AB    ROW 
        2910+ 1 2918          + TR        PRTROWW
        2911-10 2928    PRTW1 - R ADD     MASKCOL      MASKCOL IS MINUS ZERO AND ROW IS EMPTY -> SET ROW = MASKCOL = MINUS ZERO
        2912+ 1 2918          + TR        PRTROWW
        2913-10 2930    PRTW2 - R ADD     ROW          
        2914+ 3 2917          + TR +      PRTW3              
        2915- 5 2928          - SUB       MASKCOL      MASKCOL IS POSITIVE AND ROW IS NEGATIVE -> SUB MASKCOL FROM ROW
        2916+ 1 2918          + TR        PRTROWW
        2917- 9 2928    PRTW3 - ADD       MASKCOL      MASKCOL IS POSITIVE AND ROW IS POSITIVE OR EMPTY -> ADD MASKCOL TO ROW         
        2918-12    0  PRTROWW - STORE     /   /        ROW UPDTATE
        2919+ 1 2886          + TR        LOOP1        PROCEED TO NEXT ROW
        2920+ 1    0 PRTCEX   + TR        /   /
        2921+10 2921 GETBMP1  + R ADD     *
        2922+ 1   89          + TR        BMPAD        GET BASE48 CHARS BITMAP ADDRESS
        2923+12 2934          + STORE     BITMAPAD     
        2924+ 1 2880          + TR        GETBMP2      RETURN
        2925+     0             ORG       EVEN
        2926+     0  ZERO       DEF       0            
        2927+     0             DEF       0            
        2928+     0  MASKCOL    DEF       0
        2929+     0             DEF       0
        2930+     0  ROW        DEF       0
        2931+     0             DEF       0
        2932+     0  NUM        DEF       0
        2933+     0             DEF       0
        2934+     0  BITMAPAD   DEF       0
        2935+     0  SGN        DEF       0
        2936+     0  LEN        DEF       0
        2937+     0  CHAR       DEF       0
        2938+     0  TXT        DEF       0
        2939+     0  PRTROWAD   DEF       0
        2940+     0  N          DEF       0
        2941+     0  BITS       DEF       0
        2942+     1  ONE        DEF       1
        2943+     2  TWO        DEF       2
        2944+     3  D3         DEF       3
        2945+    10  D10        DEF       10
        2946+    11  D11        DEF       11
        2947+    35  D35        DEF       35
        2948+    36  D36        DEF       36
        2949+    48  D48        DEF       48
        2950+    72  D72        DEF       72
        2951+  2304  D48X48     DEF       2304
        2952+ 16384  OCT04K     DEF       *040000      BIT SIGN ON 5TH OCTINARY DIGIT
        2954+ 9 3029 PRTNLINE + ADD       TWO          PRINT A NEW LINE OF DATA
        2955+12 3032          + STORE     PARAM        SAVE PARAM LIST ADDR
        2956+10 2956          + R ADD     *            CLEAR CARD BUFFER
        2957+ 1   77          + TR        CLRBUF 
        2958+10 3032 GPARAM   + R ADD     PARAM        GET PARAM PAIR FMT/DATA
        2959+13 2964          + STORE A   P1
        2960+ 9 3028          + ADD       ONE
        2961+13 2968          + STORE A   P2
        2962+ 9 3028          + ADD       ONE
        2963+12 3032          + STORE     PARAM
        2964+10    0 P1       + R ADD     /   /
        2965+12 3034          + STORE     FMT
        2966+ 3 2968          + TR +      P2           IF FMT < 0 THEM SKIP THIS PAIR FMT/DATA
        2967+ 1 2958          + TR        GPARAM
        2968+10    0 P2       + R ADD     /   /
        2969+12 2994          + STORE     DATALOC      GET DATA ADDRESS PASED AS PARAM
        2970+13 2971          + STORE A   P2A
        2971+10    0 P2A      + R ADD     /   /
        2972+12 3033          + STORE     DATA         GET EFFECTIVE DATA
        2973+10 3027          + R ADD     ZERO
        2974+15 3034          + LOAD MQ   FMT
        2975+18 3031          + DIV       D100         ACC=REMAINDER=COL NUMBER, MQ=QUOTIEN=TYPE OF DATA
        2976+12 3035          + STORE     COL
        2977+10 3027          + R ADD     ZERO
        2978+20   18          + L LEFT    0018
        2979+14 3034          + STORE MQ  FMT
        2980+15 3033          + LOAD MQ   DATA
        2981+10 2985          + R ADD     TYPETRAD
        2982+ 9 3034          + ADD       FMT
        2983+13 2984          + STORE A   TYPETR
        2984+ 1    0 TYPETR   + TR        /   /        TR SELECTED ROUTINE
        2985+ 0 2986 TYPETRAD + STOP      TYPETRT      TYPE TRANSFER TABLE ADDRESS
        2986+ 1 3015 TYPETRT  + TR        EOL          FMT=0..6 (IE <100) -> END OF PARAM LIST -> END OF LINE 
        2987+ 1 2992          + TR        TYSTR        FMT=1 -> PRINT A STRINGZ
        2988+ 1 2997          + TR        TYINT        FMT=2 -> PRINT AN INT
        2989+ 1 3002          + TR        TYOCT        FMT=3 -> PRINT AN OCT
        2990+ 1 3007          + TR        TYCHR        FMT=4 -> PRINT A CHAR
        2991+ 1 3011          + TR        TYALF        FMT=5 -> PRINT A 3-CHR PACKED ALFA STRING
        2992+10 2992 TYSTR    + R ADD     *            PRINT STRINGZ
        2993+ 1   57          + TR        PRTSTR
        2994+ 0    0 DATALOC  + STOP      /   /
        2995- 0 3035          - STOP      COL          COLUMN WHERE TXT STARTS
        2996+ 1 2958          + TR        GPARAM
        2997+10 2997 TYINT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2998+ 1   59          + TR        PRTINT
        2999+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        3000- 0 3035          - STOP      COL          COLUMN WHERE TXT STARTS
        3001+ 1 2958          + TR        GPARAM
        3002+10 3002 TYOCT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        3003+ 1   87          + TR        PRTOCT
        3004+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        3005- 0 3035          - STOP      COL          COLUMN WHERE TXT STARTS
        3006+ 1 2958          + TR        GPARAM
        3007+10 3007 TYCHR    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        3008+ 1   85          + TR        PRTCHR
        3009- 0 3035          - STOP      COL          COLUMN WHERE TXT STARTS
        3010+ 1 2958          + TR        GPARAM
        3011+10 3011 TYALF    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        3012+ 1   83          + TR        PRTALF
        3013- 0 3035          - STOP      COL          COLUMN WHERE TXT STARTS
        3014+ 1 2958          + TR        GPARAM
        3015+10 3035 EOL      + R ADD     COL          SEND CARD BUFFER TO PRINTER AND RETURN TO CALLER
        3016+ 4 3021          + TR 0      DOPRINT      =0 -> PRINT ALLWAYS (NO SENSE SW CHECK)
        3017+ 9 3030          + ADD       D68          =1..6 -> SENSE 69..74 = OPERATOR'S PANEL SENSE SWITCH 1..6
        3018+13 3019          + STORE A   CHKSW
        3019+30    0 CHKSW    + SENSE     /   /         
        3020+ 1 3023          + TR        RETURN       SW NOT AT ON POSITION
        3021+10 3021 DOPRINT  + R ADD     *            PRINT CARD BUFFER
        3022+ 1   55          + TR        PRINTCRD
        3023+10 3032 RETURN   + R ADD     PARAM        PARAM-1 IS THE RETURN ADDR      
        3024+ 5 3028          + SUB       ONE
        3025+13 3026          + STORE A   EXIT
        3026+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        3027+ 0    0 ZERO     + STOP      0000
        3028+ 0    1 ONE      + STOP      0001
        3029+ 0    2 TWO      + STOP      0002
        3030+ 0   68 D68      + STOP      0068
        3031+ 0  100 D100     + STOP      100
        3032+ 0    0 PARAM    + STOP      0000
        3033+ 0    0 DATA     + STOP      0000
        3034+ 0    0 FMT      + STOP      0000
        3035+ 0    0 COL      + STOP      0000
        3036+ 9 3050 BMPAD    + ADD       TWO
        3037+13 3039          + STORE A   EXIT
        3038+10 3040          + R ADD     BITMAPAD
        3039+ 1    0 EXIT     + TR        /   /
        3040+ 0 3042 BITMAPAD + STOP      BITMAP
        3041+     0             ORG       EVEN
        3042+     0  BITMAP     DEF       0              <blank>     0     <none>
        3043+   256             DEF       256               1        1       1        256          =  256   
        3044+   128             DEF       128               2        2       2        128          =  128   
        3045+    64             DEF       64                3        3       3         64          =   64   
        3046+    32             DEF       32                4        4       4         32          =   32   
        3047+    16             DEF       16                5        5       5         16          =   16   
        3048+     8             DEF       8                 6        6       6          8          =    8   
        3049+     4             DEF       4                 7        7       7          4          =    4   
        3050+     2  TWO        DEF       2                 8        8       8          2          =    2   
        3051+     1             DEF       1                 9        9       9          1          =    1   
        3052+   512             DEF       512               0       10       0        512          =  512   
        3053+  1024             DEF       1024              -       11       X       1024          = 1024   
        3054+  2048             DEF       2048              +       12       Y       2048          = 2048   
        3055+  2304             DEF       2304              A       13      Y-1        256+2048    = 2304   
        3056+  2176             DEF       2176              B       14      Y-2        128+2048    = 2176   
        3057+  2112             DEF       2112              C       15      Y-3         64+2048    = 2112   
        3058+  2080             DEF       2080              D       16      Y-4         32+2048    = 2080   
        3059+  2064             DEF       2064              E       17      Y-5         16+2048    = 2064   
        3060+  2056             DEF       2056              F       18      Y-6          8+2048    = 2056   
        3061+  2052             DEF       2052              G       19      Y-7          4+2048    = 2052   
        3062+  2050             DEF       2050              H       20      Y-8          2+2048    = 2050   
        3063+  2049             DEF       2049              I       21      Y-9          1+2048    = 2049   
        3064+  1280             DEF       1280              J       22      X-1        256+1024    = 1280   
        3065+  1152             DEF       1152              K       23      X-2        128+1024    = 1152   
        3066+  1088             DEF       1088              L       24      X-3         64+1024    = 1088   
        3067+  1056             DEF       1056              M       25      X-4         32+1024    = 1056   
        3068+  1040             DEF       1040              N       26      X-5         16+1024    = 1040   
        3069+  1032             DEF       1032              O       27      X-6          8+1024    = 1032   
        3070+  1028             DEF       1028              P       28      X-7          4+1024    = 1028   
        3071+  1026             DEF       1026              Q       29      X-8          2+1024    = 1026   
        3072+  1025             DEF       1025              R       30      X-9          1+1024    = 1025   
        3073+   640             DEF       640               S       31      0-2        128+512     = 640    
        3074+   576             DEF       576               T       32      0-3         64+512     = 576    
        3075+   544             DEF       544               U       33      0-4         32+512     = 544    
        3076+   528             DEF       528               V       34      0-5         16+512     = 528    
        3077+   520             DEF       520               W       35      0-6          8+512     = 520    
        3078+   516             DEF       516               X       36      0-7          4+512     = 516    
        3079+   514             DEF       514               Y       37      0-8          2+512     = 514    
        3080+   513             DEF       513               Z       38      0-9          1+512     = 513    
        3081+   578             DEF       578               ,       39      8-3-0        2+64+512  = 578    
        3082+   546             DEF       546               %       40      8-4-0        2+32+512  = 546    
        3083+  1090             DEF       1090              $       41      8-3-X        2+64+1024 = 1090   
        3084+  1058             DEF       1058              *       42      8-4-X        2+32+1024 = 1058   
        3085+  2114             DEF       2114              .       43      8-3-Y        2+64+2048 = 2114   
        3086+  2082             DEF       2082              #       44      8-4-Y        2+32+2048 = 2082   
        3087+   768             DEF       768               /       45      0-1          512+256   = 768    
        3088+    66             DEF       66                +       46      8-3          2+64      = 66     
        3089+    34             DEF       34                -       47      8-4          2+32      = 34    This is the non-minus-sign separator
        3090+ 9 3114 CLMEM    + ADD       TWO 
        3091+13 3096          + STORE A   P1           PARM: ADDR 
        3092+ 9 3113          + ADD       ONE          
        3093+13 3098          + STORE A   P2           PARM: LOCATION OF LEN=NUMBER OF HALF-WORDS TO CLEAR 
        3094+ 9 3113          + ADD       ONE          
        3095+13 3104          + STORE A   EXIT
        3096+10    0 P1       + R ADD     /   /        GET ADDR TO CLEAR
        3097+13 3107          + STORE A   MEM
        3098+10    0 P2       + R ADD     /   /        GET LEN ADDR
        3099+13 3100          + STORE A   P2A
        3100+10    0 P2A      + R ADD     /   /        GET LEN 
        3101+12 3115          + STORE     LEN
        3102+15 3112          + LOAD MQ   ZERO
        3103+10 3115 LOOP     + R ADD     LEN
        3104+ 4    0 EXIT     + TR 0      /   /
        3105+ 5 3113          + SUB       ONE
        3106+12 3115          + STORE     LEN
        3107+14    0 MEM      + STORE MQ  /   /        
        3108+10 3107          + R ADD     MEM
        3109+ 9 3113          + ADD       ONE
        3110+13 3107          + STORE A   MEM
        3111+ 1 3103          + TR        LOOP
        3112+ 0    0 ZERO     + STOP      0000
        3113+ 0    1 ONE      + STOP      0001         constant 1
        3114+ 0    2 TWO      + STOP      0002         constant 2
        3115+ 0    0 LEN      + STOP      0000
        3116+ 9 3148 MEMCOPY  + ADD       TWO 
        3117+13 3124          + STORE A   P1           PARM: SRCADDR 
        3118+ 9 3147          + ADD       ONE          
        3119+13 3126          + STORE A   P2           PARM: DESTADDR
        3120+ 9 3147          + ADD       ONE          
        3121+13 3128          + STORE A   P3           PARM: LEN: LOCATION OF LEN=NUMBER OF HALF-WORDS TO CLEAR
        3122+ 9 3147          + ADD       ONE          
        3123+13 3134          + STORE A   EXIT
        3124+10    0 P1       + R ADD     /   /        GET SOURCE ADDR 
        3125+13 3137          + STORE A   MEMS
        3126+10    0 P2       + R ADD     /   /        GET DESTINATION ADDR 
        3127+13 3138          + STORE A   MEMD
        3128+10    0 P3       + R ADD     /   /        GET LEN ADDR
        3129+13 3130          + STORE A   P3A
        3130+10    0 P3A      + R ADD     /   /        GET LEN           
        3131+12 3149          + STORE     LEN
        3132+15 3146          + LOAD MQ   ZERO
        3133+10 3149 LOOP     + R ADD     LEN
        3134+ 4    0 EXIT     + TR 0      /   /
        3135+ 5 3147          + SUB       ONE
        3136+12 3149          + STORE     LEN
        3137+10    0 MEMS     + R ADD     /   /        
        3138+12    0 MEMD     + STORE     /   /        
        3139+10 3137          + R ADD     MEMS
        3140+ 9 3147          + ADD       ONE
        3141+13 3137          + STORE A   MEMS
        3142+10 3138          + R ADD     MEMD
        3143+ 9 3147          + ADD       ONE
        3144+13 3138          + STORE A   MEMD
        3145+ 1 3133          + TR        LOOP
        3146+ 0    0 ZERO     + STOP      0000
        3147+ 0    1 ONE      + STOP      0001         constant 1
        3148+ 0    2 TWO      + STOP      0002         constant 2
        3149+ 0    0 LEN      + STOP      0000
        3150+15 3217 SRCHTBL  + LOAD MQ   ZERO
        3151+ 1 3155          + TR        START
        3152+15 3218 EQTBL    + LOAD MQ   ONE
        3153+ 1 3155          + TR        START
        3154+15 3219 READTBL  + LOAD MQ   TWO
        3155+ 9 3219 START    + ADD       TWO 
        3156+13 3163          + STORE A   P1           PARM: ADDR OF TABLE
        3157+ 9 3218          + ADD       ONE          
        3158+13 3165          + STORE A   P2           PARM: LEN OF TABLE
        3159+ 9 3218          + ADD       ONE          
        3160+13 3170          + STORE A   P3           PARM: VAL TO FIND
        3161+ 9 3218          + ADD       ONE          
        3162+13 3211          + STORE A   EXIT
        3163+10    0 P1       + R ADD     /   /        GET ADDR OF TABLE
        3164+13 3214          + STORE A   TBL
        3165+10    0 P2       + R ADD     /   /        GET ADDR OF LEN OF TABLE/ENTRY ON TABLE
        3166+13 3167          + STORE A   P2A
        3167+10    0 P2A      + R ADD     /   /        DERREFERENCE -> ACC=LEN/ENTRY (1..LEN)
        3168+12 3212          + STORE     N
        3169+ 4 3211          + TR 0      EXIT         EXIT, CANNOT READ/STORE ON ENTRY 0, SEARCH ON EMPTY TABLE
        3170+10    0 P3       + R ADD     /   /        GET ADDR OF VAL TO FIND
        3171+13 3187          + STORE A   WRVAL
        3172+13 3173          + STORE A   P3A
        3173+10    0 P3A      + R ADD     /   /        DERREFERENCE -> ACC=VAL
        3174+12 3213          + STORE     VAL
        3175+14 3216          + STORE MQ  TEMP         JUMP TABLE DISPATCH
        3176+10 3216          + R ADD     TEMP
        3177+ 4 3192          + TR 0      LOOP0        TR TO SEARCH TABLE
        3178+10 3212          + R ADD     N            SUB ONE AS FIRST ENTRY ON TABLE IS "1"
        3179+ 5 3218          + SUB       ONE          
        3180+ 9 3214          + ADD       TBL          TABLE BASE ADDR
        3181+13 3190          + STORE A   WRTBL
        3182+13 3186          + STORE A   RDTBL2
        3183+10 3216          + R ADD     TEMP
        3184+ 5 3218          + SUB       ONE
        3185+ 4 3189          + TR 0      STORETBL 
        3186+10    0 RDTBL2   + R ADD     /   /        VAL=TBL[ENT]
        3187+12    0 WRVAL    + STORE     /   /
        3188+ 1 3211          + TR        EXIT
        3189+10 3213 STORETBL + R ADD     VAL          TBL[ENT]=VAL
        3190+12    0 WRTBL    + STORE     /   /    
        3191+ 1 3211          + TR        EXIT
        3192+10 3214 LOOP0    + R ADD     TBL
        3193+13 3199          + STORE A   RDTBL
        3194+10 3199          + R ADD     RDTBL
        3195+12 3215          + STORE     TBL0
        3196+ 9 3212          + ADD       N
        3197+12 3216          + STORE     TEMP         THE END ADDR OF TABLE
        3198+10 3213 LOOP     + R ADD     VAL          ACC=THE SEARCHED VALUE
        3199+ 5    0 RDTBL    + SUB       /   /    
        3200+ 2 3201          + TR OV     OVOK         CLEAR OV JUST IN CASE
        3201+ 4 3208 OVOK     + TR 0      FOUND        TR IF VAL FOUND IN ENTRY N
        3202+10 3199          + R ADD     RDTBL
        3203+ 9 3218          + ADD       ONE
        3204+13 3199          + STORE A   RDTBL
        3205+ 5 3216          + SUB       TEMP
        3206+ 4 3211          + TR 0      EXIT         NOT FOUND -> RETURN ZERO
        3207+ 1 3198          + TR        LOOP
        3208+10 3199 FOUND    + R ADD     RDTBL        RETURN ENTRY FOUND
        3209+ 5 3215          + SUB       TBL0
        3210+ 9 3218          + ADD       ONE
        3211+ 1    0 EXIT     + TR        /   /
        3212+ 0    0 N        + STOP      0000
        3213+ 0    0 VAL      + STOP      0000
        3214+ 0    0 TBL      + STOP      0000
        3215+ 0    0 TBL0     + STOP      0000
        3216+ 0    0 TEMP     + STOP      0000
        3217+ 0    0 ZERO     + STOP      0000
        3218+ 0    1 ONE      + STOP      0001         constant 1
        3219+ 0    2 TWO      + STOP      0002         constant 2
        3220+ 9 3279 SORTTBL  + ADD       TWO 
        3221+13 3226          + STORE A   P1           PARM: ADDR OF TABLE
        3222+ 9 3278          + ADD       ONE          
        3223+13 3228          + STORE A   P2           PARM: LEN OF TABLE
        3224+ 9 3278          + ADD       ONE          
        3225+13 3235          + STORE A   EXIT
        3226+10    0 P1       + R ADD     /   /        GET ADDR OF TABLE
        3227+13 3273          + STORE A   TBL
        3228+10    0 P2       + R ADD     /   /        GET ADDR OF LEN OF TABLE
        3229+13 3230          + STORE A   P2A
        3230+10    0 P2A      + R ADD     /   /        DERREFERENCE -> ACC=LEN
        3231+12 3271          + STORE     N
        3232+ 4 3235          + TR 0      EXIT         EXIT, NO MORE ENTRIES IN TABLE TO SORT
        3233+10 3271 LOOP     + R ADD     N            
        3234+ 5 3278          + SUB       ONE          
        3235+ 4    0 EXIT     + TR 0      /   /        EXIT, NO MORE ENTRIES TO SORT -> EXIT
        3236+12 3271          + STORE     N
        3237+12 3272          + STORE     I
        3238+10 3277          + R ADD     ZERO
        3239+12 3276          + STORE     MAXAD        NO MAX VALUE YET
        3240+10 3272 LOOPM1   + R ADD     I
        3241+ 9 3273          + ADD       TBL          TABLE BASE ADDR
        3242+13 3243          + STORE A   RDTBL
        3243+15    0 RDTBL    + LOAD MQ   /   /        MQ=TBL[I]
        3244+10 3276          + R ADD     MAXAD        IS MAXAD (ADDR OF MAX VALUE) SET?
        3245+ 4 3251          + TR 0      SORTM1       NO -> JUST SAVE MAXAD=LOCATION OF TBL[I] AND MAX=TBL[I]
        3246+14 3274          + STORE MQ  VAL          YES -> COMPARE MAX VALUE WITH TBL[I]
        3247+10 3277          + R ADD     ZERO
        3248+11 3275          + ADD AB    MAX          IF ABS(VAL) < ABS(MAX) THEN ...          
        3249+ 7 3274          + SUB AB    VAL
        3250+ 3 3254          + TR +      SORTM2       ... TR TO PROCEED WITH NEXT I
        3251+14 3275 SORTM1   + STORE MQ  MAX          SAVE MAXAD, MAX
        3252+10 3243          + R ADD     RDTBL        
        3253+13 3276          + STORE A   MAXAD     
        3254+10 3272 SORTM2   + R ADD     I            PROCEED WITH NEXT I
        3255+ 4 3259          + TR 0      SORTM3
        3256+ 5 3278          + SUB       ONE
        3257+12 3272          + STORE     I
        3258+ 1 3240          + TR        LOOPM1
        3259+10 3271 SORTM3   + R ADD     N            EXCHANGE TBL[N] <-> MAXAD (TBL ENTRY WITH MAX ABS VALUE)
        3260+ 9 3273          + ADD       TBL          SO TBL[N] NOW HAS THE MAX VALUE
        3261+13 3266          + STORE A   SWAPN1
        3262+13 3268          + STORE A   SWAPN2
        3263+10 3276          + R ADD     MAXAD
        3264+13 3267          + STORE A   SWAPM1
        3265+13 3269          + STORE A   SWAPM2
        3266+10    0 SWAPN1   + R ADD     /   /
        3267+15    0 SWAPM1   + LOAD MQ   /   /         
        3268+14    0 SWAPN2   + STORE MQ  /   /
        3269+12    0 SWAPM2   + STORE     /   /         
        3270+ 1 3233          + TR        LOOP
        3271+ 0    0 N        + STOP      0000
        3272+ 0    0 I        + STOP      0000
        3273+ 0    0 TBL      + STOP      0000
        3274+ 0    0 VAL      + STOP      0000
        3275+ 0    0 MAX      + STOP      0000
        3276+ 0    0 MAXAD    + STOP      0000
        3277+ 0    0 ZERO     + STOP      0000
        3278+ 0    1 ONE      + STOP      0001         constant 1
        3279+ 0    2 TWO      + STOP      0002         constant 2
        3280+ 9 3353 RWDRUM   + ADD       TWO 
        3281+13 3290          + STORE A   PDR1         PARM1: DRUM INSTR: READ/WRITE 0128  0129  0130  0131
        3282+ 9 3352          + ADD       ONE          
        3283+13 3292          + STORE A   PDR2         PARM2: DRUM ADDRESS (0..4094)
        3284+ 9 3352          + ADD       ONE          
        3285+13 3294          + STORE A   PDR3         PARM3: BUF START ADDRESS
        3286+ 9 3352          + ADD       ONE          
        3287+13 3296          + STORE A   PDR4         PARM4: LEN: NUMBER OF HALF-WORDS (MUST BE EVEN)
        3288+ 9 3352          + ADD       ONE          
        3289+13 3350          + STORE A   EXIT               
        3290+10    0 PDR1     + R ADD     /   /        GET DRUM INSTR
        3291+12 3298          + STORE     DRIO
        3292+10    0 PDR2     + R ADD     /   /        GET DRUM ADDR
        3293+13 3299          + STORE A   DRADDR
        3294+10    0 PDR3     + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        3295+13 3337          + STORE A   RWCOPY    
        3296+10    0 PDR4     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        3297+12 3354          + STORE     LEN
        3298+ 0    0 DRIO     + STOP      /   /        INSTR: READ/WRITE 0128  0129  0130  0131
        3299+29    0 DRADDR   + SET DR    /   /
        3300+ 1 3333          + TR        LOOP
        3301+ 9 3353 RDTAPE   + ADD       TWO 
        3302+13 3309          + STORE A   PR1          PARM1: TAPE ADDRESS
        3303+ 9 3352          + ADD       ONE          
        3304+13 3311          + STORE A   PR2          PARM2: BUF START ADDRESS
        3305+ 9 3352          + ADD       ONE          
        3306+13 3350          + STORE A   EXIT
        3307+ 2 3308          + TR OV     CLOV1        CLEAR OV THAT MAY HAVE BEEN SET
        3308+ 8    0    CLOV1 + NOOP      0000
        3309+10    0 PR1      + R ADD     /   /        GET TAPE ADDR
        3310+13 3313          + STORE A   RTAPAD       TAPE UNITS: 0256  0257  0258  0259
        3311+10    0 PR2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        3312+13 3337          + STORE A   RWCOPY    
        3313+24    0 RTAPAD   + READ      /   /
        3314+10 3351          + R ADD     ZERO
        3315+ 1 3335          + TR        LOOP1
        3316+ 9 3353 WRTAPE   + ADD       TWO 
        3317+13 3324          + STORE A   PW1          PARM1: TAPE ADDRESS
        3318+ 9 3352          + ADD       ONE          
        3319+13 3326          + STORE A   PW2          PARM2: BUF START ADDRESS
        3320+ 9 3352          + ADD       ONE          
        3321+13 3328          + STORE A   PW3          PARM3: BUF LEN
        3322+ 9 3352          + ADD       ONE          
        3323+13 3350          + STORE A   EXIT
        3324+10    0 PW1      + R ADD     /   /        GET TAPE ADDR
        3325+13 3332          + STORE A   WTAPAD       TAPE UNITS: 0256  0257  0258  0259
        3326+10    0 PW2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        3327+13 3337          + STORE A   RWCOPY    
        3328+10    0 PW3      + R ADD     /   /        GET ADDR OF LEN 
        3329+13 3330          + STORE A   PW3A
        3330+10    0 PW3A     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        3331+12 3354          + STORE     LEN
        3332+26    0 WTAPAD   + WRITE     /   /        PREPARE TO WRITE ON TAPE
        3333+10 3354 LOOP     + R ADD     LEN
        3334+ 4 3349          + TR 0      RWOK
        3335+ 5 3353 LOOP1    + SUB       TWO
        3336+12 3354          + STORE     LEN
        3337-31    0 RWCOPY   - COPY      /   /        WRITE BUFFER TO TAPE
        3338+ 1 3341          + TR        GO 
        3339+ 1 3345          + TR        EOF          END OF FILE
        3340+ 1 3347          + TR        EOR          END OF RECORD
        3341+10 3337 GO       + R ADD     RWCOPY
        3342+ 5 3353          + SUB       TWO
        3343+13 3337          + STORE A   RWCOPY
        3344+ 1 3333          + TR        LOOP
        3345+10 3352 EOF      + R ADD     ONE          SET OV FLAG TO SIGNAL END OF FILE CONDITION
        3346+22   36          + A LEFT    36
        3347+ 6 3354 EOR      + R SUB     LEN          RETURN NUMBER OF HALF-WORDS READ
        3348+ 5 3353          + SUB       TWO
        3349+26 2052 RWOK     + WRITE     2052         INSURE THAT MQ NOT IN USE            
        3350+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        3351+ 0    0 ZERO     + STOP      0000
        3352+ 0    1 ONE      + STOP      0001         
        3353+ 0    2 TWO      + STOP      0002         
        3354+     0  LEN        RES       1
        3356+12 3432 RDBTAPE  + STORE     DUMMY
        3357+10 3426          + R ADD     RDBKW        SET THE TAPE I/O INSTRUCTION
        3358+12 3396          + STORE     RTAPAD
        3359+10 3427          + R ADD     ADD2         SET TO DECREMENT RWCOPY ADDRESS
        3360+12 3406          + STORE     INCR         (INSTR IS -COPY -> NEGATIVE -> DECREMENT BY ADDING TWO)
        3361+15 3430          + LOAD MQ   ONE          FLAG OF COMPUTE: ADD=ADD+LEN-2
        3362+ 1 3369          + TR        READ
        3363+12 3432 RDFTAPE  + STORE     DUMMY
        3364+10 3425          + R ADD     RDFWD        SET THE TAPE I/O INSTRUCTION
        3365+12 3396          + STORE     RTAPAD
        3366+10 3428          + R ADD     SUB2         SET TO INCREMENT RWCOPY ADDRESS
        3367+12 3406          + STORE     INCR         (INSTR IS -COPY -> NEGATIVE -> INCREMENT BY SUBSTRACTING TWO)
        3368+15 3429          + LOAD MQ   ZERO
        3369+10 3432 READ     + R ADD     DUMMY        PROCEED
        3370+ 9 3431          + ADD       TWO 
        3371+13 3378          + STORE A   PR1          PARM1: TAPE ADDRESS
        3372+ 9 3430          + ADD       ONE          
        3373+13 3381          + STORE A   PR2          PARM2: BUF START ADDRESS
        3374+ 9 3430          + ADD       ONE          
        3375+13 3383          + STORE A   PR3          PARM2: BUF LEN ADDRESS
        3376+ 9 3430          + ADD       ONE          
        3377+13 3424          + STORE A   EXIT
        3378+10    0 PR1      + R ADD     /   /        GET TAPE ADDR
        3379+13 3396          + STORE A   RTAPAD       TAPE UNITS: 0256  0257  0258  0259
        3380+ 2 3381          + TR OV     PR2          CLEAR OVERFLOW FLAG
        3381+10    0 PR2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        3382+13 3401          + STORE A   RWCOPY    
        3383+10    0 PR3      + R ADD     /   /        GET ADDR OF LEN 
        3384+13 3385          + STORE A   PR3A
        3385+10    0 PR3A     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        3386+12 3433          + STORE     LEN
        3387+10 3429          + R ADD     ZERO
        3388+20   35          + L LEFT    0035         ACC=MQ
        3389+ 4 3394          + TR 0      PR4          IF MQ=0 -> READ FWD -> TR TO PR4
        3390+10 3401          + R ADD     RWCOPY       HERE READ BKW -> SET BUFFER START AT ADD+LEN-2
        3391+ 5 3433          + SUB       LEN
        3392+ 9 3431          + ADD       TWO
        3393+13 3401          + STORE A   RWCOPY
        3394+10 3429 PR4      + R ADD     ZERO
        3395+12 3434          + STORE     RECLEN
        3396+ 0    0 RTAPAD   + STOP      /   /        WILL BE REPLACED BY RDFWD OR RDBKW
        3397+10 3433 LOOP     + R ADD     LEN
        3398+ 4 3412          + TR 0      SKIP
        3399+ 5 3431          + SUB       TWO
        3400+12 3433          + STORE     LEN
        3401-31    0 RWCOPY   - COPY      /   /        WRITE BUFFER TO TAPE
        3402+ 1 3405          + TR        GO 
        3403+ 1 3420          + TR        EOF          END OF FILE
        3404+ 1 3422          + TR        EOR          END OF RECORD
        3405+10 3401 GO       + R ADD     RWCOPY
        3406+ 5 3431 INCR     + SUB       TWO
        3407+13 3401          + STORE A   RWCOPY
        3408+10 3434          + R ADD     RECLEN
        3409+ 9 3431          + ADD       TWO
        3410+12 3434          + STORE     RECLEN
        3411+ 1 3397          + TR        LOOP
        3412-31 3432 SKIP     - COPY      DUMMY
        3413+ 1 3416          + TR        GO2 
        3414+ 1 3420          + TR        EOF          END OF FILE
        3415+ 1 3422          + TR        EOR          END OF RECORD
        3416+10 3434 GO2      + R ADD     RECLEN
        3417+ 9 3431          + ADD       TWO
        3418+12 3434          + STORE     RECLEN
        3419+ 1 3412          + TR        SKIP
        3420+10 3430 EOF      + R ADD     ONE          SET OV FLAG TO SIGNAL END OF FILE CONDITION
        3421+22   36          + A LEFT    36
        3422+10 3434 EOR      + R ADD     RECLEN       RETURN NUMBER OF HALF-WORDS IN TAPE RECORD
        3423+26 2052          + WRITE     2052         INSURE THAT MQ NOT IN USE            
        3424+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        3425+24    0 RDFWD    + READ      0000         TAPE I/O INSTRUCTIONS 
        3426+25    0 RDBKW    + READ B    0000
        3427+ 9 3431 ADD2     + ADD       TWO
        3428+ 5 3431 SUB2     + SUB       TWO
        3429+ 0    0 ZERO     + STOP      0000
        3430+ 0    1 ONE      + STOP      0001         
        3431+ 0    2 TWO      + STOP      0002         
        3432+     0  DUMMY      RES       1
        3433+     0  LEN        RES       1
        3434+     0  RECLEN     RES       1
        3436+ 9 3451 CHAIN    + ADD       TWO
        3437+13 3438          + STORE A   CHP1
        3438+10    0 CHP1     + R ADD     /   /        GET TAPE NUMBER
        3439+13 3446          + STORE A   TAPELOAD
        3440+30   70          + SENSE     0070         SENSE SWITCH 2                                  
        3441+ 1 3445 CONTAD   + TR        ENDSTOP      (ON POSITION MAKES SENSE OPCODE TO SKIP NEXT INSTR)
        3442+10 3441          + R ADD     CONTAD       IF SW2 IS ON, A +STOP 4095 IS EXECUTED.  
        3443+12 4095          + STORE     4095         IF THEN USER PRESS START, EXECUTION WILL BE RESUMED 
        3444+ 0 4095          + STOP      4095         AND CHAINED PROGRAM WILL BE LOADED AND EXECUTED
        3445+ 8    0 ENDSTOP  + NOOP      0000
        3446+24    0 TAPELOAD + READ      0000         
        3447-31    0 TL0      - COPY      0000         READ 1ST WORD OF SELF-LOADER FROM TAPE
        3448+ 1    0          + TR        0000         TR TO SELF-LOADER
        3449+ 0 2221          + STOP      2221         ERROR LOADING: UNEXPECTED END OF FILE
        3450+ 0 2222          + STOP      2222         ERROR LOADING: UNEXPECTED END OF RECORD 
        3451+ 0    2 TWO      + STOP      0002         ERROR LOADING: UNEXPECTED END OF FILE
          48-     0  ROUTINE INIT
          49+ 1  181 ENTRY POINT
          50-     0  ROUTINE CHAIN
          51+ 1 3436 ENTRY POINT
          52-     0  ROUTINE PRTNLINE
          53+ 1 2954 ENTRY POINT
          54-     0  ROUTINE PRINTCRD
          55+ 1 2632 ENTRY POINT
          56-     0  ROUTINE PRTSTR
          57+ 1 2693 ENTRY POINT
          58-     0  ROUTINE PRTINT
          59+ 1 2794 ENTRY POINT
          60-     0  ROUTINE RDBTAPE
          61+ 1 3356 ENTRY POINT
          62-     0  ROUTINE WRTAPE
          63+ 1 3316 ENTRY POINT
          64-     0  ROUTINE RWDRUM
          65+ 1 3280 ENTRY POINT
          66-     0  ROUTINE CLMEM
          67+ 1 3090 ENTRY POINT
          68-     0  ROUTINE MEMCOPY
          69+ 1 3116 ENTRY POINT
          70-     0  ROUTINE SORTTBL
          71+ 1 3220 ENTRY POINT
          72-     0  ROUTINE SRCHTBL
          73+ 1 3150 ENTRY POINT
          74-     0  ROUTINE EQTBL
          75+ 1 3152 ENTRY POINT
          76-     0  ROUTINE CLRBUF
          77+ 1 2624 ENTRY POINT
          78-     0  ROUTINE READCRD
          79+ 1 2628 ENTRY POINT
          80-     0  ROUTINE WRITECRD
          81+ 1 2630 ENTRY POINT
          82-     0  ROUTINE PRTALF
          83+ 1 2716 ENTRY POINT
          84-     0  ROUTINE PRTCHR
          85+ 1 2836 ENTRY POINT
          86-     0  ROUTINE PRTOCT
          87+ 1 2760 ENTRY POINT
          88-     0  ROUTINE BMPAD
          89+ 1 3036 ENTRY POINT
          90-     0  ROUTINE READTBL
          91+ 1 3154 ENTRY POINT
          92-     0  ROUTINE RDTAPE
          93+ 1 3301 ENTRY POINT
          94-     0  ROUTINE RDFTAPE
          95+ 1 3363 ENTRY POINT
        4094+    48  REGION ORIGIN TABLE LOCATION
        4095+   181  INITIAL REGION
           0+ 1  181          + TR        INIT         PROGRAM START
