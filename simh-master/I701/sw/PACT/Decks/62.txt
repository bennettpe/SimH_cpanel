        DEC
        NNNN OP ADDR COMMENTS
          88+ 9 1300 LOADCC   + ADD       TWO          LOAD PACTSCR INTO CARD IMAGE SO 
          89+13  108          + STORE A   CPCCEX       CURRENT PACT SOURCE CODE CAN BE PRINTED
          90+10 1297          + R ADD     ZERO         COPY TO LEFT SIDE OF SOURCE CODE CARD IMAGE
          91+13   95          + STORE A   CPCC1        AT 0..46 FROM PACTSCR
          92+10  111          + R ADD     CPCC2
          93+13   94          + STORE A   CPCC 
          94-10    0 CPCC     - R ADD     /   /
          95-12    0 CPCC1    - STORE     /   /
          96+10   95          + R ADD     CPCC1
          97+ 5 1300          + SUB       TWO
          98+13  100          + STORE A   CPCC1B
          99+10 1297          + R ADD     ZERO
         100-12    0 CPCC1B   - STORE     /   /
         101+10   94          + R ADD     CPCC
         102+ 5 1300          + SUB       TWO
         103+13   94          + STORE A   CPCC
         104+10   95          + R ADD     CPCC1
         105+ 5 1301          + SUB       D4
         106+13   95          + STORE A   CPCC1
         107+ 5  110          + SUB       CPCCE
         108+ 4    0 CPCCEX   + TR 0      /   /        RETURN TO CALLER
         109+ 1   94          + TR        CPCC
         110-12   48 CPCCE    - STORE     0048         LAST LOCATION TO COPY FROM 
         111+ 8  248 CPCC2    + NOOP      PACTSRC      PACTSRC = FIRST LOCATION TO COPY FROM
         112+ 0 1111 BADREF   + STOP      1111         INTERNAL COMPILER ERROR
         113+10  113 INIT     + R ADD     *            
         114+ 1   53          + TR        PRTNLINE     
         115+ 0  101          + STOP      0101         STRINGZ AT COL 1
         116+ 0 1307          + STOP      MSGSTART     "FINAL ASSEMBLY PASS 2"
         117+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         118+10 1297          + R ADD     ZERO         CLEAR CC RECORD
         119+12  272          + STORE     REGION     
         120+12  273          + STORE     STEP       
         121+12  274          + STORE     OP         
         122+12  275          + STORE     FACT       
         123+12  276          + STORE     S1         
         124+12  277          + STORE     S2         
         125+12  278          + STORE     QR         
         126+12  279          + STORE     QF         
         127-12  280          - STORE     NUM        
         128+12  282          + STORE     CLUE       
         129+12  283          + STORE     STEPN      
         130+12  284          + STORE     FACTN      
         131+12  285          + STORE     FACTREG    
         132+12  286          + STORE     S1N        
         133+12  287          + STORE     S2N        
         134+12  288          + STORE     D1N        
         135+12  289          + STORE     D2N        
         136+12  290          + STORE     NINST      
         137+12  291          + STORE     NINCR 
         138+10  492          + R ADD     CCLEN        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         139+10 1296          + R ADD     MAXNINST     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         140+10  292          + R ADD     TINST        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         141+28  258          + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE)
         142+28  257          + REWIND    TAPEOUTR     REWIND TAPE OUT WITH RESOLVED REFERENCES TABLE
         143+28  259          + REWIND    TAPEINR      REWIND TAPE IN WITH REFERENCES TABLE
         144+10  144 READREG  + R ADD     *            
         145+ 1   61          + TR        RDTAPE       READ MAGNETIC TAPE (REFERENCES TABLE)
         146+ 0  259          + STOP      TAPEINR
         147+ 0  494          + STOP      MAXNREFS     READ MAXREFS (1 HW) + NREFS (1 HW)
         148+ 2  168          + TR OV     NOMORE       NO MORE REFERENCES DATA 
         149+10  149          + R ADD     *            
         150+ 1   61          + TR        RDTAPE       READ MAGNETIC TAPE (REFERENCES TABLE)
         151+ 0  259          + STOP      TAPEINR
         152+ 0  496          + STOP      TSTEPREF
         153+10 1297          + R ADD     ZERO
         154+12 1305          + STORE     IREF         INIT REFERENCES FOR THIS REGION
         155+12 1304          + STORE     IRELADDR     I RELATIVE LOCATION OF THIS STEP
         156+10 1305 NEXTREF  + R ADD     IREF
         157+ 5  495          + SUB       NREFS
         158+ 4  168          + TR 0      NOMORE 
         159+10 1305          + R ADD     IREF
         160+ 9 1299          + ADD       ONE
         161+12 1305          + STORE     IREF
         162+10  162          + R ADD     *            READ FROM TREF TABLES
         163+ 1   67          + TR        READTBL
         164+ 0  496          + STOP      TSTEPREF
         165+ 0 1305          + STOP      IREF     
         166+ 0 1306          + STOP      REF1         = TREFADDR[IREF] 
         167+ 1  170          + TR        REFOK
         168+10 1297 NOMORE   + R ADD     ZERO         SEt TO ZERO AS THERE ARE NO MORE REFERENCES TO RESOLVE
         169+12 1306          + STORE     REF1         
         170+ 8    0 REFOK    + NOOP      0000
         171+10  171 READSTEP + R ADD     *            READ PACT USER PROGRAM SOURCE CODE FROM TAPE IN
         172+ 1   61          + TR        RDTAPE
         173+ 0  258          + STOP      TAPEIN
         174+ 0  248          + STOP      CCODE        BUF TO READ IN FROM TAPE
         175+ 2  238          + TR OV     EOF          TR IF END OF FILE
         176+10  274          + R ADD     OP
         177+ 4  212          + TR 0      EOR          TR IF END OF REGION
         178+10  178          + R ADD     *            LOAD PACTSCR INTO CARD IMAGE SO 
         179+ 1   88          + TR        LOADCC       CURRENT PACT SOURCE CODE CAN BE PRINTED
         180+10 1304          + R ADD     IRELADDR     I RELATIVE LOCATION OF THIS STEP
         181+12 1303          + STORE     IREL0
         182+ 9  290          + ADD       NINST        NUMBER OF INST IN THIS STEP
         183+12 1304          + STORE     IRELADDR     I REL FOR NEXT STEP
         184+30   74          + SENSE     0074         SENSE SWITCH 6
         185+ 1  197          + TR        ENDLOG1      TR IF NO LOG SELECTED
         186+15 1303          + LOAD MQ   IREL0        I RELATIVE LOCATION OF THIS STEP
         187+10  187          + R ADD     *
         188+ 1   59          + TR        PRTINT
         189+ 0    4          + STOP      0004         LEN=4
         190+ 0   41          + STOP      0041         COL 41
         191+15 1302          + LOAD MQ   D21          'I'
         192+10  192          + R ADD     *
         193+ 1   57          + TR        PRTCHR
         194+ 0   40          + STOP      0040         COL 40
         195+10  195          + R ADD     *            PRINT STEP JUST PROCESSED
         196+ 1   55          + TR        PRINTCRD
         197+ 8    0 ENDLOG1  + NOOP      0000 
         198+10 1306          + R ADD     REF1
         199+ 4  210          + TR 0      NEXT         CONTINUE READING STEPS IF THERE ARE NO MORE REFERENCES TO SATISFY
         200+ 5  283          + SUB       STEPN        IS THIS STEP REFERENCED?
         201+ 4  204          + TR 0      CHKREF       TR IF YES
         202+ 3  210          + TR +      NEXT         STEPN NOT ARRIVED YET TO REF1. TR TO CONTINUE READING STEPS
         203+ 1  112          + TR        BADREF       INTERNAL COMPILER ERROR: THERE IS A REFERENCE TO VAL1 STEP, BUT THIS STEP DOES NOT EXISTS
         204+10  204 CHKREF   + R ADD     *            SAVE THE IREL ADDRESS FOR THE REFERENCED STEP         
         205+ 1   65          + TR        EQTBL        THIS RESOVES THE STEP REFERENCE
         206+ 0  896          + STOP      TSTEPLOC
         207+ 0 1305          + STOP      IREF
         208+ 0 1303          + STOP      IREL0        TREFADDR[IREF] = IREL0
         209+ 1  156          + TR        NEXTREF      SELECT NEXT REFERENCE TO SATISFY
         210+ 8    0 NEXT     + NOOP      0000 
         211+ 1  171          + TR        READSTEP
         212+ 8    0 EOR      + NOOP      0000         END OF REGION  
         213+10  495          + R ADD     NREFS        NUMBER OF HALF-WORDS TO SAVE ON TAPE
         214+ 9 1299          + ADD       ONE          
         215+21   19          + L RIGHT   0019         MAKE IT EVEN ((NREFS + 1) AND OCT 7776) 
         216+22   19          + A LEFT    0019
         217+12  493          + STORE     N
         218+ 5 1299          + SUB       ONE          IF =0 SET =2 TO AVOID SAVING EMPTY RECORDS ON TAPE
         219+ 3  222          + TR +      SVREFS
         220+10 1300          + R ADD     TWO
         221+12  493          + STORE     N
         222+10  222 SVREFS   + R ADD     *            
         223+ 1   63          + TR        WRTAPE       WRITE MAGNETIC TAPE (REFERENCES TABLE)
         224+ 0  257          + STOP      TAPEOUTR
         225+ 0  495          + STOP      NREFS        BUF TO WRITE TO TAPE
         226+ 0 1300          + STOP      TWO          NUM OF HALF-WORDS TO SAVE (MUST BE EVEN)
         227+10  227          + R ADD     *            
         228+ 1   63          + TR        WRTAPE       WRITE MAGNETIC TAPE (REFERENCES TABLE)
         229+ 0  257          + STOP      TAPEOUTR
         230+ 0  496          + STOP      TSTEPREF     BUF TO WRITE TO TAPE
         231+ 0  493          + STOP      N            NUM OF HALF-WORDS TO SAVE (MUST BE EVEN)
         232+10  232          + R ADD     *            
         233+ 1   63          + TR        WRTAPE       WRITE MAGNETIC TAPE (REFERENCES TABLE)
         234+ 0  257          + STOP      TAPEOUTR
         235+ 0  896          + STOP      TSTEPLOC     BUF TO WRITE TO TAPE
         236+ 0  493          + STOP      N            NUM OF HALF-WORDS TO SAVE (MUST BE EVEN)
         237+ 1  144          + TR        READREG      PROCEED WITH NEXT REGION
         238+ 8    0 EOF      + NOOP      0000         END OF FILE
         239+27  257          + WRITE EF  TAPEOUTR     WRITE EOF IN TAPE OUT (COMPACT CODE)
         240+28  258          + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE)
         241+28  257          + REWIND    TAPEOUTR     REWIND TAPE OUT WITH RESOLVED REFERENCES TABLE
         242+28  259          + REWIND    TAPEINR      REWIND TAPE IN WITH REFERENCES TABLE
         243+10  243          + R ADD     *
         244+ 1   51          + TR        CHAIN        IF SW2 IS ON, A +STOP 4095 IS EXECUTED 
         245+ 0  256          + STOP      PACTCOMP     CHAIN TO NEXT STAGE IN PACT COMPILER TAPE
         246+ 0 4095          + STOP      4095
         247+     0             ORG       EVEN
         248+     0  PACTSRC    RES       24           CARD IMAGE OF PACT SOURCE CODE CARD (12 FULL WORDS)
         272+     0  REGION     DEF       0
         273+     0  STEP       DEF       0            REGION = ALFA (<0)
         274+     0  OP         DEF       0            STEP   = INT (>0)
         275+     0  FACT       DEF       0            OP     = 0..43    =0 MEANS END OF REGION
         276+     0  S1         DEF       0            FACT   < 0 -> FACTOR IS AN ALFA SYMBOL (VAR, REGION, ...) 
         277+     0  S2         DEF       0            FACT = 0 -> BLANK FACTOR
         278+     0  QR         DEF       0            FACT = 0..9999 -> DESTINATION STEP FOR TRANSFER/RESULT OF STEP
         279+     0  QF         DEF       0            CLUE = -, R OR N
         280+     0  NUM        DEF       0            
         281+     0             DEF       0            S1/S2 = 0 -> BLANK, >0 -> INTEGER, <0 -> ALFA 
         282+     0  CLUE       DEF       0
         283+     0  STEPN      DEF       0            QR = +/- INTEGER OR BLANK. 
         284+     0  FACTN      DEF       0            QF = SET IF THERE IS AN INTEGER FACTOR/NUMBER IN CARD
         285+     0  FACTREG    DEF       0
         286+     0  S1N        DEF       0            STEPN = SEQUENTIAL NUMBER OF STEP            
         287+     0  S2N        DEF       0            IF OP IS TRANSFER -> FACTN=DESTINATION STEPN
         288+     0  D1N        DEF       0            FACTN=ADDR (0, 2, 4, ..) FACTREG=' ', 'T', 'V', 'N'
         289+     0  D2N        DEF       0            S1N/S2N=INDEX (IF <0), BLANK (IF =0), CONST (IF >0)
         290+     0  NINST      DEF       0            D1N/D2N=HALF-WORD SIZE OF EACH DIMENSION
         291+     0  NINCR      DEF       0
         292+     0  TINST      RES       200          MACHINE CODE: 1ST HALF-WORD OPCODE + REGION/LOCATION INTO STEP (FOR TRANSFERS)
         492+    44  CCLEN      DEF       0044         LENGTH OF COMPACT CODE RECORD 
         493+     0  N          DEF       0            TEMP VAR (HERE TO MAKE TABLES START AT EVEN LOCATION)
         494+   400  MAXNREFS   DEF       400          MAX 400 STEPN REFERENCES CAN DE DEFINED IN ONE REGION
         495+     0  NREFS      DEF       0            NUMBER OF ENTRIES IN TSTEPREF TABLE
         496+     0  TSTEPREF   RES       400          LOCAL STEP REFERENCES TABLE: STEPN REFERENCED BY A TR STEPN MC INSTR IN CURRENT REGION
         896+     0  TSTEPLOC   RES       400          LOCATION OF STEP REFERENCED TABLE: LOCATION ON I-REGION OF EACH STEPN REFERENCED 
        1296+   100  MAXNINST   DEF       100          MAX NUMBER OF MACHINE CODE INSTRUTIONS PER STEP
        1297+     0  ZERO       DEF       0
        1298+     0             DEF       0
        1299+     1  ONE        DEF       1
        1300+     2  TWO        DEF       2
        1301+     4  D4         DEF       4
        1302+    21  D21        DEF       21
        1303+     0  IREL0      DEF       0            REL ADDRESS USED BY CURRENT STEP
        1304+     0  IRELADDR   DEF       0            I RELATIVE LOCATION OF STEP
        1305+     0  IREF       DEF       0            CURRENT REFERENCE IN TSTEPREF/TSTEPLOC BEING RESOLVED
        1306+     0  REF1       DEF       0            CURRENT REFERENCE TO RESOLVE
        1307- 42506  MSGSTART   TXT       "FINAL ASSEMBLY PASS 2",0
        1308- 31104  
        1309- 31471  
        1310- 40382  
        1311- 57072  
        1312- 65167  
        1313- 71426  
        1314+     0  
        1316+15 1330 CLRBUF   + LOAD MQ   IOCL
        1317+14 1335          + STORE MQ  BUFIO
        1318+15 1356          + LOAD MQ   IOSTORE         
        1319+ 1 1327          + TR        INIT2
        1320+15 1352 READCRD  + LOAD MQ   IORDCRD
        1321+ 1 1325          + TR        INIT1
        1322+15 1354 WRITECRD + LOAD MQ   IOWRCRD
        1323+ 1 1325          + TR        INIT1
        1324+15 1355 PRINTCRD + LOAD MQ   IOPRCRD
        1325+14 1335 INIT1    + STORE MQ  BUFIO
        1326+15 1353          + LOAD MQ   IOCOPY         
        1327+14 1336 INIT2    + STORE MQ  BUFROW
        1328+ 9 1362          + ADD       TWO          
        1329+13 1351          + STORE A   EXIT
        1330+10 1358 IOCL     + R ADD     ZERO         RESET TO INITIAL COPY LOOP ADDRESS     
        1331+13 1336          + STORE A   BUFROW       FOR BUFFER
        1332+10 1336          + R ADD     BUFROW       X .*echo Print
        1333+ 5 1363          + SUB       D48          X 
        1334+12 1360          + STORE     ENDLP        X LOOP END VALUE
        1335- 0    0   BUFIO  - STOP      /   /        READ OR WRITE
        1336-31    0   BUFROW - COPY      /   /        COPY WORD TO/FROM PRINTER/CARDREADER
        1337+ 1 1341          + TR        BUFOK2       NORMAL PROCESSING 
        1338+ 1 1348          + TR        EODECK       FOR COPY READING END OF REG (=END OF DECK BEING READ)
        1339+ 6 1362          + R SUB     TWO          END OF FILE -> NO CARD TO READ -> STOP with Acc=-2
        1340+ 0 1335          + STOP      BUFIO        ON PRESSING START RETRY CARD READ
        1341+10 1336   BUFOK2 + R ADD     BUFROW       X
        1342+ 5 1362          + SUB       TWO          INCR BUF ADDR
        1343+13 1336          + STORE A   BUFROW       X
        1344+ 5 1360          + SUB       ENDLP        CHECK FOR END
        1345+ 4 1350          + TR 0      ENDIO
        1346+10 1358          + R ADD     ZERO         CLEAR ACC IN CASE WE ARE CLEANING THE BUFFER
        1347+ 1 1336          + TR        BUFROW
        1348+10 1361 EODECK   + R ADD     ONE          SET OV FLAG TO SIGNAL END OF DECK CONDITION
        1349+22   36          + A LEFT    36
        1350+26 2052 ENDIO    + WRITE     2052         END OF I/O: INSURE THAT MQ NOT IN USE            
        1351+ 1    0 EXIT     + TR        /   /
        1352+24 2048 IORDCRD  + READ      2048         PREPARE TO READ FROM CARD READER
        1353-31    0 IOCOPY   - COPY      /   /   
        1354+26 1024 IOWRCRD  + WRITE     1024         PREPARE TO PUNCH CARD 
        1355+26  512 IOPRCRD  + WRITE     0512         PREPARE WRITE PRTBUF ON PRINTER
        1356-12    0 IOSTORE  - STORE     /   /        CLEAR BUFFER
        1357+     0             ORG       EVEN           
        1358+     0  ZERO       DEF       0            
        1359+     0             DEF       0            
        1360+     0  ENDLP      DEF       0            LOOP END VALUE
        1361+     1  ONE        DEF       1
        1362+     2  TWO        DEF       2
        1363+    48  D48        DEF       48
        1364+ 9 1635 PRTPARM2 + ADD       TWO          GET 2 PARAMS: LEN AND COL (EITHER VALUE OR VAR ADDR)
        1365+13 1384          + STORE A   PRTPRMEX
        1366+10 1374          + R ADD     PRTP1
        1367+ 9 1635          + ADD       TWO          PRINT PACKED TEXT FROM FULL-WORD VALUE IN MQ REGISTER 
        1368+13 1374          + STORE A   PRTP1        STORE ADDR OF FIRST PARAM (LEN)
        1369+ 9 1634          + ADD       ONE
        1370+13 1376          + STORE A   PRTP2        STORE ADDR OF SECOND PARAM (COL)
        1371+ 9 1634          + ADD       ONE
        1372+13 1451          + STORE A   EXIT
        1373-14 1624          - STORE MQ  NUM          SAVE VALUE TO PRINT PARAM MQ (NUM IS ALIASED TO TXT)
        1374+10    0   PRTP1  + R ADD     /   /        GET LEN: NUMBER OF CHARS TO PRINT (1..6)
        1375+12 1628          + STORE     LEN
        1376+10    0   PRTP2  + R ADD     /   /        GET COLUMN PARAM 1..72
        1377+ 3 1380          + TR +      PRTP4
        1378+13 1379          + STORE A   PRTP3        COL<0 -> INTERPRET COL AS LOC(COL) = ADDR OF COL VAR
        1379+10    0   PRTP3  + R ADD     /   /        READ VAR COL PASED AS PARAM
        1380+ 4 1451   PRTP4  + TR 0      EXIT         COL=0 -> EXIT
        1381+ 3 1383          + TR +      PRTP5
        1382+ 1 1451          + TR        EXIT         COL<0 -> EXIT
        1383+12 1434   PRTP5  + STORE     COL
        1384+ 1    0 PRTPRMEX + TR        /   /        RETURN TO CALLER
        1385+13 1374 PRTSTR   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        1386+10 1386          + R ADD     *            FOR PRINT STRINGZ FROM MEM
        1387+ 1 1364          + TR        PRTPARM2
        1388+12 1398          + STORE     COLSZ
        1389+10 1628          + R ADD     LEN          LEN IS IN FACT THE LOCATION WHERE THE STRING STARTS
        1390+13 1393          + STORE A   STRZAD
        1391+10 1451          + R ADD     EXIT
        1392+13 1406          + STORE A   STRZEX
        1393+10    0 STRZAD   + R ADD     /   /        GET HALF-WORD WITH NEXT 3 CHARS TO PRINT
        1394+ 4 1406          + TR 0      STRZEX       IF +0 -> END OF STRING (-0 DOES NOT TERMINATES THE STRING)
        1395+21   35          + L RIGHT   0035         MQ=3-CHARS TO PRINT
        1396+10 1396          + R ADD     *            
        1397+ 1 1408          + TR        PRTALF       PRINT 3 CHARS
        1398+ 0    0 COLSZ    + STOP      0000         COL 
        1399+10 1393 STRZ1    + R ADD     STRZAD       INCR STRING ADDRESS
        1400+ 9 1634          + ADD       ONE
        1401+13 1393          + STORE A   STRZAD
        1402+10 1398          + R ADD     COLSZ        INCR COLUMN
        1403+ 9 1636          + ADD       D3
        1404+13 1398          + STORE A   COLSZ
        1405+ 1 1393          + TR        STRZAD
        1406+ 3    0 STRZEX   + TR +      /   /        IF ZERO -> END OF STRING
        1407+ 1 1399          + TR        STRZ1
        1408+ 9 1635 PRTALF   + ADD       TWO          PRINT 3-PACKED CHARS IN MQ REGISTER 
        1409+14 1630          + STORE MQ  TXT          SAVE TEXT TO PRINT (IN LEFT HALF WORD)
        1410+13 1413          + STORE A   PRTAP2       STORE ADDR OF PARAM (COL)
        1411+ 9 1634          + ADD       ONE
        1412+13 1451          + STORE A   EXIT
        1413+10    0   PRTAP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        1414+ 3 1417          + TR +      PRTAP4
        1415+13 1416          + STORE A   PRTAP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        1416+10    0   PRTAP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        1417+12 1434   PRTAP4 + STORE     COL
        1418+10 1636          + R ADD     D3
        1419+12 1628          + STORE     LEN
        1420+10 1618 PRT1     + R ADD     ZERO         UNPACK LEFTMOST CHAR 
        1421+11 1630          + ADD AB    TXT          GET TEXT DISCARD SIGN
        1422+21   35          + L RIGHT   0035         MQ=Acc
        1423+10 1618          + R ADD     ZERO
        1424+18 1643          + DIV       D48X48
        1425+12 1630          + STORE     TXT          remainder=char to print, mq=c2 * 48 + c3 in right half-word
        1426+10 1618          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        1427+20   18          + L LEFT    0018         put c2 and c3 in left half-word of MQ to be saved in CHAR half word
        1428+14 1629          + STORE MQ  CHAR         CHAR TO PRINT
        1429+10 1629          + R ADD     CHAR 
        1430+ 4 1435          + TR 0      NXTCHR       IF BLANK PROCEED TO NEXT COL
        1431+21   35          + L RIGHT   0035         MQ=CHAR TO PRINT
        1432+10 1432          + R ADD     *            PRINT CHAR
        1433+ 1 1528          + TR        PRTCHR
        1434+ 0    0 COL      + STOP      0000         COL: COLUMN NUMBER TO PRINT (1..72)
        1435+10 1628 NXTCHR   + R ADD     LEN          DECR LEN COUNT
        1436+ 5 1634          + SUB       ONE
        1437+12 1628          + STORE     LEN
        1438+ 4 1451          + TR 0      EXIT         IF NO MORE CHARS TO PRINT EXIT
        1439+10 1434          + R ADD     COL          INCR COL POSITION
        1440+ 9 1634          + ADD       ONE
        1441+12 1434          + STORE     COL
        1442+ 5 1642          + SUB       D72          IF COL > 72 RETURN TO CALLER
        1443+ 4 1445          + TR 0      GNXTCHR      ELSE PROCEED WITH NEXT CHAR
        1444+ 3 1451          + TR +      EXIT
        1445+10 1618 GNXTCHR  + R ADD     ZERO         GET NEXT CHAR 
        1446+15 1630          + LOAD MQ   TXT
        1447+16 1641          + MPY       D48
        1448+22   17          + A LEFT    0017         GET RESULT IN LEFT HALF-WORD OF ACC
        1449+12 1630          + STORE     TXT
        1450+ 1 1420          + TR        PRT1         PROCEED TO PRINT CHAR
        1451+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        1452+13 1374 PRTOCT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        1453+10 1453          + R ADD     *            FOR PRINT OCTIONARY VALUE
        1454+ 1 1364          + TR        PRTPARM2
        1455+10 1628          + R ADD     LEN          LEN = OCTAL DIGITS TO PRINT
        1456+ 9 1434          + ADD       COL
        1457+ 5 1634          + SUB       ONE
        1458+12 1470          + STORE     COLN         COL POINTS TO LEAST SIGNIFICANT DIGIT
        1459+10 1624 PRTIOCG  + R ADD     NUM          GENERATE OCTINARY DIGIT
        1460+15 1618          + LOAD MQ   ZERO         CLEAR MQ
        1461+21   21          + L RIGHT   0021         3 LSB BITS OF LEFT HALF-WORD OF ACC TO MQ
        1462+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 3 BIT)
        1463+12 1624          + STORE     NUM          SAVE BACK NUM WITH RIGHTMOST OCTIONARY DIGIY EXTRACTED (NUM'=NUM/8)
        1464+10 1618          + R ADD     ZERO
        1465+20   21          + L LEFT    0021         LEFT HALF-WORD OF ACC IS NOW RIGHTMOST OCTINARY DIGIT EXTRACTED FROM NUM 
        1466+ 4 1484          + TR 0      PRTIOZ       TR IF THIS DIGIT IS ZERO TO PRINT A '0' (BASE48 CODE = 10) INSTEAD OF A BLANK (BASE48 CODE = 0)
        1467+21   35          + L RIGHT   0035         PUT DIGIT 1..9 TO PRINT IN MQ
        1468+10 1468 PRTOCTD  + R ADD     *            PRINT OCTINARY DIGIT
        1469+ 1 1528          + TR        PRTCHR
        1470+ 0    0 COLN     + STOP      0000
        1471+10 1470          + R ADD     COLN        DECR COL NUMBER TO PRINT NEXT DIGIT
        1472+ 5 1634          + SUB       ONE
        1473+12 1470          + STORE     COLN
        1474+10 1628          + R ADD     LEN          DECR COL NUMBER TO PRINT NEXT DIGIT
        1475+ 5 1634          + SUB       ONE
        1476+ 4 1451          + TR 0      EXIT         PRINTED LEN OCTINARY DIGITS -> EXIT
        1477+12 1628          + STORE     LEN
        1478+10 1624          + R ADD     NUM          IF NUM < 0, ADD SIGN BIT TO LEFTMOST DIGIT
        1479+ 3 1459          + TR +      PRTIOCG
        1480+10 1644          + R ADD     OCT04K       
        1481+ 5 1624          + SUB       NUM
        1482+12 1624          + STORE     NUM
        1483+ 1 1459          + TR        PRTIOCG
        1484+15 1637   PRTIOZ + LOAD MQ   D10          ACC=BASE48 CODE FOR '0'
        1485+ 1 1468          + TR        PRTOCTD      TR TO PRINT IT
        1486+13 1374 PRTINT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        1487+10 1487          + R ADD     *            FOR PRINT OCTIONARY VALUE
        1488+ 1 1364          + TR        PRTPARM2
        1489+10 1434          + R ADD     COL          PRINT DECIMAL NUMBER. VALUE OF LEN = DIGITS TO PRINT, NOT INCLUDING SIGN
        1490+ 9 1628          + ADD       LEN
        1491+ 5 1634          + SUB       ONE          
        1492+12 1513          + STORE     COLNI        COL POINTS TO END OF NUMBER
        1493+10 1618          + R ADD     ZERO
        1494+12 1627          + STORE     SGN          SIGN IS POSITIVE
        1495+10 1624          + R ADD     NUM
        1496+ 3 1501          + TR +      PRTINTG
        1497+ 6 1624          + R SUB     NUM          NUM IS NEGATIVE. CONVERT TO POSITIVE
        1498+12 1624          + STORE     NUM          AND SET SGN=1
        1499+10 1634          + R ADD     ONE
        1500+12 1627          + STORE     SGN          
        1501+10 1624 PRTINTG  + R ADD     NUM          GENERATE DECIMAL DIGIT
        1502+21   35          + L RIGHT   0035         MQ=Acc
        1503+10 1618          + R ADD     ZERO
        1504+18 1637          + DIV       D10
        1505+ 4 1526          + TR 0      PRTINZ
        1506+12 1629 PRTINTG2 + STORE     CHAR         acc=remainder=digit to print, mq=num/10
        1507+10 1618          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        1508+20   18          + L LEFT    0018         digit in left half-word of MQ to be saved in CHAR half word
        1509+14 1624          + STORE MQ  NUM 
        1510+15 1629          + LOAD MQ   CHAR 
        1511+10 1511 PRTINTD  + R ADD     *            PRINT DECIMAL DIGIT
        1512+ 1 1528          + TR        PRTCHR
        1513+ 0    0 COLNI    + STOP      0000
        1514+10 1513          + R ADD     COLNI        DECR COL NUMBER TO PRINT NEXT DIGIT
        1515+ 5 1634          + SUB       ONE
        1516+12 1513          + STORE     COLNI
        1517+10 1624          + R ADD     NUM          DO NOT CARE ABOUT LEN, JUST CHECK IF NUM=0 
        1518+ 4 1520          + TR 0      PRTINS       (SO NO MORE DIGITS REMAINS TO BE PRINTED)
        1519+ 1 1501          + TR        PRTINTG      NUM NOT FINISHED, PROCEED WITH NEXT DIGIT
        1520+10 1627 PRTINS   + R ADD     SGN
        1521+ 4 1451          + TR 0      EXIT         NO SIGN -> NUM FINISHED
        1522+10 1618          + R ADD     ZERO
        1523+12 1627          + STORE     SGN          CLEAR SGN FLAG
        1524+15 1638          + LOAD MQ   D11          BASE48 CODE FOR '-' (MINUS) CHAR
        1525+ 1 1511          + TR        PRTINTD      GO TO PRINT IT
        1526+10 1637   PRTINZ + R ADD     D10          ACC=BASE48 CODE FOR '0'
        1527+ 1 1506          + TR        PRTINTG2     TR TO PRINT IT
        1528+ 9 1635 PRTCHR   + ADD       TWO          PRINT CHAR IN MQ REGISTER 
        1529+14 1629          + STORE MQ  CHAR         SAVE CHAR TO PRINT (IN LEFT HALF WORD)
        1530+13 1534          + STORE A   PRTCP2       STORE ADDR OF PARAM (COL)
        1531+ 9 1634          + ADD       ONE
        1532+13 1612          + STORE A   PRTCEX
        1533+ 2 1534          + TR OV     PRTCP2       CLEAR OV JUST IN CASE
        1534+10    0   PRTCP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        1535+ 3 1538          + TR +      PRTCP4
        1536+13 1537          + STORE A   PRTCP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        1537+10    0   PRTCP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        1538+ 5 1634   PRTCP4 + SUB       ONE
        1539+12 1632          + STORE     N            N=COL-1 -> IN RANGE 0..71
        1540+ 3 1542          + TR +      PRTSA        IF N >= 0 PROCEED WITH BASE BUFFER ADDR CALCULATION
        1541+ 1 1612          + TR        PRTCEX       IF N<0 EXIT
        1542+10 1618    PRTSA + R ADD     ZERO         CARD BUFFER USES LOCATION 0..47
        1543+13 1631          + STORE A   PRTROWAD     DETERMINE ADDRESS OF LOWER ROW TO PRINT
        1544+10 1632          + R ADD     N
        1545+ 5 1640          + SUB       D36
        1546+ 3 1548          + TR +      PRTC0
        1547+ 1 1554          + TR        PRTC1
        1548+12 1632    PRTC0 + STORE     N            COL NOW 0..35 
        1549+ 5 1640          + SUB       D36
        1550+ 3 1612          + TR +      PRTCEX       IF COL >= 36 (IE COL PASSED AS PARAM > 72) THEN EXIT
        1551+10 1631          + R ADD     PRTROWAD
        1552+ 9 1635          + ADD       TWO
        1553+13 1631          + STORE A   PRTROWAD     SET BASE BUFFER ADDR 
        1554+10 1634    PRTC1 + R ADD     ONE          DETERMINE MASKCOL WITH MASK TO SET IN CARD BUFFER
        1555+21   53          + L RIGHT   53           SET RIGHTMOST BIT OF MQ TO 1 (SHIFT 35+18=53)
        1556+10 1639          + R ADD     D35
        1557+ 5 1632          + SUB       N
        1558+13 1560          + STORE A   PRTC2
        1559+10 1618          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW
        1560+20    0    PRTC2 + L LEFT    /   /        SHIFT MQ LEFT N PLACES
        1561+ 4 1564          + TR 0      PRTC3        IF ACC STILL ZERO -> MASKCOL VALID
        1562+ 6 1634          + R SUB     ONE          ACC NOT ZERO -> SHOULD GENERATE -0 TO SET SIGN BIT ON
        1563+21   72          + L RIGHT   0072         NOW MQ = -0 -> LEFTMOST BIT OF MQ SET
        1564-14 1620    PRTC3 - STORE MQ  MASKCOL
        1565+10 1618          + R ADD     ZERO         READ THE BITMAP OF CHAR 
        1566+11 1629          + ADD AB    CHAR         DISCARD SIGN OF CHAR, IF ANY
        1567+12 1629          + STORE     CHAR
        1568+ 5 1641          + SUB       D48
        1569+ 3 1612          + TR +      PRTCEX       IF CHAR >= 48 EXIT
        1570+10 1626          + R ADD     BITMAPAD     IF ADDR OF BASE48 BITMAP NOT COMPUTED
        1571+ 4 1613          + TR 0      GETBMP1      TR TO LOAD IT
        1572+ 9 1629  GETBMP2 + ADD       CHAR         READ THE BITMAP OF CHAR 
        1573+13 1574          + STORE A   PRTC4        INDICATES THE BITS TO SET IN SELECTED 
        1574+10    0    PRTC4 + R ADD     /   /        COLUMN OF CARD BUFFER 
        1575+12 1633          + STORE     BITS
        1576+ 6 1634          + R SUB     ONE
        1577+12 1632          + STORE     N            SET TO -1
        1578+10 1632    LOOP1 + R ADD     N            CURRENT ROW (STARTS AT ZERO) = OFFSET ON PRTROWAD     
        1579+ 9 1634          + ADD       ONE
        1580+12 1632          + STORE     N
        1581+10 1633          + R ADD     BITS         EXTRACT RIGHTMOST BIT OF LEFT HALF OF ACC TO MQ
        1582+ 4 1612          + TR 0      PRTCEX       NO MORE BITS -> EXIT
        1583+21   19          + L RIGHT   0019         LSB BIT OF LEFT HALF-WORD OF ACC TO MQ
        1584+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 1 BIT)
        1585+12 1633          + STORE     BITS         SAVE BACK BITS. LSB HAS BEEN EXTACTED, CONTENTS SHIFTED RIGHT ONE PLACE
        1586+10 1618          + R ADD     ZERO
        1587+20    1          + L LEFT    0001         PUT EXTACTED BIT BACK INTO ACC
        1588+ 4 1578          + TR 0      LOOP1        NO BIT 
        1589+10 1632          + R ADD     N            READ THE ROW N AT CARD BUFFER 
        1590+22    2          + A LEFT    0002         MULT N BY 4 AS THERE ARE 4 HALF WORDS PER ROW
        1591+ 9 1631          + ADD       PRTROWAD     
        1592+13 1594          + STORE A   PRTROWR
        1593+13 1610          + STORE A   PRTROWW
        1594-10    0  PRTROWR - R ADD     /   /        
        1595-12 1622          - STORE     ROW          CURRENT CONTENTS OF ROW
        1596-10 1620          - R ADD     MASKCOL      "OR" MASKCOL IN SELECTED ROW
        1597+ 3 1605          + TR +      PRTW2
        1598-10 1622          - R ADD     ROW 
        1599+ 4 1603          + TR 0      PRTW1         
        1600+10 1618          + R ADD     ZERO         MASKCOL IS MINUS ZERO AND ROW IS NOT-EMPTY (EITHER POSITIVE OR NEGATIVE) -> SET ROW AS NEGATIVE
        1601- 7 1622          - SUB AB    ROW 
        1602+ 1 1610          + TR        PRTROWW
        1603-10 1620    PRTW1 - R ADD     MASKCOL      MASKCOL IS MINUS ZERO AND ROW IS EMPTY -> SET ROW = MASKCOL = MINUS ZERO
        1604+ 1 1610          + TR        PRTROWW
        1605-10 1622    PRTW2 - R ADD     ROW          
        1606+ 3 1609          + TR +      PRTW3              
        1607- 5 1620          - SUB       MASKCOL      MASKCOL IS POSITIVE AND ROW IS NEGATIVE -> SUB MASKCOL FROM ROW
        1608+ 1 1610          + TR        PRTROWW
        1609- 9 1620    PRTW3 - ADD       MASKCOL      MASKCOL IS POSITIVE AND ROW IS POSITIVE OR EMPTY -> ADD MASKCOL TO ROW         
        1610-12    0  PRTROWW - STORE     /   /        ROW UPDTATE
        1611+ 1 1578          + TR        LOOP1        PROCEED TO NEXT ROW
        1612+ 1    0 PRTCEX   + TR        /   /
        1613+10 1613 GETBMP1  + R ADD     *
        1614+ 1   81          + TR        BMPAD        GET BASE48 CHARS BITMAP ADDRESS
        1615+12 1626          + STORE     BITMAPAD     
        1616+ 1 1572          + TR        GETBMP2      RETURN
        1617+     0             ORG       EVEN
        1618+     0  ZERO       DEF       0            
        1619+     0             DEF       0            
        1620+     0  MASKCOL    DEF       0
        1621+     0             DEF       0
        1622+     0  ROW        DEF       0
        1623+     0             DEF       0
        1624+     0  NUM        DEF       0
        1625+     0             DEF       0
        1626+     0  BITMAPAD   DEF       0
        1627+     0  SGN        DEF       0
        1628+     0  LEN        DEF       0
        1629+     0  CHAR       DEF       0
        1630+     0  TXT        DEF       0
        1631+     0  PRTROWAD   DEF       0
        1632+     0  N          DEF       0
        1633+     0  BITS       DEF       0
        1634+     1  ONE        DEF       1
        1635+     2  TWO        DEF       2
        1636+     3  D3         DEF       3
        1637+    10  D10        DEF       10
        1638+    11  D11        DEF       11
        1639+    35  D35        DEF       35
        1640+    36  D36        DEF       36
        1641+    48  D48        DEF       48
        1642+    72  D72        DEF       72
        1643+  2304  D48X48     DEF       2304
        1644+ 16384  OCT04K     DEF       *040000      BIT SIGN ON 5TH OCTINARY DIGIT
        1646+ 9 1721 PRTNLINE + ADD       TWO          PRINT A NEW LINE OF DATA
        1647+12 1724          + STORE     PARAM        SAVE PARAM LIST ADDR
        1648+10 1648          + R ADD     *            CLEAR CARD BUFFER
        1649+ 1   69          + TR        CLRBUF 
        1650+10 1724 GPARAM   + R ADD     PARAM        GET PARAM PAIR FMT/DATA
        1651+13 1656          + STORE A   P1
        1652+ 9 1720          + ADD       ONE
        1653+13 1660          + STORE A   P2
        1654+ 9 1720          + ADD       ONE
        1655+12 1724          + STORE     PARAM
        1656+10    0 P1       + R ADD     /   /
        1657+12 1726          + STORE     FMT
        1658+ 3 1660          + TR +      P2           IF FMT < 0 THEM SKIP THIS PAIR FMT/DATA
        1659+ 1 1650          + TR        GPARAM
        1660+10    0 P2       + R ADD     /   /
        1661+12 1686          + STORE     DATALOC      GET DATA ADDRESS PASED AS PARAM
        1662+13 1663          + STORE A   P2A
        1663+10    0 P2A      + R ADD     /   /
        1664+12 1725          + STORE     DATA         GET EFFECTIVE DATA
        1665+10 1719          + R ADD     ZERO
        1666+15 1726          + LOAD MQ   FMT
        1667+18 1723          + DIV       D100         ACC=REMAINDER=COL NUMBER, MQ=QUOTIEN=TYPE OF DATA
        1668+12 1727          + STORE     COL
        1669+10 1719          + R ADD     ZERO
        1670+20   18          + L LEFT    0018
        1671+14 1726          + STORE MQ  FMT
        1672+15 1725          + LOAD MQ   DATA
        1673+10 1677          + R ADD     TYPETRAD
        1674+ 9 1726          + ADD       FMT
        1675+13 1676          + STORE A   TYPETR
        1676+ 1    0 TYPETR   + TR        /   /        TR SELECTED ROUTINE
        1677+ 0 1678 TYPETRAD + STOP      TYPETRT      TYPE TRANSFER TABLE ADDRESS
        1678+ 1 1707 TYPETRT  + TR        EOL          FMT=0..6 (IE <100) -> END OF PARAM LIST -> END OF LINE 
        1679+ 1 1684          + TR        TYSTR        FMT=1 -> PRINT A STRINGZ
        1680+ 1 1689          + TR        TYINT        FMT=2 -> PRINT AN INT
        1681+ 1 1694          + TR        TYOCT        FMT=3 -> PRINT AN OCT
        1682+ 1 1699          + TR        TYCHR        FMT=4 -> PRINT A CHAR
        1683+ 1 1703          + TR        TYALF        FMT=5 -> PRINT A 3-CHR PACKED ALFA STRING
        1684+10 1684 TYSTR    + R ADD     *            PRINT STRINGZ
        1685+ 1   77          + TR        PRTSTR
        1686+ 0    0 DATALOC  + STOP      /   /
        1687- 0 1727          - STOP      COL          COLUMN WHERE TXT STARTS
        1688+ 1 1650          + TR        GPARAM
        1689+10 1689 TYINT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1690+ 1   59          + TR        PRTINT
        1691+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        1692- 0 1727          - STOP      COL          COLUMN WHERE TXT STARTS
        1693+ 1 1650          + TR        GPARAM
        1694+10 1694 TYOCT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1695+ 1   79          + TR        PRTOCT
        1696+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        1697- 0 1727          - STOP      COL          COLUMN WHERE TXT STARTS
        1698+ 1 1650          + TR        GPARAM
        1699+10 1699 TYCHR    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1700+ 1   57          + TR        PRTCHR
        1701- 0 1727          - STOP      COL          COLUMN WHERE TXT STARTS
        1702+ 1 1650          + TR        GPARAM
        1703+10 1703 TYALF    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        1704+ 1   75          + TR        PRTALF
        1705- 0 1727          - STOP      COL          COLUMN WHERE TXT STARTS
        1706+ 1 1650          + TR        GPARAM
        1707+10 1727 EOL      + R ADD     COL          SEND CARD BUFFER TO PRINTER AND RETURN TO CALLER
        1708+ 4 1713          + TR 0      DOPRINT      =0 -> PRINT ALLWAYS (NO SENSE SW CHECK)
        1709+ 9 1722          + ADD       D68          =1..6 -> SENSE 69..74 = OPERATOR'S PANEL SENSE SWITCH 1..6
        1710+13 1711          + STORE A   CHKSW
        1711+30    0 CHKSW    + SENSE     /   /         
        1712+ 1 1715          + TR        RETURN       SW NOT AT ON POSITION
        1713+10 1713 DOPRINT  + R ADD     *            PRINT CARD BUFFER
        1714+ 1   55          + TR        PRINTCRD
        1715+10 1724 RETURN   + R ADD     PARAM        PARAM-1 IS THE RETURN ADDR      
        1716+ 5 1720          + SUB       ONE
        1717+13 1718          + STORE A   EXIT
        1718+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        1719+ 0    0 ZERO     + STOP      0000
        1720+ 0    1 ONE      + STOP      0001
        1721+ 0    2 TWO      + STOP      0002
        1722+ 0   68 D68      + STOP      0068
        1723+ 0  100 D100     + STOP      100
        1724+ 0    0 PARAM    + STOP      0000
        1725+ 0    0 DATA     + STOP      0000
        1726+ 0    0 FMT      + STOP      0000
        1727+ 0    0 COL      + STOP      0000
        1728+ 9 1742 BMPAD    + ADD       TWO
        1729+13 1731          + STORE A   EXIT
        1730+10 1732          + R ADD     BITMAPAD
        1731+ 1    0 EXIT     + TR        /   /
        1732+ 0 1734 BITMAPAD + STOP      BITMAP
        1733+     0             ORG       EVEN
        1734+     0  BITMAP     DEF       0              <blank>     0     <none>
        1735+   256             DEF       256               1        1       1        256          =  256   
        1736+   128             DEF       128               2        2       2        128          =  128   
        1737+    64             DEF       64                3        3       3         64          =   64   
        1738+    32             DEF       32                4        4       4         32          =   32   
        1739+    16             DEF       16                5        5       5         16          =   16   
        1740+     8             DEF       8                 6        6       6          8          =    8   
        1741+     4             DEF       4                 7        7       7          4          =    4   
        1742+     2  TWO        DEF       2                 8        8       8          2          =    2   
        1743+     1             DEF       1                 9        9       9          1          =    1   
        1744+   512             DEF       512               0       10       0        512          =  512   
        1745+  1024             DEF       1024              -       11       X       1024          = 1024   
        1746+  2048             DEF       2048              +       12       Y       2048          = 2048   
        1747+  2304             DEF       2304              A       13      Y-1        256+2048    = 2304   
        1748+  2176             DEF       2176              B       14      Y-2        128+2048    = 2176   
        1749+  2112             DEF       2112              C       15      Y-3         64+2048    = 2112   
        1750+  2080             DEF       2080              D       16      Y-4         32+2048    = 2080   
        1751+  2064             DEF       2064              E       17      Y-5         16+2048    = 2064   
        1752+  2056             DEF       2056              F       18      Y-6          8+2048    = 2056   
        1753+  2052             DEF       2052              G       19      Y-7          4+2048    = 2052   
        1754+  2050             DEF       2050              H       20      Y-8          2+2048    = 2050   
        1755+  2049             DEF       2049              I       21      Y-9          1+2048    = 2049   
        1756+  1280             DEF       1280              J       22      X-1        256+1024    = 1280   
        1757+  1152             DEF       1152              K       23      X-2        128+1024    = 1152   
        1758+  1088             DEF       1088              L       24      X-3         64+1024    = 1088   
        1759+  1056             DEF       1056              M       25      X-4         32+1024    = 1056   
        1760+  1040             DEF       1040              N       26      X-5         16+1024    = 1040   
        1761+  1032             DEF       1032              O       27      X-6          8+1024    = 1032   
        1762+  1028             DEF       1028              P       28      X-7          4+1024    = 1028   
        1763+  1026             DEF       1026              Q       29      X-8          2+1024    = 1026   
        1764+  1025             DEF       1025              R       30      X-9          1+1024    = 1025   
        1765+   640             DEF       640               S       31      0-2        128+512     = 640    
        1766+   576             DEF       576               T       32      0-3         64+512     = 576    
        1767+   544             DEF       544               U       33      0-4         32+512     = 544    
        1768+   528             DEF       528               V       34      0-5         16+512     = 528    
        1769+   520             DEF       520               W       35      0-6          8+512     = 520    
        1770+   516             DEF       516               X       36      0-7          4+512     = 516    
        1771+   514             DEF       514               Y       37      0-8          2+512     = 514    
        1772+   513             DEF       513               Z       38      0-9          1+512     = 513    
        1773+   578             DEF       578               ,       39      8-3-0        2+64+512  = 578    
        1774+   546             DEF       546               %       40      8-4-0        2+32+512  = 546    
        1775+  1090             DEF       1090              $       41      8-3-X        2+64+1024 = 1090   
        1776+  1058             DEF       1058              *       42      8-4-X        2+32+1024 = 1058   
        1777+  2114             DEF       2114              .       43      8-3-Y        2+64+2048 = 2114   
        1778+  2082             DEF       2082              #       44      8-4-Y        2+32+2048 = 2082   
        1779+   768             DEF       768               /       45      0-1          512+256   = 768    
        1780+    66             DEF       66                +       46      8-3          2+64      = 66     
        1781+    34             DEF       34                -       47      8-4          2+32      = 34    This is the non-minus-sign separator
        1782+15 1849 SRCHTBL  + LOAD MQ   ZERO
        1783+ 1 1787          + TR        START
        1784+15 1850 EQTBL    + LOAD MQ   ONE
        1785+ 1 1787          + TR        START
        1786+15 1851 READTBL  + LOAD MQ   TWO
        1787+ 9 1851 START    + ADD       TWO 
        1788+13 1795          + STORE A   P1           PARM: ADDR OF TABLE
        1789+ 9 1850          + ADD       ONE          
        1790+13 1797          + STORE A   P2           PARM: LEN OF TABLE
        1791+ 9 1850          + ADD       ONE          
        1792+13 1802          + STORE A   P3           PARM: VAL TO FIND
        1793+ 9 1850          + ADD       ONE          
        1794+13 1843          + STORE A   EXIT
        1795+10    0 P1       + R ADD     /   /        GET ADDR OF TABLE
        1796+13 1846          + STORE A   TBL
        1797+10    0 P2       + R ADD     /   /        GET ADDR OF LEN OF TABLE/ENTRY ON TABLE
        1798+13 1799          + STORE A   P2A
        1799+10    0 P2A      + R ADD     /   /        DERREFERENCE -> ACC=LEN/ENTRY (1..LEN)
        1800+12 1844          + STORE     N
        1801+ 4 1843          + TR 0      EXIT         EXIT, CANNOT READ/STORE ON ENTRY 0, SEARCH ON EMPTY TABLE
        1802+10    0 P3       + R ADD     /   /        GET ADDR OF VAL TO FIND
        1803+13 1819          + STORE A   WRVAL
        1804+13 1805          + STORE A   P3A
        1805+10    0 P3A      + R ADD     /   /        DERREFERENCE -> ACC=VAL
        1806+12 1845          + STORE     VAL
        1807+14 1848          + STORE MQ  TEMP         JUMP TABLE DISPATCH
        1808+10 1848          + R ADD     TEMP
        1809+ 4 1824          + TR 0      LOOP0        TR TO SEARCH TABLE
        1810+10 1844          + R ADD     N            SUB ONE AS FIRST ENTRY ON TABLE IS "1"
        1811+ 5 1850          + SUB       ONE          
        1812+ 9 1846          + ADD       TBL          TABLE BASE ADDR
        1813+13 1822          + STORE A   WRTBL
        1814+13 1818          + STORE A   RDTBL2
        1815+10 1848          + R ADD     TEMP
        1816+ 5 1850          + SUB       ONE
        1817+ 4 1821          + TR 0      STORETBL 
        1818+10    0 RDTBL2   + R ADD     /   /        VAL=TBL[ENT]
        1819+12    0 WRVAL    + STORE     /   /
        1820+ 1 1843          + TR        EXIT
        1821+10 1845 STORETBL + R ADD     VAL          TBL[ENT]=VAL
        1822+12    0 WRTBL    + STORE     /   /    
        1823+ 1 1843          + TR        EXIT
        1824+10 1846 LOOP0    + R ADD     TBL
        1825+13 1831          + STORE A   RDTBL
        1826+10 1831          + R ADD     RDTBL
        1827+12 1847          + STORE     TBL0
        1828+ 9 1844          + ADD       N
        1829+12 1848          + STORE     TEMP         THE END ADDR OF TABLE
        1830+10 1845 LOOP     + R ADD     VAL          ACC=THE SEARCHED VALUE
        1831+ 5    0 RDTBL    + SUB       /   /    
        1832+ 2 1833          + TR OV     OVOK         CLEAR OV JUST IN CASE
        1833+ 4 1840 OVOK     + TR 0      FOUND        TR IF VAL FOUND IN ENTRY N
        1834+10 1831          + R ADD     RDTBL
        1835+ 9 1850          + ADD       ONE
        1836+13 1831          + STORE A   RDTBL
        1837+ 5 1848          + SUB       TEMP
        1838+ 4 1843          + TR 0      EXIT         NOT FOUND -> RETURN ZERO
        1839+ 1 1830          + TR        LOOP
        1840+10 1831 FOUND    + R ADD     RDTBL        RETURN ENTRY FOUND
        1841+ 5 1847          + SUB       TBL0
        1842+ 9 1850          + ADD       ONE
        1843+ 1    0 EXIT     + TR        /   /
        1844+ 0    0 N        + STOP      0000
        1845+ 0    0 VAL      + STOP      0000
        1846+ 0    0 TBL      + STOP      0000
        1847+ 0    0 TBL0     + STOP      0000
        1848+ 0    0 TEMP     + STOP      0000
        1849+ 0    0 ZERO     + STOP      0000
        1850+ 0    1 ONE      + STOP      0001         constant 1
        1851+ 0    2 TWO      + STOP      0002         constant 2
        1852+ 9 1925 RWDRUM   + ADD       TWO 
        1853+13 1862          + STORE A   PDR1         PARM1: DRUM INSTR: READ/WRITE 0128  0129  0130  0131
        1854+ 9 1924          + ADD       ONE          
        1855+13 1864          + STORE A   PDR2         PARM2: DRUM ADDRESS (0..4094)
        1856+ 9 1924          + ADD       ONE          
        1857+13 1866          + STORE A   PDR3         PARM3: BUF START ADDRESS
        1858+ 9 1924          + ADD       ONE          
        1859+13 1868          + STORE A   PDR4         PARM4: LEN: NUMBER OF HALF-WORDS (MUST BE EVEN)
        1860+ 9 1924          + ADD       ONE          
        1861+13 1922          + STORE A   EXIT               
        1862+10    0 PDR1     + R ADD     /   /        GET DRUM INSTR
        1863+12 1870          + STORE     DRIO
        1864+10    0 PDR2     + R ADD     /   /        GET DRUM ADDR
        1865+13 1871          + STORE A   DRADDR
        1866+10    0 PDR3     + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1867+13 1909          + STORE A   RWCOPY    
        1868+10    0 PDR4     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        1869+12 1926          + STORE     LEN
        1870+ 0    0 DRIO     + STOP      /   /        INSTR: READ/WRITE 0128  0129  0130  0131
        1871+29    0 DRADDR   + SET DR    /   /
        1872+ 1 1905          + TR        LOOP
        1873+ 9 1925 RDTAPE   + ADD       TWO 
        1874+13 1881          + STORE A   PR1          PARM1: TAPE ADDRESS
        1875+ 9 1924          + ADD       ONE          
        1876+13 1883          + STORE A   PR2          PARM2: BUF START ADDRESS
        1877+ 9 1924          + ADD       ONE          
        1878+13 1922          + STORE A   EXIT
        1879+ 2 1880          + TR OV     CLOV1        CLEAR OV THAT MAY HAVE BEEN SET
        1880+ 8    0    CLOV1 + NOOP      0000
        1881+10    0 PR1      + R ADD     /   /        GET TAPE ADDR
        1882+13 1885          + STORE A   RTAPAD       TAPE UNITS: 0256  0257  0258  0259
        1883+10    0 PR2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1884+13 1909          + STORE A   RWCOPY    
        1885+24    0 RTAPAD   + READ      /   /
        1886+10 1923          + R ADD     ZERO
        1887+ 1 1907          + TR        LOOP1
        1888+ 9 1925 WRTAPE   + ADD       TWO 
        1889+13 1896          + STORE A   PW1          PARM1: TAPE ADDRESS
        1890+ 9 1924          + ADD       ONE          
        1891+13 1898          + STORE A   PW2          PARM2: BUF START ADDRESS
        1892+ 9 1924          + ADD       ONE          
        1893+13 1900          + STORE A   PW3          PARM3: BUF LEN
        1894+ 9 1924          + ADD       ONE          
        1895+13 1922          + STORE A   EXIT
        1896+10    0 PW1      + R ADD     /   /        GET TAPE ADDR
        1897+13 1904          + STORE A   WTAPAD       TAPE UNITS: 0256  0257  0258  0259
        1898+10    0 PW2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        1899+13 1909          + STORE A   RWCOPY    
        1900+10    0 PW3      + R ADD     /   /        GET ADDR OF LEN 
        1901+13 1902          + STORE A   PW3A
        1902+10    0 PW3A     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        1903+12 1926          + STORE     LEN
        1904+26    0 WTAPAD   + WRITE     /   /        PREPARE TO WRITE ON TAPE
        1905+10 1926 LOOP     + R ADD     LEN
        1906+ 4 1921          + TR 0      RWOK
        1907+ 5 1925 LOOP1    + SUB       TWO
        1908+12 1926          + STORE     LEN
        1909-31    0 RWCOPY   - COPY      /   /        WRITE BUFFER TO TAPE
        1910+ 1 1913          + TR        GO 
        1911+ 1 1917          + TR        EOF          END OF FILE
        1912+ 1 1919          + TR        EOR          END OF RECORD
        1913+10 1909 GO       + R ADD     RWCOPY
        1914+ 5 1925          + SUB       TWO
        1915+13 1909          + STORE A   RWCOPY
        1916+ 1 1905          + TR        LOOP
        1917+10 1924 EOF      + R ADD     ONE          SET OV FLAG TO SIGNAL END OF FILE CONDITION
        1918+22   36          + A LEFT    36
        1919+ 6 1926 EOR      + R SUB     LEN          RETURN NUMBER OF HALF-WORDS READ
        1920+ 5 1925          + SUB       TWO
        1921+26 2052 RWOK     + WRITE     2052         INSURE THAT MQ NOT IN USE            
        1922+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        1923+ 0    0 ZERO     + STOP      0000
        1924+ 0    1 ONE      + STOP      0001         
        1925+ 0    2 TWO      + STOP      0002         
        1926+     0  LEN        RES       1
        1928+ 9 1943 CHAIN    + ADD       TWO
        1929+13 1930          + STORE A   CHP1
        1930+10    0 CHP1     + R ADD     /   /        GET TAPE NUMBER
        1931+13 1938          + STORE A   TAPELOAD
        1932+30   70          + SENSE     0070         SENSE SWITCH 2                                  
        1933+ 1 1937 CONTAD   + TR        ENDSTOP      (ON POSITION MAKES SENSE OPCODE TO SKIP NEXT INSTR)
        1934+10 1933          + R ADD     CONTAD       IF SW2 IS ON, A +STOP 4095 IS EXECUTED.  
        1935+12 4095          + STORE     4095         IF THEN USER PRESS START, EXECUTION WILL BE RESUMED 
        1936+ 0 4095          + STOP      4095         AND CHAINED PROGRAM WILL BE LOADED AND EXECUTED
        1937+ 8    0 ENDSTOP  + NOOP      0000
        1938+24    0 TAPELOAD + READ      0000         
        1939-31    0 TL0      - COPY      0000         READ 1ST WORD OF SELF-LOADER FROM TAPE
        1940+ 1    0          + TR        0000         TR TO SELF-LOADER
        1941+ 0 2221          + STOP      2221         ERROR LOADING: UNEXPECTED END OF FILE
        1942+ 0 2222          + STOP      2222         ERROR LOADING: UNEXPECTED END OF RECORD 
        1943+ 0    2 TWO      + STOP      0002         ERROR LOADING: UNEXPECTED END OF FILE
          48-     0  ROUTINE INIT
          49+ 1  113 ENTRY POINT
          50-     0  ROUTINE CHAIN
          51+ 1 1928 ENTRY POINT
          52-     0  ROUTINE PRTNLINE
          53+ 1 1646 ENTRY POINT
          54-     0  ROUTINE PRINTCRD
          55+ 1 1324 ENTRY POINT
          56-     0  ROUTINE PRTCHR
          57+ 1 1528 ENTRY POINT
          58-     0  ROUTINE PRTINT
          59+ 1 1486 ENTRY POINT
          60-     0  ROUTINE RDTAPE
          61+ 1 1873 ENTRY POINT
          62-     0  ROUTINE WRTAPE
          63+ 1 1888 ENTRY POINT
          64-     0  ROUTINE EQTBL
          65+ 1 1784 ENTRY POINT
          66-     0  ROUTINE READTBL
          67+ 1 1786 ENTRY POINT
          68-     0  ROUTINE CLRBUF
          69+ 1 1316 ENTRY POINT
          70-     0  ROUTINE READCRD
          71+ 1 1320 ENTRY POINT
          72-     0  ROUTINE WRITECRD
          73+ 1 1322 ENTRY POINT
          74-     0  ROUTINE PRTALF
          75+ 1 1408 ENTRY POINT
          76-     0  ROUTINE PRTSTR
          77+ 1 1385 ENTRY POINT
          78-     0  ROUTINE PRTOCT
          79+ 1 1452 ENTRY POINT
          80-     0  ROUTINE BMPAD
          81+ 1 1728 ENTRY POINT
          82-     0  ROUTINE SRCHTBL
          83+ 1 1782 ENTRY POINT
          84-     0  ROUTINE RWDRUM
          85+ 1 1852 ENTRY POINT
        4094+    48  REGION ORIGIN TABLE LOCATION
        4095+   113  INITIAL REGION
           0+ 1  113          + TR        INIT         PROGRAM START
