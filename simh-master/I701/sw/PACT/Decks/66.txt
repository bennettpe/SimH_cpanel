        DEC
        NNNN OP ADDR COMMENTS
          96+ 9 2009 LOADCC   + ADD       TWO          LOAD PACTSCR INTO CARD IMAGE SO 
          97+13  116          + STORE A   CPCCEX       CURRENT PACT SOURCE CODE CAN BE PRINTED
          98+10 2006          + R ADD     ZERO         COPY TO LEFT SIDE OF SOURCE CODE CARD IMAGE
          99+13  103          + STORE A   CPCC1        AT 0..46 FROM PACTSCR
         100+10  119          + R ADD     CPCC2
         101+13  102          + STORE A   CPCC 
         102-10    0 CPCC     - R ADD     /   /
         103-12    0 CPCC1    - STORE     /   /
         104+10  103          + R ADD     CPCC1
         105+ 5 2009          + SUB       TWO
         106+13  108          + STORE A   CPCC1B
         107+10 2006          + R ADD     ZERO
         108-12    0 CPCC1B   - STORE     /   /
         109+10  102          + R ADD     CPCC
         110+ 5 2009          + SUB       TWO
         111+13  102          + STORE A   CPCC
         112+10  103          + R ADD     CPCC1
         113+ 5 2011          + SUB       D4
         114+13  103          + STORE A   CPCC1
         115+ 5  118          + SUB       CPCCE
         116+ 4    0 CPCCEX   + TR 0      /   /        RETURN TO CALLER
         117+ 1  102          + TR        CPCC
         118-12   48 CPCCE    - STORE     0048         LAST LOCATION TO COPY FROM 
         119+ 8  502 CPCC2    + NOOP      PACTSRC      PACTSRC = FIRST LOCATION TO COPY FROM
         120+ 9 2009 PRTOCT4  + ADD       TWO          PRINT OCTIONARY VALUE IN MQ, 4 DIGITS, 
         121+13  124          + STORE A   POCTP1       LEFTMOST ZEROES SUPRESSED
         122+ 9 2008          + ADD       ONE
         123+13  142          + STORE A   PRTOCTEX
         124+10    0 POCTP1   + R ADD     /   /        PARAM: COL WHERE TO START
         125+ 9 2010          + ADD       D3
         126+12  137          + STORE     COLN         COL POINTS TO LEAST SIGNIFICANT DIGIT
         127+14  534          + STORE MQ  NUM
         128+10  534 PRTIOCG  + R ADD     NUM          GENERATE OCTIONARY DIGIT
         129+23    3          + A RIGHT   0003
         130+12  534          + STORE     NUM          REMOVE RIGHTMOST 3 BITS FROM NUM
         131+ 5  534          + SUB       NUM
         132+22    3          + A LEFT    0003         ACC=RIGHTMOST 3 BITS
         133+ 4  144          + TR 0      PRTIOZ       TR IF THIS DIGIT IS ZERO TO PRINT A '0' (BASE48 CODE = 10) INSTEAD OF A BLANK (BASE48 CODE = 0)
         134+21   35          + L RIGHT   0035         PUT DIGIT 1..9 TO PRINT IN MQ
         135+10  135 PRTOCTD  + R ADD     *            PRINT OCTINARY DIGIT
         136+ 1   61          + TR        PRTCHR
         137+ 0    0 COLN     + STOP      0000
         138+10  137          + R ADD     COLN         DECR COL NUMBER TO PRINT NEXT DIGIT
         139+ 5 2008          + SUB       ONE
         140+12  137          + STORE     COLN
         141+10  534          + R ADD     NUM          
         142+ 4    0 PRTOCTEX + TR 0      /   /
         143+ 1  128          + TR        PRTIOCG
         144+15 2013   PRTIOZ + LOAD MQ   D10          ACC=BASE48 CODE FOR '0'
         145+ 1  135          + TR        PRTOCTD      TR TO PRINT IT
         146+ 9 2009 PCHCRD   + ADD       TWO          PUNCH A BINARY REL CARD        
         147+13  151          + STORE A   PCHCRDEX
         148+10  148          + R ADD     *
         149+ 1   75          + TR        WRITECR2     PUNCH THE CARD
         150+ 0    0 LBINCRD  + STOP      /   /        ADDR OF BINCARD BUFFER TO BE WRITTEN 
         151+ 1    0 PCHCRDEX + TR        /   /         
         152+10  152 INIT     + R ADD     *            
         153+ 1   53          + TR        PRTNLINE     
         154+ 0  101          + STOP      0101         STRINGZ AT COL 1
         155+ 0 2033          + STOP      MSGSTART     "LIST AND PUNCH"
         156+ 0    6          + STOP      0006         END OF LINE. 
         157+10 2006          + R ADD     ZERO         CLEAR CC RECORD
         158+12  526          + STORE     REGION     
         159+12  527          + STORE     STEP       
         160+12  528          + STORE     OP         
         161+12  529          + STORE     FACT       
         162+12  530          + STORE     S1         
         163+12  531          + STORE     S2         
         164+12  532          + STORE     QR         
         165+12  533          + STORE     QF         
         166-12  534          - STORE     NUM        
         167+12  536          + STORE     CLUE       
         168+12  537          + STORE     STEPN      
         169+12  538          + STORE     FACTN      
         170+12  539          + STORE     FACTREG    
         171+12  540          + STORE     S1N        
         172+12  541          + STORE     S2N        
         173+12  542          + STORE     D1N        
         174+12  543          + STORE     D2N        
         175+12  544          + STORE     NINST      
         176+12  545          + STORE     NINCR 
         177+10  746          + R ADD     CCLEN        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         178+10  535          + R ADD     NUM2         NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         179+10  747          + R ADD     MAXNINST     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING              
         180+10 1406          + R ADD     TSYMBEXT     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING              
         181+10  798          + R ADD     OPADDR       NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING              
         182+10  799          + R ADD     FORMAT       NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING              
         183+10  800          + R ADD     REGLOC       NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING              
         184+10  801          + R ADD     DUMMY        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING              
         185+10  802          + R ADD     LCLEN        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING              
         186+10  803          + R ADD     DUMMY2       NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING              
         187+28  259          + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE)
         188+10  188          + R ADD     *            
         189+ 1   63          + TR        RWDRUM       READ TSYMBREF TABLE (SYMBOLS USED BY ALL REGIONS) FROM DRUM 
         190+24  128          + READ      0128         DRUM INSTR
         191+ 0    0          + STOP      0000         DRUM ADDR 
         192+ 0  804          + STOP      MAXNSYMB     ADDR OF START OF TABLES
         193+ 0 1202          + STOP      1202         MAXNSYMB (1 HALF-WORD) + NSYMBS (1 HW) 
         194+10  194          + R ADD     *            SET WRITE CARD ROUTINE TO BE CALLED WHEN FLUSHING THE REL BINARY CARD 
         195+ 1   71          + TR        WRIBREL      RETURNS IN ACC THE ADDR OF BINCARD BUFFER TO BE WRITTEN BY WRITE ROUTINE  
         196+ 0    2          + STOP      0002         +02 -> SET WRITE CARD ROUTINE
         197+ 0  146          + STOP      PCHCRD       THE WRITE ROUTINE ADDRESS
         198+13  150          + STORE A   LBINCRD      SAVE ADDR OF BINCARD BUFFER TO BE WRITTEN, RETURNED IN ACC
         199+10  199          + R ADD     *
         200+ 1   53          + TR        PRTNLINE
         201+ 0    0          + STOP      0000         PRINT BLANK LINE
         202+10  202          + R ADD     *            
         203+ 1   53          + TR        PRTNLINE     
         204+ 0  101          + STOP      0101         STRINGZ AT COL 1
         205+ 0 2039          + STOP      MSGHDR1      "REGSTEPOP  CFACT S1 S2 Q    N   LOC OPTREL  OPTREL  OPTREL  OPTREL"
         206+ 0  134          + STOP      0134         STRINGZ AT COL 34
         207+ 0 2050          + STOP      MSGHDR2     
         208+ 0    0          + STOP      0000         END OF LINE. 
         209+10 2006 READREG  + R ADD     ZERO
         210+12 2026          + STORE     IRELADDR     REL ADDRESS USED BY I REGION 
         211+30  521          + SENSE     0521         SHEET EJECTION -> NEW PAGE FOR REGION LISTING
         212+10  212 READSTEP + R ADD     *            READ PACT USER PROGRAM SOURCE CODE FROM TAPE IN
         213+ 1   65          + TR        RDTAPE
         214+ 0  259          + STOP      TAPEIN
         215+ 0  502          + STOP      CCODE        BUF TO READ IN FROM TAPE
         216+ 2  230          + TR OV     EOF          TR IF END OF FILE
         217+10  528          + R ADD     OP
         218+ 4  228          + TR 0      EOR          TR IF END OF REGION
         219+10  219          + R ADD     *            LOAD PACTSCR INTO CARD IMAGE SO 
         220+ 1   96          + TR        LOADCC       CURRENT PACT SOURCE CODE CAN BE PRINTED
         221+10 2026          + R ADD     IRELADDR     I RELATIVE LOCATION STEP
         222+12 2027          + STORE     IREL0        I RELATIVE LOCATION OF THIS STEP
         223+ 9  544          + ADD       NINST        NUMBER OF INST IN THIS STEP
         224+12 2026          + STORE     IRELADDR 
         225+10  225          + R ADD     *
         226+ 1  250          + TR        MCPRTPCH     PRINT AND PUNCH MC INSTR FOR CURRENT STEP
         227+ 1  212          + TR        READSTEP     PROCEED WITH NEXT STEP
         228+ 8    0 EOR      + NOOP      0000         END OF REGION  
         229+ 1  209          + TR        READREG      PROCEED WITH NEXT REGION
         230+ 8    0 EOF      + NOOP      0000         END OF FILE
         231+10  231          + R ADD     *            FLUSH ANY PENDING BINARY CARD  
         232+ 1   71          + TR        WRIBREL
         233+ 0    1          + STOP      0001         +01 -> FLUSH LAST CARD
         234+10  234          + R ADD     *
         235+ 1  404          + TR        LIBPCH       PUNCH MC INSTR FOR USED LIBRARIES 
         236+10  236          + R ADD     *
         237+ 1  484          + TR        PCHXFER      PUNCH TRANSFER CARD 
         238+30   74          + SENSE     0074         SENSE SWITCH 6
         239+ 1  245          + TR        ENDLOG1Z     TR IF NO LOG SELECTED
         240+10  240          + R ADD     *
         241+ 1   53          + TR        PRTNLINE     
         242+ 0  101          + STOP      0101         STRINGZ AT COL 1
         243+ 0 2079          + STOP      MSGECOMP     "END OF COMPILATION"
         244+ 0    6          + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
         245+ 8    0 ENDLOG1Z + NOOP      0000 
         246+10  246          + R ADD     *
         247+ 1   53          + TR        PRTNLINE     
         248+ 0    0          + STOP      0000         PRINT BLANK LINE
         249+ 0 4095          + STOP      4095         STOP FOR COMPILATION OK
         250+ 9 2009 MCPRTPCH + ADD       TWO
         251+13  329          + STORE A   PRTPCHEX
         252+10 2006          + R ADD     ZERO         PRINT INSTR GENERATED IN THIS STEP
         253+12 2025          + STORE     MCNUM
         254+12  317          + STORE     MCCOL
         255+10 2008          + R ADD     ONE          SIGNAL TO ADD THE PACT SOURCE CODE AS A COMMENT
         256+12 2020          + STORE     MC.PACT      ON FIRST MC INSTR TXT CARD PUNCHED 
         257+10 2025 MCLOOP   + R ADD     MCNUM
         258+ 5  544          + SUB       NINST
         259+ 4  327          + TR 0      MCLOEND      TR TO PROCESS NEXT STEP IF ALL NINST INSTRUCTIONS PRINTED
         260+10 2025          + R ADD     MCNUM        INCR COUNT
         261+ 9 2008          + ADD       ONE
         262+12 2025          + STORE     MCNUM        GET MC INSTR FROM TINST[ (PRTMCNUM-1)*2 ]
         263+ 9 2025          + ADD       MCNUM
         264+ 5 2009          + SUB       TWO
         265+ 9  326          + ADD       TINSTAD
         266+13  271          + STORE A   MCAD1
         267+ 9 2008          + ADD       ONE
         268+13  275          + STORE A   MCAD2
         269+10 2006          + R ADD     ZERO
         270+12 2023          + STORE     MC.REG       INIT REGION REFERENCED BY MC
         271+10    0 MCAD1    + R ADD     /   /         
         272+13 2023          + STORE A   MC.REG
         273+23   12          + A RIGHT   0012
         274+12 2022          + STORE     MC.OP        MC.OP HAS NOW THE SIGNED OPCODE -31..31 
         275+10    0 MCAD2    + R ADD     /   /
         276+12 2024          + STORE     MC.ADDR
         277+10 2027          + R ADD     IREL0        SET MC.LOC = THE RELATIVE LOCATION OF STEP 
         278+ 9 2025          + ADD       MCNUM        ADD THE NUMBER OF INSTR (-1 BECAUSE STARTS AT 1)
         279+ 5 2008          + SUB       ONE
         280+12 2021          + STORE     MC.LOC
         281+10  317          + R ADD     MCCOL        PRINT LOC ONLY IF MCCOL=0
         282+ 4  297          + TR 0      MCL2         IF MCCOL=0 -> TR TO PRINT LOC 
         283+10 2010          + R ADD     D3           
         284+ 5  317          + SUB       MCCOL
         285+ 3  315          + TR +      MCL3         IF MCCOL=1..3 -> TR TO PRINT MC INSTR
         286+10 2006          + R ADD     ZERO         IF MCCOL=4 -> LINE FULL -> PRINT IT AND BACK TO COL 0
         287+12  317          + STORE     MCCOL
         288+10  288          + R ADD     *            PRINT CURRENT LINE
         289+ 1   55          + TR        PRINTCRD
         290+10  290          + R ADD     *            START NEW LINE 
         291+ 1   51          + TR        CLRBUF
         292+10  528          + R ADD     OP           IF OP=44 OPNCONST -> WE ARE PRINTING LOOP CONSTANT POOL -> PRINT LOC ON START OF LINE
         293+ 5 2017          + SUB       OPNCONST     ELSE JUST PRINT TH MC INSTR
         294+ 4  297          + TR 0      MCL2
         295+ 1  315          + TR        MCL3         TR TO PRINT MC INSTR
         296-10   48 MCL2E    - R ADD     0048
         297+10 2006 MCL2     + R ADD     ZERO         CLEAR COLUMNS 32..36
         298+13  300          + STORE A   MCL2R
         299+13  303          + STORE A   MCL2S
         300-10    0 MCL2R    - R ADD     /   /        RSV: On original complier, formating of instr is done via printer
         301+23    5          + A RIGHT   0005              control panel, using whole printer's 120 columns. 
         302+22    5          + A LEFT    0005              As simulated printer only shows 80 cols on cpanel, 
         303-12    0 MCL2S    - STORE     /   /             we format the output programmatically to squeeze the 
         304+10  300          + R ADD     MCL2R             printed line to fit in 72 columns. We do not use printer
         305+ 5 2011          + SUB       D4                wiring to add extra separation spaces between the printed
         306+13  300          + STORE A   MCL2R             instr to not mess up the printout of compiler debug messages 
         307+13  303          + STORE A   MCL2S
         308+ 5  296          + SUB       MCL2E
         309+ 4  311          + TR 0      MCL2B
         310+ 1  300          + TR        MCL2R
         311+15 2021 MCL2B    + LOAD MQ   MC.LOC       PRINT INSTR LOCATION AT COL 33..36
         312+10  312          + R ADD     *
         313+ 1  120          + TR        PRTOCT4
         314+ 0   33          + STOP      0033         AT COL 33
         315+10  315 MCL3     + R ADD     *
         316+ 1  330          + TR        PRTMC        PRINT MC INSTRUCTION
         317+ 0    0 MCCOL    + STOP      /   /        COLUM WHERE TO PRINT = MCCOL*9 + 37
         318+10  318          + R ADD     *            
         319+ 1  388          + TR        PCHMC        PUNCH MC INSTRUCTION
         320+10 2006          + R ADD     ZERO         SIGNAL TO NOT ADD ANYMORE THE PACT SOURCE CODE AS A COMMENT
         321+12 2020          + STORE     MC.PACT      ON FIRST MC INSTR TXT CARD PUNCHED 
         322+10  317          + R ADD     MCCOL        
         323+ 9 2008          + ADD       ONE          
         324+12  317          + STORE     MCCOL
         325+ 1  257          + TR        MCLOOP
         326+ 0  546 TINSTAD  + STOP      TINST  
         327+10  327 MCLOEND  + R ADD     *            PRINT CURRENT LINE (LAST ONE)
         328+ 1   55          + TR        PRINTCRD
         329+ 1    0 PRTPCHEX + TR        /   /
         330+ 9 2009 PRTMC    + ADD       TWO          PRINT MC INSTRUCTION MC.LOC, MC.OP, REG, MC.ADDR
         331+13  334          + STORE A   PRTMCP1      PARAM: COLUM WHERE TO PRINT 0..3
         332+ 9 2008          + ADD       ONE
         333+13  385          + STORE A   PRTMCEX
         334+10    0 PRTMCP1  + R ADD     /   /        COLUM WHERE TO PRINT 0..3
         335+12 2028          + STORE     VAL
         336+22    3          + A LEFT    0003         X 8
         337+ 9 2028          + ADD       VAL          
         338+ 9 2016          + ADD       D37          COLUM WHERE TO PRINT = MCCOL*9 + 37
         339+13  353          + STORE A   PMCOLSGN     COL FOR SIGN
         340+ 9 2008          + ADD       ONE
         341+13  361          + STORE A   PMCOLMNE     COL FOR MNEMONIC OPCODE
         342+ 9 2010          + ADD       D3
         343+13  369          + STORE A   PMCOLREG     COL FOR REGION TAG
         344+ 9 2008          + ADD       ONE
         345+13  377          + STORE A   PMCOLADR     COL FOR ADDRESS WHEN PRINTED IN OCTAL
         346+13  383          + STORE A   PMCOLAD2     COL FOR ADDRESS WHEN PRINTED IN DECIMAL
         347+15 2015          + LOAD MQ   D12          '+'
         348+10 2022          + R ADD     MC.OP
         349+ 3  351          + TR +      PMC6
         350+15 2014          + LOAD MQ   D11          '-'
         351+10  351 PMC6     + R ADD     *            PRINT OP SIGN
         352+ 1   61          + TR        PRTCHR
         353+ 0    0 PMCOLSGN + STOP      /   /
         354+10 2006          + R ADD     ZERO
         355+11 2022          + ADD AB    MC.OP
         356+ 9  386          + ADD       TMNEAD
         357+13  358          + STORE A   PMC7
         358+15    0 PMC7     + LOAD MQ   /   /
         359+10  359          + R ADD     *            PRINT OP MNEMONIC
         360+ 1   57          + TR        PRTALF
         361+ 0    0 PMCOLMNE + STOP      /   /
         362+10 2023          + R ADD     MC.REG       REGION 0..7
         363+ 9  387          + ADD       TREGMNEA     CHARS IN TREGMNE ARE TXT ALFA VALUES  
         364+13  365          + STORE A   PMC8         THUS ARE NEGATIVE
         365+ 6    0 PMC8     + R SUB     /   /        CHANGE SIGN BEFORE STORING IT IN MQ
         366+21   35          + L RIGHT   0035
         367+10  367          + R ADD     *            PRINT REGION LETTER V I S T A N
         368+ 1   61          + TR        PRTCHR
         369+ 0    0 PMCOLREG + STOP      /   /
         370+10 2023          + R ADD     MC.REG       IF REGION = A OR REGION = V THEN PRINT ADDR IN DECIMAL
         371+ 4  379          + TR 0      PMDEC        ELSE PRINT REGION IN OCTAL 
         372+ 5 2009          + SUB       TWO         
         373+ 4  379          + TR 0      PMDEC
         374+15 2024          + LOAD MQ   MC.ADDR      PRINT ADDRESS IN OCTAL ON REGIONS I S T N 
         375+10  375          + R ADD     *
         376+ 1  120          + TR        PRTOCT4
         377+ 0    0 PMCOLADR + STOP      /   /        COLUMN TO PRINT AT
         378+ 1  385          + TR        PRTMCEX  
         379+15 2024 PMDEC    + LOAD MQ   MC.ADDR      PRINT ADDRESS IN DECIMAL ON REGIONS A V
         380+10  380          + R ADD     *
         381+ 1   59          + TR        PRTINT
         382+ 0    4          + STOP      0004         LEN=4
         383+ 0    0 PMCOLAD2 + STOP      /   /        COLUMN TO PRINT AT
         384+ 1  385          + TR        PRTMCEX  
         385+ 1    0 PRTMCEX  + TR        /   /        RETURN TO CALLER
         386+ 0 2094 TMNEAD   + STOP      TMNE
         387+ 0 2086 TREGMNEA + STOP      TREGMNE
         388+ 9 2009 PCHMC    + ADD       TWO          PUNCH INSTR
         389+13  403          + STORE A   PCHMCEX
         390+10 2022          + R ADD     MC.OP        PUNCH INSTR CARD
         391+22   12          + A LEFT    0012
         392+12 2028          + STORE     VAL
         393+10 2024          + R ADD     MC.ADDR
         394+13 2028          + STORE A   VAL          VAL = LMC.OP << 12 | LMC.ADDR
         395+10  395          + R ADD     *            ADD MC INSTR TO CURRENT REL BINARY CARD
         396+ 1   71          + TR        WRIBREL      
         397- 0    0          - STOP      0000         PARAM: BIN CARD TYPE REQUITED: -00 -> INSTR CARD, 
         398+12  526          + STORE     REGION       PARAM: BIN CARD SYMBOL REQUITED
         399+12 2021          + STORE     MC.LOC       PARAM: LOCATION 0..4095 
         400+ 0    0          + STOP      0000         PARAM: =0 -> DATA1=DATA TO STORE, DATA2=INDEX TAG
         401+12 2028          + STORE     VAL          PARAM: DATA 
         402+12 2023          + STORE     MC.REG       PARAM: DATA2 RIGHT HALF-WORD 
         403+ 1    0 PCHMCEX  + TR        /   /
         404+ 9 2009 LIBPCH   + ADD       TWO          PUNCH BINARY REL CARDS FOR USED LIBRARIES 
         405+13  483          + STORE A   LIBPCHEX 
         406+10 2006          + R ADD     ZERO
         407+12 2031          + STORE     LIB          INIT NAME OF CURRENT LIB BEING PROCESSED
         408+12 2032          + STORE     LPCHFLG      LIB PUNCH FLAG: =1 -> SHOULD PUNCH CURRENT LIB, =0 -> SHOULD SKIP CURRENT LIB
         409+10  409 READLIB  + R ADD     *            READ LIBRARY FROM TAPE
         410+ 1   65          + TR        RDTAPE       
         411+ 0  256          + STOP      TAPEBIN
         412+ 0  748          + STOP      LIBCODE      BUF TO WRITE TO TAPE
         413+10  748          + R ADD     LTYPE         
         414+ 5 2019          + SUB       D999         999 SIGNAL END OF LIB 
         415+ 4  448          + TR 0      LIBSDONE     IF =0 -> NO MORE LIBRARY ROUTINE TO SCAN
         416+10  749          + R ADD     LLIBNAM      IF READING NEXT RECORD OF CURRENT LIB ROUTINE 
         417+ 5 2031          + SUB       LIB          THEN TR TO LIBOK TO PUNCH IT IF REQUERIED
         418+ 4  442          + TR 0      LIBOK
         419+10  749          + R ADD     LLIBNAM      NEW ROUTINE
         420+12 2031          + STORE     LIB          IS SET AS CURRENT ONE
         421+10 2006          + R ADD     ZERO         RESET LIB PUNCH FLAG
         422+12 2032          + STORE     LPCHFLG      LIB PUNCH FLAG: =1 -> SHOULD PUNCH CURRENT LIB, =0 -> SHOULD SKIP CURRENT LIB
         423+10  423          + R ADD     *
         424+ 1   67          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         425+ 0  806          + STOP      TSYMBREF     ... GLOBAL SYMBOL TABLE
         426+ 0  805          + STOP      NSYMBS       ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NSYMBS
         427+ 0  749          + STOP      LLIBNAM      ... THE VALUE TO FIND 
         428+ 4  409          + TR 0      READLIB      ROUTINE IN LIBRARY IS NOT REFERENCED IN PACT PROG SYMBOL LIST -> TR TO 
         429+10 2008          + R ADD     ONE          SET LIB PUNCH FLAG
         430+12 2032          + STORE     LPCHFLG      LIB PUNCH FLAG: =1 -> SHOULD PUNCH CURRENT LIB, =0 -> SHOULD SKIP CURRENT LIB
         431+10  431          + R ADD     *
         432+ 1   53          + TR        PRTNLINE     
         433+ 0  401          + STOP      0401         CHAR AT COL 1
         434+ 0 2018          + STOP      D45          '/'
         435+ 0  502          + STOP      0502         ALFA TXT
         436+ 0  749          + STOP      LLIBNAM      LIB ROUTINE TO BE ADDED TO PACT PROGRAM
         437+ 0  405          + STOP      0405         CHAR AT COL 5
         438+ 0 2018          + STOP      D45          '/'
         439+ 0  107          + STOP      0107         STRINGZ AT COL 7
         440+ 0 2064          + STOP      MSGPCHOK     "LIB ROUTINE PUNCHED"
         441+ 0    6          + STOP      0006         END OF LINE. PRINT ONLY IF SW6 IS ON
         442+10 2032 LIBOK    + R ADD     LPCHFLG      LIB PUNCH FLAG: =1 -> SHOULD PUNCH CURRENT LIB, =0 -> SHOULD SKIP CURRENT LIB
         443+ 4  409          + TR 0      READLIB      ROUTINE IN LIBRARY NOT TO BE PUNCHED -> TR TO TRY WITH NEXT RECORD IN LIBRARY
         444+10  444          + R ADD     *
         445+ 1   75          + TR        WRITECR2     PUNCH THE CARD
         446+ 0  750          + STOP      LSRC         ADDR OF CARD IMAGE BUFFER 
         447+ 1  409          + TR        READLIB      ROUTINE IN LIBRARY PUNCHED -> TR TO PROCEED WITH NEXT RECORD IN LIBRARY
         448+10 2006 LIBSDONE + R ADD     ZERO         SCAN TSYMBXET. IF = -1 -> CORRESPONDING TSYMBREF IS NOT RESOLVED
         449+12 2029          + STORE     N
         450+10  481          + R ADD     TSYMBAD
         451+13  455          + STORE A   SYNAME
         452+10 2029 SYLOOP   + R ADD     N
         453+ 5  805          + SUB       NSYMBS
         454+ 4  482          + TR 0      SYLOEND      EXIT LOOP, ALL SYMBOLS SCANNED
         455+10    0 SYNAME   + R ADD     /   /        GET SYMBOL NAME (EITHER A PACT REGION OR A LIBRARY ROUTINE)
         456+12 2030          + STORE     SY
         457+10  455          + R ADD     SYNAME
         458+ 9  804          + ADD       MAXNSYMB
         459+13  460          + STORE A   SYEXT
         460+10    0 SYEXT    + R ADD     /   /        GET SYMBOL EXTENSION
         461+ 3  474          + TR +      SYLOOP1      IF EXTENSION < 0 -> SYMBOL NOT RESOLVED -> PRINT A MESSAGE
         462+10  462          + R ADD     *
         463+ 1   53          + TR        PRTNLINE     
         464+ 0  401          + STOP      0401         CHAR AT COL 1
         465+ 0 2018          + STOP      D45          '/'
         466+ 0  502          + STOP      0502         ALFA TXT
         467+ 0 2030          + STOP      SY           SYMBOL NOT RESOLVED
         468+ 0  405          + STOP      0405         CHAR AT COL 5
         469+ 0 2018          + STOP      D45          '/'
         470+ 0  107          + STOP      0107         STRINGZ AT COL 7
         471+ 0 2072          + STOP      MSGSYNOK     "ROUTINE NOT IN LIB"
         472+ 0    0          + STOP      0000         END OF LINE. 
         473+ 0  474          + STOP      SYLOOP1      STOP BECAUSE ROUTINE NOT RESOLVED. PRESS START TO CONTINUE
         474+10 2029 SYLOOP1  + R ADD     N
         475+ 9 2008          + ADD       ONE
         476+12 2029          + STORE     N
         477+10  455          + R ADD     SYNAME
         478+ 9 2008          + ADD       ONE
         479+13  455          + STORE A   SYNAME
         480+ 1  452          + TR        SYLOOP
         481+ 0  806 TSYMBAD  + STOP      TSYMBREF
         482+ 8    0 SYLOEND  + NOOP      0000
         483+ 1    0 LIBPCHEX + TR        /   /
         484+ 9 2009 PCHXFER  + ADD       TWO          PUNCH TRANSFER CARD 
         485+13  495          + STORE A   PCHXFEX
         486+10  486          + R ADD     *            NEW CARD: CLEAR CARD BUFFER 
         487+ 1   51          + TR        CLRBUF
         488+10  488          + R ADD     *            COPY XFER BINARY PROGRAM TO CARD BUFFER
         489+ 1   69          + TR        MEMCOPY
         490+ 0  496          + STOP      XFERBIN
         491+ 0    0          + STOP      0000
         492+ 0 2012          + STOP      D5
         493+10  493          + R ADD     *
         494+ 1   73          + TR        WRITECRD     WRITE BINARY TRANSFER CARD
         495+ 1    0 PCHXFEX  + TR        /   /        PROCEED
         496+10 4095 XFERBIN  + R ADD     4095         [4095]=ABS LOC OF 1ST REGION 
         497+13    3          + STORE A   0003
         498+10    2          + R ADD     0002         R ADD *
         499+ 1    0          + TR        0000         TR    REGION
         500+ 0    0          + STOP      0000         STOP  END OF COMPILED PROGRAM EXECUTION
         501+     0             ORG       EVEN
         502+     0  PACTSRC    RES       24           CARD IMAGE OF PACT SOURCE CODE CARD (12 FULL WORDS)
         526+     0  REGION     DEF       0
         527+     0  STEP       DEF       0            REGION = ALFA (<0)
         528+     0  OP         DEF       0            STEP   = INT (>0)
         529+     0  FACT       DEF       0            OP     = 0..43    =0 MEANS END OF REGION
         530+     0  S1         DEF       0            FACT   < 0 -> FACTOR IS AN ALFA SYMBOL (VAR, REGION, ...) 
         531+     0  S2         DEF       0            FACT = 0 -> BLANK FACTOR
         532+     0  QR         DEF       0            FACT = 0..9999 -> DESTINATION STEP FOR TRANSFER/RESULT OF STEP
         533+     0  QF         DEF       0            CLUE = -, R OR N
         534+     0  NUM        DEF       0            
         535+     0  NUM2       DEF       0            S1/S2 = 0 -> BLANK, >0 -> INTEGER, <0 -> ALFA 
         536+     0  CLUE       DEF       0
         537+     0  STEPN      DEF       0            QR = +/- INTEGER OR BLANK. 
         538+     0  FACTN      DEF       0            QF = SET IF THERE IS AN INTEGER FACTOR/NUMBER IN CARD
         539+     0  FACTREG    DEF       0
         540+     0  S1N        DEF       0            STEPN = SEQUENTIAL NUMBER OF STEP            
         541+     0  S2N        DEF       0            IF OP IS TRANSFER -> FACTN=DESTINATION STEPN
         542+     0  D1N        DEF       0            FACTN=ADDR (0, 2, 4, ..) FACTREG=' ', 'T', 'V', 'N'
         543+     0  D2N        DEF       0            S1N/S2N=INDEX (IF <0), BLANK (IF =0), CONST (IF >0)
         544+     0  NINST      DEF       0            D1N/D2N=HALF-WORD SIZE OF EACH DIMENSION
         545+     0  NINCR      DEF       0
         546+     0  TINST      RES       200          MACHINE CODE: 1ST HALF-WORD OPCODE + REGION/LOCATION INTO STEP (FOR TRANSFERS)
         746+    44  CCLEN      DEF       0044         LENGTH OF COMPACT CODE RECORD 
         747+   100  MAXNINST   DEF       100          MAX NUMBER OF MACHINE CODE INSTRUTIONS PER STEP
         748+     0  LTYPE      DEF       0            TYPE OF RECORD: 100=REGULAR RECORD. 999=END OF LIB 
         749+     0  LLIBNAM    DEF       0            LIBRARY ROUTINE NAME TO WITCH THIS RECORD BELONGS
         750+     0  LSRC       RES       48           CARD IMAGE OF PACT REL ASSEMBLER CARD/REL BINARY CARD (24 FULL WORDS)
         798+     0  OPADDR     DEF       0            = +/- MC.OP  MC.ADDR
         799+     0  FORMAT     DEF       0            =0 -> BINARY FORMAT, =1 -> TEXT FORMAT (MC INSTR), =2 -> TEXT FORMAT (NUM), 
         800+     0  REGLOC     DEF       0            = + MC.REG MC.LOC (REG A=0, I=1, V=2, T=3, N=4, P=5, S=7)
         801+     0  DUMMY      DEF       0            Spare
         802+    54  LCLEN      DEF       54           LENGH OF LIBRARY CODE RECORD 
         803+     0  DUMMY2     DEF       0            Spare
         804+   600  MAXNSYMB   DEF       600          MAX 600 SYMBOL (LIBRARIES/REGION) REFERENCES CAN DE DEFINED IN THE WHOLE PROGRAM
         805+     0  NSYMBS     DEF       0            NUMBER OF ENTRIES IN TSYMBREF GLOBAL SYMBOL TABLE
         806+     0  TSYMBREF   RES       600          GLOBAL SYMBOL TABLE: ALFA VALUE OF SYMBOLS REFERENCED. <0 IF NOT RESOLVED, >0 IF RESOLVED
        1406+     0  TSYMBEXT   RES       600          EXTENSION (=SIZE) FOR DEFINED SYMBOLS
        2006+     0  ZERO       DEF       0
        2007+     0             DEF       0
        2008+     1  ONE        DEF       1
        2009+     2  TWO        DEF       2
        2010+     3  D3         DEF       3
        2011+     4  D4         DEF       4
        2012+     5  D5         DEF       5
        2013+    10  D10        DEF       10
        2014+    11  D11        DEF       11
        2015+    12  D12        DEF       12
        2016+    37  D37        DEF       37
        2017+    44  D44        DEF       44
        2018+    45  D45        DEF       45
        2019+   999  D999       DEF       999
        2020+     0  MC.PACT    DEF       0            =1 -> ADD PACT SOURCE CODE LINE AS COMMENT ON MC INSTR PUNCHED AS RELATIVE TEXT CARD
        2021+     0  MC.LOC     DEF       0            MC OPCODE RELATIVE LOCATION
        2022+     0  MC.OP      DEF       0            MC OPCODE GENERATED
        2023+     0  MC.REG     DEF       0            REGION REFERENCED BY MC OPCODE GENERATED
        2024+     0  MC.ADDR    DEF       0            MC ADDR GENERATED. BOTH WILL BE STORED IN TINST TABLE IN COMPCAT CODE RECORD
        2025+     0  MCNUM      DEF       0            NEXT INSTR TO PROCESS
        2026+     0  IRELADDR   DEF       0            I RELATIVE LOCATION OF STEP
        2027+     0  IREL0      DEF       0            I RELATIVE LOCATION OF THIS STEP
        2028+     0  VAL        DEF       0
        2029+     0  N          DEF       0
        2030+     0  SY         DEF       0
        2031+     0  LIB        DEF       0
        2032+     0  LPCHFLG    DEF       0            LIB PUNCH FLAG: =1 -> SHOULD PUNCH CURRENT LIB, =0 -> SHOULD SKIP CURRENT LIB
        2033- 56335  MSGSTART   TXT       "LIST AND PUNCH",0
        2034- 73741  
        2035- 60672  
        2036- 66122  
        2037- 35520  
        2038+     0  
        2039- 69955  MSGHDR1    TXT       "REGSTEPOP  CFACT S1 S2 Q    N",0
        2040- 72977  
        2041- 65836  
        2042-    15  
        2043- 42111  
        2044- 73759  
        2045-  2335  
        2046-  4637  
        2047-     0  
        2048-  1248  
        2049+     0  
        2050- 56607  MSGHDR2    TXT       "LOC OP T REL OP T REL OP T REL OP T REL",0
        2051-  1324  
        2052-  1536  
        2053- 69960  
        2054-  1324  
        2055-  1536  
        2056- 69960  
        2057-  1324  
        2058-  1536  
        2059- 69960  
        2060-  1324  
        2061-  1536  
        2062- 69960  
        2063+     0  
        2064- 56318  MSGPCHOK   TXT       "LIB ROUTINE PUNCHED",0
        2065-  1467  
        2066- 77589  
        2067- 60720  
        2068- 66122  
        2069- 35537  
        2070- 36864  
        2071+     0  
        2072- 70449  MSGSYNOK   TXT       "ROUTINE NOT IN LIB",0
        2073- 74762  
        2074- 39194  
        2075- 63744  
        2076- 49632  
        2077- 56318  
        2078+     0  
        2079- 40432  MSGECOMP   TXT       "END OF COMPILATION",0
        2080-  1314  
        2081-   747  
        2082- 58965  
        2083- 55952  
        2084- 49706  
        2085+     0  
        2086-    13  TREGMNE    TXT       '  A'
        2087-    21             TXT       '  I'
        2088-    34             TXT       '  V'
        2089-    32             TXT       '  T'
        2090-    26             TXT       '  N'
        2091-    28             TXT       '  P'        PERISHABLE STORAGE (=LIB LOCAL VARS)
        2092-    44             TXT       '  #'        UNUSED
        2093-    31             TXT       '  S'
        2094- 46080  TMNE       TXT       'H  '        STOP/HALT
        2095- 73728             TXT       'T  '        TRANSFER
        2096- 74592             TXT       'TF '        TRANSFER ON OVERLOF
        2097- 75072             TXT       'TP '        TRANSFER ON PLUS
        2098- 75552             TXT       'TZ '        TRANSFER ON ZERO
        2099- 71424             TXT       'S  '        SUBTRACT
        2100- 70608             TXT       'RS '        RESET AND SUBTRACT
        2101- 73056             TXT       'SV '        SUBTRACT ABSOLUTE VALUE
        2102- 59904             TXT       'N  '        NO OPERATION
        2103- 29952             TXT       'A  '        ADD
        2104- 69744             TXT       'RA '        RESET AND ADD
        2105- 31584             TXT       'AV '        ADD ABSOLUTE VALUE
        2106- 72960             TXT       'ST '        STORE
        2107- 72048             TXT       'SA '        STORE ADDRESS
        2108- 72624             TXT       'SM '        STORE MQ
        2109- 56496             TXT       'LM '        LOAD MQ
        2110- 57600             TXT       'M  '        MULTIPLY
        2111- 59040             TXT       'MR '        MULTIPLY AND ROUND
        2112- 36864             TXT       'D  '        DIVIDE
        2113- 69120             TXT       'R  '        ROUND
        2114- 56448             TXT       'LL '        LONG LEFT SHIFT
        2115- 56736             TXT       'LR '        LONG RIGHT SHIFT
        2116- 31104             TXT       'AL '        ACCUMULATOR LEFT SHIFT
        2117- 31392             TXT       'AR '        ACCUMULATOR RIGHT SHIFT
        2118- 69888             TXT       'RD '        READ
        2119- 69792             TXT       'RB '        READ BACKWARDs
        2120- 80640             TXT       'W  '        WRITE
        2121- 81456             TXT       'WE '        WRITE END OF FILE
        2122- 70800             TXT       'RW '        REWIND TAPE
        2123- 72192             TXT       'SD '        SET DRUM DDR
        2124- 72240             TXT       'SE '        SENSE
        2125- 34560             TXT       'C  '        COPY
        2126+15 2140 CLRBUF   + LOAD MQ   IOCL
        2127+14 2145          + STORE MQ  BUFIO
        2128+15 2166          + LOAD MQ   IOSTORE         
        2129+ 1 2137          + TR        INIT2
        2130+15 2162 READCRD  + LOAD MQ   IORDCRD
        2131+ 1 2135          + TR        INIT1
        2132+15 2164 WRITECRD + LOAD MQ   IOWRCRD
        2133+ 1 2135          + TR        INIT1
        2134+15 2165 PRINTCRD + LOAD MQ   IOPRCRD
        2135+14 2145 INIT1    + STORE MQ  BUFIO
        2136+15 2163          + LOAD MQ   IOCOPY         
        2137+14 2146 INIT2    + STORE MQ  BUFROW
        2138+ 9 2172          + ADD       TWO          
        2139+13 2161          + STORE A   EXIT
        2140+10 2168 IOCL     + R ADD     ZERO         RESET TO INITIAL COPY LOOP ADDRESS     
        2141+13 2146          + STORE A   BUFROW       FOR BUFFER
        2142+10 2146          + R ADD     BUFROW       X .*echo Print
        2143+ 5 2173          + SUB       D48          X 
        2144+12 2170          + STORE     ENDLP        X LOOP END VALUE
        2145- 0    0   BUFIO  - STOP      /   /        READ OR WRITE
        2146-31    0   BUFROW - COPY      /   /        COPY WORD TO/FROM PRINTER/CARDREADER
        2147+ 1 2151          + TR        BUFOK2       NORMAL PROCESSING 
        2148+ 1 2158          + TR        EODECK       FOR COPY READING END OF REG (=END OF DECK BEING READ)
        2149+ 6 2172          + R SUB     TWO          END OF FILE -> NO CARD TO READ -> STOP with Acc=-2
        2150+ 0 2145          + STOP      BUFIO        ON PRESSING START RETRY CARD READ
        2151+10 2146   BUFOK2 + R ADD     BUFROW       X
        2152+ 5 2172          + SUB       TWO          INCR BUF ADDR
        2153+13 2146          + STORE A   BUFROW       X
        2154+ 5 2170          + SUB       ENDLP        CHECK FOR END
        2155+ 4 2160          + TR 0      ENDIO
        2156+10 2168          + R ADD     ZERO         CLEAR ACC IN CASE WE ARE CLEANING THE BUFFER
        2157+ 1 2146          + TR        BUFROW
        2158+10 2171 EODECK   + R ADD     ONE          SET OV FLAG TO SIGNAL END OF DECK CONDITION
        2159+22   36          + A LEFT    36
        2160+26 2052 ENDIO    + WRITE     2052         END OF I/O: INSURE THAT MQ NOT IN USE            
        2161+ 1    0 EXIT     + TR        /   /
        2162+24 2048 IORDCRD  + READ      2048         PREPARE TO READ FROM CARD READER
        2163-31    0 IOCOPY   - COPY      /   /   
        2164+26 1024 IOWRCRD  + WRITE     1024         PREPARE TO PUNCH CARD 
        2165+26  512 IOPRCRD  + WRITE     0512         PREPARE WRITE PRTBUF ON PRINTER
        2166-12    0 IOSTORE  - STORE     /   /        CLEAR BUFFER
        2167+     0             ORG       EVEN           
        2168+     0  ZERO       DEF       0            
        2169+     0             DEF       0            
        2170+     0  ENDLP      DEF       0            LOOP END VALUE
        2171+     1  ONE        DEF       1
        2172+     2  TWO        DEF       2
        2173+    48  D48        DEF       48
        2174+ 9 2445 PRTPARM2 + ADD       TWO          GET 2 PARAMS: LEN AND COL (EITHER VALUE OR VAR ADDR)
        2175+13 2194          + STORE A   PRTPRMEX
        2176+10 2184          + R ADD     PRTP1
        2177+ 9 2445          + ADD       TWO          PRINT PACKED TEXT FROM FULL-WORD VALUE IN MQ REGISTER 
        2178+13 2184          + STORE A   PRTP1        STORE ADDR OF FIRST PARAM (LEN)
        2179+ 9 2444          + ADD       ONE
        2180+13 2186          + STORE A   PRTP2        STORE ADDR OF SECOND PARAM (COL)
        2181+ 9 2444          + ADD       ONE
        2182+13 2261          + STORE A   EXIT
        2183-14 2434          - STORE MQ  NUM          SAVE VALUE TO PRINT PARAM MQ (NUM IS ALIASED TO TXT)
        2184+10    0   PRTP1  + R ADD     /   /        GET LEN: NUMBER OF CHARS TO PRINT (1..6)
        2185+12 2438          + STORE     LEN
        2186+10    0   PRTP2  + R ADD     /   /        GET COLUMN PARAM 1..72
        2187+ 3 2190          + TR +      PRTP4
        2188+13 2189          + STORE A   PRTP3        COL<0 -> INTERPRET COL AS LOC(COL) = ADDR OF COL VAR
        2189+10    0   PRTP3  + R ADD     /   /        READ VAR COL PASED AS PARAM
        2190+ 4 2261   PRTP4  + TR 0      EXIT         COL=0 -> EXIT
        2191+ 3 2193          + TR +      PRTP5
        2192+ 1 2261          + TR        EXIT         COL<0 -> EXIT
        2193+12 2244   PRTP5  + STORE     COL
        2194+ 1    0 PRTPRMEX + TR        /   /        RETURN TO CALLER
        2195+13 2184 PRTSTR   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2196+10 2196          + R ADD     *            FOR PRINT STRINGZ FROM MEM
        2197+ 1 2174          + TR        PRTPARM2
        2198+12 2208          + STORE     COLSZ
        2199+10 2438          + R ADD     LEN          LEN IS IN FACT THE LOCATION WHERE THE STRING STARTS
        2200+13 2203          + STORE A   STRZAD
        2201+10 2261          + R ADD     EXIT
        2202+13 2216          + STORE A   STRZEX
        2203+10    0 STRZAD   + R ADD     /   /        GET HALF-WORD WITH NEXT 3 CHARS TO PRINT
        2204+ 4 2216          + TR 0      STRZEX       IF +0 -> END OF STRING (-0 DOES NOT TERMINATES THE STRING)
        2205+21   35          + L RIGHT   0035         MQ=3-CHARS TO PRINT
        2206+10 2206          + R ADD     *            
        2207+ 1 2218          + TR        PRTALF       PRINT 3 CHARS
        2208+ 0    0 COLSZ    + STOP      0000         COL 
        2209+10 2203 STRZ1    + R ADD     STRZAD       INCR STRING ADDRESS
        2210+ 9 2444          + ADD       ONE
        2211+13 2203          + STORE A   STRZAD
        2212+10 2208          + R ADD     COLSZ        INCR COLUMN
        2213+ 9 2446          + ADD       D3
        2214+13 2208          + STORE A   COLSZ
        2215+ 1 2203          + TR        STRZAD
        2216+ 3    0 STRZEX   + TR +      /   /        IF ZERO -> END OF STRING
        2217+ 1 2209          + TR        STRZ1
        2218+ 9 2445 PRTALF   + ADD       TWO          PRINT 3-PACKED CHARS IN MQ REGISTER 
        2219+14 2440          + STORE MQ  TXT          SAVE TEXT TO PRINT (IN LEFT HALF WORD)
        2220+13 2223          + STORE A   PRTAP2       STORE ADDR OF PARAM (COL)
        2221+ 9 2444          + ADD       ONE
        2222+13 2261          + STORE A   EXIT
        2223+10    0   PRTAP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        2224+ 3 2227          + TR +      PRTAP4
        2225+13 2226          + STORE A   PRTAP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        2226+10    0   PRTAP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        2227+12 2244   PRTAP4 + STORE     COL
        2228+10 2446          + R ADD     D3
        2229+12 2438          + STORE     LEN
        2230+10 2428 PRT1     + R ADD     ZERO         UNPACK LEFTMOST CHAR 
        2231+11 2440          + ADD AB    TXT          GET TEXT DISCARD SIGN
        2232+21   35          + L RIGHT   0035         MQ=Acc
        2233+10 2428          + R ADD     ZERO
        2234+18 2453          + DIV       D48X48
        2235+12 2440          + STORE     TXT          remainder=char to print, mq=c2 * 48 + c3 in right half-word
        2236+10 2428          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        2237+20   18          + L LEFT    0018         put c2 and c3 in left half-word of MQ to be saved in CHAR half word
        2238+14 2439          + STORE MQ  CHAR         CHAR TO PRINT
        2239+10 2439          + R ADD     CHAR 
        2240+ 4 2245          + TR 0      NXTCHR       IF BLANK PROCEED TO NEXT COL
        2241+21   35          + L RIGHT   0035         MQ=CHAR TO PRINT
        2242+10 2242          + R ADD     *            PRINT CHAR
        2243+ 1 2338          + TR        PRTCHR
        2244+ 0    0 COL      + STOP      0000         COL: COLUMN NUMBER TO PRINT (1..72)
        2245+10 2438 NXTCHR   + R ADD     LEN          DECR LEN COUNT
        2246+ 5 2444          + SUB       ONE
        2247+12 2438          + STORE     LEN
        2248+ 4 2261          + TR 0      EXIT         IF NO MORE CHARS TO PRINT EXIT
        2249+10 2244          + R ADD     COL          INCR COL POSITION
        2250+ 9 2444          + ADD       ONE
        2251+12 2244          + STORE     COL
        2252+ 5 2452          + SUB       D72          IF COL > 72 RETURN TO CALLER
        2253+ 4 2255          + TR 0      GNXTCHR      ELSE PROCEED WITH NEXT CHAR
        2254+ 3 2261          + TR +      EXIT
        2255+10 2428 GNXTCHR  + R ADD     ZERO         GET NEXT CHAR 
        2256+15 2440          + LOAD MQ   TXT
        2257+16 2451          + MPY       D48
        2258+22   17          + A LEFT    0017         GET RESULT IN LEFT HALF-WORD OF ACC
        2259+12 2440          + STORE     TXT
        2260+ 1 2230          + TR        PRT1         PROCEED TO PRINT CHAR
        2261+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        2262+13 2184 PRTOCT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2263+10 2263          + R ADD     *            FOR PRINT OCTIONARY VALUE
        2264+ 1 2174          + TR        PRTPARM2
        2265+10 2438          + R ADD     LEN          LEN = OCTAL DIGITS TO PRINT
        2266+ 9 2244          + ADD       COL
        2267+ 5 2444          + SUB       ONE
        2268+12 2280          + STORE     COLN         COL POINTS TO LEAST SIGNIFICANT DIGIT
        2269+10 2434 PRTIOCG  + R ADD     NUM          GENERATE OCTINARY DIGIT
        2270+15 2428          + LOAD MQ   ZERO         CLEAR MQ
        2271+21   21          + L RIGHT   0021         3 LSB BITS OF LEFT HALF-WORD OF ACC TO MQ
        2272+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 3 BIT)
        2273+12 2434          + STORE     NUM          SAVE BACK NUM WITH RIGHTMOST OCTIONARY DIGIY EXTRACTED (NUM'=NUM/8)
        2274+10 2428          + R ADD     ZERO
        2275+20   21          + L LEFT    0021         LEFT HALF-WORD OF ACC IS NOW RIGHTMOST OCTINARY DIGIT EXTRACTED FROM NUM 
        2276+ 4 2294          + TR 0      PRTIOZ       TR IF THIS DIGIT IS ZERO TO PRINT A '0' (BASE48 CODE = 10) INSTEAD OF A BLANK (BASE48 CODE = 0)
        2277+21   35          + L RIGHT   0035         PUT DIGIT 1..9 TO PRINT IN MQ
        2278+10 2278 PRTOCTD  + R ADD     *            PRINT OCTINARY DIGIT
        2279+ 1 2338          + TR        PRTCHR
        2280+ 0    0 COLN     + STOP      0000
        2281+10 2280          + R ADD     COLN        DECR COL NUMBER TO PRINT NEXT DIGIT
        2282+ 5 2444          + SUB       ONE
        2283+12 2280          + STORE     COLN
        2284+10 2438          + R ADD     LEN          DECR COL NUMBER TO PRINT NEXT DIGIT
        2285+ 5 2444          + SUB       ONE
        2286+ 4 2261          + TR 0      EXIT         PRINTED LEN OCTINARY DIGITS -> EXIT
        2287+12 2438          + STORE     LEN
        2288+10 2434          + R ADD     NUM          IF NUM < 0, ADD SIGN BIT TO LEFTMOST DIGIT
        2289+ 3 2269          + TR +      PRTIOCG
        2290+10 2454          + R ADD     OCT04K       
        2291+ 5 2434          + SUB       NUM
        2292+12 2434          + STORE     NUM
        2293+ 1 2269          + TR        PRTIOCG
        2294+15 2447   PRTIOZ + LOAD MQ   D10          ACC=BASE48 CODE FOR '0'
        2295+ 1 2278          + TR        PRTOCTD      TR TO PRINT IT
        2296+13 2184 PRTINT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2297+10 2297          + R ADD     *            FOR PRINT OCTIONARY VALUE
        2298+ 1 2174          + TR        PRTPARM2
        2299+10 2244          + R ADD     COL          PRINT DECIMAL NUMBER. VALUE OF LEN = DIGITS TO PRINT, NOT INCLUDING SIGN
        2300+ 9 2438          + ADD       LEN
        2301+ 5 2444          + SUB       ONE          
        2302+12 2323          + STORE     COLNI        COL POINTS TO END OF NUMBER
        2303+10 2428          + R ADD     ZERO
        2304+12 2437          + STORE     SGN          SIGN IS POSITIVE
        2305+10 2434          + R ADD     NUM
        2306+ 3 2311          + TR +      PRTINTG
        2307+ 6 2434          + R SUB     NUM          NUM IS NEGATIVE. CONVERT TO POSITIVE
        2308+12 2434          + STORE     NUM          AND SET SGN=1
        2309+10 2444          + R ADD     ONE
        2310+12 2437          + STORE     SGN          
        2311+10 2434 PRTINTG  + R ADD     NUM          GENERATE DECIMAL DIGIT
        2312+21   35          + L RIGHT   0035         MQ=Acc
        2313+10 2428          + R ADD     ZERO
        2314+18 2447          + DIV       D10
        2315+ 4 2336          + TR 0      PRTINZ
        2316+12 2439 PRTINTG2 + STORE     CHAR         acc=remainder=digit to print, mq=num/10
        2317+10 2428          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        2318+20   18          + L LEFT    0018         digit in left half-word of MQ to be saved in CHAR half word
        2319+14 2434          + STORE MQ  NUM 
        2320+15 2439          + LOAD MQ   CHAR 
        2321+10 2321 PRTINTD  + R ADD     *            PRINT DECIMAL DIGIT
        2322+ 1 2338          + TR        PRTCHR
        2323+ 0    0 COLNI    + STOP      0000
        2324+10 2323          + R ADD     COLNI        DECR COL NUMBER TO PRINT NEXT DIGIT
        2325+ 5 2444          + SUB       ONE
        2326+12 2323          + STORE     COLNI
        2327+10 2434          + R ADD     NUM          DO NOT CARE ABOUT LEN, JUST CHECK IF NUM=0 
        2328+ 4 2330          + TR 0      PRTINS       (SO NO MORE DIGITS REMAINS TO BE PRINTED)
        2329+ 1 2311          + TR        PRTINTG      NUM NOT FINISHED, PROCEED WITH NEXT DIGIT
        2330+10 2437 PRTINS   + R ADD     SGN
        2331+ 4 2261          + TR 0      EXIT         NO SIGN -> NUM FINISHED
        2332+10 2428          + R ADD     ZERO
        2333+12 2437          + STORE     SGN          CLEAR SGN FLAG
        2334+15 2448          + LOAD MQ   D11          BASE48 CODE FOR '-' (MINUS) CHAR
        2335+ 1 2321          + TR        PRTINTD      GO TO PRINT IT
        2336+10 2447   PRTINZ + R ADD     D10          ACC=BASE48 CODE FOR '0'
        2337+ 1 2316          + TR        PRTINTG2     TR TO PRINT IT
        2338+ 9 2445 PRTCHR   + ADD       TWO          PRINT CHAR IN MQ REGISTER 
        2339+14 2439          + STORE MQ  CHAR         SAVE CHAR TO PRINT (IN LEFT HALF WORD)
        2340+13 2344          + STORE A   PRTCP2       STORE ADDR OF PARAM (COL)
        2341+ 9 2444          + ADD       ONE
        2342+13 2422          + STORE A   PRTCEX
        2343+ 2 2344          + TR OV     PRTCP2       CLEAR OV JUST IN CASE
        2344+10    0   PRTCP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        2345+ 3 2348          + TR +      PRTCP4
        2346+13 2347          + STORE A   PRTCP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        2347+10    0   PRTCP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        2348+ 5 2444   PRTCP4 + SUB       ONE
        2349+12 2442          + STORE     N            N=COL-1 -> IN RANGE 0..71
        2350+ 3 2352          + TR +      PRTSA        IF N >= 0 PROCEED WITH BASE BUFFER ADDR CALCULATION
        2351+ 1 2422          + TR        PRTCEX       IF N<0 EXIT
        2352+10 2428    PRTSA + R ADD     ZERO         CARD BUFFER USES LOCATION 0..47
        2353+13 2441          + STORE A   PRTROWAD     DETERMINE ADDRESS OF LOWER ROW TO PRINT
        2354+10 2442          + R ADD     N
        2355+ 5 2450          + SUB       D36
        2356+ 3 2358          + TR +      PRTC0
        2357+ 1 2364          + TR        PRTC1
        2358+12 2442    PRTC0 + STORE     N            COL NOW 0..35 
        2359+ 5 2450          + SUB       D36
        2360+ 3 2422          + TR +      PRTCEX       IF COL >= 36 (IE COL PASSED AS PARAM > 72) THEN EXIT
        2361+10 2441          + R ADD     PRTROWAD
        2362+ 9 2445          + ADD       TWO
        2363+13 2441          + STORE A   PRTROWAD     SET BASE BUFFER ADDR 
        2364+10 2444    PRTC1 + R ADD     ONE          DETERMINE MASKCOL WITH MASK TO SET IN CARD BUFFER
        2365+21   53          + L RIGHT   53           SET RIGHTMOST BIT OF MQ TO 1 (SHIFT 35+18=53)
        2366+10 2449          + R ADD     D35
        2367+ 5 2442          + SUB       N
        2368+13 2370          + STORE A   PRTC2
        2369+10 2428          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW
        2370+20    0    PRTC2 + L LEFT    /   /        SHIFT MQ LEFT N PLACES
        2371+ 4 2374          + TR 0      PRTC3        IF ACC STILL ZERO -> MASKCOL VALID
        2372+ 6 2444          + R SUB     ONE          ACC NOT ZERO -> SHOULD GENERATE -0 TO SET SIGN BIT ON
        2373+21   72          + L RIGHT   0072         NOW MQ = -0 -> LEFTMOST BIT OF MQ SET
        2374-14 2430    PRTC3 - STORE MQ  MASKCOL
        2375+10 2428          + R ADD     ZERO         READ THE BITMAP OF CHAR 
        2376+11 2439          + ADD AB    CHAR         DISCARD SIGN OF CHAR, IF ANY
        2377+12 2439          + STORE     CHAR
        2378+ 5 2451          + SUB       D48
        2379+ 3 2422          + TR +      PRTCEX       IF CHAR >= 48 EXIT
        2380+10 2436          + R ADD     BITMAPAD     IF ADDR OF BASE48 BITMAP NOT COMPUTED
        2381+ 4 2423          + TR 0      GETBMP1      TR TO LOAD IT
        2382+ 9 2439  GETBMP2 + ADD       CHAR         READ THE BITMAP OF CHAR 
        2383+13 2384          + STORE A   PRTC4        INDICATES THE BITS TO SET IN SELECTED 
        2384+10    0    PRTC4 + R ADD     /   /        COLUMN OF CARD BUFFER 
        2385+12 2443          + STORE     BITS
        2386+ 6 2444          + R SUB     ONE
        2387+12 2442          + STORE     N            SET TO -1
        2388+10 2442    LOOP1 + R ADD     N            CURRENT ROW (STARTS AT ZERO) = OFFSET ON PRTROWAD     
        2389+ 9 2444          + ADD       ONE
        2390+12 2442          + STORE     N
        2391+10 2443          + R ADD     BITS         EXTRACT RIGHTMOST BIT OF LEFT HALF OF ACC TO MQ
        2392+ 4 2422          + TR 0      PRTCEX       NO MORE BITS -> EXIT
        2393+21   19          + L RIGHT   0019         LSB BIT OF LEFT HALF-WORD OF ACC TO MQ
        2394+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 1 BIT)
        2395+12 2443          + STORE     BITS         SAVE BACK BITS. LSB HAS BEEN EXTACTED, CONTENTS SHIFTED RIGHT ONE PLACE
        2396+10 2428          + R ADD     ZERO
        2397+20    1          + L LEFT    0001         PUT EXTACTED BIT BACK INTO ACC
        2398+ 4 2388          + TR 0      LOOP1        NO BIT 
        2399+10 2442          + R ADD     N            READ THE ROW N AT CARD BUFFER 
        2400+22    2          + A LEFT    0002         MULT N BY 4 AS THERE ARE 4 HALF WORDS PER ROW
        2401+ 9 2441          + ADD       PRTROWAD     
        2402+13 2404          + STORE A   PRTROWR
        2403+13 2420          + STORE A   PRTROWW
        2404-10    0  PRTROWR - R ADD     /   /        
        2405-12 2432          - STORE     ROW          CURRENT CONTENTS OF ROW
        2406-10 2430          - R ADD     MASKCOL      "OR" MASKCOL IN SELECTED ROW
        2407+ 3 2415          + TR +      PRTW2
        2408-10 2432          - R ADD     ROW 
        2409+ 4 2413          + TR 0      PRTW1         
        2410+10 2428          + R ADD     ZERO         MASKCOL IS MINUS ZERO AND ROW IS NOT-EMPTY (EITHER POSITIVE OR NEGATIVE) -> SET ROW AS NEGATIVE
        2411- 7 2432          - SUB AB    ROW 
        2412+ 1 2420          + TR        PRTROWW
        2413-10 2430    PRTW1 - R ADD     MASKCOL      MASKCOL IS MINUS ZERO AND ROW IS EMPTY -> SET ROW = MASKCOL = MINUS ZERO
        2414+ 1 2420          + TR        PRTROWW
        2415-10 2432    PRTW2 - R ADD     ROW          
        2416+ 3 2419          + TR +      PRTW3              
        2417- 5 2430          - SUB       MASKCOL      MASKCOL IS POSITIVE AND ROW IS NEGATIVE -> SUB MASKCOL FROM ROW
        2418+ 1 2420          + TR        PRTROWW
        2419- 9 2430    PRTW3 - ADD       MASKCOL      MASKCOL IS POSITIVE AND ROW IS POSITIVE OR EMPTY -> ADD MASKCOL TO ROW         
        2420-12    0  PRTROWW - STORE     /   /        ROW UPDTATE
        2421+ 1 2388          + TR        LOOP1        PROCEED TO NEXT ROW
        2422+ 1    0 PRTCEX   + TR        /   /
        2423+10 2423 GETBMP1  + R ADD     *
        2424+ 1   83          + TR        BMPAD        GET BASE48 CHARS BITMAP ADDRESS
        2425+12 2436          + STORE     BITMAPAD     
        2426+ 1 2382          + TR        GETBMP2      RETURN
        2427+     0             ORG       EVEN
        2428+     0  ZERO       DEF       0            
        2429+     0             DEF       0            
        2430+     0  MASKCOL    DEF       0
        2431+     0             DEF       0
        2432+     0  ROW        DEF       0
        2433+     0             DEF       0
        2434+     0  NUM        DEF       0
        2435+     0             DEF       0
        2436+     0  BITMAPAD   DEF       0
        2437+     0  SGN        DEF       0
        2438+     0  LEN        DEF       0
        2439+     0  CHAR       DEF       0
        2440+     0  TXT        DEF       0
        2441+     0  PRTROWAD   DEF       0
        2442+     0  N          DEF       0
        2443+     0  BITS       DEF       0
        2444+     1  ONE        DEF       1
        2445+     2  TWO        DEF       2
        2446+     3  D3         DEF       3
        2447+    10  D10        DEF       10
        2448+    11  D11        DEF       11
        2449+    35  D35        DEF       35
        2450+    36  D36        DEF       36
        2451+    48  D48        DEF       48
        2452+    72  D72        DEF       72
        2453+  2304  D48X48     DEF       2304
        2454+ 16384  OCT04K     DEF       *040000      BIT SIGN ON 5TH OCTINARY DIGIT
        2456+ 9 2531 PRTNLINE + ADD       TWO          PRINT A NEW LINE OF DATA
        2457+12 2534          + STORE     PARAM        SAVE PARAM LIST ADDR
        2458+10 2458          + R ADD     *            CLEAR CARD BUFFER
        2459+ 1   51          + TR        CLRBUF 
        2460+10 2534 GPARAM   + R ADD     PARAM        GET PARAM PAIR FMT/DATA
        2461+13 2466          + STORE A   P1
        2462+ 9 2530          + ADD       ONE
        2463+13 2470          + STORE A   P2
        2464+ 9 2530          + ADD       ONE
        2465+12 2534          + STORE     PARAM
        2466+10    0 P1       + R ADD     /   /
        2467+12 2536          + STORE     FMT
        2468+ 3 2470          + TR +      P2           IF FMT < 0 THEM SKIP THIS PAIR FMT/DATA
        2469+ 1 2460          + TR        GPARAM
        2470+10    0 P2       + R ADD     /   /
        2471+12 2496          + STORE     DATALOC      GET DATA ADDRESS PASED AS PARAM
        2472+13 2473          + STORE A   P2A
        2473+10    0 P2A      + R ADD     /   /
        2474+12 2535          + STORE     DATA         GET EFFECTIVE DATA
        2475+10 2529          + R ADD     ZERO
        2476+15 2536          + LOAD MQ   FMT
        2477+18 2533          + DIV       D100         ACC=REMAINDER=COL NUMBER, MQ=QUOTIEN=TYPE OF DATA
        2478+12 2537          + STORE     COL
        2479+10 2529          + R ADD     ZERO
        2480+20   18          + L LEFT    0018
        2481+14 2536          + STORE MQ  FMT
        2482+15 2535          + LOAD MQ   DATA
        2483+10 2487          + R ADD     TYPETRAD
        2484+ 9 2536          + ADD       FMT
        2485+13 2486          + STORE A   TYPETR
        2486+ 1    0 TYPETR   + TR        /   /        TR SELECTED ROUTINE
        2487+ 0 2488 TYPETRAD + STOP      TYPETRT      TYPE TRANSFER TABLE ADDRESS
        2488+ 1 2517 TYPETRT  + TR        EOL          FMT=0..6 (IE <100) -> END OF PARAM LIST -> END OF LINE 
        2489+ 1 2494          + TR        TYSTR        FMT=1 -> PRINT A STRINGZ
        2490+ 1 2499          + TR        TYINT        FMT=2 -> PRINT AN INT
        2491+ 1 2504          + TR        TYOCT        FMT=3 -> PRINT AN OCT
        2492+ 1 2509          + TR        TYCHR        FMT=4 -> PRINT A CHAR
        2493+ 1 2513          + TR        TYALF        FMT=5 -> PRINT A 3-CHR PACKED ALFA STRING
        2494+10 2494 TYSTR    + R ADD     *            PRINT STRINGZ
        2495+ 1   79          + TR        PRTSTR
        2496+ 0    0 DATALOC  + STOP      /   /
        2497- 0 2537          - STOP      COL          COLUMN WHERE TXT STARTS
        2498+ 1 2460          + TR        GPARAM
        2499+10 2499 TYINT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2500+ 1   59          + TR        PRTINT
        2501+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        2502- 0 2537          - STOP      COL          COLUMN WHERE TXT STARTS
        2503+ 1 2460          + TR        GPARAM
        2504+10 2504 TYOCT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2505+ 1   81          + TR        PRTOCT
        2506+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        2507- 0 2537          - STOP      COL          COLUMN WHERE TXT STARTS
        2508+ 1 2460          + TR        GPARAM
        2509+10 2509 TYCHR    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2510+ 1   61          + TR        PRTCHR
        2511- 0 2537          - STOP      COL          COLUMN WHERE TXT STARTS
        2512+ 1 2460          + TR        GPARAM
        2513+10 2513 TYALF    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2514+ 1   57          + TR        PRTALF
        2515- 0 2537          - STOP      COL          COLUMN WHERE TXT STARTS
        2516+ 1 2460          + TR        GPARAM
        2517+10 2537 EOL      + R ADD     COL          SEND CARD BUFFER TO PRINTER AND RETURN TO CALLER
        2518+ 4 2523          + TR 0      DOPRINT      =0 -> PRINT ALLWAYS (NO SENSE SW CHECK)
        2519+ 9 2532          + ADD       D68          =1..6 -> SENSE 69..74 = OPERATOR'S PANEL SENSE SWITCH 1..6
        2520+13 2521          + STORE A   CHKSW
        2521+30    0 CHKSW    + SENSE     /   /         
        2522+ 1 2525          + TR        RETURN       SW NOT AT ON POSITION
        2523+10 2523 DOPRINT  + R ADD     *            PRINT CARD BUFFER
        2524+ 1   55          + TR        PRINTCRD
        2525+10 2534 RETURN   + R ADD     PARAM        PARAM-1 IS THE RETURN ADDR      
        2526+ 5 2530          + SUB       ONE
        2527+13 2528          + STORE A   EXIT
        2528+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        2529+ 0    0 ZERO     + STOP      0000
        2530+ 0    1 ONE      + STOP      0001
        2531+ 0    2 TWO      + STOP      0002
        2532+ 0   68 D68      + STOP      0068
        2533+ 0  100 D100     + STOP      100
        2534+ 0    0 PARAM    + STOP      0000
        2535+ 0    0 DATA     + STOP      0000
        2536+ 0    0 FMT      + STOP      0000
        2537+ 0    0 COL      + STOP      0000
        2538+ 9 2552 BMPAD    + ADD       TWO
        2539+13 2541          + STORE A   EXIT
        2540+10 2542          + R ADD     BITMAPAD
        2541+ 1    0 EXIT     + TR        /   /
        2542+ 0 2544 BITMAPAD + STOP      BITMAP
        2543+     0             ORG       EVEN
        2544+     0  BITMAP     DEF       0              <blank>     0     <none>
        2545+   256             DEF       256               1        1       1        256          =  256   
        2546+   128             DEF       128               2        2       2        128          =  128   
        2547+    64             DEF       64                3        3       3         64          =   64   
        2548+    32             DEF       32                4        4       4         32          =   32   
        2549+    16             DEF       16                5        5       5         16          =   16   
        2550+     8             DEF       8                 6        6       6          8          =    8   
        2551+     4             DEF       4                 7        7       7          4          =    4   
        2552+     2  TWO        DEF       2                 8        8       8          2          =    2   
        2553+     1             DEF       1                 9        9       9          1          =    1   
        2554+   512             DEF       512               0       10       0        512          =  512   
        2555+  1024             DEF       1024              -       11       X       1024          = 1024   
        2556+  2048             DEF       2048              +       12       Y       2048          = 2048   
        2557+  2304             DEF       2304              A       13      Y-1        256+2048    = 2304   
        2558+  2176             DEF       2176              B       14      Y-2        128+2048    = 2176   
        2559+  2112             DEF       2112              C       15      Y-3         64+2048    = 2112   
        2560+  2080             DEF       2080              D       16      Y-4         32+2048    = 2080   
        2561+  2064             DEF       2064              E       17      Y-5         16+2048    = 2064   
        2562+  2056             DEF       2056              F       18      Y-6          8+2048    = 2056   
        2563+  2052             DEF       2052              G       19      Y-7          4+2048    = 2052   
        2564+  2050             DEF       2050              H       20      Y-8          2+2048    = 2050   
        2565+  2049             DEF       2049              I       21      Y-9          1+2048    = 2049   
        2566+  1280             DEF       1280              J       22      X-1        256+1024    = 1280   
        2567+  1152             DEF       1152              K       23      X-2        128+1024    = 1152   
        2568+  1088             DEF       1088              L       24      X-3         64+1024    = 1088   
        2569+  1056             DEF       1056              M       25      X-4         32+1024    = 1056   
        2570+  1040             DEF       1040              N       26      X-5         16+1024    = 1040   
        2571+  1032             DEF       1032              O       27      X-6          8+1024    = 1032   
        2572+  1028             DEF       1028              P       28      X-7          4+1024    = 1028   
        2573+  1026             DEF       1026              Q       29      X-8          2+1024    = 1026   
        2574+  1025             DEF       1025              R       30      X-9          1+1024    = 1025   
        2575+   640             DEF       640               S       31      0-2        128+512     = 640    
        2576+   576             DEF       576               T       32      0-3         64+512     = 576    
        2577+   544             DEF       544               U       33      0-4         32+512     = 544    
        2578+   528             DEF       528               V       34      0-5         16+512     = 528    
        2579+   520             DEF       520               W       35      0-6          8+512     = 520    
        2580+   516             DEF       516               X       36      0-7          4+512     = 516    
        2581+   514             DEF       514               Y       37      0-8          2+512     = 514    
        2582+   513             DEF       513               Z       38      0-9          1+512     = 513    
        2583+   578             DEF       578               ,       39      8-3-0        2+64+512  = 578    
        2584+   546             DEF       546               %       40      8-4-0        2+32+512  = 546    
        2585+  1090             DEF       1090              $       41      8-3-X        2+64+1024 = 1090   
        2586+  1058             DEF       1058              *       42      8-4-X        2+32+1024 = 1058   
        2587+  2114             DEF       2114              .       43      8-3-Y        2+64+2048 = 2114   
        2588+  2082             DEF       2082              #       44      8-4-Y        2+32+2048 = 2082   
        2589+   768             DEF       768               /       45      0-1          512+256   = 768    
        2590+    66             DEF       66                +       46      8-3          2+64      = 66     
        2591+    34             DEF       34                -       47      8-4          2+32      = 34    This is the non-minus-sign separator
        2592+ 9 2611 WRITECR2 + ADD       TWO          WRITE CARD (SEND CARD BUFFER TO CARD PUNCH DEVICE)
        2593+13 2596          + STORE A   WRP1         PARAM: ADDRESS OF BUFFER TO SEND TO PUNCH (MUST BE EVEN)
        2594+ 9 2610          + ADD       ONE
        2595+13 2607          + STORE A   EXIT         USE A WRITE-COPY LOOP TO PUNCH GIVEN CARD BUFFER AS PARAM 
        2596+10    0 WRP1     + R ADD     /   /
        2597+13 2602          + STORE A   BUFROW
        2598+26 1024          + WRITE     1024         PREPARE TO PUNCH CARD 
        2599+10 2602          + R ADD     BUFROW        
        2600+ 5 2612          + SUB       D48           
        2601+12 2609          + STORE     ENDLP        LOOP END VALUE
        2602-31    0   BUFROW - COPY      /   /        COPY WORD TO CARDPUNCH
        2603+10 2602          + R ADD     BUFROW       
        2604+ 5 2611          + SUB       TWO          INCR BUF ADDR
        2605+13 2602          + STORE A   BUFROW       
        2606+ 5 2609          + SUB       ENDLP        CHECK FOR END
        2607+ 4    0 EXIT     + TR 0      /   /        RETURN TO CALLER
        2608+ 1 2602          + TR        BUFROW
        2609+     0  ENDLP      DEF       0            LOOP END VALUE
        2610+     1  ONE        DEF       1
        2611+     2  TWO        DEF       2
        2612+    48  D48        DEF       48
        2614+ 9 2638 CLMEM    + ADD       TWO 
        2615+13 2620          + STORE A   P1           PARM: ADDR 
        2616+ 9 2637          + ADD       ONE          
        2617+13 2622          + STORE A   P2           PARM: LOCATION OF LEN=NUMBER OF HALF-WORDS TO CLEAR 
        2618+ 9 2637          + ADD       ONE          
        2619+13 2628          + STORE A   EXIT
        2620+10    0 P1       + R ADD     /   /        GET ADDR TO CLEAR
        2621+13 2631          + STORE A   MEM
        2622+10    0 P2       + R ADD     /   /        GET LEN ADDR
        2623+13 2624          + STORE A   P2A
        2624+10    0 P2A      + R ADD     /   /        GET LEN 
        2625+12 2639          + STORE     LEN
        2626+15 2636          + LOAD MQ   ZERO
        2627+10 2639 LOOP     + R ADD     LEN
        2628+ 4    0 EXIT     + TR 0      /   /
        2629+ 5 2637          + SUB       ONE
        2630+12 2639          + STORE     LEN
        2631+14    0 MEM      + STORE MQ  /   /        
        2632+10 2631          + R ADD     MEM
        2633+ 9 2637          + ADD       ONE
        2634+13 2631          + STORE A   MEM
        2635+ 1 2627          + TR        LOOP
        2636+ 0    0 ZERO     + STOP      0000
        2637+ 0    1 ONE      + STOP      0001         constant 1
        2638+ 0    2 TWO      + STOP      0002         constant 2
        2639+ 0    0 LEN      + STOP      0000
        2640+ 9 2672 MEMCOPY  + ADD       TWO 
        2641+13 2648          + STORE A   P1           PARM: SRCADDR 
        2642+ 9 2671          + ADD       ONE          
        2643+13 2650          + STORE A   P2           PARM: DESTADDR
        2644+ 9 2671          + ADD       ONE          
        2645+13 2652          + STORE A   P3           PARM: LEN: LOCATION OF LEN=NUMBER OF HALF-WORDS TO CLEAR
        2646+ 9 2671          + ADD       ONE          
        2647+13 2658          + STORE A   EXIT
        2648+10    0 P1       + R ADD     /   /        GET SOURCE ADDR 
        2649+13 2661          + STORE A   MEMS
        2650+10    0 P2       + R ADD     /   /        GET DESTINATION ADDR 
        2651+13 2662          + STORE A   MEMD
        2652+10    0 P3       + R ADD     /   /        GET LEN ADDR
        2653+13 2654          + STORE A   P3A
        2654+10    0 P3A      + R ADD     /   /        GET LEN           
        2655+12 2673          + STORE     LEN
        2656+15 2670          + LOAD MQ   ZERO
        2657+10 2673 LOOP     + R ADD     LEN
        2658+ 4    0 EXIT     + TR 0      /   /
        2659+ 5 2671          + SUB       ONE
        2660+12 2673          + STORE     LEN
        2661+10    0 MEMS     + R ADD     /   /        
        2662+12    0 MEMD     + STORE     /   /        
        2663+10 2661          + R ADD     MEMS
        2664+ 9 2671          + ADD       ONE
        2665+13 2661          + STORE A   MEMS
        2666+10 2662          + R ADD     MEMD
        2667+ 9 2671          + ADD       ONE
        2668+13 2662          + STORE A   MEMD
        2669+ 1 2657          + TR        LOOP
        2670+ 0    0 ZERO     + STOP      0000
        2671+ 0    1 ONE      + STOP      0001         constant 1
        2672+ 0    2 TWO      + STOP      0002         constant 2
        2673+ 0    0 LEN      + STOP      0000
        2674+15 2741 SRCHTBL  + LOAD MQ   ZERO
        2675+ 1 2679          + TR        START
        2676+15 2742 EQTBL    + LOAD MQ   ONE
        2677+ 1 2679          + TR        START
        2678+15 2743 READTBL  + LOAD MQ   TWO
        2679+ 9 2743 START    + ADD       TWO 
        2680+13 2687          + STORE A   P1           PARM: ADDR OF TABLE
        2681+ 9 2742          + ADD       ONE          
        2682+13 2689          + STORE A   P2           PARM: LEN OF TABLE
        2683+ 9 2742          + ADD       ONE          
        2684+13 2694          + STORE A   P3           PARM: VAL TO FIND
        2685+ 9 2742          + ADD       ONE          
        2686+13 2735          + STORE A   EXIT
        2687+10    0 P1       + R ADD     /   /        GET ADDR OF TABLE
        2688+13 2738          + STORE A   TBL
        2689+10    0 P2       + R ADD     /   /        GET ADDR OF LEN OF TABLE/ENTRY ON TABLE
        2690+13 2691          + STORE A   P2A
        2691+10    0 P2A      + R ADD     /   /        DERREFERENCE -> ACC=LEN/ENTRY (1..LEN)
        2692+12 2736          + STORE     N
        2693+ 4 2735          + TR 0      EXIT         EXIT, CANNOT READ/STORE ON ENTRY 0, SEARCH ON EMPTY TABLE
        2694+10    0 P3       + R ADD     /   /        GET ADDR OF VAL TO FIND
        2695+13 2711          + STORE A   WRVAL
        2696+13 2697          + STORE A   P3A
        2697+10    0 P3A      + R ADD     /   /        DERREFERENCE -> ACC=VAL
        2698+12 2737          + STORE     VAL
        2699+14 2740          + STORE MQ  TEMP         JUMP TABLE DISPATCH
        2700+10 2740          + R ADD     TEMP
        2701+ 4 2716          + TR 0      LOOP0        TR TO SEARCH TABLE
        2702+10 2736          + R ADD     N            SUB ONE AS FIRST ENTRY ON TABLE IS "1"
        2703+ 5 2742          + SUB       ONE          
        2704+ 9 2738          + ADD       TBL          TABLE BASE ADDR
        2705+13 2714          + STORE A   WRTBL
        2706+13 2710          + STORE A   RDTBL2
        2707+10 2740          + R ADD     TEMP
        2708+ 5 2742          + SUB       ONE
        2709+ 4 2713          + TR 0      STORETBL 
        2710+10    0 RDTBL2   + R ADD     /   /        VAL=TBL[ENT]
        2711+12    0 WRVAL    + STORE     /   /
        2712+ 1 2735          + TR        EXIT
        2713+10 2737 STORETBL + R ADD     VAL          TBL[ENT]=VAL
        2714+12    0 WRTBL    + STORE     /   /    
        2715+ 1 2735          + TR        EXIT
        2716+10 2738 LOOP0    + R ADD     TBL
        2717+13 2723          + STORE A   RDTBL
        2718+10 2723          + R ADD     RDTBL
        2719+12 2739          + STORE     TBL0
        2720+ 9 2736          + ADD       N
        2721+12 2740          + STORE     TEMP         THE END ADDR OF TABLE
        2722+10 2737 LOOP     + R ADD     VAL          ACC=THE SEARCHED VALUE
        2723+ 5    0 RDTBL    + SUB       /   /    
        2724+ 2 2725          + TR OV     OVOK         CLEAR OV JUST IN CASE
        2725+ 4 2732 OVOK     + TR 0      FOUND        TR IF VAL FOUND IN ENTRY N
        2726+10 2723          + R ADD     RDTBL
        2727+ 9 2742          + ADD       ONE
        2728+13 2723          + STORE A   RDTBL
        2729+ 5 2740          + SUB       TEMP
        2730+ 4 2735          + TR 0      EXIT         NOT FOUND -> RETURN ZERO
        2731+ 1 2722          + TR        LOOP
        2732+10 2723 FOUND    + R ADD     RDTBL        RETURN ENTRY FOUND
        2733+ 5 2739          + SUB       TBL0
        2734+ 9 2742          + ADD       ONE
        2735+ 1    0 EXIT     + TR        /   /
        2736+ 0    0 N        + STOP      0000
        2737+ 0    0 VAL      + STOP      0000
        2738+ 0    0 TBL      + STOP      0000
        2739+ 0    0 TBL0     + STOP      0000
        2740+ 0    0 TEMP     + STOP      0000
        2741+ 0    0 ZERO     + STOP      0000
        2742+ 0    1 ONE      + STOP      0001         constant 1
        2743+ 0    2 TWO      + STOP      0002         constant 2
        2744+ 9 2817 RWDRUM   + ADD       TWO 
        2745+13 2754          + STORE A   PDR1         PARM1: DRUM INSTR: READ/WRITE 0128  0129  0130  0131
        2746+ 9 2816          + ADD       ONE          
        2747+13 2756          + STORE A   PDR2         PARM2: DRUM ADDRESS (0..4094)
        2748+ 9 2816          + ADD       ONE          
        2749+13 2758          + STORE A   PDR3         PARM3: BUF START ADDRESS
        2750+ 9 2816          + ADD       ONE          
        2751+13 2760          + STORE A   PDR4         PARM4: LEN: NUMBER OF HALF-WORDS (MUST BE EVEN)
        2752+ 9 2816          + ADD       ONE          
        2753+13 2814          + STORE A   EXIT               
        2754+10    0 PDR1     + R ADD     /   /        GET DRUM INSTR
        2755+12 2762          + STORE     DRIO
        2756+10    0 PDR2     + R ADD     /   /        GET DRUM ADDR
        2757+13 2763          + STORE A   DRADDR
        2758+10    0 PDR3     + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        2759+13 2801          + STORE A   RWCOPY    
        2760+10    0 PDR4     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        2761+12 2818          + STORE     LEN
        2762+ 0    0 DRIO     + STOP      /   /        INSTR: READ/WRITE 0128  0129  0130  0131
        2763+29    0 DRADDR   + SET DR    /   /
        2764+ 1 2797          + TR        LOOP
        2765+ 9 2817 RDTAPE   + ADD       TWO 
        2766+13 2773          + STORE A   PR1          PARM1: TAPE ADDRESS
        2767+ 9 2816          + ADD       ONE          
        2768+13 2775          + STORE A   PR2          PARM2: BUF START ADDRESS
        2769+ 9 2816          + ADD       ONE          
        2770+13 2814          + STORE A   EXIT
        2771+ 2 2772          + TR OV     CLOV1        CLEAR OV THAT MAY HAVE BEEN SET
        2772+ 8    0    CLOV1 + NOOP      0000
        2773+10    0 PR1      + R ADD     /   /        GET TAPE ADDR
        2774+13 2777          + STORE A   RTAPAD       TAPE UNITS: 0256  0257  0258  0259
        2775+10    0 PR2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        2776+13 2801          + STORE A   RWCOPY    
        2777+24    0 RTAPAD   + READ      /   /
        2778+10 2815          + R ADD     ZERO
        2779+ 1 2799          + TR        LOOP1
        2780+ 9 2817 WRTAPE   + ADD       TWO 
        2781+13 2788          + STORE A   PW1          PARM1: TAPE ADDRESS
        2782+ 9 2816          + ADD       ONE          
        2783+13 2790          + STORE A   PW2          PARM2: BUF START ADDRESS
        2784+ 9 2816          + ADD       ONE          
        2785+13 2792          + STORE A   PW3          PARM3: BUF LEN
        2786+ 9 2816          + ADD       ONE          
        2787+13 2814          + STORE A   EXIT
        2788+10    0 PW1      + R ADD     /   /        GET TAPE ADDR
        2789+13 2796          + STORE A   WTAPAD       TAPE UNITS: 0256  0257  0258  0259
        2790+10    0 PW2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        2791+13 2801          + STORE A   RWCOPY    
        2792+10    0 PW3      + R ADD     /   /        GET ADDR OF LEN 
        2793+13 2794          + STORE A   PW3A
        2794+10    0 PW3A     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        2795+12 2818          + STORE     LEN
        2796+26    0 WTAPAD   + WRITE     /   /        PREPARE TO WRITE ON TAPE
        2797+10 2818 LOOP     + R ADD     LEN
        2798+ 4 2813          + TR 0      RWOK
        2799+ 5 2817 LOOP1    + SUB       TWO
        2800+12 2818          + STORE     LEN
        2801-31    0 RWCOPY   - COPY      /   /        WRITE BUFFER TO TAPE
        2802+ 1 2805          + TR        GO 
        2803+ 1 2809          + TR        EOF          END OF FILE
        2804+ 1 2811          + TR        EOR          END OF RECORD
        2805+10 2801 GO       + R ADD     RWCOPY
        2806+ 5 2817          + SUB       TWO
        2807+13 2801          + STORE A   RWCOPY
        2808+ 1 2797          + TR        LOOP
        2809+10 2816 EOF      + R ADD     ONE          SET OV FLAG TO SIGNAL END OF FILE CONDITION
        2810+22   36          + A LEFT    36
        2811+ 6 2818 EOR      + R SUB     LEN          RETURN NUMBER OF HALF-WORDS READ
        2812+ 5 2817          + SUB       TWO
        2813+26 2052 RWOK     + WRITE     2052         INSURE THAT MQ NOT IN USE            
        2814+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        2815+ 0    0 ZERO     + STOP      0000
        2816+ 0    1 ONE      + STOP      0001         
        2817+ 0    2 TWO      + STOP      0002         
        2818+     0  LEN        RES       1
        2820+ 9 2852 CHKSUM   + ADD       TWO          CALC CHEKSUM 
        2821+13 2824          + STORE A   CKP1
        2822+ 9 2851          + ADD       ONE
        2823+13 2845          + STORE A   CHKSUMEX     RETURN ADDR
        2824+10    0 CKP1     + R ADD     /   /        GET CARD IMAGE ADDRESS
        2825+13 2831          + STORE A   RDDATA
        2826+ 9 2853          + ADD       D46
        2827+13 2842          + STORE A   RDEND
        2828+10 2850          + R ADD     ZERO
        2829-12 2848          - STORE     SUM
        2830-12 2846          - STORE     DATA
        2831+10    0 RDDATA   + R ADD     /   /
        2832+12 2847          + STORE     DATA2
        2833-10 2846          - R ADD     DATA
        2834- 9 2848          - ADD       SUM
        2835-12 2848          - STORE     SUM
        2836+10 2831          + R ADD     RDDATA
        2837+ 9 2851          + ADD       ONE
        2838+13 2831          + STORE A   RDDATA
        2839+ 5 2842          + SUB       RDEND
        2840+ 4 2843          + TR 0      CHKSUM2
        2841+ 1 2831          + TR        RDDATA
        2842+10    0 RDEND    + R ADD     0000         
        2843-10 2848 CHKSUM2  - R ADD     SUM
        2844- 9 2848          - ADD       SUM          ADD TWICE -> CHKSUM IS DOUBLED -> CHKSUM IS SHIFTED TO LEFT ONE BIT -> RIGHTMOST BIT IS ZERO
        2845+ 1    0 CHKSUMEX + TR        /   /
        2846+     0  DATA       DEF       0            CHECKSUM CALCULATION WORDS
        2847+     0  DATA2      DEF       0
        2848+     0  SUM        DEF       0            
        2849+     0             DEF       0
        2850+     0  ZERO       DEF       0
        2851+     1  ONE        DEF       1
        2852+     2  TWO        DEF       2
        2853+    46  D46        DEF       46
        2854+ 9 3086 WRIBREL  + ADD       TWO          CHECK IF CURRENT CARD IN MEMORY IS TYPE/SYMBOL GIVEN AS PARAM, 
        2855+13 2868          + STORE A   CHKP1        LOC OF DATA TO ADD IS IN SEQUENCE WITH PREVIOUS ONES, AND CARD HAS ROOM FOR DATA.
        2856+ 9 3085          + ADD       ONE          IF NOT, FLUSH CURRENT CARD AND CREATE A NEW ONE, THEN PLACE THE DATA.
        2857+13 2870          + STORE A   CHKP2        WHEN FLUSHING THE CARD, CALL WRITE ROUTINE DEFINED
        2858+ 9 3085          + ADD       ONE
        2859+13 2874          + STORE A   CHKP3
        2860+ 9 3085          + ADD       ONE
        2861+13 2878          + STORE A   CHKP4
        2862+ 9 3085          + ADD       ONE
        2863+13 2880          + STORE A   CHKP5
        2864+ 9 3085          + ADD       ONE
        2865+13 2884          + STORE A   CHKP6
        2866+ 9 3085          + ADD       ONE
        2867+13 2990          + STORE A   CHKEXIT
        2868+10    0 CHKP1    + R ADD     /   /
        2869+12 3076          + STORE     CRDTY        PARAM: BIN CARD TYPE REQUITED: -01 -> CONTROL CARD, -00 -> MC INSTR CARD, 
        2870+10    0 CHKP2    + R ADD     /   /                                       +01 -> FLUSH CURRENT CARD (NO MORE PARAMS)
        2871+13 2872          + STORE A   CHKP2A                                      +02 -> SET WRITE CARD ROUTINE TO BE CALLED IN NEXT PARAM 
        2872+10    0 CHKP2A   + R ADD     /   /                                              RETURNS IN ACC THE ADDR OF BINCARD BUFFER TO BE WRITTEN
        2873+12 3077          + STORE     CRDSY        
        2874+10    0 CHKP3    + R ADD     /   /
        2875+13 2876          + STORE A   CHKP3A
        2876+10    0 CHKP3A   + R ADD     /   /
        2877+12 3078          + STORE     CRDLOC       PARAM: LOCATION 0..4095 
        2878+10    0 CHKP4    + R ADD     /   /
        2879+12 3079          + STORE     CRDDATY      PARAM: DATA TYPE: =0 -> DATA1=DATA TO STORE, DATA2=INDEX TAG
        2880+10    0 CHKP5    + R ADD     /   /                          =1 -> DATA1/DATA2=FULL WORD TO STORE
        2881+13 2882          + STORE A   CHKP5A
        2882+10    0 CHKP5A   + R ADD     /   /
        2883+12 3082          + STORE     CRDDATA      PARAM: DATA 
        2884+10    0 CHKP6    + R ADD     /   /        
        2885+13 2886          + STORE A   CHKP6A
        2886+10    0 CHKP6A   + R ADD     /   /
        2887+12 3083          + STORE     CRDDATA2     PARAM: DATA2 (RIGHT HALF-WORD / INDEX TAG)
        2888+10 3076          + R ADD     CRDTY        
        2889+ 5 3085          + SUB       ONE
        2890+ 4 2991          + TR 0      CHKFLSHR     IF CRDTY=1 -> JUST FLUSH THE CURRENT CARD AND RETURN
        2891+ 5 3085          + SUB       ONE
        2892+ 4 3000          + TR 0      CHKWR        IF CRDTY=2 -> SET WRITE CARD ROUTINE TO BE CALLED WHEN FLUSHING THE CURRENT CARD AND RETURN
        2893+10 3068          + R ADD     BINCRD44     CODE + ORIGIN IN CARD IN MEMORY. 
        2894+13 3080          + STORE A   CRDORG
        2895+ 3 2924          + TR +      CHKNEWC      IF >=0 -> CREATE A FRESH NEW CARD 
        2896+23   12          + A RIGHT   0012         GET CODE ON CURRENT CARD BEING BUILD IE MEM
        2897+23   18          + A RIGHT   0018         CLEAR RIGHT ACC HALF-WORD
        2898+22   18          + A LEFT    0018
        2899+ 5 3076          + SUB       CRDTY
        2900+ 4 2902          + TR 0      CHK1         SAME TYPE, TR TO CONTINUE
        2901+ 1 2922          + TR        CHKFLSH      NOT SAME TYPE, TR TO FLUSH CURRENT CARD 
        2902+10 3069 CHK1     + R ADD     BINCRD45     CURRENT CARD SYMBOL
        2903+ 5 3077          + SUB       CRDSY
        2904+ 4 2906          + TR 0      CHK2         SAME TOP SYMBOL, TR TO CONTINUE
        2905+ 1 2922          + TR        CHKFLSH      NOT SAME SYMBOL, TR TO FLUSH CURRENT CARD 
        2906+10 3066 CHK2     + R ADD     BINCRD42     COUNT IN CARD
        2907+ 5 3089          + SUB       D36
        2908+ 4 2922          + TR 0      CHKFLSH      CARD FULL, TR TO FLUSH CURRENT CARD 
        2909+10 3080          + R ADD     CRDORG
        2910+ 9 3066          + ADD       BINCRD42     ACC=ORIGIN + COUNT = NEXT CONSECUTIVE REL LOCATION ON BIN CARD
        2911+ 5 3078          + SUB       CRDLOC       
        2912+ 4 2935          + TR 0      CHKADD       IF ORIGIN+COUNT=LOC -> ADD DATA TO CURRENT CARD IN MEMORY, AT NEXT CONSECUTIVE LOCATION LOC
        2913+ 3 2922          + TR +      CHKFLSH      IF ORIGIN+COUNT>LOC -> LOC IS LESS THAN LAST LOC ADDED -> TR TO FLUSH AND START A NEW CARD AT NEW LOC
        2914+10 3078          + R ADD     CRDLOC
        2915+ 5 3080          + SUB       CRDORG       ACC=LOC - ORIGIN = POSITION IN CARD 
        2916+12 3081          + STORE     CRDN
        2917+ 5 3089          + SUB       D36          
        2918+ 3 2922          + TR +      CHKFLSH      IF POSITION IN CARD >= 36 -> LOC DOES NOT FIT IN CURRENT CARD -> TR TO FLUSH
        2919+10 3081          + R ADD     CRDN         ELSE -> POSITION IN CARD < 36 -> LOC FITS IN CURRENT CARD
        2920+12 3066          + STORE     BINCRD42     ADJUST COUNT
        2921+ 1 2935          + TR        CHKADD       TR TO ADD DATA TO CURRENT CARD IN MEMORY
        2922+10 2922 CHKFLSH  + R ADD     *            
        2923+ 1 3011          + TR        FLUSHCRD 
        2924+10 2924 CHKNEWC  + R ADD     *            NEW CARD: CLEAR CARD BUFFER IN MEM
        2925+ 1   91          + TR        CLMEM        BINCARD
        2926+ 0 3024          + STOP      BINCARD
        2927+ 0 3090          + STOP      D48
        2928+10 3076          + R ADD     CRDTY        CODE   = -01 / -00 
        2929+22   12          + A LEFT    0012         PLACE AS OP
        2930+ 5 3078          + SUB       CRDLOC       ORIGIN = CURRENT LOC
        2931+12 3068          + STORE     BINCRD44     STORE CODE + ORIGIN IN CARD IN MEMORY. 
        2932+13 3080          + STORE A   CRDORG
        2933+10 3077          + R ADD     CRDSY        SYMBOL 
        2934+12 3069          + STORE     BINCRD45     CURRENT CARD SYMBOL
        2935+10 3078 CHKADD   + R ADD     CRDLOC       COMPUTE WHERE TO STORE THE DATA
        2936+ 5 3080          + SUB       CRDORG       ADDR = BINCRD ADDRESS + (LOC - ORIGIN)
        2937+ 9 3010          + ADD       BINCRDAD 
        2938+13 2940          + STORE A   CHKSTO1
        2939+10 3082          + R ADD     CRDDATA      STORE DATA
        2940+12    0 CHKSTO1  + STORE     /   /
        2941+10 3079          + R ADD     CRDDATY      PARAM: DATA TYPE: =0 -> DATA1=DATA TO STORE, DATA2=INDEX TAG
        2942+ 4 2952          + TR 0      CHKIDX                         =1 -> DATA1/DATA2=FULL WORD TO STORE
        2943+10 2940          + R ADD     CHKSTO1      STORE A FULL WORD
        2944+ 9 3085          + ADD       ONE       
        2945+13 2947          + STORE A   CHKSTO2
        2946+10 3083          + R ADD     CRDDATA2     STORE DATA2
        2947+12    0 CHKSTO2  + STORE     /   /
        2948+10 3066          + R ADD     BINCRD42     COUNT IN CARD
        2949+ 9 3086          + ADD       TWO
        2950+12 3066          + STORE     BINCRD42     
        2951+ 1 2990          + TR        CHKEXIT
        2952+10 3083 CHKIDX   + R ADD     CRDDATA2     STORE DATA HALF-WORD + DATA2 INDEX
        2953+ 4 2987          + TR 0      CHK20
        2954+10 3078          + R ADD     CRDLOC       COMPUTE WHERE TO STORE THE DATA
        2955+ 5 3080          + SUB       CRDORG       IN INDICES BLOCK
        2956+12 3081          + STORE     CRDN
        2957+10 3010          + R ADD     BINCRDAD     SET START OD INICES ADDR
        2958+ 9 3089          + ADD       D36
        2959+13 2979          + STORE A   CHKSTO3A
        2960+13 2986          + STORE A   CHKSTO3B
        2961+10 3084          + R ADD     ZERO
        2962-12 3072          - STORE     DATA
        2963-12 3074          - STORE     SUM
        2964+10 3081 CHK10    + R ADD     CRDN         INDICES ADDR += (LOC - ORIGIN) DIV 6
        2965+ 5 3088          + SUB       D6
        2966+ 3 2968          + TR +      CHK11
        2967+ 1 2974          + TR        CHK12
        2968+12 3081 CHK11    + STORE     CRDN
        2969+10 2979          + R ADD     CHKSTO3A
        2970+ 9 3085          + ADD       ONE
        2971+13 2979          + STORE A   CHKSTO3A
        2972+13 2986          + STORE A   CHKSTO3B
        2973+ 1 2964          + TR        CHK10
        2974+10 3081 CHK12    + R ADD     CRDN         SHIFT = (N+1)*3
        2975+ 9 3081          + ADD       CRDN
        2976+ 9 3081          + ADD       CRDN
        2977+ 9 3087          + ADD       D3
        2978+13 2982          + STORE A   CHKSHF
        2979+10    0 CHKSTO3A + R ADD     /   /
        2980+12 3073          + STORE     DATA2
        2981+10 3083          + R ADD     CRDDATA2     SHIFT RIGHT AND STORE AT INDICES ADDR
        2982+23    0 CHKSHF   + A RIGHT   /   /
        2983- 9 3072          - ADD       DATA
        2984-12 3074          - STORE     SUM
        2985+10 3075          + R ADD     SUM2
        2986+12    0 CHKSTO3B + STORE     /   /
        2987+10 3066 CHK20    + R ADD     BINCRD42     COUNT IN CARD
        2988+ 9 3085          + ADD       ONE
        2989+12 3066          + STORE     BINCRD42     
        2990+ 1    0 CHKEXIT  + TR        /   /
        2991+10 2991 CHKFLSHR + R ADD     *            JUST FLUSH CURRENT CARD AND RETURN
        2992+ 1 3011          + TR        FLUSHCRD
        2993+10 2993          + R ADD     *            CLEAR CARD BUFFER IN MEM
        2994+ 1   91          + TR        CLMEM        BINCARD
        2995+ 0 3024          + STOP      BINCARD
        2996+ 0 3090          + STOP      D48
        2997+10 2870          + R ADD     CHKP2        SECOND PARAM HAS THE RETURN ADDR
        2998+13 2999          + STORE A   FLSHEX       
        2999+ 1    0 FLSHEX   + TR        /   /        RETURN TO CALLER
        3000+10 2872 CHKWR    + R ADD     CHKP2A       SECOND PARAM HAS THE ADDR OF BIN CARD WRITE ROUTINE TO BE CALLED BY FLUSH (INSTEAD THE TOP SYMBOL)
        3001+13 3020          + STORE A   WRCRD
        3002+10 2874          + R ADD     CHKP3        THIRD PARAM HAS THE RETURN ADDR 
        3003+13 3009          + STORE A   CHKWREX
        3004+10 3004          + R ADD     *            CLEAR CARD BUFFER IN MEM
        3005+ 1   91          + TR        CLMEM        BINCARD
        3006+ 0 3024          + STOP      BINCARD
        3007+ 0 3090          + STOP      D48
        3008+10 3010          + R ADD     BINCRDAD     RETURN IN ACC THE ADDR OF BINCARD BUFFER TO BE WRITTEN BY WRITE ROUTINE  
        3009+ 1    0 CHKWREX  + TR        /   /        RETURN TO CALLER
        3010+ 0 3024 BINCRDAD + STOP      BINCARD      SOURCE ADDR
        3011+ 9 3086 FLUSHCRD + ADD       TWO          PUNCH PACT CARD IN CARD BUFFER
        3012+13 3023          + STORE A   FLUSHEX
        3013+10 3066          + R ADD     BINCRD42     GET COUNT
        3014+ 4 3023          + TR 0      FLUSHEX      IF =0 -> THE CARD IS EMPTY -> EXIT WITHOUT PUNCHING
        3015+10 3015          + R ADD     *
        3016+ 1   93          + TR        CHKSUM       COMPUTE CHECKSUM OF CARD ...
        3017+ 0 3024          + STOP      BINCARD      
        3018-12 3070          - STORE     BINCRD46     ... AND STORE IT AT LOCATION 46 AND 47
        3019+10 3019          + R ADD     *
        3020+ 1    0 WRCRD    + TR        /   /        CALL WRITE CARD ROUTINE
        3021+10 3084          + R ADD     ZERO
        3022+12 3066          + STORE     BINCRD42     CLEAR COUNT 
        3023+ 1    0 FLUSHEX  + TR        /   /
        3024+     0  BINCARD    RES       42           BUFFER FOR PACT RELATIVE BINARY CARD INSTR 
        3066+     0  BINCRD42   DEF       0            COUNT OF INSTR IN CARD
        3067+     0             DEF       0
        3068+     0  BINCRD44   DEF       0            CODE + ORIGIN IN CARD
        3069+     0  BINCRD45   DEF       0            SYMBOL 
        3070+     0  BINCRD46   DEF       0            CHECKSUM
        3071+     0             DEF       0            BINCARD TAKES 48 HALF-WORDS IN TOTAL
        3072+     0  DATA       DEF       0            
        3073+     0  DATA2      DEF       0
        3074+     0  SUM        DEF       0            
        3075+     0  SUM2       DEF       0
        3076+     0  CRDTY      DEF       0            BIN CARD TYPE REQUITED: -01 -> CONTROL CARD, -00 -> MC INSTR CARD
        3077+     0  CRDSY      DEF       0            BIN CARD SYMBOL REQUITED
        3078+     0  CRDLOC     DEF       0            LOCATION 0..4095 
        3079+     0  CRDDATY    DEF       0            DATA TYPE: =0 -> DATA1=DATA TO STORE, DATA2=INDEX TAG
        3080+     0  CRDORG     DEF       0
        3081+     0  CRDN       DEF       0
        3082+     0  CRDDATA    DEF       0
        3083+     0  CRDDATA2   DEF       0
        3084+     0  ZERO       DEF       0
        3085+     1  ONE        DEF       1
        3086+     2  TWO        DEF       2
        3087+     3  D3         DEF       3
        3088+     6  D6         DEF       6
        3089+    36  D36        DEF       36
        3090+    48  D48        DEF       48
          48-     0  ROUTINE INIT
          49+ 1  152 ENTRY POINT
          50-     0  ROUTINE CLRBUF
          51+ 1 2126 ENTRY POINT
          52-     0  ROUTINE PRTNLINE
          53+ 1 2456 ENTRY POINT
          54-     0  ROUTINE PRINTCRD
          55+ 1 2134 ENTRY POINT
          56-     0  ROUTINE PRTALF
          57+ 1 2218 ENTRY POINT
          58-     0  ROUTINE PRTINT
          59+ 1 2296 ENTRY POINT
          60-     0  ROUTINE PRTCHR
          61+ 1 2338 ENTRY POINT
          62-     0  ROUTINE RWDRUM
          63+ 1 2744 ENTRY POINT
          64-     0  ROUTINE RDTAPE
          65+ 1 2765 ENTRY POINT
          66-     0  ROUTINE SRCHTBL
          67+ 1 2674 ENTRY POINT
          68-     0  ROUTINE MEMCOPY
          69+ 1 2640 ENTRY POINT
          70-     0  ROUTINE WRIBREL
          71+ 1 2854 ENTRY POINT
          72-     0  ROUTINE WRITECRD
          73+ 1 2132 ENTRY POINT
          74-     0  ROUTINE WRITECR2
          75+ 1 2592 ENTRY POINT
          76-     0  ROUTINE READCRD
          77+ 1 2130 ENTRY POINT
          78-     0  ROUTINE PRTSTR
          79+ 1 2195 ENTRY POINT
          80-     0  ROUTINE PRTOCT
          81+ 1 2262 ENTRY POINT
          82-     0  ROUTINE BMPAD
          83+ 1 2538 ENTRY POINT
          84-     0  ROUTINE EQTBL
          85+ 1 2676 ENTRY POINT
          86-     0  ROUTINE READTBL
          87+ 1 2678 ENTRY POINT
          88-     0  ROUTINE WRTAPE
          89+ 1 2780 ENTRY POINT
          90-     0  ROUTINE CLMEM
          91+ 1 2614 ENTRY POINT
          92-     0  ROUTINE CHKSUM
          93+ 1 2820 ENTRY POINT
        4094+    48  REGION ORIGIN TABLE LOCATION
        4095+   152  INITIAL REGION
           0+ 1  152          + TR        INIT         PROGRAM START
