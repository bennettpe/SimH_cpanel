        DEC
        NNNN OP ADDR COMMENTS
          94+10   94 INIT     + R ADD     *            
          95+ 1   63          + TR        PRTNLINE     
          96+ 0  101          + STOP      0101         STRINGZ AT COL 1
          97+ 0 2299          + STOP      MSGSTART     "PUNCH ABS TEXT CARDS"
          98+ 0    6          + STOP      0006         END OF LINE. 
          99+10 2286          + R ADD     ZERO         CLEAR CC RECORD
         100+12  764          + STORE     REGION     
         101+12  765          + STORE     STEP       
         102+12  766          + STORE     OP         
         103+12  767          + STORE     FACT       
         104+12  768          + STORE     S1         
         105+12  769          + STORE     S2         
         106+12  770          + STORE     QR         
         107+12  771          + STORE     QF         
         108-12  772          - STORE     NUM        
         109+12  774          + STORE     CLUE       
         110+12  775          + STORE     STEPN      
         111+12  776          + STORE     FACTN      
         112+12  777          + STORE     FACTREG    
         113+12  778          + STORE     S1N        
         114+12  779          + STORE     S2N        
         115+12  780          + STORE     D1N        
         116+12  781          + STORE     D2N        
         117+12  782          + STORE     NINST      
         118+12  783          + STORE     NINCR 
         119+10  984          + R ADD     CCLEN        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         120+10 1040          + R ADD     LCLEN        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         121+10 1039          + R ADD     DUMMY        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         122+10 1041          + R ADD     DUMMY2       NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         123+10 1053          + R ADD     DUMMY3       NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         124+10  985          + R ADD     MAXNINST     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         125+10 1043          + R ADD     NVARS        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         126+10 1047          + R ADD     I.EXT        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         127+10 1048          + R ADD     P.EXT        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         128+10 1049          + R ADD     IL.EXT       NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         129+10  129          + R ADD     *            TO CONSTRUCT REGION ORIGIN TABLE/CARDS
         130+ 1   67          + TR        RWDRUM       READ TSYMBREF TABLE (SYMBOLS USED BY ALL REGIONS) FROM DRUM 
         131+24  128          + READ      0128         DRUM INSTR
         132+ 0    0          + STOP      0000         DRUM ADDR 
         133+ 0 1056          + STOP      MAXNSYMB     ADDR OF START OF TABLES
         134+ 0 1202          + STOP      1202         MAXNSYMB (1 HALF-WORD) + NSYMBS (1 HW) 
         135+10  135          + R ADD     *            TO CONSTRUCT REGION ORIGIN INITIAL CARDS
         136+ 1   67          + TR        RWDRUM       READ RELNUM0, NVARS, HIVRELAD, HINRELAD, HITRELAD, HIIRELAD, HIPRELAD AND HISIZE
         137+24  130          + READ      0130         DRUM INSTR
         138+ 0    0          + STOP      0000         DRUM ADDR 
         139+ 0 1042          + STOP      RELNUM0      ADDR OF DATA TO SAVE
         140+ 0   12          + STOP      0012         12 HALF WORDS
         141+10  141          + R ADD     *            TO CONSTRUCT REGION ORIGIN INITIAL CARDS
         142+ 1   67          + TR        RWDRUM       READ MAXNNUMS, NNUMS. KEEP TNUMPOOL IN DRUM
         143+24  130          + READ      0130         DRUM INSTR
         144+ 0   16          + STOP      0016         DRUM ADDR 
         145+ 0 1054          + STOP      MAXNNUMS     ADDR OF DATA TO SAVE
         146+ 0    2          + STOP      0002         MAXNNUMS (1 HALF-WORD) + NNUMS (1 HW) 
         147+28  259          + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE) TO BE USED 
         148+10  148          + R ADD     *            MAKE REGION ORIGIN TABLE = RUN TIME COMPILED PROG MEMORY MAP
         149+ 1  175          + TR        MAKROTBL
         150+10  150          + R ADD     *            PUNCH PROGRAM START
         151+ 1  225          + TR        PCHSTART
         152+10  152          + R ADD     *            PUNCH REGION ORIGIN TABLE
         153+ 1  271          + TR        PCHROTBL
         154+10  154          + R ADD     *            PUNCH PROGRAM
         155+ 1  473          + TR        PCHPROG
         156+10  156          + R ADD     *            PUNCH LIBS
         157+ 1  386          + TR        LIBPCH
         158+10  158          + R ADD     *            PUNCH NUMBER CONSTANTS CARDS (REGION N)
         159+ 1  336          + TR        PCHNUMS
         160+10  160          + R ADD     *
         161+ 1   63          + TR        PRTNLINE     
         162+ 0  101          + STOP      0101         STRINGZ AT COL 1
         163+ 0 2307          + STOP      MSGEPCH      "ABS PROG PUNCHED"
         164+ 0    6          + STOP      0006         END OF LINE. 
         165+ 0 4095          + STOP      4095
         166+ 9 2288 ADDEXT   + ADD       TWO          HI=HI - MAKE EVEN(SYMBOL EXTENT IN MQ)
         167+13  174          + STORE A   ADDEXTEX     RESULT IN ACC
         168+14 2274          + STORE MQ  EXT
         169+10 2275          + R ADD     HI           HERE  OP>0 -> SET ABSOLUTE LOCATION OF SYMBOL = HI - OP.EXT
         170+ 5 2274          + SUB       EXT          HI=HI - MAKE EVEN(SYMBOL EXTENT+1)
         171+23   19          + A RIGHT   0019      
         172+22   19          + A LEFT    0019
         173+13 2275          + STORE A   HI           
         174+ 1    0 ADDEXTEX + TR        /   /        RETURN
         175+ 9 2288 MAKROTBL + ADD       TWO          MAKE REGION ORIGIN TABLE: THE RUN TIME COMPILED PROG MEMORY MAP
         176+13  224          + STORE A   MAKROEX
         177+10 1044          + R ADD     V.EXT
         178+ 9 1052          + ADD       LR.EXT       ADD RESERVED SPACE FOR LOADER TO PREVENT VARS LOC BEING OVER LOADER
         179+12 1044          + STORE     V.EXT
         180+10 2298          + R ADD     D4094
         181+12 2275          + STORE     HI
         182+15 1044          + LOAD MQ   V.EXT        ADD VAR REGION
         183+10  183          + R ADD     *
         184+ 1  166          + TR        ADDEXT
         185+12 2265          + STORE     V.ORG        SET THE RUN-TIME LOCATION OF VARS
         186+15 1046          + LOAD MQ   T.EXT        ADD TEMP STORAGE REGION (FOR PACT PROGRAM USE)
         187+10  187          + R ADD     *
         188+ 1  166          + TR        ADDEXT
         189+12 2267          + STORE     T.ORG        SET THE RUN-TIME LOCATION OF VARS
         190+15 1045          + LOAD MQ   N.EXT        ADD NUMBERS REGION 
         191+10  191          + R ADD     *
         192+ 1  166          + TR        ADDEXT
         193+12 2269          + STORE     N.ORG        SET THE RUN-TIME LOCATION OF VARS
         194+10 1051          + R ADD     INIREG       ABS LOCATION OF 1ST REGION OF PACT PRG   <- set by stage 65 Punch loader
         195+13 1658          + STORE A   TSYMBEXT     1ST REGION IS THE ONLY ONE THAT IS PLACED ON LOW MEM, JUST AFTER RO TABLE
         196+10 2287          + R ADD     ONE          1ST REGION (=1ST SYMBOL) ALREADY SET, SO N STARTS IN 1 (INSTEAD OF 0)
         197+12 2272          + STORE     N            LOOP ON TSYMBEXT TABLE CONVERTING EXT VALUE IN ABS LOCATION OF REGION
         198+12 2274          + STORE     EXT          
         199+10 2258          + R ADD     TSYMBAD
         200+ 9 1056          + ADD       MAXNSYMB
         201+ 9 2272          + ADD       N
         202+13  207          + STORE A   SYEXT1A
         203+13  215          + STORE A   SYEXT2A
         204+10 2272 MAKROLOO + R ADD     N
         205+ 5 1057          + SUB       NSYMBS
         206+ 4  224          + TR 0      MAKROEX      EXIT LOOP, ALL SYMBOLS NOW WITH ABS LOCATION 
         207+10    0 SYEXT1A  + R ADD     /   /        GET SYMBOL EXTENSION
         208+ 3  211          + TR +      MAKROLO1
         209+10 2286          + R ADD     ZERO         IF EXTENSION < 0 -> SYMBOL NOT DEF -> STORE ZERO AS LOCATION
         210+ 1  215          + TR        SYEXT2A
         211+13 2274 MAKROLO1 + STORE A   EXT
         212+15 2274          + LOAD MQ   EXT          ADD REGION EXTENT
         213+10  213          + R ADD     *
         214+ 1  166          + TR        ADDEXT
         215+12    0 SYEXT2A  + STORE     /   /        SAVE RUNTIME ABS LOCATION WHERE REGION STARTS
         216+10 2272          + R ADD     N
         217+ 9 2287          + ADD       ONE
         218+12 2272          + STORE     N
         219+10  207          + R ADD     SYEXT1A
         220+ 9 2287          + ADD       ONE
         221+13  207          + STORE A   SYEXT1A
         222+13  215          + STORE A   SYEXT2A
         223+ 1  204          + TR        MAKROLOO
         224+ 1    0 MAKROEX  + TR        /   /
         225+ 9 2288 PCHSTART + ADD       TWO          PUNCH PROGRAM START
         226+13  265          + STORE A   PCHSTEX
         227+10  227          + R ADD     *
         228+ 1   51          + TR        CLRBUF
         229+10  229          + R ADD     *
         230+ 1   57          + TR        PRTSTR
         231+ 0 2330          + STOP      TDEC         "DEC"
         232+ 0    1          + STOP      0001         AT COL 1
         233+10  233          + R ADD     *
         234+ 1   53          + TR        WRITECRD     PUNCH CARD BUFFER
         235+10  235          + R ADD     *
         236+ 1   51          + TR        CLRBUF
         237+10  237          + R ADD     *
         238+ 1   57          + TR        PRTSTR
         239+ 0 2332          + STOP      THDR         "NNNN OP ADDR COMMENTS"
         240+ 0    1          + STOP      0001         AT COL 1
         241+10  241          + R ADD     *
         242+ 1   53          + TR        WRITECRD     PUNCH CARD BUFFER
         243+10  243          + R ADD     *            PUNCH LOCATION, INSTR DATA, COMMENT
         244+ 1  642          + TR        PCHATXT
         245+ 0 2286          + STOP      ZERO         LOC TO PUNCH
         246+ 1  266          + 01        XFERBIN1
         247+ 9 2360          + ADD       TXFER1       "R ADD   4095  HAS LOC OF 1ST REGION"
         248+ 1  267          + 01        XFERBIN2
         249+ 9 2373          + ADD       TXFER2       "STORE A 0003"
         250+ 1  268          + 01        XFERBIN3
         251+ 9 2378          + ADD       TXFER3       "R ADD   *"
         252+ 1  269          + 01        XFERBIN4
         253+ 9 2382          + ADD       TXFER4       "TR      /   / TR TO 1ST REGION"
         254+ 1  270          + 01        XFERBIN5
         255+ 0 2393          + STOP      TXFRE5       "STOP    0000  END OF PACT PROG"
         256+10  256          + R ADD     *            PUNCH LOCATION (PCHLOC++), INSTR DATA, COMMENT
         257+ 1  642          + TR        PCHATXT
         258+ 0 2298          + STOP      D4094        LOC TO PUNCH
         259+ 1 1050          + 01        ROTBLAD
         260+ 9 2340          + ADD       T4ROTAD      "/4094/ HAS RO TABLE LOC"
         261+ 1 1051          + 01        INIREG
         262+ 0 2349          + STOP      T4LOC1ST     "/4095/ HAS LOC OF 1ST REGION"
         263+10  263          + R ADD     *            PUNCH BLANK CARD/LINE AS SEPARATOR
         264+ 1  733          + TR        PCHBLANK 
         265+ 1    0 PCHSTEX  + TR        /   /
         266+10 4095 XFERBIN1 + R ADD     4095         [4095]=ABS LOC OF 1ST REGION 
         267+13    3 XFERBIN2 + STORE A   0003
         268+10    2 XFERBIN3 + R ADD     0002         R ADD *
         269+ 1    0 XFERBIN4 + TR        0000         TR    1ST REGION
         270+ 0    0 XFERBIN5 + STOP      0000         STOP  END OF COMPILED PROGRAM EXECUTION
         271+ 9 2288 PCHROTBL + ADD       TWO          PUNCH REGION ORIGIN TABLE
         272+13  335          + STORE A   PCHROEX
         273+10  273          + R ADD     *            PUNCH LOCATION (PCH.LOC++), INSTR DATA, COMMENT
         274+ 1  642          + TR        PCHATXT
         275+ 0 1050          + STOP      ROTBLAD      VALUE PUNCHED AS LOCATION = ABS LOC OF RO TABLE AT RUNTIME 
         276+ 2 2286          + 02        ZERO         01 -> MC INSTR FORMAT, 02 -> HALF-WORD VALUE FORMAT
         277+ 9 2410          + ADD       TREGA        "0 REG.A"
         278+ 1 2286          + 01        ZERO         
         279+ 9 2404          + ADD       TREGLOC      "START LOCATION"
         280+ 2 2287          + 02        ONE
         281+ 9 2423          + ADD       TREGI        "1 REG.I"
         282+ 1 2286          + 01        ZERO         
         283+ 9 2404          + ADD       TREGLOC      "START LOCATION"
         284+ 2 2288          + 02        TWO          
         285+ 9 2429          + ADD       TREGV        "2 REG.V - PACT VARS"
         286+ 1 2265          + 01        V.ORG        
         287+ 9 2404          + ADD       TREGLOC      "START LOCATION"
         288+ 2 2289          + 02        D3           
         289+ 9 2436          + ADD       TREGT        "3 REG.T - PACT TEMP STORAGE"
         290+ 1 2267          + 01        T.ORG        
         291+ 9 2404          + ADD       TREGLOC      "START LOCATION"
         292+ 2 2290          + 02        D4           
         293+ 9 2446          + ADD       TREGN        "4 REG.N - NUMBERS"
         294+ 1 2269          + 01        N.ORG        
         295+ 9 2404          + ADD       TREGLOC      "START LOCATION"
         296+ 2 2291          + 02        D5           
         297+ 9 2452          + ADD       TREGP        "5 REG.P - PERISHABLE STORAGE "
         298+ 1 2271          + 01        P.ORG        
         299+ 9 2404          + ADD       TREGLOC      "START LOCATION"
         300+ 1 2286          + 01        ZERO
         301+ 9 2462          + ADD       TREG6        "6 REG.# - NOT USED "
         302+ 1 2286          + 01        ZERO         
         303+ 0 2286          + STOP      ZERO         STOP -> NO MORE LINES
         304+10 2286          + R ADD     ZERO         LOOP ON TSYMBEXT TABLE TO PUNCH ABS LOCATION OF REGION
         305+12 2272          + STORE     N    
         306+10 2258          + R ADD     TSYMBAD
         307+13  313          + STORE A   SYNAM1B
         308+ 9 1056          + ADD       MAXNSYMB
         309+13  315          + STORE A   SYEXT1B
         310+10 2272 RDROLOOP + R ADD     N
         311+ 5 1057          + SUB       NSYMBS
         312+ 4  333          + TR 0      PCHROLEX     EXIT LOOP, ALL SYMBOLS OF RO TABLE PUNCHED
         313+10    0 SYNAM1B  + R ADD     /   /        GET SYMBOL ALFA BASE48 NAME
         314+12 2466          + STORE     TNAM         SAVE IT
         315+10    0 SYEXT1B  + R ADD     /   /        GET SYMBOL RUN-TIME ABS LOCATION 
         316+12 2273          + STORE     LOC
         317+10  317          + R ADD     *            PUNCH LOCATION (PCH.LOC++), INSTR DATA, COMMENT
         318+ 1  642          + TR        PCHATXT
         319+ 0  727          + STOP      PCH.LOC      
         320+ 2 2466          + 02        TNAM          
         321+ 9 2466          + ADD       TNAM         "AAA ROUTINE"
         322+ 1 2273          + 01        LOC
         323+ 0 2404          + STOP      TREGLOC      "START LOCATION"
         324+10 2272          + R ADD     N
         325+ 9 2287          + ADD       ONE
         326+12 2272          + STORE     N
         327+10  313          + R ADD     SYNAM1B
         328+ 9 2287          + ADD       ONE
         329+13  313          + STORE A   SYNAM1B
         330+ 9 1056          + ADD       MAXNSYMB
         331+13  315          + STORE A   SYEXT1B
         332+ 1  310          + TR        RDROLOOP
         333+10  333 PCHROLEX + R ADD     *
         334+ 1  733          + TR        PCHBLANK     PUNCH A BLANK CARD AS SEPARATOR
         335+ 1    0 PCHROEX  + TR        /   /         
         336+ 9 2288 PCHNUMS  + ADD       TWO          PUNCH NUMBER CONSTANTS CARDS (REGION N)
         337+13  385          + STORE A   PCHNUMEX
         338+10 1042          + R ADD     RELNUM0      WHERE NUMBERS STARTS IN NUMBER POOL (USUALLY = 0)
         339+ 9 2269          + ADD       N.ORG
         340+12 2273          + STORE     LOC
         341+10  341          + R ADD     *            PUNCH LOCATION, INSTR DATA, COMMENT
         342+ 1  642          + TR        PCHATXT
         343+ 0 2273          + STOP      LOC      
         344+ 2 2286          + 02        ZERO          
         345+ 9 2471          + ADD       TNUM         "CONSTANT ZERO - START OF NUMBERS POOL"
         346+ 2 2286          + 02        ZERO
         347+ 0 2286          + STOP      ZERO
         348+10 2286          + R ADD     ZERO
         349+12 2272          + STORE     N
         350+10 2294          + R ADD     D18          TNUMPOOL STARTS AT ADDR 0018 ON DRUM 0130 
         351+13  356          + STORE A   RDNUM
         352+10 2272 PCHNULOO + R ADD     N
         353+ 5 1055          + SUB       NNUMS
         354+ 4  383          + TR 0      PCHNUEND     TR IF ALL NUMBERS PUNCHED
         355+24  130          + READ      0130
         356+29    0 RDNUM    + SET DR    /   /
         357-31  772          - COPY      NUM          GET NUMBER N FROM POOL
         358+10  356          + R ADD     RDNUM        INCR ADDR IN POOL
         359+ 9 2288          + ADD       TWO
         360+13  356          + STORE A   RDNUM
         361+10 2273          + R ADD     LOC          PRE-INCREMENT LOC, SO 1ST ENTRY In NUMBER POOL (N=0) GOES
         362+ 9 2288          + ADD       TWO          TO LOC=0002. LOC=0000 CONATAINS CONSTANT ZERO
         363+12 2273          + STORE     LOC
         364+10  364          + R ADD     *            WRITE NUMBER IN BINARY REL CARD 
         365+ 1   75          + TR        WRIBREL
         366- 0    0          - STOP      0000         PARAM: BIN CARD TYPE REQUITED: -00 -> INSTR CARD, 
         367+ 0 2290          + STOP      D4           PARAM: BIN CARD SYMBOL REQUITED
         368+ 0 2273          + STOP      LOC          PARAM: LOCATION 0..4095 
         369+ 0    1          + STOP      0001         PARAM: =1 -> NEXT PARAM IS A FULL WORD TO ADD TO BIN CARD (INDEX = 0)
         370+ 0  772          + STOP      NUM          PARAM: LEFT HALF WORD = BASE48 SYMBOL ALFA NAME 
         371+ 0  773          + STOP      NUM2         PARAM: RIGHT HALF WORD = (OP=01) << 12 + SYMBOL EXTENSION 
         372+10  372          + R ADD     *            PUNCH LOCATION, INSTR DATA, COMMENT
         373+ 1  642          + TR        PCHATXT
         374+ 0 2273          + STOP      LOC      
         375+ 2  772          + 02        NUM 
         376+ 9 2286          + ADD       ZERO
         377+ 2  773          + 02        NUM2
         378+ 0 2286          + STOP      ZERO
         379+10 2272          + R ADD     N
         380+ 9 2287          + ADD       ONE
         381+12 2272          + STORE     N
         382+ 1  352          + TR        PCHNULOO
         383+10  383 PCHNUEND + R ADD     *            
         384+ 1  733          + TR        PCHBLANK     PUNCH A BLANK CARD AS SEPARATOR
         385+ 1    0 PCHNUMEX + TR        /   /        RETURN TO CALLER
         386+ 9 2288 LIBPCH   + ADD       TWO          PUNCH ABS TEXT CARDS FOR USED LIBRARIES 
         387+13  437          + STORE A   LIBPCHEX 
         388+10 2286          + R ADD     ZERO
         389+12 2276          + STORE     LIB          INIT NAME OF CURRENT LIB BEING PROCESSED
         390+12 2277          + STORE     LPCHFLG      LIB PUNCH FLAG: =1 -> SHOULD PUNCH CURRENT LIB, =0 -> SHOULD SKIP CURRENT LIB
         391+10  391 READLIB  + R ADD     *            READ LIBRARY FROM TAPE
         392+ 1   65          + TR        RDTAPE       
         393+ 0  256          + STOP      TAPETXT
         394+ 0  986          + STOP      LIBCODE      BUF TO WRITE TO TAPE
         395+10  986          + R ADD     LTYPE         
         396+ 5 2297          + SUB       D999         999 SIGNAL END OF LIB 
         397+ 4  435          + TR 0      LIBSDONE     IF =0 -> NO MORE LIBRARY ROUTINE TO SCAN
         398+10  987          + R ADD     LLIBNAM      IF READING NEXT RECORD OF CURRENT LIB ROUTINE 
         399+ 5 2276          + SUB       LIB          THEN TR TO LIBOK TO PUNCH IT IF REQUERIED
         400+ 4  430          + TR 0      LIBOK
         401+10  987          + R ADD     LLIBNAM      NEW ROUTINE
         402+12 2276          + STORE     LIB          IS SET AS CURRENT ONE
         403+10 2286          + R ADD     ZERO         RESET LIB PUNCH FLAG
         404+12 2277          + STORE     LPCHFLG      LIB PUNCH FLAG: =1 -> SHOULD PUNCH CURRENT LIB, =0 -> SHOULD SKIP CURRENT LIB
         405+10  405          + R ADD     *
         406+ 1   71          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         407+ 0 1058          + STOP      TSYMBREF     ... GLOBAL SYMBOL TABLE
         408+ 0 1057          + STOP      NSYMBS       ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NSYMBS
         409+ 0  987          + STOP      LLIBNAM      ... THE VALUE TO FIND 
         410+12 2278          + STORE     ISYMB
         411+ 4  391          + TR 0      READLIB      ROUTINE IN LIBRARY IS NOT REFERENCED IN PACT PROG SYMBOL LIST -> TR TO 
         412+10  412          + R ADD     *            GET THE ABS LOACTION FOR THIS LIBRARY ROUTINE     
         413+ 1   73          + TR        READTBL      
         414+ 0 1658          + STOP      TSYMBEXT
         415+ 0 2278          + STOP      ISYMB
         416+ 0 2263          + STOP      I.ORG        = TSYMBEXT[ISYMB] 
         417+10 2287          + R ADD     ONE          SET LIB PUNCH FLAG
         418+12 2277          + STORE     LPCHFLG      LIB PUNCH FLAG: =1 -> SHOULD PUNCH CURRENT LIB, =0 -> SHOULD SKIP CURRENT LIB
         419+10  419          + R ADD     *
         420+ 1   63          + TR        PRTNLINE     
         421+ 0  401          + STOP      0401         CHAR AT COL 1
         422+ 0 2295          + STOP      D45          '/'
         423+ 0  502          + STOP      0502         ALFA TXT
         424+ 0  987          + STOP      LLIBNAM      LIB ROUTINE TO BE ADDED TO PACT PROGRAM
         425+ 0  405          + STOP      0405         CHAR AT COL 5
         426+ 0 2295          + STOP      D45          '/'
         427+ 0  107          + STOP      0107         STRINGZ AT COL 7
         428+ 0 2314          + STOP      MSGLPCH     "LIB ROUTINE PUNCHED"
         429+ 0    6          + STOP      0006         END OF LINE. 
         430+10 2277 LIBOK    + R ADD     LPCHFLG      LIB PUNCH FLAG: =1 -> SHOULD PUNCH CURRENT LIB, =0 -> SHOULD SKIP CURRENT LIB
         431+ 4  391          + TR 0      READLIB      ROUTINE IN LIBRARY NOT TO BE PUNCHED -> TR TO TRY WITH NEXT RECORD IN LIBRARY
         432+10  432          + R ADD     *
         433+ 1  438          + TR        PCHLREC      PUNCH LIB RECORD
         434+ 1  391          + TR        READLIB      ROUTINE IN LIBRARY PUNCHED -> TR TO PROCEED WITH NEXT RECORD IN LIBRARY
         435+10  435 LIBSDONE + R ADD     *            
         436+ 1  733          + TR        PCHBLANK     PUNCH A BLANK CARD AS SEPARATOR
         437+ 1    0 LIBPCHEX + TR        /   /
         438+ 9 2288 PCHLREC  + ADD       TWO          PUNCH LIB RECORD
         439+13  472          + STORE A   PCHLREX
         440+10  440          + R ADD     *            
         441+ 1   69          + TR        MEMCOPY
         442+ 0  988          + STOP      LSRC
         443+ 0    0          + STOP      0000
         444+ 0 2296          + STOP      D48
         445+10 1036          + R ADD     OPADDR       = +/- MC.OP  MC.ADDR
         446+13 2282          + STORE A   MC.ADDR
         447+10 1038          + R ADD     REGLOC       = + MC.REG MC.LOC (REG A=0, I=1, V=2, T=3, N=4, P=5, S=7)
         448+13 2273          + STORE A   LOC
         449+23   12          + A RIGHT   0012         GET THE REGION
         450+22    1          + A LEFT    0001         COMPUTE ABS LOC OF ADDR FOR ITS REGION
         451+ 9 2259          + ADD       ROAD
         452+ 9 2287          + ADD       ONE
         453+13  454          + STORE A   LORG
         454+10    0 LORG     + R ADD     /   /        GET THE REGION ORIGIN
         455+ 9 2282          + ADD       MC.ADDR
         456+13 1036          + STORE A   OPADDR       NOW OPADDR HAS THE ADDR AS ABSLUTE LOCATION
         457+10 2273          + R ADD     LOC          COMPUTE ABS LOC OF MCINSTR
         458+ 9 2263          + ADD       I.ORG
         459+12 2273          + STORE     LOC
         460+10  470          + R ADD     PCHLFMT
         461+21   30          + L RIGHT   0030         30 = 12 + 18
         462+10 2286          + R ADD     ZERO
         463+20   18          + L LEFT    0018
         464+ 9 1037          + ADD       FORMAT       =0 -> BINARY FORMAT, =1 -> TEXT FORMAT (MC INSTR), =2 -> TEXT FORMAT (NUM)
         465+22   12          + A LEFT    0012
         466+12  470          + STORE     PCHLFMT      NOW LIBFMT = NN OPADDR
         467+10  467          + R ADD     *            PUNCH LOCATION, INSTR DATA, COMMENT
         468+ 1  642          + TR        PCHATXT
         469+ 0 2273          + STOP      LOC      
         470+ 0 1036 PCHLFMT  + 00        OPADDR       PUNCH DATA MCINSTR/NUM
         471+ 0    0          + STOP      0000         KEEPING CURRENT CARD IMAGE 
         472+ 1    0 PCHLREX  + TR        /   /
         473+ 9 2288 PCHPROG  + ADD       TWO          PUNCH PACT COMPILED PROGRAM
         474+13  524          + STORE A   PCHPRGEX
         475+10 2286 READREG  + R ADD     ZERO
         476+12 2284          + STORE     IRELADDR     REL ADDRESS USED BY I REGION 
         477+ 6 2287          + R SUB     ONE
         478+12 2263          + STORE     I.ORG        I.ORG=-1 -> NOT DEFINED
         479+10  479 READSTEP + R ADD     *            READ PACT USER PROGRAM SOURCE CODE FROM TAPE IN
         480+ 1   65          + TR        RDTAPE
         481+ 0  259          + STOP      TAPEIN
         482+ 0  740          + STOP      CCODE        BUF TO READ IN FROM TAPE
         483+ 2  523          + TR OV     EOF          TR IF END OF FILE
         484+10  766          + R ADD     OP
         485+ 4  508          + TR 0      EOR          TR IF END OF REGION
         486+10 2263          + R ADD     I.ORG        IF I.ORG SET -> PROCEED WITH CURRENT PACT STEP
         487+ 3  499          + TR +      RDSTEP
         488+10  488          + R ADD     *
         489+ 1   71          + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         490+ 0 1058          + STOP      TSYMBREF     ... GLOBAL SYMBOL TABLE
         491+ 0 1057          + STOP      NSYMBS       ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NSYMBS
         492+ 0  764          + STOP      REGION       ... THE VALUE TO FIND 
         493+12 2278          + STORE     ISYMB
         494+10  494          + R ADD     *            GET THE ABS LOCATION FOR THIS REGION 
         495+ 1   73          + TR        READTBL      
         496+ 0 1658          + STOP      TSYMBEXT
         497+ 0 2278          + STOP      ISYMB
         498+ 0 2263          + STOP      I.ORG        = TSYMBEXT[ISYMB] 
         499+10  499 RDSTEP   + R ADD     *            LOAD PACTSCR INTO CARD IMAGE SO 
         500+ 1  525          + TR        LOADCC       CURRENT PACT SOURCE CODE CAN BE PRINTED
         501+10 2284          + R ADD     IRELADDR     I RELATIVE LOCATION STEP
         502+12 2285          + STORE     IREL0        I RELATIVE LOCATION OF THIS STEP
         503+ 9  782          + ADD       NINST        NUMBER OF INST IN THIS STEP
         504+12 2284          + STORE     IRELADDR 
         505+10  505          + R ADD     *
         506+ 1  551          + TR        MCPCH        PUNCH MC INSTR FOR CURRENT STEP
         507+ 1  479          + TR        READSTEP     PROCEED WITH NEXT STEP
         508+ 8    0 EOR      + NOOP      0000         END OF REGION  
         509+10  509          + R ADD     *
         510+ 1   63          + TR        PRTNLINE     
         511+ 0  401          + STOP      0401         CHAR AT COL 1
         512+ 0 2295          + STOP      D45          '/'
         513+ 0  502          + STOP      0502         ALFA TXT
         514+ 0  764          + STOP      REGION       PACT REGION NAME
         515+ 0  405          + STOP      0405         CHAR AT COL 5
         516+ 0 2295          + STOP      D45          '/'
         517+ 0  107          + STOP      0107         STRINGZ AT COL 7
         518+ 0 2322          + STOP      MSGPPCH      "PACT REGION PUNCHED"
         519+ 0    6          + STOP      0006         END OF LINE. 
         520+10  520          + R ADD     *            
         521+ 1  733          + TR        PCHBLANK     PUNCH A BLANK CARD AS SEPARATOR
         522+ 1  475          + TR        READREG      PROCEED WITH NEXT REGION
         523+ 8    0 EOF      + NOOP      0000         END OF PACT PROGRAM
         524+ 1    0 PCHPRGEX + TR        /   /
         525+ 9 2288 LOADCC   + ADD       TWO          LOAD PACTSCR INTO CARD IMAGE SO 
         526+13  547          + STORE A   CPCCEX       CURRENT PACT SOURCE CODE CAN BE PRINTED
         527+10 2286          + R ADD     ZERO
         528-12    0          - STORE     0000
         529+10 2288          + R ADD     TWO          COPY TO RIGHT SIDE OF CARD IMAGE
         530+13  534          + STORE A   CPCC1        AT 0..46 FROM PACTSCR
         531+10  550          + R ADD     CPCC2
         532+13  533          + STORE A   CPCC 
         533-10    0 CPCC     - R ADD     /   /
         534-12    0 CPCC1    - STORE     /   /
         535+10  534          + R ADD     CPCC1
         536+ 5 2288          + SUB       TWO
         537+13  539          + STORE A   CPCC1B
         538+10 2286          + R ADD     ZERO
         539-12    0 CPCC1B   - STORE     /   /
         540+10  533          + R ADD     CPCC
         541+ 5 2288          + SUB       TWO
         542+13  533          + STORE A   CPCC
         543+10  534          + R ADD     CPCC1
         544+ 5 2290          + SUB       D4
         545+13  534          + STORE A   CPCC1
         546+ 5  549          + SUB       CPCCE
         547+ 4    0 CPCCEX   + TR 0      /   /        RETURN TO CALLER
         548+ 1  533          + TR        CPCC
         549-12   50 CPCCE    - STORE     0050         LAST LOCATION TO COPY FROM 
         550+ 8  740 CPCC2    + NOOP      PACTSRC      PACTSRC = FIRST LOCATION TO COPY FROM
         551+ 9 2288 MCPCH    + ADD       TWO
         552+13  585          + STORE A   MCPCHEX
         553+10 2286          + R ADD     ZERO         INSTR GENERATED IN THIS STEP
         554+12 2283          + STORE     MCNUM
         555+10 2283 MCLOOP   + R ADD     MCNUM
         556+ 5  782          + SUB       NINST
         557+ 4  584          + TR 0      MCLOEND      TR TO PROCESS NEXT STEP IF ALL NINST INSTRUCTIONS PRINTED
         558+10 2283          + R ADD     MCNUM        INCR COUNT
         559+ 9 2287          + ADD       ONE
         560+12 2283          + STORE     MCNUM        GET MC INSTR FROM TINST[ (PRTMCNUM-1)*2 ]
         561+ 9 2283          + ADD       MCNUM
         562+ 5 2288          + SUB       TWO
         563+ 9  583          + ADD       TINSTAD
         564+13  569          + STORE A   MCAD1
         565+ 9 2287          + ADD       ONE
         566+13  574          + STORE A   MCAD2
         567+10 2286          + R ADD     ZERO
         568+12 2281          + STORE     MC.REG       INIT REGION REFERENCED BY MC
         569+10    0 MCAD1    + R ADD     /   /  
         570+12 1036          + STORE     OPADDR       
         571+13 2281          + STORE A   MC.REG
         572+23   12          + A RIGHT   0012
         573+12 2280          + STORE     MC.OP        MC.OP HAS NOW THE SIGNED OPCODE -31..31 
         574+10    0 MCAD2    + R ADD     /   /
         575+12 2282          + STORE     MC.ADDR
         576+10 2285          + R ADD     IREL0        SET MC.LOC = THE RELATIVE LOCATION OF STEP 
         577+ 9 2283          + ADD       MCNUM        ADD THE NUMBER OF INSTR (-1 BECAUSE STARTS AT 1)
         578+ 5 2287          + SUB       ONE
         579+12 2279          + STORE     MC.LOC       
         580+10  580          + R ADD     *
         581+ 1  586          + TR        PCHMC        PUNCH ONE MC INSTRUCTION GIVEN BY MC.LOC, MC.OP, MC.REG. MC.ADDR
         582+ 1  555          + TR        MCLOOP
         583+ 0  784 TINSTAD  + STOP      TINST  
         584+ 8    0 MCLOEND  + NOOP      0000
         585+ 1    0 MCPCHEX  + TR        /   /
         586+ 9 2288 PCHMC    + ADD       TWO          PUNCH ONE MC INSTRUCTION GIVEN BY MC.LOC, MC.OP, MC.REG. MC.ADDR
         587+13  639          + STORE A   PCHMCEX      ALL ADDR ARE RELATIVE
         588+15 2279          + LOAD MQ   MC.LOC
         589+10  589          + R ADD     *
         590+ 1   59          + TR        PRTINT
         591+ 0    4          + STOP      0004         LEN=4
         592+ 0   18          + STOP      0018         COL 18
         593+15 2293          + LOAD MQ   D12          '+'
         594+10 2280          + R ADD     MC.OP
         595+ 3  597          + TR +      PMC6
         596+15 2292          + LOAD MQ   D11          '-'
         597+10  597 PMC6     + R ADD     *            PRINT OP SIGN
         598+ 1   55          + TR        PRTCHR
         599+ 0   23          + STOP      0023         COL 23
         600+10 2286          + R ADD     ZERO
         601+11 2280          + ADD AB    MC.OP
         602+ 9  640          + ADD       TMNEAD
         603+13  604          + STORE A   PMC7
         604+15    0 PMC7     + LOAD MQ   /   /
         605+10  605          + R ADD     *            PRINT OP MNEMONIC
         606+ 1   61          + TR        PRTALF
         607+ 0   24          + STOP      0024         COL 24
         608+10 2281          + R ADD     MC.REG       REGION 0..7
         609+ 9  641          + ADD       TREGMNEA     CHARS IN TREGMNE ARE TXT ALFA VALUES  
         610+13  611          + STORE A   PMC8         THUS ARE NEGATIVE
         611+ 6    0 PMC8     + R SUB     /   /        CHANGE SIGN BEFORE STORING IT IN MQ
         612+21   35          + L RIGHT   0035
         613+10  613          + R ADD     *            PRINT REGION LETTER V I S T A N
         614+ 1   55          + TR        PRTCHR
         615+ 0   27          + STOP      0027         COL 27
         616+15 2282          + LOAD MQ   MC.ADDR      PRINT ADDRESS IN DECIMAL 
         617+10  617          + R ADD     *
         618+ 1   59          + TR        PRTINT
         619+ 0    4          + STOP      0004         LEN=4
         620+ 0   29          + STOP      0029         COL 29
         621+10 2279          + R ADD     MC.LOC       CONVER LOC TO ABS ADDR
         622+ 9 2263          + ADD       I.ORG
         623+12 2273          + STORE     LOC
         624+10 2281          + R ADD     MC.REG 
         625+22    1          + A LEFT    0001         COMPUTE ABS LOC OF ADDR FOR ITS REGION
         626+ 9 2259          + ADD       ROAD
         627+ 9 2287          + ADD       ONE
         628+13  629          + STORE A   MORG
         629+10    0 MORG     + R ADD     /   /        GET THE REGION ORIGIN
         630+ 9 2282          + ADD       MC.ADDR
         631+13 1036          + STORE A   OPADDR       NOW OPADDR HAS THE ADDR AS ABSOLUTE LOCATION
         632+10  632          + R ADD     *            PUNCH LOCATION, INSTR DATA, COMMENT
         633+ 1  642          + TR        PCHATXT
         634+ 0 2273          + STOP      LOC      
         635+ 1 1036          + 01        OPADDR       PUNCH DATA MCINSTR
         636+ 0    0          + STOP      0000         KEEPING CURRENT CARD IMAGE 
         637+10  637          + R ADD     *            CLEAR BUF AFTER PUNCHING
         638+ 1   51          + TR        CLRBUF            
         639+ 1    0 PCHMCEX  + TR        /   /
         640+ 0 2493 TMNEAD   + STOP      TMNE
         641+ 0 2485 TREGMNEA + STOP      TREGMNE
         642+ 9 2288 PCHATXT  + ADD       TWO          PUNCH AN ABS TEXT CARD
         643+13  646          + STORE A   PCHP0
         644+ 9 2287          + ADD       ONE                                                            
         645+13  728          + STORE A   PCH.P        NEXT PARAM LOCATION
         646+10    0 PCHP0    + R ADD     /   /
         647+13  648          + STORE A   PCHP0A
         648+10    0 PCHP0A   + R ADD     /   /                 
         649+12  727          + STORE     PCH.LOC      LOC TO PUNCH
         650+10  728 PCHACRD  + R ADD     PCH.P
         651+13  657          + STORE A   PCHP1
         652+ 9 2287          + ADD       ONE
         653+13  663          + STORE A   PCHP2
         654+ 9 2287          + ADD       ONE
         655+13  728          + STORE A   PCH.P
         656+13  732          + STORE A   PCHAEX       JUST IN CASE THIS PARAM IS LAST ONE
         657+10    0 PCHP1    + R ADD     /   /
         658+13  661          + STORE A   PCHP1A
         659+23   12          + A RIGHT   0012
         660+12  729          + STORE     PCH.FMT      FORMAT: 00 -> LOC/INSTR BLANK, COMMENT PUNCHED (PCHLOC NOT INCREMENTED)
         661+10    0 PCHP1A   + R ADD     /   /                01 -> MC INSTR FORMAT, 02 -> HALF-WORD VALUE FORMAT   
         662+12  730          + STORE     PCH.DATA     THE HALF-WORD DATA TO PUNCH
         663+10    0 PCHP2    + R ADD     /   /
         664+13  720          + STORE A   PCHCMAD      LOCATION OF COMMENT (AS STRINGZ)
         665+23   12          + A RIGHT   0012
         666+12  731          + STORE     PCH.MORE     >0 -> TR TO PUNCH MORE LINES, =0 -> THIS WAS THE LAST LINE PUNCHED
         667+10  720          + R ADD     PCHCMAD      IF LOCATION OF COMMENT <> 0000 
         668+ 4  672          + TR 0      PCHNOCMN     THEN CLEAR THE CURRENT CARD IMAGE                               
         669+10  669          + R ADD     *            ELSE DO NOT CLEAR CURRENT CARD IMAGE                               
         670+ 1   51          + TR        CLRBUF            AND SET ZERO AS LOCATIOn OF COMMENT 
         671+ 1  674          + TR        PCHGO             (ZERO INTERPRETED AS STRINGZ MEANS EMPTY STRING)
         672+10  691 PCHNOCMN + R ADD     ZEROAD
         673+13  720          + STORE A   PCHCMAD
         674+10  729 PCHGO    + R ADD     PCH.FMT      IF FORMAT = 00 -> DO NOT PRINT LOC/DATA, NOR INCREMENT LOC
         675+ 4  718          + TR 0      PCHCMNT      TR TO PRINT COMMENT
         676+15  727          + LOAD MQ   PCH.LOC      PRINT LOC IN DECIMAL 
         677+10  677          + R ADD     *
         678+ 1   59          + TR        PRTINT
         679+ 0    4          + STOP      0004         LEN=4
         680+ 0    1          + STOP      0001         COLUMN TO PRINT AT
         681+10  727          + R ADD     PCH.LOC      INCREMENT PCHLOC 
         682+ 9 2287          + ADD       ONE
         683+12  727          + STORE     PCH.LOC
         684+15 2293          + LOAD MQ   D12
         685+10  730          + R ADD     PCH.DATA
         686+ 3  688          + TR +      PCHSGN
         687+15 2292          + LOAD MQ   D11
         688+10  688 PCHSGN   + R ADD     *            
         689+ 1   55          + TR        PRTCHR       PRINT SIGN CHAR
         690+ 0    5          + STOP      0005         AT COL 5
         691+10 2286 ZEROAD   + R ADD     ZERO
         692+11  730          + ADD AB    PCH.DATA
         693+12  730          + STORE     PCH.DATA     REMOVE SIGN
         694+10  729          + R ADD     PCH.FMT      IF FORMAT = 01 -> MC INSTR FORMAT, 02 -> HALF-WORD VALUE FORMAT   
         695+ 5 2287          + SUB       ONE
         696+ 4  703          + TR 0      PCHMCFMT
         697+15  730          + LOAD MQ   PCH.DATA     PRINT DATA AS NUMBER IN DECIMAL 
         698+10  698          + R ADD     *
         699+ 1   59          + TR        PRTINT
         700+ 0    6          + STOP      0006         LEN=6
         701+ 0    6          + STOP      0006         COLUMN TO PRINT AT
         702+ 1  718          + TR        PCHCMNT
         703+10  730 PCHMCFMT + R ADD     PCH.DATA
         704+23   12          + A RIGHT   0012
         705+21   35          + L RIGHT   0035         MQ=0..31 OPCODE
         706+10  706          + R ADD     *
         707+ 1   59          + TR        PRTINT
         708+ 0    2          + STOP      0002         LEN=2
         709+ 0    6          + STOP      0006         COLUMN TO PRINT AT
         710+10  730          + R ADD     PCH.DATA
         711+21   30          + L RIGHT   0030
         712+10 2286          + R ADD     ZERO
         713+21    5          + L RIGHT   0005         MQ=0..4095 ADDR
         714+10  714          + R ADD     *
         715+ 1   59          + TR        PRTINT
         716+ 0    4          + STOP      0004         LEN=4
         717+ 0    9          + STOP      0009         COLUMN TO PRINT AT
         718+10  718 PCHCMNT  + R ADD     *
         719+ 1   57          + TR        PRTSTR
         720+ 0    0 PCHCMAD  + STOP      /   /        PRINT COMMENT IN CARD IMAGE
         721+ 0   14          + STOP      0014         AT COL 14
         722+10  722          + R ADD     *
         723+ 1   53          + TR        WRITECRD     PUNCH CARD BUFFER
         724+10  731          + R ADD     PCH.MORE      
         725+ 4  732          + TR 0      PCHAEX       IF MORE = 0 -> NO MORE CARDS TO PUNCH -> EXIT
         726+ 1  650          + TR        PCHACRD      ELSE TR TO PROCESS NEXT PAIR OF PARAMS
         727+ 0    0 PCH.LOC  + STOP      0000         LOC 
         728+ 0    0 PCH.P    + STOP      0000         PARAMS POINTER
         729+ 0    0 PCH.FMT  + STOP      0000         FORMAT
         730+ 0    0 PCH.DATA + STOP      0000         THE HALF-WORD DATA TO PUNCH
         731+ 0    0 PCH.MORE + STOP      0000         
         732+ 1    0 PCHAEX   + TR        /   /
         733+ 9 2288 PCHBLANK + ADD       TWO          PUNCH A BLANK CARD AS SEPARATOR
         734+13  739          + STORE A   PCHBLEX
         735+10  735          + R ADD     *
         736+ 1   51          + TR        CLRBUF
         737+10  737          + R ADD     *
         738+ 1   53          + TR        WRITECRD     PUNCH CARD BUFFER
         739+ 1    0 PCHBLEX  + TR        /   /
         740+     0  PACTSRC    RES       24           CARD IMAGE OF PACT SOURCE CODE CARD (12 FULL WORDS)
         764+     0  REGION     DEF       0
         765+     0  STEP       DEF       0            REGION = ALFA (<0)
         766+     0  OP         DEF       0            STEP   = INT (>0)
         767+     0  FACT       DEF       0            OP     = 0..43    =0 MEANS END OF REGION
         768+     0  S1         DEF       0            FACT   < 0 -> FACTOR IS AN ALFA SYMBOL (VAR, REGION, ...) 
         769+     0  S2         DEF       0            FACT = 0 -> BLANK FACTOR
         770+     0  QR         DEF       0            FACT = 0..9999 -> DESTINATION STEP FOR TRANSFER/RESULT OF STEP
         771+     0  QF         DEF       0            CLUE = -, R OR N
         772+     0  NUM        DEF       0            
         773+     0  NUM2       DEF       0            S1/S2 = 0 -> BLANK, >0 -> INTEGER, <0 -> ALFA 
         774+     0  CLUE       DEF       0
         775+     0  STEPN      DEF       0            QR = +/- INTEGER OR BLANK. 
         776+     0  FACTN      DEF       0            QF = SET IF THERE IS AN INTEGER FACTOR/NUMBER IN CARD
         777+     0  FACTREG    DEF       0
         778+     0  S1N        DEF       0            STEPN = SEQUENTIAL NUMBER OF STEP            
         779+     0  S2N        DEF       0            IF OP IS TRANSFER -> FACTN=DESTINATION STEPN
         780+     0  D1N        DEF       0            FACTN=ADDR (0, 2, 4, ..) FACTREG=' ', 'T', 'V', 'N'
         781+     0  D2N        DEF       0            S1N/S2N=INDEX (IF <0), BLANK (IF =0), CONST (IF >0)
         782+     0  NINST      DEF       0            D1N/D2N=HALF-WORD SIZE OF EACH DIMENSION
         783+     0  NINCR      DEF       0
         784+     0  TINST      RES       200          MACHINE CODE: 1ST HALF-WORD OPCODE + REGION/LOCATION INTO STEP (FOR TRANSFERS)
         984+    44  CCLEN      DEF       0044         LENGTH OF COMPACT CODE RECORD 
         985+   100  MAXNINST   DEF       100          MAX NUMBER OF MACHINE CODE INSTRUTIONS PER STEP
         986+     0  LTYPE      DEF       0            TYPE OF RECORD: 100=REGULAR RECORD. 999=END OF LIB 
         987+     0  LLIBNAM    DEF       0            LIBRARY ROUTINE NAME TO WITCH THIS RECORD BELONGS
         988+     0  LSRC       RES       48           CARD IMAGE OF PACT REL ASSEMBLER CARD/REL BINARY CARD (24 FULL WORDS)
        1036+     0  OPADDR     DEF       0            = +/- MC.OP  MC.ADDR
        1037+     0  FORMAT     DEF       0            =0 -> BINARY FORMAT, =1 -> TEXT FORMAT (MC INSTR), =2 -> TEXT FORMAT (NUM), 
        1038+     0  REGLOC     DEF       0            = + MC.REG MC.LOC (REG A=0, I=1, V=2, T=3, N=4, P=5, S=7)
        1039+     0  DUMMY      DEF       0            Spare
        1040+    54  LCLEN      DEF       54           LENGH OF LIBRARY CODE RECORD 
        1041+     0  DUMMY2     DEF       0            Spare
        1042+     0  RELNUM0    DEF       0            LOCATION OF 1ST NUM IN POOL              <- set by stage 31 Read Var Cards
        1043+     0  NVARS      DEF       0            NUMBER OF VARS DEFINED                   <- set by stage 33 Compute Var loc
        1044+     0  V.EXT      DEF       0            EXTENSION OF VARIABLE REGION (IS EVEN)   <- set by stage 33 Compute Var loc
        1045+     0  N.EXT      DEF       0            EXTENSION OF NUMBER REGION (IS EVEN)     <- set by stage 34 Storage Assign
        1046+     0  T.EXT      DEF       0            EXTENSION OF TEMP VARS REGION (IS EVEN)  <- set by stage 63 final assembly pass 3
        1047+     0  I.EXT      DEF       0            EXTENSION OF TOTAL INSTR OF PROGRAM      <- set by stage 63 final assembly pass 3
        1048+     0  P.EXT      DEF       0            EXTENSION (IS EVEN) OF PERISHABLE REGION <- set by stage 64 Scan Library
        1049+     0  IL.EXT     DEF       0            TOTAL STORAGE NEEDED BY ALL LIBRARIES    <- set by stage 64 Scan Library
        1050+     0  ROTBLAD    DEF       0            ABS LOCATION OF REGION ORIGIN TABLE      <- set by stage 65 Punch loader
        1051+     0  INIREG     DEF       0            ABS LOCATION OF 1ST REGION OF PACT PRG   <- set by stage 65 Punch loader
        1052+     0  LR.EXT     DEF       0            SPACE RESERVED FOR LOADER                <- set by stage 65 Punch loader
        1053+     0  DUMMY3     DEF       0
        1054+   512  MAXNNUMS   DEF       512          MAX NUMBER OF NUMBERS THAT CAN BE DEFINED
        1055+     0  NNUMS      DEF       0            NUMBER OF NUMBERS IN NUMBER POOL
        1056+   600  MAXNSYMB   DEF       600          MAX (600) SYMBOL (LIBRARIES/REGION) REFERENCES CAN DE DEFINED IN THE WHOLE PROGRAM
        1057+     0  NSYMBS     DEF       0            NUMBER OF ENTRIES IN TSYMBREF GLOBAL SYMBOL TABLE
        1058+     0  TSYMBREF   RES       600          GLOBAL SYMBOL TABLE: ALFA VALUE OF SYMBOLS REFERENCED. 
        1658+     0  TSYMBEXT   RES       600          EXTENSION (=SIZE) FOR DEFINED SYMBOLS
        2258+ 0 1058 TSYMBAD  + STOP      TSYMBREF  
        2259+ 0 2260 ROAD     + STOP      RO
        2260+     0  RO         DEF       0            (REG A=0, I=1, V=2, T=3, N=4, P=5, S=7)
        2261+     0             DEF       0
        2262+     1             DEF       1            INSTR REGION (I=1)
        2263+     0  I.ORG      DEF       0            ABS LOC FOR REG.I IN RUNTIME
        2264+     2             DEF       2            VAR REGION (V=2)
        2265+     0  V.ORG      DEF       0            ABS LOC FOR REG.V IN RUNTIME
        2266+     3             DEF       3            TEMP STORAGE REGION (T=3)
        2267+     0  T.ORG      DEF       0            ABS LOC FOR REG.T IN RUNTIME
        2268+     4             DEF       4            NUMBERS REGION (N=4)
        2269+     0  N.ORG      DEF       0            ABS LOC FOR REG.N IN RUNTIME
        2270+     5             DEF       5            PERISHABLE STORAGE REGION (P=5)
        2271+     6  P.ORG      DEF       6            ABS LOC ALLWAYS = 6
        2272+     0  N          DEF       0
        2273+     0  LOC        DEF       0
        2274+     0  EXT        DEF       0
        2275+     0  HI         DEF       0            START OF REGIONS IN HI-MEM 
        2276+     0  LIB        DEF       0
        2277+     0  LPCHFLG    DEF       0
        2278+     0  ISYMB      DEF       0
        2279+     0  MC.LOC     DEF       0            MC OPCODE RELATIVE LOCATION
        2280+     0  MC.OP      DEF       0            MC OPCODE GENERATED
        2281+     0  MC.REG     DEF       0            REGION REFERENCED BY MC OPCODE GENERATED
        2282+     0  MC.ADDR    DEF       0            MC ADDR GENERATED. BOTH WILL BE STORED IN TINST TABLE IN COMPCAT CODE RECORD
        2283+     0  MCNUM      DEF       0            NEXT INSTR TO PROCESS
        2284+     0  IRELADDR   DEF       0            I RELATIVE LOCATION OF STEP
        2285+     0  IREL0      DEF       0            I RELATIVE LOCATION OF THIS STEP
        2286+     0  ZERO       DEF       0
        2287+     1  ONE        DEF       1
        2288+     2  TWO        DEF       2
        2289+     3  D3         DEF       3
        2290+     4  D4         DEF       4
        2291+     5  D5         DEF       5
        2292+    11  D11        DEF       11
        2293+    12  D12        DEF       12
        2294+    18  D18        DEF       18
        2295+    45  D45        DEF       45
        2296+    48  D48        DEF       48
        2297+   999  D999       DEF       999
        2298+  4094  D4094      DEF       4094
        2299- 66122  MSGSTART   TXT       "PUNCH ABS TEXT CARDS",0
        2300- 35520  
        2301- 30655  
        2302-  1553  
        2303- 84480  
        2304- 35214  
        2305- 38352  
        2306+     0  
        2307- 30655  MSGEPCH    TXT       "ABS PROG PUNCHED",0
        2308-  1374  
        2309- 63120  
        2310- 66122  
        2311- 35537  
        2312- 36864  
        2313+     0  
        2314- 56318  MSGLPCH    TXT       "LIB ROUTINE PUNCHED",0
        2315-  1467  
        2316- 77589  
        2317- 60720  
        2318- 66122  
        2319- 35537  
        2320- 36864  
        2321+     0  
        2322- 65151  MSGPPCH    TXT       "PACT REGION PUNCHED",0
        2323- 73758  
        2324- 40101  
        2325- 63456  
        2326- 66122  
        2327- 35537  
        2328- 36864  
        2329+     0  
        2330- 37695  TDEC       TXT       "DEC",0
        2331+     0  
        2332- 61178  THDR       TXT       "NNNN OP ADDR COMMENTS",0
        2333- 59931  
        2334- 64525  
        2335- 37662  
        2336-   747  
        2337- 58817  
        2338- 61471  
        2339+     0  
        2340-103882  T4ROTAD    TXT       "/4094/ HAS RO TABLE LOC",0
        2341- 20973  
        2342-   973  
        2343- 71454  
        2344- 62240  
        2345- 30648  
        2346- 39192  
        2347- 62928  
        2348+     0  
        2349-103882  T4LOC1ST   TXT       "/4095/ HAS LOC OF 1ST REGION",0
        2350- 21021  
        2351-   973  
        2352- 71448  
        2353- 62928  
        2354- 63072  
        2355-  3824  
        2356-  1457  
        2357- 44811  
        2358- 59904  
        2359+     0  
        2360- 69133  TXFER1     TXT       "R ADD   4095  HAS LOC OF 1ST REGION",0
        2361- 37632  
        2362-     4  
        2363- 23477  
        2364-    20  
        2365- 31440  
        2366- 56607  
        2367-  1314  
        2368-    79  
        2369- 73758  
        2370- 40101  
        2371- 63456  
        2372+     0  
        2373- 72987  TXFER2     TXT       "STORE A 0003",0
        2374- 69936  
        2375- 29962  
        2376- 23523  
        2377+     0  
        2378- 69133  TXFER3     TXT       "R ADD   *",0
        2379- 37632  
        2380-    42  
        2381+     0  
        2382- 75168  TXFER4     TXT       "TR      /   / TR TO 1ST REGION",0
        2383-     0  
        2384-    45  
        2385-     0  
        2386-103712  
        2387- 69152  
        2388- 62209  
        2389- 72960  
        2390- 69955  
        2391- 49706  
        2392+     0  
        2393- 72987  TXFRE5     TXT       "STOP    0000  END OF PACT PROG",0
        2394- 64512  
        2395-    10  
        2396- 23530  
        2397-    17  
        2398- 60672  
        2399- 63072  
        2400- 65151  
        2401- 73756  
        2402- 70435  
        2403+     0  
        2404- 72973  TREGLOC    TXT       "START LOCATION",0
        2405- 70656  
        2406- 56607  
        2407- 31509  
        2408- 63456  
        2409+     0  
        2410- 69955  TREGA      TXT       "REG.A - START OF REGION ORIGIN TABLE",0
        2411- 99696  
        2412- 25375  
        2413- 74382  
        2414- 73755  
        2415- 41502  
        2416- 40101  
        2417- 63456  
        2418- 63669  
        2419- 44810  
        2420-  1549  
        2421- 33425  
        2422+     0  
        2423- 69955  TREGI      TXT       "REG.I - INSTR",0
        2424-100080  
        2425- 25365  
        2426- 61424  
        2427- 69120  
        2428+     0  
        2429- 69955  TREGV      TXT       "REG.V - PACT VARS",0
        2430-100704  
        2431- 25372  
        2432- 30704  
        2433-  1645  
        2434- 70608  
        2435+     0  
        2436- 69955  TREGT      TXT       "REG.T - PACT TEMP STORAGE",0
        2437-100608  
        2438- 25372  
        2439- 30704  
        2440-  1553  
        2441- 58944  
        2442- 72987  
        2443- 69763  
        2444- 39168  
        2445+     0  
        2446- 69955  TREGN      TXT       "REG.N - NUMBERS",0
        2447-100320  
        2448- 25370  
        2449- 77246  
        2450- 40639  
        2451+     0  
        2452- 69955  TREGP      TXT       "REG.P - PERISHABLE STORAGE",0
        2453-100416  
        2454- 25372  
        2455- 40629  
        2456- 72397  
        2457- 33425  
        2458-  1520  
        2459- 63661  
        2460- 44592  
        2461+     0  
        2462- 61232  TREG6      TXT       "NOT USED",0
        2463-  1615  
        2464- 39936  
        2465+     0  
        2466- 30589  TNAM       TXT       "AAA ROUTINE",0
        2467-  1467  
        2468- 77589  
        2469- 60720  
        2470+     0  
        2471- 35882  TNUM       TXT       "CONSTANT ZERO - START OF NUMBERS POOL",0
        2472- 72973  
        2473- 61440  
        2474- 88398  
        2475- 62219  
        2476-  1520  
        2477- 31424  
        2478-  1314  
        2479-  1281  
        2480- 58289  
        2481- 70608  
        2482- 65835  
        2483- 55296  
        2484+     0  
        2485-    13  TREGMNE    TXT       '  A'
        2486-    21             TXT       '  I'
        2487-    34             TXT       '  V'
        2488-    32             TXT       '  T'
        2489-    26             TXT       '  N'
        2490-    28             TXT       '  P'        PERISHABLE STORAGE (=LIB LOCAL VARS)
        2491-    44             TXT       '  #'        UNUSED
        2492-    31             TXT       '  S'
        2493- 46080  TMNE       TXT       'H  '        STOP/HALT
        2494- 73728             TXT       'T  '        TRANSFER
        2495- 74592             TXT       'TF '        TRANSFER ON OVERLOF
        2496- 75072             TXT       'TP '        TRANSFER ON PLUS
        2497- 75552             TXT       'TZ '        TRANSFER ON ZERO
        2498- 71424             TXT       'S  '        SUBTRACT
        2499- 70608             TXT       'RS '        RESET AND SUBTRACT
        2500- 73056             TXT       'SV '        SUBTRACT ABSOLUTE VALUE
        2501- 59904             TXT       'N  '        NO OPERATION
        2502- 29952             TXT       'A  '        ADD
        2503- 69744             TXT       'RA '        RESET AND ADD
        2504- 31584             TXT       'AV '        ADD ABSOLUTE VALUE
        2505- 72960             TXT       'ST '        STORE
        2506- 72048             TXT       'SA '        STORE ADDRESS
        2507- 72624             TXT       'SM '        STORE MQ
        2508- 56496             TXT       'LM '        LOAD MQ
        2509- 57600             TXT       'M  '        MULTIPLY
        2510- 59040             TXT       'MR '        MULTIPLY AND ROUND
        2511- 36864             TXT       'D  '        DIVIDE
        2512- 69120             TXT       'R  '        ROUND
        2513- 56448             TXT       'LL '        LONG LEFT SHIFT
        2514- 56736             TXT       'LR '        LONG RIGHT SHIFT
        2515- 31104             TXT       'AL '        ACCUMULATOR LEFT SHIFT
        2516- 31392             TXT       'AR '        ACCUMULATOR RIGHT SHIFT
        2517- 69888             TXT       'RD '        READ
        2518- 69792             TXT       'RB '        READ BACKWARDs
        2519- 80640             TXT       'W  '        WRITE
        2520- 81456             TXT       'WE '        WRITE END OF FILE
        2521- 70800             TXT       'RW '        REWIND TAPE
        2522- 72192             TXT       'SD '        SET DRUM DDR
        2523- 72240             TXT       'SE '        SENSE
        2524- 34560             TXT       'C  '        COPY
        2526+15 2540 CLRBUF   + LOAD MQ   IOCL
        2527+14 2545          + STORE MQ  BUFIO
        2528+15 2566          + LOAD MQ   IOSTORE         
        2529+ 1 2537          + TR        INIT2
        2530+15 2562 READCRD  + LOAD MQ   IORDCRD
        2531+ 1 2535          + TR        INIT1
        2532+15 2564 WRITECRD + LOAD MQ   IOWRCRD
        2533+ 1 2535          + TR        INIT1
        2534+15 2565 PRINTCRD + LOAD MQ   IOPRCRD
        2535+14 2545 INIT1    + STORE MQ  BUFIO
        2536+15 2563          + LOAD MQ   IOCOPY         
        2537+14 2546 INIT2    + STORE MQ  BUFROW
        2538+ 9 2572          + ADD       TWO          
        2539+13 2561          + STORE A   EXIT
        2540+10 2568 IOCL     + R ADD     ZERO         RESET TO INITIAL COPY LOOP ADDRESS     
        2541+13 2546          + STORE A   BUFROW       FOR BUFFER
        2542+10 2546          + R ADD     BUFROW       X .*echo Print
        2543+ 5 2573          + SUB       D48          X 
        2544+12 2570          + STORE     ENDLP        X LOOP END VALUE
        2545- 0    0   BUFIO  - STOP      /   /        READ OR WRITE
        2546-31    0   BUFROW - COPY      /   /        COPY WORD TO/FROM PRINTER/CARDREADER
        2547+ 1 2551          + TR        BUFOK2       NORMAL PROCESSING 
        2548+ 1 2558          + TR        EODECK       FOR COPY READING END OF REG (=END OF DECK BEING READ)
        2549+ 6 2572          + R SUB     TWO          END OF FILE -> NO CARD TO READ -> STOP with Acc=-2
        2550+ 0 2545          + STOP      BUFIO        ON PRESSING START RETRY CARD READ
        2551+10 2546   BUFOK2 + R ADD     BUFROW       X
        2552+ 5 2572          + SUB       TWO          INCR BUF ADDR
        2553+13 2546          + STORE A   BUFROW       X
        2554+ 5 2570          + SUB       ENDLP        CHECK FOR END
        2555+ 4 2560          + TR 0      ENDIO
        2556+10 2568          + R ADD     ZERO         CLEAR ACC IN CASE WE ARE CLEANING THE BUFFER
        2557+ 1 2546          + TR        BUFROW
        2558+10 2571 EODECK   + R ADD     ONE          SET OV FLAG TO SIGNAL END OF DECK CONDITION
        2559+22   36          + A LEFT    36
        2560+26 2052 ENDIO    + WRITE     2052         END OF I/O: INSURE THAT MQ NOT IN USE            
        2561+ 1    0 EXIT     + TR        /   /
        2562+24 2048 IORDCRD  + READ      2048         PREPARE TO READ FROM CARD READER
        2563-31    0 IOCOPY   - COPY      /   /   
        2564+26 1024 IOWRCRD  + WRITE     1024         PREPARE TO PUNCH CARD 
        2565+26  512 IOPRCRD  + WRITE     0512         PREPARE WRITE PRTBUF ON PRINTER
        2566-12    0 IOSTORE  - STORE     /   /        CLEAR BUFFER
        2567+     0             ORG       EVEN           
        2568+     0  ZERO       DEF       0            
        2569+     0             DEF       0            
        2570+     0  ENDLP      DEF       0            LOOP END VALUE
        2571+     1  ONE        DEF       1
        2572+     2  TWO        DEF       2
        2573+    48  D48        DEF       48
        2574+ 9 2845 PRTPARM2 + ADD       TWO          GET 2 PARAMS: LEN AND COL (EITHER VALUE OR VAR ADDR)
        2575+13 2594          + STORE A   PRTPRMEX
        2576+10 2584          + R ADD     PRTP1
        2577+ 9 2845          + ADD       TWO          PRINT PACKED TEXT FROM FULL-WORD VALUE IN MQ REGISTER 
        2578+13 2584          + STORE A   PRTP1        STORE ADDR OF FIRST PARAM (LEN)
        2579+ 9 2844          + ADD       ONE
        2580+13 2586          + STORE A   PRTP2        STORE ADDR OF SECOND PARAM (COL)
        2581+ 9 2844          + ADD       ONE
        2582+13 2661          + STORE A   EXIT
        2583-14 2834          - STORE MQ  NUM          SAVE VALUE TO PRINT PARAM MQ (NUM IS ALIASED TO TXT)
        2584+10    0   PRTP1  + R ADD     /   /        GET LEN: NUMBER OF CHARS TO PRINT (1..6)
        2585+12 2838          + STORE     LEN
        2586+10    0   PRTP2  + R ADD     /   /        GET COLUMN PARAM 1..72
        2587+ 3 2590          + TR +      PRTP4
        2588+13 2589          + STORE A   PRTP3        COL<0 -> INTERPRET COL AS LOC(COL) = ADDR OF COL VAR
        2589+10    0   PRTP3  + R ADD     /   /        READ VAR COL PASED AS PARAM
        2590+ 4 2661   PRTP4  + TR 0      EXIT         COL=0 -> EXIT
        2591+ 3 2593          + TR +      PRTP5
        2592+ 1 2661          + TR        EXIT         COL<0 -> EXIT
        2593+12 2644   PRTP5  + STORE     COL
        2594+ 1    0 PRTPRMEX + TR        /   /        RETURN TO CALLER
        2595+13 2584 PRTSTR   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2596+10 2596          + R ADD     *            FOR PRINT STRINGZ FROM MEM
        2597+ 1 2574          + TR        PRTPARM2
        2598+12 2608          + STORE     COLSZ
        2599+10 2838          + R ADD     LEN          LEN IS IN FACT THE LOCATION WHERE THE STRING STARTS
        2600+13 2603          + STORE A   STRZAD
        2601+10 2661          + R ADD     EXIT
        2602+13 2616          + STORE A   STRZEX
        2603+10    0 STRZAD   + R ADD     /   /        GET HALF-WORD WITH NEXT 3 CHARS TO PRINT
        2604+ 4 2616          + TR 0      STRZEX       IF +0 -> END OF STRING (-0 DOES NOT TERMINATES THE STRING)
        2605+21   35          + L RIGHT   0035         MQ=3-CHARS TO PRINT
        2606+10 2606          + R ADD     *            
        2607+ 1 2618          + TR        PRTALF       PRINT 3 CHARS
        2608+ 0    0 COLSZ    + STOP      0000         COL 
        2609+10 2603 STRZ1    + R ADD     STRZAD       INCR STRING ADDRESS
        2610+ 9 2844          + ADD       ONE
        2611+13 2603          + STORE A   STRZAD
        2612+10 2608          + R ADD     COLSZ        INCR COLUMN
        2613+ 9 2846          + ADD       D3
        2614+13 2608          + STORE A   COLSZ
        2615+ 1 2603          + TR        STRZAD
        2616+ 3    0 STRZEX   + TR +      /   /        IF ZERO -> END OF STRING
        2617+ 1 2609          + TR        STRZ1
        2618+ 9 2845 PRTALF   + ADD       TWO          PRINT 3-PACKED CHARS IN MQ REGISTER 
        2619+14 2840          + STORE MQ  TXT          SAVE TEXT TO PRINT (IN LEFT HALF WORD)
        2620+13 2623          + STORE A   PRTAP2       STORE ADDR OF PARAM (COL)
        2621+ 9 2844          + ADD       ONE
        2622+13 2661          + STORE A   EXIT
        2623+10    0   PRTAP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        2624+ 3 2627          + TR +      PRTAP4
        2625+13 2626          + STORE A   PRTAP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        2626+10    0   PRTAP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        2627+12 2644   PRTAP4 + STORE     COL
        2628+10 2846          + R ADD     D3
        2629+12 2838          + STORE     LEN
        2630+10 2828 PRT1     + R ADD     ZERO         UNPACK LEFTMOST CHAR 
        2631+11 2840          + ADD AB    TXT          GET TEXT DISCARD SIGN
        2632+21   35          + L RIGHT   0035         MQ=Acc
        2633+10 2828          + R ADD     ZERO
        2634+18 2853          + DIV       D48X48
        2635+12 2840          + STORE     TXT          remainder=char to print, mq=c2 * 48 + c3 in right half-word
        2636+10 2828          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        2637+20   18          + L LEFT    0018         put c2 and c3 in left half-word of MQ to be saved in CHAR half word
        2638+14 2839          + STORE MQ  CHAR         CHAR TO PRINT
        2639+10 2839          + R ADD     CHAR 
        2640+ 4 2645          + TR 0      NXTCHR       IF BLANK PROCEED TO NEXT COL
        2641+21   35          + L RIGHT   0035         MQ=CHAR TO PRINT
        2642+10 2642          + R ADD     *            PRINT CHAR
        2643+ 1 2738          + TR        PRTCHR
        2644+ 0    0 COL      + STOP      0000         COL: COLUMN NUMBER TO PRINT (1..72)
        2645+10 2838 NXTCHR   + R ADD     LEN          DECR LEN COUNT
        2646+ 5 2844          + SUB       ONE
        2647+12 2838          + STORE     LEN
        2648+ 4 2661          + TR 0      EXIT         IF NO MORE CHARS TO PRINT EXIT
        2649+10 2644          + R ADD     COL          INCR COL POSITION
        2650+ 9 2844          + ADD       ONE
        2651+12 2644          + STORE     COL
        2652+ 5 2852          + SUB       D72          IF COL > 72 RETURN TO CALLER
        2653+ 4 2655          + TR 0      GNXTCHR      ELSE PROCEED WITH NEXT CHAR
        2654+ 3 2661          + TR +      EXIT
        2655+10 2828 GNXTCHR  + R ADD     ZERO         GET NEXT CHAR 
        2656+15 2840          + LOAD MQ   TXT
        2657+16 2851          + MPY       D48
        2658+22   17          + A LEFT    0017         GET RESULT IN LEFT HALF-WORD OF ACC
        2659+12 2840          + STORE     TXT
        2660+ 1 2630          + TR        PRT1         PROCEED TO PRINT CHAR
        2661+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        2662+13 2584 PRTOCT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2663+10 2663          + R ADD     *            FOR PRINT OCTIONARY VALUE
        2664+ 1 2574          + TR        PRTPARM2
        2665+10 2838          + R ADD     LEN          LEN = OCTAL DIGITS TO PRINT
        2666+ 9 2644          + ADD       COL
        2667+ 5 2844          + SUB       ONE
        2668+12 2680          + STORE     COLN         COL POINTS TO LEAST SIGNIFICANT DIGIT
        2669+10 2834 PRTIOCG  + R ADD     NUM          GENERATE OCTINARY DIGIT
        2670+15 2828          + LOAD MQ   ZERO         CLEAR MQ
        2671+21   21          + L RIGHT   0021         3 LSB BITS OF LEFT HALF-WORD OF ACC TO MQ
        2672+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 3 BIT)
        2673+12 2834          + STORE     NUM          SAVE BACK NUM WITH RIGHTMOST OCTIONARY DIGIY EXTRACTED (NUM'=NUM/8)
        2674+10 2828          + R ADD     ZERO
        2675+20   21          + L LEFT    0021         LEFT HALF-WORD OF ACC IS NOW RIGHTMOST OCTINARY DIGIT EXTRACTED FROM NUM 
        2676+ 4 2694          + TR 0      PRTIOZ       TR IF THIS DIGIT IS ZERO TO PRINT A '0' (BASE48 CODE = 10) INSTEAD OF A BLANK (BASE48 CODE = 0)
        2677+21   35          + L RIGHT   0035         PUT DIGIT 1..9 TO PRINT IN MQ
        2678+10 2678 PRTOCTD  + R ADD     *            PRINT OCTINARY DIGIT
        2679+ 1 2738          + TR        PRTCHR
        2680+ 0    0 COLN     + STOP      0000
        2681+10 2680          + R ADD     COLN        DECR COL NUMBER TO PRINT NEXT DIGIT
        2682+ 5 2844          + SUB       ONE
        2683+12 2680          + STORE     COLN
        2684+10 2838          + R ADD     LEN          DECR COL NUMBER TO PRINT NEXT DIGIT
        2685+ 5 2844          + SUB       ONE
        2686+ 4 2661          + TR 0      EXIT         PRINTED LEN OCTINARY DIGITS -> EXIT
        2687+12 2838          + STORE     LEN
        2688+10 2834          + R ADD     NUM          IF NUM < 0, ADD SIGN BIT TO LEFTMOST DIGIT
        2689+ 3 2669          + TR +      PRTIOCG
        2690+10 2854          + R ADD     OCT04K       
        2691+ 5 2834          + SUB       NUM
        2692+12 2834          + STORE     NUM
        2693+ 1 2669          + TR        PRTIOCG
        2694+15 2847   PRTIOZ + LOAD MQ   D10          ACC=BASE48 CODE FOR '0'
        2695+ 1 2678          + TR        PRTOCTD      TR TO PRINT IT
        2696+13 2584 PRTINT   + STORE A   PRTP1        PARSE PRINT PARAMS LEN AND COL
        2697+10 2697          + R ADD     *            FOR PRINT OCTIONARY VALUE
        2698+ 1 2574          + TR        PRTPARM2
        2699+10 2644          + R ADD     COL          PRINT DECIMAL NUMBER. VALUE OF LEN = DIGITS TO PRINT, NOT INCLUDING SIGN
        2700+ 9 2838          + ADD       LEN
        2701+ 5 2844          + SUB       ONE          
        2702+12 2723          + STORE     COLNI        COL POINTS TO END OF NUMBER
        2703+10 2828          + R ADD     ZERO
        2704+12 2837          + STORE     SGN          SIGN IS POSITIVE
        2705+10 2834          + R ADD     NUM
        2706+ 3 2711          + TR +      PRTINTG
        2707+ 6 2834          + R SUB     NUM          NUM IS NEGATIVE. CONVERT TO POSITIVE
        2708+12 2834          + STORE     NUM          AND SET SGN=1
        2709+10 2844          + R ADD     ONE
        2710+12 2837          + STORE     SGN          
        2711+10 2834 PRTINTG  + R ADD     NUM          GENERATE DECIMAL DIGIT
        2712+21   35          + L RIGHT   0035         MQ=Acc
        2713+10 2828          + R ADD     ZERO
        2714+18 2847          + DIV       D10
        2715+ 4 2736          + TR 0      PRTINZ
        2716+12 2839 PRTINTG2 + STORE     CHAR         acc=remainder=digit to print, mq=num/10
        2717+10 2828          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW BIT SET
        2718+20   18          + L LEFT    0018         digit in left half-word of MQ to be saved in CHAR half word
        2719+14 2834          + STORE MQ  NUM 
        2720+15 2839          + LOAD MQ   CHAR 
        2721+10 2721 PRTINTD  + R ADD     *            PRINT DECIMAL DIGIT
        2722+ 1 2738          + TR        PRTCHR
        2723+ 0    0 COLNI    + STOP      0000
        2724+10 2723          + R ADD     COLNI        DECR COL NUMBER TO PRINT NEXT DIGIT
        2725+ 5 2844          + SUB       ONE
        2726+12 2723          + STORE     COLNI
        2727+10 2834          + R ADD     NUM          DO NOT CARE ABOUT LEN, JUST CHECK IF NUM=0 
        2728+ 4 2730          + TR 0      PRTINS       (SO NO MORE DIGITS REMAINS TO BE PRINTED)
        2729+ 1 2711          + TR        PRTINTG      NUM NOT FINISHED, PROCEED WITH NEXT DIGIT
        2730+10 2837 PRTINS   + R ADD     SGN
        2731+ 4 2661          + TR 0      EXIT         NO SIGN -> NUM FINISHED
        2732+10 2828          + R ADD     ZERO
        2733+12 2837          + STORE     SGN          CLEAR SGN FLAG
        2734+15 2848          + LOAD MQ   D11          BASE48 CODE FOR '-' (MINUS) CHAR
        2735+ 1 2721          + TR        PRTINTD      GO TO PRINT IT
        2736+10 2847   PRTINZ + R ADD     D10          ACC=BASE48 CODE FOR '0'
        2737+ 1 2716          + TR        PRTINTG2     TR TO PRINT IT
        2738+ 9 2845 PRTCHR   + ADD       TWO          PRINT CHAR IN MQ REGISTER 
        2739+14 2839          + STORE MQ  CHAR         SAVE CHAR TO PRINT (IN LEFT HALF WORD)
        2740+13 2744          + STORE A   PRTCP2       STORE ADDR OF PARAM (COL)
        2741+ 9 2844          + ADD       ONE
        2742+13 2822          + STORE A   PRTCEX
        2743+ 2 2744          + TR OV     PRTCP2       CLEAR OV JUST IN CASE
        2744+10    0   PRTCP2 + R ADD     /   /        GET COLUMN NUMBER PARAM 1..72
        2745+ 3 2748          + TR +      PRTCP4
        2746+13 2747          + STORE A   PRTCP3       COL<0 -> INTERPRET COL AS L(COL) = ADDR OF COL VAR
        2747+10    0   PRTCP3 + R ADD     /   /        READ VAR COL PASED AS PARAM
        2748+ 5 2844   PRTCP4 + SUB       ONE
        2749+12 2842          + STORE     N            N=COL-1 -> IN RANGE 0..71
        2750+ 3 2752          + TR +      PRTSA        IF N >= 0 PROCEED WITH BASE BUFFER ADDR CALCULATION
        2751+ 1 2822          + TR        PRTCEX       IF N<0 EXIT
        2752+10 2828    PRTSA + R ADD     ZERO         CARD BUFFER USES LOCATION 0..47
        2753+13 2841          + STORE A   PRTROWAD     DETERMINE ADDRESS OF LOWER ROW TO PRINT
        2754+10 2842          + R ADD     N
        2755+ 5 2850          + SUB       D36
        2756+ 3 2758          + TR +      PRTC0
        2757+ 1 2764          + TR        PRTC1
        2758+12 2842    PRTC0 + STORE     N            COL NOW 0..35 
        2759+ 5 2850          + SUB       D36
        2760+ 3 2822          + TR +      PRTCEX       IF COL >= 36 (IE COL PASSED AS PARAM > 72) THEN EXIT
        2761+10 2841          + R ADD     PRTROWAD
        2762+ 9 2845          + ADD       TWO
        2763+13 2841          + STORE A   PRTROWAD     SET BASE BUFFER ADDR 
        2764+10 2844    PRTC1 + R ADD     ONE          DETERMINE MASKCOL WITH MASK TO SET IN CARD BUFFER
        2765+21   53          + L RIGHT   53           SET RIGHTMOST BIT OF MQ TO 1 (SHIFT 35+18=53)
        2766+10 2849          + R ADD     D35
        2767+ 5 2842          + SUB       N
        2768+13 2770          + STORE A   PRTC2
        2769+10 2828          + R ADD     ZERO         CLEAR ACC TO AVOID OVERFLOW
        2770+20    0    PRTC2 + L LEFT    /   /        SHIFT MQ LEFT N PLACES
        2771+ 4 2774          + TR 0      PRTC3        IF ACC STILL ZERO -> MASKCOL VALID
        2772+ 6 2844          + R SUB     ONE          ACC NOT ZERO -> SHOULD GENERATE -0 TO SET SIGN BIT ON
        2773+21   72          + L RIGHT   0072         NOW MQ = -0 -> LEFTMOST BIT OF MQ SET
        2774-14 2830    PRTC3 - STORE MQ  MASKCOL
        2775+10 2828          + R ADD     ZERO         READ THE BITMAP OF CHAR 
        2776+11 2839          + ADD AB    CHAR         DISCARD SIGN OF CHAR, IF ANY
        2777+12 2839          + STORE     CHAR
        2778+ 5 2851          + SUB       D48
        2779+ 3 2822          + TR +      PRTCEX       IF CHAR >= 48 EXIT
        2780+10 2836          + R ADD     BITMAPAD     IF ADDR OF BASE48 BITMAP NOT COMPUTED
        2781+ 4 2823          + TR 0      GETBMP1      TR TO LOAD IT
        2782+ 9 2839  GETBMP2 + ADD       CHAR         READ THE BITMAP OF CHAR 
        2783+13 2784          + STORE A   PRTC4        INDICATES THE BITS TO SET IN SELECTED 
        2784+10    0    PRTC4 + R ADD     /   /        COLUMN OF CARD BUFFER 
        2785+12 2843          + STORE     BITS
        2786+ 6 2844          + R SUB     ONE
        2787+12 2842          + STORE     N            SET TO -1
        2788+10 2842    LOOP1 + R ADD     N            CURRENT ROW (STARTS AT ZERO) = OFFSET ON PRTROWAD     
        2789+ 9 2844          + ADD       ONE
        2790+12 2842          + STORE     N
        2791+10 2843          + R ADD     BITS         EXTRACT RIGHTMOST BIT OF LEFT HALF OF ACC TO MQ
        2792+ 4 2822          + TR 0      PRTCEX       NO MORE BITS -> EXIT
        2793+21   19          + L RIGHT   0019         LSB BIT OF LEFT HALF-WORD OF ACC TO MQ
        2794+22   18          + A LEFT    0018         BACK TO LEFT HALF OF ACC (BIT SHIFTED RIGHT 1 BIT)
        2795+12 2843          + STORE     BITS         SAVE BACK BITS. LSB HAS BEEN EXTACTED, CONTENTS SHIFTED RIGHT ONE PLACE
        2796+10 2828          + R ADD     ZERO
        2797+20    1          + L LEFT    0001         PUT EXTACTED BIT BACK INTO ACC
        2798+ 4 2788          + TR 0      LOOP1        NO BIT 
        2799+10 2842          + R ADD     N            READ THE ROW N AT CARD BUFFER 
        2800+22    2          + A LEFT    0002         MULT N BY 4 AS THERE ARE 4 HALF WORDS PER ROW
        2801+ 9 2841          + ADD       PRTROWAD     
        2802+13 2804          + STORE A   PRTROWR
        2803+13 2820          + STORE A   PRTROWW
        2804-10    0  PRTROWR - R ADD     /   /        
        2805-12 2832          - STORE     ROW          CURRENT CONTENTS OF ROW
        2806-10 2830          - R ADD     MASKCOL      "OR" MASKCOL IN SELECTED ROW
        2807+ 3 2815          + TR +      PRTW2
        2808-10 2832          - R ADD     ROW 
        2809+ 4 2813          + TR 0      PRTW1         
        2810+10 2828          + R ADD     ZERO         MASKCOL IS MINUS ZERO AND ROW IS NOT-EMPTY (EITHER POSITIVE OR NEGATIVE) -> SET ROW AS NEGATIVE
        2811- 7 2832          - SUB AB    ROW 
        2812+ 1 2820          + TR        PRTROWW
        2813-10 2830    PRTW1 - R ADD     MASKCOL      MASKCOL IS MINUS ZERO AND ROW IS EMPTY -> SET ROW = MASKCOL = MINUS ZERO
        2814+ 1 2820          + TR        PRTROWW
        2815-10 2832    PRTW2 - R ADD     ROW          
        2816+ 3 2819          + TR +      PRTW3              
        2817- 5 2830          - SUB       MASKCOL      MASKCOL IS POSITIVE AND ROW IS NEGATIVE -> SUB MASKCOL FROM ROW
        2818+ 1 2820          + TR        PRTROWW
        2819- 9 2830    PRTW3 - ADD       MASKCOL      MASKCOL IS POSITIVE AND ROW IS POSITIVE OR EMPTY -> ADD MASKCOL TO ROW         
        2820-12    0  PRTROWW - STORE     /   /        ROW UPDTATE
        2821+ 1 2788          + TR        LOOP1        PROCEED TO NEXT ROW
        2822+ 1    0 PRTCEX   + TR        /   /
        2823+10 2823 GETBMP1  + R ADD     *
        2824+ 1   83          + TR        BMPAD        GET BASE48 CHARS BITMAP ADDRESS
        2825+12 2836          + STORE     BITMAPAD     
        2826+ 1 2782          + TR        GETBMP2      RETURN
        2827+     0             ORG       EVEN
        2828+     0  ZERO       DEF       0            
        2829+     0             DEF       0            
        2830+     0  MASKCOL    DEF       0
        2831+     0             DEF       0
        2832+     0  ROW        DEF       0
        2833+     0             DEF       0
        2834+     0  NUM        DEF       0
        2835+     0             DEF       0
        2836+     0  BITMAPAD   DEF       0
        2837+     0  SGN        DEF       0
        2838+     0  LEN        DEF       0
        2839+     0  CHAR       DEF       0
        2840+     0  TXT        DEF       0
        2841+     0  PRTROWAD   DEF       0
        2842+     0  N          DEF       0
        2843+     0  BITS       DEF       0
        2844+     1  ONE        DEF       1
        2845+     2  TWO        DEF       2
        2846+     3  D3         DEF       3
        2847+    10  D10        DEF       10
        2848+    11  D11        DEF       11
        2849+    35  D35        DEF       35
        2850+    36  D36        DEF       36
        2851+    48  D48        DEF       48
        2852+    72  D72        DEF       72
        2853+  2304  D48X48     DEF       2304
        2854+ 16384  OCT04K     DEF       *040000      BIT SIGN ON 5TH OCTINARY DIGIT
        2856+ 9 2931 PRTNLINE + ADD       TWO          PRINT A NEW LINE OF DATA
        2857+12 2934          + STORE     PARAM        SAVE PARAM LIST ADDR
        2858+10 2858          + R ADD     *            CLEAR CARD BUFFER
        2859+ 1   51          + TR        CLRBUF 
        2860+10 2934 GPARAM   + R ADD     PARAM        GET PARAM PAIR FMT/DATA
        2861+13 2866          + STORE A   P1
        2862+ 9 2930          + ADD       ONE
        2863+13 2870          + STORE A   P2
        2864+ 9 2930          + ADD       ONE
        2865+12 2934          + STORE     PARAM
        2866+10    0 P1       + R ADD     /   /
        2867+12 2936          + STORE     FMT
        2868+ 3 2870          + TR +      P2           IF FMT < 0 THEM SKIP THIS PAIR FMT/DATA
        2869+ 1 2860          + TR        GPARAM
        2870+10    0 P2       + R ADD     /   /
        2871+12 2896          + STORE     DATALOC      GET DATA ADDRESS PASED AS PARAM
        2872+13 2873          + STORE A   P2A
        2873+10    0 P2A      + R ADD     /   /
        2874+12 2935          + STORE     DATA         GET EFFECTIVE DATA
        2875+10 2929          + R ADD     ZERO
        2876+15 2936          + LOAD MQ   FMT
        2877+18 2933          + DIV       D100         ACC=REMAINDER=COL NUMBER, MQ=QUOTIEN=TYPE OF DATA
        2878+12 2937          + STORE     COL
        2879+10 2929          + R ADD     ZERO
        2880+20   18          + L LEFT    0018
        2881+14 2936          + STORE MQ  FMT
        2882+15 2935          + LOAD MQ   DATA
        2883+10 2887          + R ADD     TYPETRAD
        2884+ 9 2936          + ADD       FMT
        2885+13 2886          + STORE A   TYPETR
        2886+ 1    0 TYPETR   + TR        /   /        TR SELECTED ROUTINE
        2887+ 0 2888 TYPETRAD + STOP      TYPETRT      TYPE TRANSFER TABLE ADDRESS
        2888+ 1 2917 TYPETRT  + TR        EOL          FMT=0..6 (IE <100) -> END OF PARAM LIST -> END OF LINE 
        2889+ 1 2894          + TR        TYSTR        FMT=1 -> PRINT A STRINGZ
        2890+ 1 2899          + TR        TYINT        FMT=2 -> PRINT AN INT
        2891+ 1 2904          + TR        TYOCT        FMT=3 -> PRINT AN OCT
        2892+ 1 2909          + TR        TYCHR        FMT=4 -> PRINT A CHAR
        2893+ 1 2913          + TR        TYALF        FMT=5 -> PRINT A 3-CHR PACKED ALFA STRING
        2894+10 2894 TYSTR    + R ADD     *            PRINT STRINGZ
        2895+ 1   57          + TR        PRTSTR
        2896+ 0    0 DATALOC  + STOP      /   /
        2897- 0 2937          - STOP      COL          COLUMN WHERE TXT STARTS
        2898+ 1 2860          + TR        GPARAM
        2899+10 2899 TYINT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2900+ 1   59          + TR        PRTINT
        2901+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        2902- 0 2937          - STOP      COL          COLUMN WHERE TXT STARTS
        2903+ 1 2860          + TR        GPARAM
        2904+10 2904 TYOCT    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2905+ 1   81          + TR        PRTOCT
        2906+ 0    6          + STOP      0006         UP TO 6 DECIMAL DIGITS 
        2907- 0 2937          - STOP      COL          COLUMN WHERE TXT STARTS
        2908+ 1 2860          + TR        GPARAM
        2909+10 2909 TYCHR    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2910+ 1   55          + TR        PRTCHR
        2911- 0 2937          - STOP      COL          COLUMN WHERE TXT STARTS
        2912+ 1 2860          + TR        GPARAM
        2913+10 2913 TYALF    + R ADD     *            MQ ALREADY LOADED WITH DATA TO PRINT
        2914+ 1   61          + TR        PRTALF
        2915- 0 2937          - STOP      COL          COLUMN WHERE TXT STARTS
        2916+ 1 2860          + TR        GPARAM
        2917+10 2937 EOL      + R ADD     COL          SEND CARD BUFFER TO PRINTER AND RETURN TO CALLER
        2918+ 4 2923          + TR 0      DOPRINT      =0 -> PRINT ALLWAYS (NO SENSE SW CHECK)
        2919+ 9 2932          + ADD       D68          =1..6 -> SENSE 69..74 = OPERATOR'S PANEL SENSE SWITCH 1..6
        2920+13 2921          + STORE A   CHKSW
        2921+30    0 CHKSW    + SENSE     /   /         
        2922+ 1 2925          + TR        RETURN       SW NOT AT ON POSITION
        2923+10 2923 DOPRINT  + R ADD     *            PRINT CARD BUFFER
        2924+ 1   77          + TR        PRINTCRD
        2925+10 2934 RETURN   + R ADD     PARAM        PARAM-1 IS THE RETURN ADDR      
        2926+ 5 2930          + SUB       ONE
        2927+13 2928          + STORE A   EXIT
        2928+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        2929+ 0    0 ZERO     + STOP      0000
        2930+ 0    1 ONE      + STOP      0001
        2931+ 0    2 TWO      + STOP      0002
        2932+ 0   68 D68      + STOP      0068
        2933+ 0  100 D100     + STOP      100
        2934+ 0    0 PARAM    + STOP      0000
        2935+ 0    0 DATA     + STOP      0000
        2936+ 0    0 FMT      + STOP      0000
        2937+ 0    0 COL      + STOP      0000
        2938+ 9 2952 BMPAD    + ADD       TWO
        2939+13 2941          + STORE A   EXIT
        2940+10 2942          + R ADD     BITMAPAD
        2941+ 1    0 EXIT     + TR        /   /
        2942+ 0 2944 BITMAPAD + STOP      BITMAP
        2943+     0             ORG       EVEN
        2944+     0  BITMAP     DEF       0              <blank>     0     <none>
        2945+   256             DEF       256               1        1       1        256          =  256   
        2946+   128             DEF       128               2        2       2        128          =  128   
        2947+    64             DEF       64                3        3       3         64          =   64   
        2948+    32             DEF       32                4        4       4         32          =   32   
        2949+    16             DEF       16                5        5       5         16          =   16   
        2950+     8             DEF       8                 6        6       6          8          =    8   
        2951+     4             DEF       4                 7        7       7          4          =    4   
        2952+     2  TWO        DEF       2                 8        8       8          2          =    2   
        2953+     1             DEF       1                 9        9       9          1          =    1   
        2954+   512             DEF       512               0       10       0        512          =  512   
        2955+  1024             DEF       1024              -       11       X       1024          = 1024   
        2956+  2048             DEF       2048              +       12       Y       2048          = 2048   
        2957+  2304             DEF       2304              A       13      Y-1        256+2048    = 2304   
        2958+  2176             DEF       2176              B       14      Y-2        128+2048    = 2176   
        2959+  2112             DEF       2112              C       15      Y-3         64+2048    = 2112   
        2960+  2080             DEF       2080              D       16      Y-4         32+2048    = 2080   
        2961+  2064             DEF       2064              E       17      Y-5         16+2048    = 2064   
        2962+  2056             DEF       2056              F       18      Y-6          8+2048    = 2056   
        2963+  2052             DEF       2052              G       19      Y-7          4+2048    = 2052   
        2964+  2050             DEF       2050              H       20      Y-8          2+2048    = 2050   
        2965+  2049             DEF       2049              I       21      Y-9          1+2048    = 2049   
        2966+  1280             DEF       1280              J       22      X-1        256+1024    = 1280   
        2967+  1152             DEF       1152              K       23      X-2        128+1024    = 1152   
        2968+  1088             DEF       1088              L       24      X-3         64+1024    = 1088   
        2969+  1056             DEF       1056              M       25      X-4         32+1024    = 1056   
        2970+  1040             DEF       1040              N       26      X-5         16+1024    = 1040   
        2971+  1032             DEF       1032              O       27      X-6          8+1024    = 1032   
        2972+  1028             DEF       1028              P       28      X-7          4+1024    = 1028   
        2973+  1026             DEF       1026              Q       29      X-8          2+1024    = 1026   
        2974+  1025             DEF       1025              R       30      X-9          1+1024    = 1025   
        2975+   640             DEF       640               S       31      0-2        128+512     = 640    
        2976+   576             DEF       576               T       32      0-3         64+512     = 576    
        2977+   544             DEF       544               U       33      0-4         32+512     = 544    
        2978+   528             DEF       528               V       34      0-5         16+512     = 528    
        2979+   520             DEF       520               W       35      0-6          8+512     = 520    
        2980+   516             DEF       516               X       36      0-7          4+512     = 516    
        2981+   514             DEF       514               Y       37      0-8          2+512     = 514    
        2982+   513             DEF       513               Z       38      0-9          1+512     = 513    
        2983+   578             DEF       578               ,       39      8-3-0        2+64+512  = 578    
        2984+   546             DEF       546               %       40      8-4-0        2+32+512  = 546    
        2985+  1090             DEF       1090              $       41      8-3-X        2+64+1024 = 1090   
        2986+  1058             DEF       1058              *       42      8-4-X        2+32+1024 = 1058   
        2987+  2114             DEF       2114              .       43      8-3-Y        2+64+2048 = 2114   
        2988+  2082             DEF       2082              #       44      8-4-Y        2+32+2048 = 2082   
        2989+   768             DEF       768               /       45      0-1          512+256   = 768    
        2990+    66             DEF       66                +       46      8-3          2+64      = 66     
        2991+    34             DEF       34                -       47      8-4          2+32      = 34    This is the non-minus-sign separator
        2992+ 9 3016 CLMEM    + ADD       TWO 
        2993+13 2998          + STORE A   P1           PARM: ADDR 
        2994+ 9 3015          + ADD       ONE          
        2995+13 3000          + STORE A   P2           PARM: LOCATION OF LEN=NUMBER OF HALF-WORDS TO CLEAR 
        2996+ 9 3015          + ADD       ONE          
        2997+13 3006          + STORE A   EXIT
        2998+10    0 P1       + R ADD     /   /        GET ADDR TO CLEAR
        2999+13 3009          + STORE A   MEM
        3000+10    0 P2       + R ADD     /   /        GET LEN ADDR
        3001+13 3002          + STORE A   P2A
        3002+10    0 P2A      + R ADD     /   /        GET LEN 
        3003+12 3017          + STORE     LEN
        3004+15 3014          + LOAD MQ   ZERO
        3005+10 3017 LOOP     + R ADD     LEN
        3006+ 4    0 EXIT     + TR 0      /   /
        3007+ 5 3015          + SUB       ONE
        3008+12 3017          + STORE     LEN
        3009+14    0 MEM      + STORE MQ  /   /        
        3010+10 3009          + R ADD     MEM
        3011+ 9 3015          + ADD       ONE
        3012+13 3009          + STORE A   MEM
        3013+ 1 3005          + TR        LOOP
        3014+ 0    0 ZERO     + STOP      0000
        3015+ 0    1 ONE      + STOP      0001         constant 1
        3016+ 0    2 TWO      + STOP      0002         constant 2
        3017+ 0    0 LEN      + STOP      0000
        3018+ 9 3050 MEMCOPY  + ADD       TWO 
        3019+13 3026          + STORE A   P1           PARM: SRCADDR 
        3020+ 9 3049          + ADD       ONE          
        3021+13 3028          + STORE A   P2           PARM: DESTADDR
        3022+ 9 3049          + ADD       ONE          
        3023+13 3030          + STORE A   P3           PARM: LEN: LOCATION OF LEN=NUMBER OF HALF-WORDS TO CLEAR
        3024+ 9 3049          + ADD       ONE          
        3025+13 3036          + STORE A   EXIT
        3026+10    0 P1       + R ADD     /   /        GET SOURCE ADDR 
        3027+13 3039          + STORE A   MEMS
        3028+10    0 P2       + R ADD     /   /        GET DESTINATION ADDR 
        3029+13 3040          + STORE A   MEMD
        3030+10    0 P3       + R ADD     /   /        GET LEN ADDR
        3031+13 3032          + STORE A   P3A
        3032+10    0 P3A      + R ADD     /   /        GET LEN           
        3033+12 3051          + STORE     LEN
        3034+15 3048          + LOAD MQ   ZERO
        3035+10 3051 LOOP     + R ADD     LEN
        3036+ 4    0 EXIT     + TR 0      /   /
        3037+ 5 3049          + SUB       ONE
        3038+12 3051          + STORE     LEN
        3039+10    0 MEMS     + R ADD     /   /        
        3040+12    0 MEMD     + STORE     /   /        
        3041+10 3039          + R ADD     MEMS
        3042+ 9 3049          + ADD       ONE
        3043+13 3039          + STORE A   MEMS
        3044+10 3040          + R ADD     MEMD
        3045+ 9 3049          + ADD       ONE
        3046+13 3040          + STORE A   MEMD
        3047+ 1 3035          + TR        LOOP
        3048+ 0    0 ZERO     + STOP      0000
        3049+ 0    1 ONE      + STOP      0001         constant 1
        3050+ 0    2 TWO      + STOP      0002         constant 2
        3051+ 0    0 LEN      + STOP      0000
        3052+15 3119 SRCHTBL  + LOAD MQ   ZERO
        3053+ 1 3057          + TR        START
        3054+15 3120 EQTBL    + LOAD MQ   ONE
        3055+ 1 3057          + TR        START
        3056+15 3121 READTBL  + LOAD MQ   TWO
        3057+ 9 3121 START    + ADD       TWO 
        3058+13 3065          + STORE A   P1           PARM: ADDR OF TABLE
        3059+ 9 3120          + ADD       ONE          
        3060+13 3067          + STORE A   P2           PARM: LEN OF TABLE
        3061+ 9 3120          + ADD       ONE          
        3062+13 3072          + STORE A   P3           PARM: VAL TO FIND
        3063+ 9 3120          + ADD       ONE          
        3064+13 3113          + STORE A   EXIT
        3065+10    0 P1       + R ADD     /   /        GET ADDR OF TABLE
        3066+13 3116          + STORE A   TBL
        3067+10    0 P2       + R ADD     /   /        GET ADDR OF LEN OF TABLE/ENTRY ON TABLE
        3068+13 3069          + STORE A   P2A
        3069+10    0 P2A      + R ADD     /   /        DERREFERENCE -> ACC=LEN/ENTRY (1..LEN)
        3070+12 3114          + STORE     N
        3071+ 4 3113          + TR 0      EXIT         EXIT, CANNOT READ/STORE ON ENTRY 0, SEARCH ON EMPTY TABLE
        3072+10    0 P3       + R ADD     /   /        GET ADDR OF VAL TO FIND
        3073+13 3089          + STORE A   WRVAL
        3074+13 3075          + STORE A   P3A
        3075+10    0 P3A      + R ADD     /   /        DERREFERENCE -> ACC=VAL
        3076+12 3115          + STORE     VAL
        3077+14 3118          + STORE MQ  TEMP         JUMP TABLE DISPATCH
        3078+10 3118          + R ADD     TEMP
        3079+ 4 3094          + TR 0      LOOP0        TR TO SEARCH TABLE
        3080+10 3114          + R ADD     N            SUB ONE AS FIRST ENTRY ON TABLE IS "1"
        3081+ 5 3120          + SUB       ONE          
        3082+ 9 3116          + ADD       TBL          TABLE BASE ADDR
        3083+13 3092          + STORE A   WRTBL
        3084+13 3088          + STORE A   RDTBL2
        3085+10 3118          + R ADD     TEMP
        3086+ 5 3120          + SUB       ONE
        3087+ 4 3091          + TR 0      STORETBL 
        3088+10    0 RDTBL2   + R ADD     /   /        VAL=TBL[ENT]
        3089+12    0 WRVAL    + STORE     /   /
        3090+ 1 3113          + TR        EXIT
        3091+10 3115 STORETBL + R ADD     VAL          TBL[ENT]=VAL
        3092+12    0 WRTBL    + STORE     /   /    
        3093+ 1 3113          + TR        EXIT
        3094+10 3116 LOOP0    + R ADD     TBL
        3095+13 3101          + STORE A   RDTBL
        3096+10 3101          + R ADD     RDTBL
        3097+12 3117          + STORE     TBL0
        3098+ 9 3114          + ADD       N
        3099+12 3118          + STORE     TEMP         THE END ADDR OF TABLE
        3100+10 3115 LOOP     + R ADD     VAL          ACC=THE SEARCHED VALUE
        3101+ 5    0 RDTBL    + SUB       /   /    
        3102+ 2 3103          + TR OV     OVOK         CLEAR OV JUST IN CASE
        3103+ 4 3110 OVOK     + TR 0      FOUND        TR IF VAL FOUND IN ENTRY N
        3104+10 3101          + R ADD     RDTBL
        3105+ 9 3120          + ADD       ONE
        3106+13 3101          + STORE A   RDTBL
        3107+ 5 3118          + SUB       TEMP
        3108+ 4 3113          + TR 0      EXIT         NOT FOUND -> RETURN ZERO
        3109+ 1 3100          + TR        LOOP
        3110+10 3101 FOUND    + R ADD     RDTBL        RETURN ENTRY FOUND
        3111+ 5 3117          + SUB       TBL0
        3112+ 9 3120          + ADD       ONE
        3113+ 1    0 EXIT     + TR        /   /
        3114+ 0    0 N        + STOP      0000
        3115+ 0    0 VAL      + STOP      0000
        3116+ 0    0 TBL      + STOP      0000
        3117+ 0    0 TBL0     + STOP      0000
        3118+ 0    0 TEMP     + STOP      0000
        3119+ 0    0 ZERO     + STOP      0000
        3120+ 0    1 ONE      + STOP      0001         constant 1
        3121+ 0    2 TWO      + STOP      0002         constant 2
        3122+ 9 3195 RWDRUM   + ADD       TWO 
        3123+13 3132          + STORE A   PDR1         PARM1: DRUM INSTR: READ/WRITE 0128  0129  0130  0131
        3124+ 9 3194          + ADD       ONE          
        3125+13 3134          + STORE A   PDR2         PARM2: DRUM ADDRESS (0..4094)
        3126+ 9 3194          + ADD       ONE          
        3127+13 3136          + STORE A   PDR3         PARM3: BUF START ADDRESS
        3128+ 9 3194          + ADD       ONE          
        3129+13 3138          + STORE A   PDR4         PARM4: LEN: NUMBER OF HALF-WORDS (MUST BE EVEN)
        3130+ 9 3194          + ADD       ONE          
        3131+13 3192          + STORE A   EXIT               
        3132+10    0 PDR1     + R ADD     /   /        GET DRUM INSTR
        3133+12 3140          + STORE     DRIO
        3134+10    0 PDR2     + R ADD     /   /        GET DRUM ADDR
        3135+13 3141          + STORE A   DRADDR
        3136+10    0 PDR3     + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        3137+13 3179          + STORE A   RWCOPY    
        3138+10    0 PDR4     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        3139+12 3196          + STORE     LEN
        3140+ 0    0 DRIO     + STOP      /   /        INSTR: READ/WRITE 0128  0129  0130  0131
        3141+29    0 DRADDR   + SET DR    /   /
        3142+ 1 3175          + TR        LOOP
        3143+ 9 3195 RDTAPE   + ADD       TWO 
        3144+13 3151          + STORE A   PR1          PARM1: TAPE ADDRESS
        3145+ 9 3194          + ADD       ONE          
        3146+13 3153          + STORE A   PR2          PARM2: BUF START ADDRESS
        3147+ 9 3194          + ADD       ONE          
        3148+13 3192          + STORE A   EXIT
        3149+ 2 3150          + TR OV     CLOV1        CLEAR OV THAT MAY HAVE BEEN SET
        3150+ 8    0    CLOV1 + NOOP      0000
        3151+10    0 PR1      + R ADD     /   /        GET TAPE ADDR
        3152+13 3155          + STORE A   RTAPAD       TAPE UNITS: 0256  0257  0258  0259
        3153+10    0 PR2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        3154+13 3179          + STORE A   RWCOPY    
        3155+24    0 RTAPAD   + READ      /   /
        3156+10 3193          + R ADD     ZERO
        3157+ 1 3177          + TR        LOOP1
        3158+ 9 3195 WRTAPE   + ADD       TWO 
        3159+13 3166          + STORE A   PW1          PARM1: TAPE ADDRESS
        3160+ 9 3194          + ADD       ONE          
        3161+13 3168          + STORE A   PW2          PARM2: BUF START ADDRESS
        3162+ 9 3194          + ADD       ONE          
        3163+13 3170          + STORE A   PW3          PARM3: BUF LEN
        3164+ 9 3194          + ADD       ONE          
        3165+13 3192          + STORE A   EXIT
        3166+10    0 PW1      + R ADD     /   /        GET TAPE ADDR
        3167+13 3174          + STORE A   WTAPAD       TAPE UNITS: 0256  0257  0258  0259
        3168+10    0 PW2      + R ADD     /   /        GET BUF ADDR (MUST BE EVEN)
        3169+13 3179          + STORE A   RWCOPY    
        3170+10    0 PW3      + R ADD     /   /        GET ADDR OF LEN 
        3171+13 3172          + STORE A   PW3A
        3172+10    0 PW3A     + R ADD     /   /        GET BUF LEN (MUST BE EVEN, CAN BE 0)
        3173+12 3196          + STORE     LEN
        3174+26    0 WTAPAD   + WRITE     /   /        PREPARE TO WRITE ON TAPE
        3175+10 3196 LOOP     + R ADD     LEN
        3176+ 4 3191          + TR 0      RWOK
        3177+ 5 3195 LOOP1    + SUB       TWO
        3178+12 3196          + STORE     LEN
        3179-31    0 RWCOPY   - COPY      /   /        WRITE BUFFER TO TAPE
        3180+ 1 3183          + TR        GO 
        3181+ 1 3187          + TR        EOF          END OF FILE
        3182+ 1 3189          + TR        EOR          END OF RECORD
        3183+10 3179 GO       + R ADD     RWCOPY
        3184+ 5 3195          + SUB       TWO
        3185+13 3179          + STORE A   RWCOPY
        3186+ 1 3175          + TR        LOOP
        3187+10 3194 EOF      + R ADD     ONE          SET OV FLAG TO SIGNAL END OF FILE CONDITION
        3188+22   36          + A LEFT    36
        3189+ 6 3196 EOR      + R SUB     LEN          RETURN NUMBER OF HALF-WORDS READ
        3190+ 5 3195          + SUB       TWO
        3191+26 2052 RWOK     + WRITE     2052         INSURE THAT MQ NOT IN USE            
        3192+ 1    0 EXIT     + TR        /   /        RETURN TO CALLER
        3193+ 0    0 ZERO     + STOP      0000
        3194+ 0    1 ONE      + STOP      0001         
        3195+ 0    2 TWO      + STOP      0002         
        3196+     0  LEN        RES       1
        3198+ 9 3230 CHKSUM   + ADD       TWO          CALC CHEKSUM 
        3199+13 3202          + STORE A   CKP1
        3200+ 9 3229          + ADD       ONE
        3201+13 3223          + STORE A   CHKSUMEX     RETURN ADDR
        3202+10    0 CKP1     + R ADD     /   /        GET CARD IMAGE ADDRESS
        3203+13 3209          + STORE A   RDDATA
        3204+ 9 3231          + ADD       D46
        3205+13 3220          + STORE A   RDEND
        3206+10 3228          + R ADD     ZERO
        3207-12 3226          - STORE     SUM
        3208-12 3224          - STORE     DATA
        3209+10    0 RDDATA   + R ADD     /   /
        3210+12 3225          + STORE     DATA2
        3211-10 3224          - R ADD     DATA
        3212- 9 3226          - ADD       SUM
        3213-12 3226          - STORE     SUM
        3214+10 3209          + R ADD     RDDATA
        3215+ 9 3229          + ADD       ONE
        3216+13 3209          + STORE A   RDDATA
        3217+ 5 3220          + SUB       RDEND
        3218+ 4 3221          + TR 0      CHKSUM2
        3219+ 1 3209          + TR        RDDATA
        3220+10    0 RDEND    + R ADD     0000         
        3221-10 3226 CHKSUM2  - R ADD     SUM
        3222- 9 3226          - ADD       SUM          ADD TWICE -> CHKSUM IS DOUBLED -> CHKSUM IS SHIFTED TO LEFT ONE BIT -> RIGHTMOST BIT IS ZERO
        3223+ 1    0 CHKSUMEX + TR        /   /
        3224+     0  DATA       DEF       0            CHECKSUM CALCULATION WORDS
        3225+     0  DATA2      DEF       0
        3226+     0  SUM        DEF       0            
        3227+     0             DEF       0
        3228+     0  ZERO       DEF       0
        3229+     1  ONE        DEF       1
        3230+     2  TWO        DEF       2
        3231+    46  D46        DEF       46
        3232+ 9 3464 WRIBREL  + ADD       TWO          CHECK IF CURRENT CARD IN MEMORY IS TYPE/SYMBOL GIVEN AS PARAM, 
        3233+13 3246          + STORE A   CHKP1        LOC OF DATA TO ADD IS IN SEQUENCE WITH PREVIOUS ONES, AND CARD HAS ROOM FOR DATA.
        3234+ 9 3463          + ADD       ONE          IF NOT, FLUSH CURRENT CARD AND CREATE A NEW ONE, THEN PLACE THE DATA.
        3235+13 3248          + STORE A   CHKP2        WHEN FLUSHING THE CARD, CALL WRITE ROUTINE DEFINED
        3236+ 9 3463          + ADD       ONE
        3237+13 3252          + STORE A   CHKP3
        3238+ 9 3463          + ADD       ONE
        3239+13 3256          + STORE A   CHKP4
        3240+ 9 3463          + ADD       ONE
        3241+13 3258          + STORE A   CHKP5
        3242+ 9 3463          + ADD       ONE
        3243+13 3262          + STORE A   CHKP6
        3244+ 9 3463          + ADD       ONE
        3245+13 3368          + STORE A   CHKEXIT
        3246+10    0 CHKP1    + R ADD     /   /
        3247+12 3454          + STORE     CRDTY        PARAM: BIN CARD TYPE REQUITED: -01 -> CONTROL CARD, -00 -> MC INSTR CARD, 
        3248+10    0 CHKP2    + R ADD     /   /                                       +01 -> FLUSH CURRENT CARD (NO MORE PARAMS)
        3249+13 3250          + STORE A   CHKP2A                                      +02 -> SET WRITE CARD ROUTINE TO BE CALLED IN NEXT PARAM 
        3250+10    0 CHKP2A   + R ADD     /   /                                              RETURNS IN ACC THE ADDR OF BINCARD BUFFER TO BE WRITTEN
        3251+12 3455          + STORE     CRDSY        
        3252+10    0 CHKP3    + R ADD     /   /
        3253+13 3254          + STORE A   CHKP3A
        3254+10    0 CHKP3A   + R ADD     /   /
        3255+12 3456          + STORE     CRDLOC       PARAM: LOCATION 0..4095 
        3256+10    0 CHKP4    + R ADD     /   /
        3257+12 3457          + STORE     CRDDATY      PARAM: DATA TYPE: =0 -> DATA1=DATA TO STORE, DATA2=INDEX TAG
        3258+10    0 CHKP5    + R ADD     /   /                          =1 -> DATA1/DATA2=FULL WORD TO STORE
        3259+13 3260          + STORE A   CHKP5A
        3260+10    0 CHKP5A   + R ADD     /   /
        3261+12 3460          + STORE     CRDDATA      PARAM: DATA 
        3262+10    0 CHKP6    + R ADD     /   /        
        3263+13 3264          + STORE A   CHKP6A
        3264+10    0 CHKP6A   + R ADD     /   /
        3265+12 3461          + STORE     CRDDATA2     PARAM: DATA2 (RIGHT HALF-WORD / INDEX TAG)
        3266+10 3454          + R ADD     CRDTY        
        3267+ 5 3463          + SUB       ONE
        3268+ 4 3369          + TR 0      CHKFLSHR     IF CRDTY=1 -> JUST FLUSH THE CURRENT CARD AND RETURN
        3269+ 5 3463          + SUB       ONE
        3270+ 4 3378          + TR 0      CHKWR        IF CRDTY=2 -> SET WRITE CARD ROUTINE TO BE CALLED WHEN FLUSHING THE CURRENT CARD AND RETURN
        3271+10 3446          + R ADD     BINCRD44     CODE + ORIGIN IN CARD IN MEMORY. 
        3272+13 3458          + STORE A   CRDORG
        3273+ 3 3302          + TR +      CHKNEWC      IF >=0 -> CREATE A FRESH NEW CARD 
        3274+23   12          + A RIGHT   0012         GET CODE ON CURRENT CARD BEING BUILD IE MEM
        3275+23   18          + A RIGHT   0018         CLEAR RIGHT ACC HALF-WORD
        3276+22   18          + A LEFT    0018
        3277+ 5 3454          + SUB       CRDTY
        3278+ 4 3280          + TR 0      CHK1         SAME TYPE, TR TO CONTINUE
        3279+ 1 3300          + TR        CHKFLSH      NOT SAME TYPE, TR TO FLUSH CURRENT CARD 
        3280+10 3447 CHK1     + R ADD     BINCRD45     CURRENT CARD SYMBOL
        3281+ 5 3455          + SUB       CRDSY
        3282+ 4 3284          + TR 0      CHK2         SAME TOP SYMBOL, TR TO CONTINUE
        3283+ 1 3300          + TR        CHKFLSH      NOT SAME SYMBOL, TR TO FLUSH CURRENT CARD 
        3284+10 3444 CHK2     + R ADD     BINCRD42     COUNT IN CARD
        3285+ 5 3467          + SUB       D36
        3286+ 4 3300          + TR 0      CHKFLSH      CARD FULL, TR TO FLUSH CURRENT CARD 
        3287+10 3458          + R ADD     CRDORG
        3288+ 9 3444          + ADD       BINCRD42     ACC=ORIGIN + COUNT = NEXT CONSECUTIVE REL LOCATION ON BIN CARD
        3289+ 5 3456          + SUB       CRDLOC       
        3290+ 4 3313          + TR 0      CHKADD       IF ORIGIN+COUNT=LOC -> ADD DATA TO CURRENT CARD IN MEMORY, AT NEXT CONSECUTIVE LOCATION LOC
        3291+ 3 3300          + TR +      CHKFLSH      IF ORIGIN+COUNT>LOC -> LOC IS LESS THAN LAST LOC ADDED -> TR TO FLUSH AND START A NEW CARD AT NEW LOC
        3292+10 3456          + R ADD     CRDLOC
        3293+ 5 3458          + SUB       CRDORG       ACC=LOC - ORIGIN = POSITION IN CARD 
        3294+12 3459          + STORE     CRDN
        3295+ 5 3467          + SUB       D36          
        3296+ 3 3300          + TR +      CHKFLSH      IF POSITION IN CARD >= 36 -> LOC DOES NOT FIT IN CURRENT CARD -> TR TO FLUSH
        3297+10 3459          + R ADD     CRDN         ELSE -> POSITION IN CARD < 36 -> LOC FITS IN CURRENT CARD
        3298+12 3444          + STORE     BINCRD42     ADJUST COUNT
        3299+ 1 3313          + TR        CHKADD       TR TO ADD DATA TO CURRENT CARD IN MEMORY
        3300+10 3300 CHKFLSH  + R ADD     *            
        3301+ 1 3389          + TR        FLUSHCRD 
        3302+10 3302 CHKNEWC  + R ADD     *            NEW CARD: CLEAR CARD BUFFER IN MEM
        3303+ 1   89          + TR        CLMEM        BINCARD
        3304+ 0 3402          + STOP      BINCARD
        3305+ 0 3468          + STOP      D48
        3306+10 3454          + R ADD     CRDTY        CODE   = -01 / -00 
        3307+22   12          + A LEFT    0012         PLACE AS OP
        3308+ 5 3456          + SUB       CRDLOC       ORIGIN = CURRENT LOC
        3309+12 3446          + STORE     BINCRD44     STORE CODE + ORIGIN IN CARD IN MEMORY. 
        3310+13 3458          + STORE A   CRDORG
        3311+10 3455          + R ADD     CRDSY        SYMBOL 
        3312+12 3447          + STORE     BINCRD45     CURRENT CARD SYMBOL
        3313+10 3456 CHKADD   + R ADD     CRDLOC       COMPUTE WHERE TO STORE THE DATA
        3314+ 5 3458          + SUB       CRDORG       ADDR = BINCRD ADDRESS + (LOC - ORIGIN)
        3315+ 9 3388          + ADD       BINCRDAD 
        3316+13 3318          + STORE A   CHKSTO1
        3317+10 3460          + R ADD     CRDDATA      STORE DATA
        3318+12    0 CHKSTO1  + STORE     /   /
        3319+10 3457          + R ADD     CRDDATY      PARAM: DATA TYPE: =0 -> DATA1=DATA TO STORE, DATA2=INDEX TAG
        3320+ 4 3330          + TR 0      CHKIDX                         =1 -> DATA1/DATA2=FULL WORD TO STORE
        3321+10 3318          + R ADD     CHKSTO1      STORE A FULL WORD
        3322+ 9 3463          + ADD       ONE       
        3323+13 3325          + STORE A   CHKSTO2
        3324+10 3461          + R ADD     CRDDATA2     STORE DATA2
        3325+12    0 CHKSTO2  + STORE     /   /
        3326+10 3444          + R ADD     BINCRD42     COUNT IN CARD
        3327+ 9 3464          + ADD       TWO
        3328+12 3444          + STORE     BINCRD42     
        3329+ 1 3368          + TR        CHKEXIT
        3330+10 3461 CHKIDX   + R ADD     CRDDATA2     STORE DATA HALF-WORD + DATA2 INDEX
        3331+ 4 3365          + TR 0      CHK20
        3332+10 3456          + R ADD     CRDLOC       COMPUTE WHERE TO STORE THE DATA
        3333+ 5 3458          + SUB       CRDORG       IN INDICES BLOCK
        3334+12 3459          + STORE     CRDN
        3335+10 3388          + R ADD     BINCRDAD     SET START OD INICES ADDR
        3336+ 9 3467          + ADD       D36
        3337+13 3357          + STORE A   CHKSTO3A
        3338+13 3364          + STORE A   CHKSTO3B
        3339+10 3462          + R ADD     ZERO
        3340-12 3450          - STORE     DATA
        3341-12 3452          - STORE     SUM
        3342+10 3459 CHK10    + R ADD     CRDN         INDICES ADDR += (LOC - ORIGIN) DIV 6
        3343+ 5 3466          + SUB       D6
        3344+ 3 3346          + TR +      CHK11
        3345+ 1 3352          + TR        CHK12
        3346+12 3459 CHK11    + STORE     CRDN
        3347+10 3357          + R ADD     CHKSTO3A
        3348+ 9 3463          + ADD       ONE
        3349+13 3357          + STORE A   CHKSTO3A
        3350+13 3364          + STORE A   CHKSTO3B
        3351+ 1 3342          + TR        CHK10
        3352+10 3459 CHK12    + R ADD     CRDN         SHIFT = (N+1)*3
        3353+ 9 3459          + ADD       CRDN
        3354+ 9 3459          + ADD       CRDN
        3355+ 9 3465          + ADD       D3
        3356+13 3360          + STORE A   CHKSHF
        3357+10    0 CHKSTO3A + R ADD     /   /
        3358+12 3451          + STORE     DATA2
        3359+10 3461          + R ADD     CRDDATA2     SHIFT RIGHT AND STORE AT INDICES ADDR
        3360+23    0 CHKSHF   + A RIGHT   /   /
        3361- 9 3450          - ADD       DATA
        3362-12 3452          - STORE     SUM
        3363+10 3453          + R ADD     SUM2
        3364+12    0 CHKSTO3B + STORE     /   /
        3365+10 3444 CHK20    + R ADD     BINCRD42     COUNT IN CARD
        3366+ 9 3463          + ADD       ONE
        3367+12 3444          + STORE     BINCRD42     
        3368+ 1    0 CHKEXIT  + TR        /   /
        3369+10 3369 CHKFLSHR + R ADD     *            JUST FLUSH CURRENT CARD AND RETURN
        3370+ 1 3389          + TR        FLUSHCRD
        3371+10 3371          + R ADD     *            CLEAR CARD BUFFER IN MEM
        3372+ 1   89          + TR        CLMEM        BINCARD
        3373+ 0 3402          + STOP      BINCARD
        3374+ 0 3468          + STOP      D48
        3375+10 3248          + R ADD     CHKP2        SECOND PARAM HAS THE RETURN ADDR
        3376+13 3377          + STORE A   FLSHEX       
        3377+ 1    0 FLSHEX   + TR        /   /        RETURN TO CALLER
        3378+10 3250 CHKWR    + R ADD     CHKP2A       SECOND PARAM HAS THE ADDR OF BIN CARD WRITE ROUTINE TO BE CALLED BY FLUSH (INSTEAD THE TOP SYMBOL)
        3379+13 3398          + STORE A   WRCRD
        3380+10 3252          + R ADD     CHKP3        THIRD PARAM HAS THE RETURN ADDR 
        3381+13 3387          + STORE A   CHKWREX
        3382+10 3382          + R ADD     *            CLEAR CARD BUFFER IN MEM
        3383+ 1   89          + TR        CLMEM        BINCARD
        3384+ 0 3402          + STOP      BINCARD
        3385+ 0 3468          + STOP      D48
        3386+10 3388          + R ADD     BINCRDAD     RETURN IN ACC THE ADDR OF BINCARD BUFFER TO BE WRITTEN BY WRITE ROUTINE  
        3387+ 1    0 CHKWREX  + TR        /   /        RETURN TO CALLER
        3388+ 0 3402 BINCRDAD + STOP      BINCARD      SOURCE ADDR
        3389+ 9 3464 FLUSHCRD + ADD       TWO          PUNCH PACT CARD IN CARD BUFFER
        3390+13 3401          + STORE A   FLUSHEX
        3391+10 3444          + R ADD     BINCRD42     GET COUNT
        3392+ 4 3401          + TR 0      FLUSHEX      IF =0 -> THE CARD IS EMPTY -> EXIT WITHOUT PUNCHING
        3393+10 3393          + R ADD     *
        3394+ 1   91          + TR        CHKSUM       COMPUTE CHECKSUM OF CARD ...
        3395+ 0 3402          + STOP      BINCARD      
        3396-12 3448          - STORE     BINCRD46     ... AND STORE IT AT LOCATION 46 AND 47
        3397+10 3397          + R ADD     *
        3398+ 1    0 WRCRD    + TR        /   /        CALL WRITE CARD ROUTINE
        3399+10 3462          + R ADD     ZERO
        3400+12 3444          + STORE     BINCRD42     CLEAR COUNT 
        3401+ 1    0 FLUSHEX  + TR        /   /
        3402+     0  BINCARD    RES       42           BUFFER FOR PACT RELATIVE BINARY CARD INSTR 
        3444+     0  BINCRD42   DEF       0            COUNT OF INSTR IN CARD
        3445+     0             DEF       0
        3446+     0  BINCRD44   DEF       0            CODE + ORIGIN IN CARD
        3447+     0  BINCRD45   DEF       0            SYMBOL 
        3448+     0  BINCRD46   DEF       0            CHECKSUM
        3449+     0             DEF       0            BINCARD TAKES 48 HALF-WORDS IN TOTAL
        3450+     0  DATA       DEF       0            
        3451+     0  DATA2      DEF       0
        3452+     0  SUM        DEF       0            
        3453+     0  SUM2       DEF       0
        3454+     0  CRDTY      DEF       0            BIN CARD TYPE REQUITED: -01 -> CONTROL CARD, -00 -> MC INSTR CARD
        3455+     0  CRDSY      DEF       0            BIN CARD SYMBOL REQUITED
        3456+     0  CRDLOC     DEF       0            LOCATION 0..4095 
        3457+     0  CRDDATY    DEF       0            DATA TYPE: =0 -> DATA1=DATA TO STORE, DATA2=INDEX TAG
        3458+     0  CRDORG     DEF       0
        3459+     0  CRDN       DEF       0
        3460+     0  CRDDATA    DEF       0
        3461+     0  CRDDATA2   DEF       0
        3462+     0  ZERO       DEF       0
        3463+     1  ONE        DEF       1
        3464+     2  TWO        DEF       2
        3465+     3  D3         DEF       3
        3466+     6  D6         DEF       6
        3467+    36  D36        DEF       36
        3468+    48  D48        DEF       48
          48-     0  ROUTINE INIT
          49+ 1   94 ENTRY POINT
          50-     0  ROUTINE CLRBUF
          51+ 1 2526 ENTRY POINT
          52-     0  ROUTINE WRITECRD
          53+ 1 2532 ENTRY POINT
          54-     0  ROUTINE PRTCHR
          55+ 1 2738 ENTRY POINT
          56-     0  ROUTINE PRTSTR
          57+ 1 2595 ENTRY POINT
          58-     0  ROUTINE PRTINT
          59+ 1 2696 ENTRY POINT
          60-     0  ROUTINE PRTALF
          61+ 1 2618 ENTRY POINT
          62-     0  ROUTINE PRTNLINE
          63+ 1 2856 ENTRY POINT
          64-     0  ROUTINE RDTAPE
          65+ 1 3143 ENTRY POINT
          66-     0  ROUTINE RWDRUM
          67+ 1 3122 ENTRY POINT
          68-     0  ROUTINE MEMCOPY
          69+ 1 3018 ENTRY POINT
          70-     0  ROUTINE SRCHTBL
          71+ 1 3052 ENTRY POINT
          72-     0  ROUTINE READTBL
          73+ 1 3056 ENTRY POINT
          74-     0  ROUTINE WRIBREL
          75+ 1 3232 ENTRY POINT
          76-     0  ROUTINE PRINTCRD
          77+ 1 2534 ENTRY POINT
          78-     0  ROUTINE READCRD
          79+ 1 2530 ENTRY POINT
          80-     0  ROUTINE PRTOCT
          81+ 1 2662 ENTRY POINT
          82-     0  ROUTINE BMPAD
          83+ 1 2938 ENTRY POINT
          84-     0  ROUTINE EQTBL
          85+ 1 3054 ENTRY POINT
          86-     0  ROUTINE WRTAPE
          87+ 1 3158 ENTRY POINT
          88-     0  ROUTINE CLMEM
          89+ 1 2992 ENTRY POINT
          90-     0  ROUTINE CHKSUM
          91+ 1 3198 ENTRY POINT
        4094+    48  REGION ORIGIN TABLE LOCATION
        4095+    94  INITIAL REGION
           0+ 1   94          + TR        INIT         PROGRAM START
