                                  (c) May 2025 by Roberto Sancho

                                  PACT I Compiler
                                   
                                  To be assembled with Ibm701Assembler.exe cross-assembler

LABEL--- S OPCODE--- OPADDR---    COMMENT   *NNNN -> octal number, else decimal number


           HEAD      PACTREL      USING PACT RELATIVE ASSEMLER SYNTAX

                                  DEFINE SYMBOLS NAME FOR PACT LOADER

           HEAD      DEF:INIT        STAGE 51 LOOP EXPANSION PASS 1 ENTRY POINT, PACT COMPILER 
           HEAD      USE:CHAIN       LOAD ABS PROGRAM RECORDS FROM TAPE, 
           HEAD      USE:CLRBUF      CLEAR CARD BUFFER 
           HEAD      USE:PRTNLINE    PRINT A NEW LINE OF DATA
           HEAD      USE:PRINTCRD    PRINT CARD BUFFER
           HEAD      USE:PRTSTR      PRINT ALFANUMERIC TEXT STRING, ZERO TERMINATED
           HEAD      USE:PRTALF      PRINT PACKED ALFANUMERIC TEXT STRING
           HEAD      USE:PRTINT      PRINT DECIMAL INTEGER 
           HEAD      USE:PRTCHR      PRINT BASE48 CHAR 
           HEAD      USE:RDTAPE      READ MAGNETIC TAPE
           HEAD      USE:WRTAPE      WRITE MAGNETIC TAPE
           HEAD      USE:EQTBL       STORE VALUE INTO TABLE
           HEAD      USE:EQTBL2      STORE VALUES IN TABLE
           HEAD      USE:READTBL     TAKE VALUE FROM TABLE
           HEAD      USE:READTBL2    TAKE VALUES FROM TABLE
           HEAD      USE:SRCHTBL     SEARCH TABLE
           HEAD      USE:CLMEM       CLEAR MEMORY STORAGE
           HEAD      USE:MEMCOPY     COPY MEMORY STORAGE FROM ONE ADDR TO ANOTHER
              
                                  PURPOSE:
                                  - SCAN SOURCE CODE TO EXPAND TEST INSTR. 
                                  - FOR EACH REGION, FOR EACH PACT INSTRUCTION, 
                                    - IF IT REFERENCES A MATRIX/VECTOR -> POPULATE TREF TABLES 
                                      (BUT DOES NOT GENERATE MC CODE)
                                    - IF IT IS ID/FOR BELLOW A CALL INSTR -> POPULATE TPAR, TLOCONST TABLES 
                                      (BUT DOES NOT GENERATE MC CODE)
                                    - IF IT IS USE/SET -> BUILD TIDX TABLES 
                                      (BUT DOES NOT GENERATE MC CODE)
                                    - IF IT IS TEST -> USE TIDX AND TREF, POPULATE TLOCONST TABLE 
                                      EXPAND THIS INSTR (GENERATE MC CODE)
                                  - SAVE UPDATED COMPACT CODE TO TAPE
                                  - AT END OF REGION, 
                                      - SAVE TPAR AND TIDX IN TAPE TO BE USED BY PASS2
                                      - ADD TLOCONST TABLE TO END OF REGION RECORD
                                  - PACT INSTRUCTIONS NOT EXPANDED: 
                                       CALL/ID/FOR
                                       USE/SET

LOADCC   + ADD       TWO          LOAD PACTSCR INTO CARD IMAGE SO 
         + STORE A   CPCCEX       CURRENT PACT SOURCE CODE CAN BE PRINTED

         + R ADD     ZERO         COPY TO LEFT SIDE OF SOURCE CODE CARD IMAGE
         + STORE A   CPCC1        AT 0..46 FROM PACTSCR
         + R ADD     CPCC2
         + STORE A   CPCC 
CPCC     - R ADD     /   /
CPCC1    - STORE     /   /
         + R ADD     CPCC1
         + SUB       TWO
         + STORE A   CPCC1B
         + R ADD     ZERO
CPCC1B   - STORE     /   /
         + R ADD     CPCC
         + SUB       TWO
         + STORE A   CPCC
         + R ADD     CPCC1
         + SUB       D4
         + STORE A   CPCC1
         + SUB       CPCCE
CPCCEX   + TR 0      /   /        RETURN TO CALLER
         + TR        CPCC
CPCCE    - STORE     0048         LAST LOCATION TO COPY FROM 
CPCC2    + NOOP      PACTSRC      PACTSRC = FIRST LOCATION TO COPY FROM


INIT     + R ADD     *            
         + TR        PRTNLINE     
         + STOP      0101         STRINGZ AT COL 1
         + STOP      MSGSTART     "LOOP EXPANSION"
         + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON

         + R ADD     ZERO         CLEAR CC RECORD
         + STORE     REGION     
         + STORE     STEP       
         + STORE     OP         
         + STORE     FACT       
         + STORE     S1         
         + STORE     S2         
         + STORE     QR         
         + STORE     QF         
         - STORE     NUM        
         + STORE     CLUE       
         + STORE     STEPN      
         + STORE     FACTN      
         + STORE     FACTREG    
         + STORE     S1N        
         + STORE     S2N        
         + STORE     D1N        
         + STORE     D2N        
         + STORE     NINST      
         + STORE     NINCR 
         + R ADD     CCLEN        NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         + R ADD     TPARSTEP     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         + R ADD     TPARFACT     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         + R ADD     TREFIDX1     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         + R ADD     TREFIDX2     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         + R ADD     TREFSTEP     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         + R ADD     TREFINCR     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         + R ADD     TREFADDR     NOT NEEDED. THIS INSTR IS JUST TO AVOID A "NOT REFERENCED" WARNING ON ASSEMBLING     
         + R ADD     *            CLEAR GENERATED MACHINE CODE INSTR ON CC RECORD
         + TR        CLMEM        
TINSTAD  + STOP      TINST      
         + STOP      D200         TINST (200 HALF-WORDS) = 2 * MAXNINST (MAX NUMBER OF MACHINE CODE INSTRUTIONS PER STEP)

         + R ADD     ZERO
         + STORE     NREGIONS     NUMBER OF REGIONS PROCESSED

         + REWIND    TAPEIN       REWIND TAPE IN (PACT COMPACT CODE)
         + REWIND    TAPEOUT      REWIND TAPE OUT WITH UPDATED PACT COMPACT CODE
         + REWIND    TAPEOUTR     OUTPUT TO TAPE 4 (PASS1 POPULATED TABLES FOR EACH REGION)

                                  READ A NEW PACT REGION
READREG  + R ADD     ZERO
         + STORE     NIDXS        INIT NUMBER OF INDEXES IN THIS REGION
         + STORE     NREFS        INIT NUMBER OF REFERENCES
         + STORE     NPARAMS      INIT NUMBER OF PARAMS DEFINED
         + STORE     NLOCONST     NUM OF ENTRIES IN LOOP CONSTANT POOL OF REGION 
         + STORE     SVNINST      SO WE CAN PRINT A LOG OF CC THAT GET GENERATED MC INSTR
         + STORE     SVSTEPN      SAVE LAST STEPN 
         + STORE     PRGSTEPN     FIRST STEPN OF PROGRAM AFTER INITIAL CALL/ID/FOR (IE STEP-1 IS CALL/ID/FOR INSTR)
         + STORE     REGCSTEP     STEPN WHERE THE REG.C SITS

READSTEP + R ADD     *            READ PACT USER PROGRAM SOURCE CODE FROM TAPE IN
         + TR        RDTAPE
         + STOP      TAPEIN
         + STOP      CCODE        BUF TO READ IN FROM TAPE
         + TR OV     EOF          TR IF END OF FILE

         + R ADD     OP
         + TR 0      EOR          TR IF END OF REGION

         + R ADD     *            LOAD PACTSCR INTO CARD IMAGE SO 
         + TR        LOADCC       CURRENT PACT SOURCE CODE CAN BE PRINTED

         + R ADD     NINST        SAVE CURRENT NUMBER OF MC INSTR IN THE COMPACT CODE RECORD
         + STORE     SVNINST      SO WE CAN PRINT A LOG OF CC THAT GET GENERATED MC INSTR
         + R ADD     STEPN
         + STORE     SVSTEPN      SAVE LAST STEPN TO MAKE EOR RECORD FOLLOW

         + R ADD     OP           JUMP TABLE TO HANDLE EACH TYPE OF PACT OPERATION
         + ADD       OPTBL
         + STORE A   OPTBLTR
OPTBLTR  + TR        /   /
OPTBL    + STOP      *
         + TR        CHECKREF     OP=1   TAKE   FACTOR CANNOT BE BLANK 
         + TR        CHECKREF     OP=2   ADD    ALLOWS BLANK FACTOR 
         + TR        CHECKREF     OP=3   SUB    ALLOWS BLANK FACTOR 
         + TR        CHECKREF     OP=4   MUL    ALLOWS BLANK FACTOR
         + TR        CHECKREF     OP=5   DIV    FACTOR CANNOT BE BLANK 
         + TR        NEXT         OP=6   RES    NO FACTOR
         + TR        CHECKREF     OP=7   EQ     NEEDS VARIABLE AS FACTOR
         + TR        CHECKREF     OP=8   +ABS   ALLOWS BLANK FACTOR
         + TR        CHECKREF     OP=9   -ABS   ALLOWS BLANK FACTOR
         + TR        CHECKREF     OP=10  ABS    FACTOR CANNOT BE BLANK 
         + TR        NEXT         OP=11  T      FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         + TR        NEXT         OP=12  TZ     FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         + TR        NEXT         OP=13  TP     FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         + TR        NEXT         OP=14  TN     FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         + TR        NEXT         OP=15  TF     FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         + TR        NEXT         OP=16  HALT   FACTOR=DESTINATION STEP -> NO VARIABLE FACTOR TO PROCESS
         + TR        TEST         OP=17  TEST   
         + TR        USESET       OP=18  SET    
         + TR        USESET       OP=19  USE    
         + TR        NEXT         OP=20  DO     ALREADY PROCESSED IN OPERATION EXPANSION
         + TR        NEXT         OP=21  EXIT
         + TR        BADOP        OP=22  DUP    SHOULD NOT BE PRESENT. IT IS ALREADY PROCESSED
         + TR        NEXT         OP=23  LIB    ALREADY PROCESSES IN OPERATIOn EXPANSION
         + TR        BADOP        OP=24  ID     SHOULD NOT BE PRESENT. IT IS DESAMBIGUATED
         + TR        BADOP        OP=25  FOR    SHOULD NOT BE PRESENT. IT IS DESAMBIGUATED
         + TR        NEXT         OP=26  CALL   
         + TR        CHECKREF     OP=27  SIN    ALLOWS BLANK FACTOR
         + TR        CHECKREF     OP=28  COS    ALLOWS BLANK FACTOR
         + TR        CHECKREF     OP=29  ARCT   ALLOWS BLANK FACTOR
         + TR        CHECKREF     OP=30  SQRT   ALLOWS BLANK FACTOR
         + TR        CHECKREF     OP=31  LOG    ALLOWS BLANK FACTOR
         + TR        CHECKREF     OP=32  EXP    ALLOWS BLANK FACTOR
         + TR        NEXT         OP=33  SE
         + TR        CHECKREF     OP=34  CL     NEEDS VARIABLE AS FACTOR
         + TR        NEXT         OP=35  READ
         + TR        NEXT         OP=36  LIST
         + TR        NEXT         OP=37  RES for MULT
         + TR        NEXT         OP=38  RES for DIV
         + TR        CHECKREF     OP=39  ID for LIST         FACTOR CANNOT BE BLANK 
         + TR        CHECKREF     OP=40  ID for DO/LIB       ONLY APPLIES INDEX IF IT IS ACTIVE
         + TR        IDCALL       OP=41  ID for CALL         
         + TR        NEXT         OP=42  FOR for DO/LIB      
         + TR        FORCALL      OP=43  FOR for CALL        

BADOP    + STOP      1111         INTERNAL COMPILER ERROR: SHOULD NOT BE PRESENT. IT SHOULD HAVE BEEN DESAMBIGUATED

NEXT     + NOOP      0000         CONTINUE 

         + R ADD     OP           IF OP=26 (CALL), OP=41 (ID for CALL), OP=43  FOR for CALL
         + SUB       OPCALL       WE ARE IN THE PARAMETERS SECTION OF THIS REGION
         + TR 0      NXWR         WHEN FIRST STEPN OF PROGRAM ARRIVES, SAVE ITS NUMBER IN 
         + R ADD     OP           PRGSTEPN VARIABLE. THIS IS THE FIRST PROGRAM STEPN  
         + SUB       OPIDCALL     AFTER INITIAL CALL/ID/FOR. 
         + TR 0      NXWR
         + R ADD     OP
         + SUB       OPFORCAL
         + TR 0      NXWR
         + R ADD     PRGSTEPN     =0?   
         + SUB       ONE 
         + TR +      NXWR         NO, IS >0 -> ALREADY SET -> CONTINUE
         + R ADD     STEPN        YES, IS=0 -> SET PRGSTEPN=CURRENT STEPN
         + STORE     PRGSTEPN     FIRST STEPN OF PROGRAM AFTER INITIAL CALL/ID/FOR (IE STEP-1 IS CALL/ID/FOR INSTR)

NXWR     + R ADD     *            WRITE COMPACT CODE ON TAPEOUT
         + TR        WRCC         WITH LOG

                                  PROCESS NEXT STEP 
         + TR        READSTEP     

EOR      + NOOP      0000         END OF REGION  
                                 
         + R ADD     *
         + TR        WREORCC      IF NEEDED, ADD COMPACT CODE RECORD OP=44 OPNCONST
                                  THAT CONTAINS (IN TINST) THE GENEARTED LOOP CONSTANTS POOL 
                              
         + R ADD     *            SAVE IN TAPEOUTR THE POPULATED TABLES
         + TR        WREORTBL     TO BE USED BY PASS 2
                   
         + R ADD     NREGIONS     NUMBER OF REGIONS PROCESSED
         + ADD       ONE
         + STORE     NREGIONS     
                        
         + TR        READREG      PROCESS NEXT REGION

EOF      + NOOP      0000         END OF FILE

         + WRITE EF  TAPEOUT      WRITE EOF IN TAPE OUT (COMPACT CODE)
         + WRITE EF  TAPEOUTR     WRITE EOF IN TAPE OUT (REGION TABLES)

                                  NO MORE STEPS. IF SW6 ON THEN 
                                  PRINT NUMBER OF REGIONS
         + SENSE     0074         SENSE SWITCH 6
         + TR        ENDLOG1B     TR IF NO LOG SELECTED
         + R ADD     *
         + TR        PRTNLINE     
         + STOP      0101         STRINGZ AT COL 1
         + STOP      MSGDONE      "REGIONS"
         + STOP      0210         INT AT COL 10
         + STOP      NREGIONS     NUMBER OF REGIONS PROCESSED
         + STOP      0006         END OF LINE. PRINT IF SWITCH 6 IS ON
ENDLOG1B + NOOP      0000

                                  CHAIN TO NEXT COMPILER PHASE/STAGE
         + R ADD     *
         + TR        CHAIN        IF SW2 IS ON, A +STOP 4095 IS EXECUTED 
         + STOP      PACTCOMP     CHAIN TO NEXT STAGE IN PACT COMPILER TAPE

         + STOP      4095


WRCC     + ADD       TWO          WRITE COMPACT CODE ON TAPE WITH TRAILING RECORD
         + STORE A   WRCCEXIT     TO ALLOW READING BACKWARDS. IF SW6 ON PRINT LOG
         
         + R ADD     CCLEN        SAVE MC INSTRUCTIONS GENERATED SO FAR
         + ADD       NINST        ADD NINST TWICE AS EACH MC INSTR USES TWO HALF-WORDS
         + ADD       NINST
         + STORE     N

         + R ADD     *
         + TR        WRTAPE       WRITE MAGNETIC TAPE TAPEOUT (PACT COMPACT CODE)
         + STOP      TAPEOUT
         + STOP      CCODE        BUF TO WRITE TO TAPE
         + STOP      N            LEN

         + R ADD     STEPN
         + STORE     DATA
         + R ADD     NINST
         + STORE     DATA2

         + R ADD     *            WRITE TRAILING IDENTIFICATION RECORD
         + TR        WRTAPE       (MC CODE GENERATED STEPN + NINST)
         + STOP      TAPEOUT      SO TAPE CAN BE READ BACKWARDS ON PASS 2
         + STOP      DATA         BUF TO WRITE TO TAPE
         + STOP      TWO          LEN

         + SENSE     0074         SENSE SWITCH 6
         + TR        ENDLOG1      TR IF NO LOG SELECTED

         + R ADD     OP
         + TR 0      ENDLOG1      DO NOT PRINT EOR 

         + R ADD     *            PRINT STEP JUST PROCESSED
         + TR        PRINTCRD
         
         + R ADD     NINST        IF NUMBER OF MC INSTR IN THE COMPACT CODE RECORD HAS CHANGED
         + SUB       SVNINST      -> CC GOT GENERATED MC INSTR -> PRINT MC INSTR GENERATED
         + TR 0      ENDLOG1
         
         + R ADD     *
         + TR        PRTMC        PRINT TINST TABLE WITH MC INSTRUCTIONS GENERATED FOR THIS STEP
ENDLOG1  + NOOP      0000 
WRCCEXIT + TR        /   /         

WREORCC  + ADD       TWO          ADD LOOP CONSTANTS POOL AS TINST ON CC RECORD                           
         + STORE A   WREOREX

         + R ADD     NLOCONST     
         + STORE     NINST
         + A LEFT    0001
         + TR 0      SVEOR        SKIP IF NO LOOP CONSTANTS POOL
         + STORE     LEN

         + R ADD     *            
         + TR        MEMCOPY
         + STOP      TLOCONST   
         + STOP      TINST      
         + STOP      LEN

         + R ADD     OPNCONST     MAKE EOR RECORD A NEW ADDED OPNCONST CONSTANT LOOP POOL RECORD
         + STORE     OP           WILL CONTAINS THE LOOP CONSTANTS AS MC INSTR
         + R ADD     SVSTEPN                        STEPN = REGCSTEP
         + ADD       ONE                            FACTN = PRGSTEPN FIRST STEPN OF PROGRAM AFTER INITIAL CALL/ID/FOR (IE STEP-1 IS CALL/ID/FOR INSTR) 
         + STORE     SVSTEPN
         + STORE     REGCSTEP     THIS IS THE STEPN WHERE THE REG.C SITS
         + STORE     STEPN
         + R ADD     PRGSTEPN     FIRST STEPN OF PROGRAM AFTER INITIAL CALL/ID/FOR (IE STEP-1 IS CALL/ID/FOR INSTR) 
         + STORE     FACTN

         + R ADD     ZERO
         + STORE     SVNINST

         + R ADD     *            CLEAR CARD BUFFER
         + TR        CLRBUF 

         + LOAD MQ   REGION
         + R ADD     *            
         + TR        PRTALF
         + STOP      0001         AT COL 1

         + R ADD     *            PRINT STRINGZ
         + TR        PRTSTR
         + STOP      HALTTXT      "HALT"
         + STOP      0008         COLUMN WHERE TXT STARTS

         + LOAD MQ   D10          PRINT '0'
         + R ADD     *
         + TR        PRTCHR
         + STOP      0015         COLUMN WHERE CHR IS

         + R ADD     ZERO         COPY LEFT SIDE OF SOURCE CODE CARD IMAGE
         + STORE A   DPCC1        AT 0..46 TO PACTSCR
         + R ADD     DPCC2
         + STORE A   DPCC 
DPCC1    - R ADD     /   /
DPCC     - STORE     /   /
         + R ADD     DPCC
         + SUB       TWO
         + STORE A   DPCC
         + R ADD     DPCC1
         + SUB       D4
         + STORE A   DPCC1
         + SUB       DPCCE
         + TR 0      DPCC2
         + TR        DPCC1 
DPCCE    - R ADD     0048         LAST LOCATION TO COPY FROM 
DPCC2    + NOOP      PACTSRC      PACTSRC = FIRST LOCATION TO COPY TO 

         + R ADD     *            WRITE COMPACT CODE ON TAPEOUT
         + TR        WRCC         WITH LOG

         + R ADD     ZERO         REVERT CHANGES TO EOR RECORD
         + STORE     OP
         + STORE     NINST
         + STORE     SVNINST
         + R ADD     STEPN
         + ADD       ONE
         + STORE     STEPN
         
         + R ADD     *
         + TR        CLMEM        
         + STOP      PACTSRC      
         + STOP      D24

SVEOR    + R ADD     *            WRITE NEW EOR RECORD
         + TR        WRCC         
WREOREX  + TR        /   /

WREORTBL + ADD       TWO          SAVE IN TAPEOUTR THE POPULATED TABLES
         + STORE A   WREORTEX     TO BE USED BY PASS 2
                      
         + R ADD     NIDXS        MAKE NAME OF ALL INDEXES NEGATIVE
         + STORE     N            BEFORE SAVING THEM TO TAPE
         + R ADD     TIDXNAAD
         + STORE A   SVIXRD
         + STORE A   SVIXWR

SVIXLO   + R ADD     N
         + TR 0      SVIXEND
         + SUB       ONE         
         + STORE     N
         + R ADD     ZERO
SVIXRD   + SUB AB    /   /
SVIXWR   + STORE     /   / 
         + R ADD     SVIXRD
         + ADD       ONE
         + STORE A   SVIXRD
         + STORE A   SVIXWR
         + TR        SVIXLO
TIDXNAAD + STOP      TIDXNAME
SVIXEND  + NOOP      0000
            
SVTA1    + NOOP      MAXNPAR      FIRST VAR OF TABLES TO SAVE TO TAPE
SVTA2    + NOOP      MAXNREFS     VAR JUST AFTER TABLES, NOT TO SAVE 
         + R ADD     SVTA2
         + SUB       SVTA1        SAVE AT ONCE TPAR TABLES ( 2 + 5*34 HALF WORDS )
         + STORE     N            AND TIDX TABLES ( 2 + 4*34 HALF WORDS )
                                  TOTAL LEN TO SAVE = 310 HALF WORDS
         + R ADD     *                              = 155 FULLWORDS ON TAPE
         + TR        WRTAPE       
         + STOP      TAPEOUTR     
         + STOP      MAXNPAR      BUF TO WRITE TO TAPE
         + STOP      N            LEN

WREORTEX + TR        /   /

ERROR    + ADD       TWO
         + STORE A   ERRP1
ERRP1    + R ADD     /   /
         + STORE A   ERRSTRZ      SAVE ADDR OF ERROR TXT MESSAGE

         + R ADD     *            PRINT USER PROGRAM SOURCE CODE CARD JUST PROCESSED
         + TR        PRINTCRD
         + R ADD     *
         + TR        PRTNLINE     
         + STOP      0101         STRINGZ AT COL 1
ERRSTRZ  + STOP      /   /        ERROR MESSAGE
         + STOP      0000         END OF LINE

         + STOP      READSTEP     IF USER PRESS STARTS, PROGRAM RESUMES PROCESSING NEXT SOURCE CODE STEP 


                                  CODE GENERATION ROUTINES

                                  PACT OP=41 ID BELOW A CALL INSTR

                                  ID instr for CALL -> param definition into called function body
                                                       does not generate mc instr in pass1. 
                                                       Will generate mc instr in pass2. 
                                  ID num           <-- will receive the value in num temp var
                                  ID var [I [J]]   <-- Var name only in fact part (no definitive subscripts allowed)
                                                      The addr/D1 of var will replaced by the ones sent as param from caller
                                                      replacement occurs in all factors and in SET/USE/TEST

                                        TPARTYPE   TPARFACT   TPARLOC1   TPARNAME  DESCR

                                  ID 3        -1   3                     4096      CONSTANT. VALUE PASED AS PARAM IS STORED IN TEMP VAR
                                  ID VAR       0   FACTN                 FACTN     SCALAR VAR BY REF. FACT=FACTN OF VARIABLE ON CURRENT REGION
                                  ID VECT I    1   FACTN      L(D1)      FACTN     VECTOR BY REF. FACT=FACTN OF VARIABLE. LOC1=ENTRY IN LOOP CONSTANTS POOL OF D1 VALUE PASED AS PARAM 
                                  ID MAT  I J  2   FACTN      L(D1)      FACTN     MATRIX

IDCALL   + NOOP      0000
 
         + R ADD     NUM
         + TR 0      AP0A
         + TR        PARAMNUM     TR PARAM IS A CONSTANT
AP0A     + R ADD     FACTREG
         + SUB       D34          'V'
         + TR 0      AP0B

         + R ADD     *
         + TR        ERROR         
         + STOP      ERRNOVAR     ERROR: ID PARAM MUST BE A VAR (CANNOT BE A TEMP/PERISHABLE VAR)

AP0B     + R ADD     S1N
         + TR 0      PARAMSCA     TR PARAM IS A SCALAR VAR
         + R ADD     S2N
         + TR 0      PARAMVEC     TR PARAM IS A VECTOR
         + TR        PARAMMAT     TR PARAM IS A MATRIX

PARAMNUM + R SUB     ONE          NUMERIC CONSTANT PARAM: TPARTYPE=-1
         + STORE     PTYPE
         + R ADD     D4096
         + STORE     PNAME        TPARNAME=4096
         + R ADD     ZERO         
         + STORE     DATA2        TPARLOC1=0
         + R ADD     NUM
         + STORE     DATA         TPARFACT=number
         + TR        ADDPARAM

PARAMSCA + R ADD     ZERO         SCALAR VAR PARAM: TPARTYPE=0
         + STORE     PTYPE        NOTE THAT SCALAR -> NO D1 VALUE TO SEND AS PARAM
         + STORE     DATA2        -> TPARLOC1=0
         + TR        PARAMVAR

PARAMMAT + R ADD     TWO          VECTOR MATRIX: TPARTYPE=2
         + TR        AP1
PARAMVEC + R ADD     ONE          VECTOR PARAM: TPARTYPE=1
AP1      + STORE     PTYPE        

         + R ADD     *
         + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
         + STOP      REG.A        '+H  A 0000' -> ENTRY IN CONTANT POOL THAT CONTAINS THE D1 DIMENSION 
         + STOP      0000         PASSED AS PARAM. "STOP 0000" -> CREATE A NEW ENTRY WITH ZERO VALUE
         + STORE     DATA2        TPARLOC1=ENTRY IN POOL THAT CONTAINS D1 PASSED AS PARAM (0000=FIRST ENTRY)

PARAMVAR + R ADD     FACTN        THE NAME (SHOULD BE UNIQUE) OF THE PARAM IS THE VAR ADDRESS
         + STORE     PNAME
         + STORE     DATA         TPARFACT=FACTN -> THE ADDR OF MATRIX/VECTOR (REGION IS ALLWAYS 'V')
         + TR        ADDPARAM

ADDPARAM + R ADD     *
         + TR        ADDPAR
         + TR        NEXT    

ADDPAR   + ADD       TWO
         + STORE A   ADDPAREX
        
         + R ADD     PNAME
         + SUB       D4096
         + TR 0      AP2          TR AS PARAM IS NUMERIC

         + R ADD     *
         + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         + STOP      TPARNAME     ... INDEX NAME TABLE
         + STOP      NPARAMS      ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
         + STOP      PNAME        ... THE VALUE TO FIND 
         
         + TR 0      AP2          TR AS PNAME NOT USED AS PARAM
         
         + R ADD     *
         + TR        ERROR
         + STOP      ERRDPARS     ERROR: DUPLICATED PARAMETER NAME

ERROVPAR + R ADD     *
         + TR        ERROR
         + STOP      ERROVPAS     ERROR: TOO MANY PARAMS DEFINED (MAX 34)
         
AP2      + R ADD     NPARAMS      CREATE A NEW CALLED REGION PARAMETER ENTRY
         + SUB       MAXNPAR
         + TR 0      ERROVPAR

         + R ADD     NPARAMS
         + ADD       ONE
         + STORE     NPARAMS
         + STORE     NPAR

         + R ADD     *            STORE IN TABLES
         + TR        EQTBL2
         + STOP      TPARNAME     
         + STOP      MAXNPAR
         + STOP      NPAR
         + STOP      PNAME        TPARNAME[NPAR] = 
         + STOP      STEPN        TPARSTEP[NPAR] =
         + STOP      PTYPE        TPARTYPE[NPAR] = 
         + STOP      DATA         TPARFACT[NPAR] = 
         + STOP      DATA2        TPARLOC1[NPAR] = 
         + STOP      0000

ADDPAREX + TR        /   /


                                  PACT OP=43 FOR BELOW A CALL INSTR

                                  FOR instr for CALL -> param definition into called function body
                                                        does not generate mc instr in pass1. 
                                                        Will generate mc instr in pass2. 
                                  FOR index  nun  num       <- create two entries in loop constant pool to receive a copy
                                                               of start/end values from caller. 
                                  FOR var|num var|num|blank var|num|blank  <- can be scalar var, or num value.
                                                               num -> copies const value param on caller to num temp var
                                                               var -> copies var on caller contents to stated var in FOR instr
            
                                                               RSV: On PACT manual it is not stated the difference
                                                                    between ID and FOR in the way the params are passed. 
                                                                    when passing loop start/end values it is clear that it is 
                                                                    passing the value from caller, So it seems logica that
                                                                    FOR pass the caller params by copy (ID pass params by reference).

                                  PROCESS FOR INSTRUCTION DO/LIB/CALL
                                          OP       FACT             S1              S2
                                  SYNTAX: FOR      VAR|NUM|INDEX    VAR|NUM|BLANK   VAR|NUM|BLANK
                                          FACT     <0   0   <0        
                                          FACTN    Vnn  0    0
                                          NUM      0   nnn   0
                                          S1/S2                     <0  nnn   0     <0  nnn   0
                                          S1N/S2N                   nn   0    0      nn  0    0    <-- nn=Var addr

                                        TPARTYPE   TPARFACT   TPARLOC1   TPARNAME    DESCR

                                  FOR I A B   -2   L(A)       L(B)       ALFA (<0)   INDEX LOOP START/END: NAME=ALFA BASE48 (<0) WITH INDEX NAME, FACT=ENTRY IN LOOP CONSTANTS POOL OF LOOP START VALUE PASED AS PARAM, LOC1=LOOP END VALUE
                                  FOR A B C   -3   FACTN                 FACTN       SCALAR VARS BY VALUE. FACTN=FACTN OF VARIABLE A. GENERATES ONE ENTRY FOR A, ONE FOR B AND ONE FOR C
                                  FOR 3 4 5   -1   3                     4096        CONSTANT. VALUE PASED AS PARAM IS STORED IN TEMP VAR

FORCALL  + R ADD     FACT
         + TR +      FC1          IF >=0 -> TR AS NOT AN INDEX (IS A NUM)
         + R ADD     FACTREG
         + SUB       D34          'V'
         + TR +      FC1          IF ='V' -> TR AS NOT AN INDEX (IS A VAR)
         
                                  FOR index num num <- create a loop const to receive a copy
                                             of index start/end value from caller the var num value in 
                                             this FOR instr is discarded. It is just a placeholder
         + R ADD     S1
         + TR 0      ERRNDIX1     MISSING LOOP START PLACEHOLDER
         + R ADD     S2
         + TR 0      ERRNDIX2     MISSING LOOP END PLACEHOLDER

         + R SUB     TWO          INDEX LIMITS PARAM: TPARTYPE=-2
         + STORE     PTYPE        
         + R ADD     FACT         TPARNAME=THE BASE48 NAME OF INDEX
         + STORE     PNAME

         + R ADD     *
         + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
         + STOP      REG.A        '+H  A 0000' -> ENTRY IN CONTANT POOL THAT CONTAINS THE LOOP START VALUE PASSED AS PARAM
         + STOP      0000         0000 -> CREATE A NEW ENTRY WITH ZERO VALUE
         + STORE     VAL          TPARLOC1=THE ENTRY IN POOL THAT CONTAINS LOOP START VALUE PASSED AS PARAM (0000=FIRST ENTRY)

         + R ADD     *
         + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
         + STOP      REG.A        '+H  A 0000' -> ENTRY IN CONTANT POOL THAT CONTAINS THE LOOP END VALUE PASSED AS PARAM
         + STOP      0000         0000 -> CREATE A NEW ENTRY WITH ZERO VALUE
         + STORE     DATA2        TPARLOC1=THE ENTRY IN POOL THAT CONTAINS LOOP END VALUE PASSED AS PARAM (0000=FIRST ENTRY)

         + R ADD     VAL
         + STORE     DATA         TPARFACT= THE LOOP START VALUE PASSED AS PARAM
         + TR        ADDPARAM

FC1      + R ADD     *
         + TR        ADDFORPA
         + STOP      FACT         IF FACT is var -> <0 -> type=-3 scalar passed by value
         + STOP      FACTN                   num -> =0 -> type=-1
         + STOP      NUM

         + R ADD     S1
         + TR 0      NEXT         NO MORE PARAMS IN "FOR" INSTR

         + R ADD     *
         + TR        ADDFORPA
         + STOP      S1           IF S1 is var -> <0 -> type=-3 scalar passed by value
         + STOP      S1N                   num -> >0 -> type=-1
         + STOP      S1
         
         + R ADD     S2
         + TR 0      NEXT         NO MORE PARAMS IN "FOR" INSTR

         + R ADD     *
         + TR        ADDFORPA
         + STOP      S2           IF S2 is var -> <0 -> type=-3 scalar passed by value
         + STOP      S2N                   num -> >0 -> type=-1
         + STOP      S2

         + TR        NEXT    

ADDFORPA + ADD       TWO          ADD PARAM USING FOR DATA
         + STORE A   AF1
         + ADD       ONE
         + STORE A   AF2
         + ADD       ONE
         + STORE A   AF3
         + ADD       ONE
         + STORE A   ADDFOREX
         
AF2      + R ADD     /   /        PARAM: DATA TO STORE IN TPARFACT IF SCALAR PASSED BY VALUE
         + STORE A   AF2A
AF2A     + R ADD     /   /        DERREFERENCE TO GET VNNNN PACT VAR ADDR
         + STORE     RADDR
AF3      + R ADD     /   /        PARAM: DATA TO STORE IN TPARFACT IF NUM CONST PARAM
         + STORE A   AF3A
AF3A     + R ADD     /   /        DERREFERENCE TO GET CONST
         + STORE     N

AF1      + R ADD     /   /        PARAM: NAME >0 -> NUM CONST, <0 -> SCALAR VAR PASSED BY VALUE
         + STORE A   AF1A
AF1A     + R ADD     /   /        DERREFERENCE TO GET CONST
         + STORE     PNAME
         + TR +      AF4          TR IF PARAM IS NUMERIC CONST
         
         + R SUB     D3           PARAM IS A SCALAR PASSED BY VALUE : TPARTYPE=-3
         + STORE     PTYPE
         + R ADD     ZERO         
         + STORE     DATA2        TPARLOC1=0 
         + R ADD     RADDR
         + STORE     DATA        
         + TR        AF5         

AF4      + R SUB     ONE          NUMERIC CONSTANT PARAM: TPARTYPE=-1
         + STORE     PTYPE
         + R ADD     D4096        TPARNAME=4096
         + STORE     PNAME
         + STORE     DATA2        TPARLOC1=0
         + R ADD     N
         + STORE     DATA        
         
AF5      + R ADD     *
         + TR        ADDPAR

ADDFOREX + TR        /   /


                                  PACT OP=18 SET   ALL THESE OPERATIONS NEEDS AN INDEX AND A VALUE
                                       OP=19 USE
                                       
                                          OP       FACT                    S1     S2
                                  SYNTAX: USE|SET  BLANK                   INDEX  INDEX|ALFAVAR|NUM
                                  IF S2 IS A VARIABLE, ASSIGN ITS ADDRESS TO FACTORN
                                  HERE, S1 IS AN INDEX (SHOULD BE ALFA VALUE <0)
                                        S2 IS AN INDEX (ALFA VALUE <0)
                                           OR  A VAR   (ALFA VALUE <0) -> IN THIS CASE -> FACTN=ADDR OF VAR, FACTREG='V'
                                           OR  A NUMBER (>0)

                                                   FACT                    S1     S2
                                                   BLANK                   INDEX  INDEX|ALFAVAR|NUM
                                           FACT    0               
                                           S1                              <0
                                           S2                                     <0    <0      nnn
                                           FACTN                                  0     Vnn     0


USESET   + R ADD     S1N
         + TR +      ERRNOIDX     ERROR: MISSING INDEX
         + R ADD     S2N
         + TR 0      ERRNOIDV     ERROR: MISSING INDEX VALUE

         + R ADD     *
         + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         + STOP      TIDXNAME     ... INDEX NAME TABLE
         + STOP      NIDXS        ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
         + STOP      S1N          ... THE VALUE TO FIND 
         
         + TR 0      SE1          IF NOT FOUND TR TO CREATE A NEW ONE
         + STORE     NIDX
         
         + R ADD     OP           INDEX ALREADY DEFINED. 
         + SUB       OPUSE        IF OP=USE -> JUST PROCEED TO NEXT STEP
         + TR 0      NEXT    
         
         + R ADD     *            
         + TR        READTBL      IF VAL > 0 IT IS ALSO ACTIVE
         + STOP      TIDXSETN   
         + STOP      NIDX
         + STOP      VAL          = TIDXSETN[NIDX] 
         
         + R ADD     VAL
         + TR 0      SE2          INDEX IS ONLY DEFINED. TR TO MAKE IT ACTIVE
         + TR        ERRDSET      ERROR: INDEX ALREADY ACTIVE -> DUPLICATED SET ON INDEX
         
SE1      + R SUB     S1N          CHECK IF THIS INDEX NAME HAS BEEN ALREADY USED IN A 
         + STORE     VAL          PREVIOUS SET-TEST LOOP. IF SO, THE INDEX IS NOT DEFINED (AND NAME HAS
                                  POSITIVE SIGN)
         + R ADD     *
         + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         + STOP      TIDXNAME     ... INDEX NAME TABLE
         + STOP      NIDXS        ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
         + STOP      VAL          ... THE VALUE TO FIND 
         
         + TR 0      NEWIDX       TR BECAUSE IT IS FIRST TIME S1N INDEX IS SET
         + STORE     NIDX         S1N INDEX IS NOT ACTIVE, IT HAS BEEN USED IN A PREVIOUS SET-TEST LOOP
         + TR        SE2          TR TO RE-ACTIVATE IT BY MAKING ITS NAME SIGN NEGATIVE AGAIN
         
NEWIDX   + R ADD     NIDXS        ADD A NEW INDEX 
         + SUB       MAXNIDXS
         + TR 0      ERRIDXOV     ERROR: TOO MANY INDEXES (MAX 34)
         + R ADD     NIDXS        NUMBER OF INDEXES IN THIS REGION
         + ADD       ONE
         + STORE     NIDXS
         + STORE     NIDX

         + R ADD     *
         + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
         + STOP      REG.A        '+H  A 0000' -> INITIAL VALUE FOR INDEX 
         + STOP      0000         0000 -> CREATE A NEW ENTRY WITH ZERO VALUE
         + STORE     ECONSTMK     SAVE THE ENTRY IN POOL THAT CONTAINS THE CREATED CONSTANT (0000=FIRST ENTRY)

         + R ADD     *            SET NEW INDEX VALUE
         + TR        EQTBL
         + STOP      TIDXLOC
         + STOP      NIDX
         + STOP      ECONSTMK     TIDXLOC [NIDX] = ECONSTMK   LOCATION OF INDEX VALUE (NOT USED FOR ADDRESS INDEX, BUT CREATED ANYWAY)

SE2      + R ADD     *            SET THE NAME OF INDEX 
         + TR        EQTBL   
         + STOP      TIDXNAME
         + STOP      NIDX        
         + STOP      S1N          TIDXNAME[NIDX] = S1N = ALFA NAME OF INDEX (<0)

         + R ADD     *            SET INDEX TYPE AS "ADDRESS INDEX" 
         + TR        EQTBL
         + STOP      TIDXTYPE
         + STOP      NIDX
         + STOP      ZERO         TIDXTYPE[NIDX] = 0 -> "ADDRESS INDEX" 

         + R ADD     OP           
         + SUB       OPUSE        IF OP=USE -> TIDXSETN[NIDX] = 0
         + TR 0      SE3          IF OP=SET -> TIDXSETN[NIDX] = STEPN
         + R ADD     STEPN
SE3      + STORE     VAL

         + R ADD     *            SAVE STEPN OF "SET" INSTR: IS THE START OF LOOP
         + TR        EQTBL        ELSE IS A "USE" INSTR THUS SETN=0
         + STOP      TIDXSETN
         + STOP      NIDX      
         + STOP      VAL          TIDXSETN[NIDX] = STEPN OF CURRENT PACT "SET" INSTR / ZERO FOT "USE" INSTR

         + TR        NEXT    

ERRNOIDX + R ADD     *
         + TR        ERROR
         + STOP      ERRNOIXS     ERROR: MISSING INDEX

ERRNOIDV + R ADD     *
         + TR        ERROR
         + STOP      ERRNOIVS     ERROR: MISSING INDEX VALUE

ERRDSET  + R ADD     *
         + TR        ERROR
         + STOP      ERRDSETS     ERROR: DUPLICATED SET ON SAME INDEX

ERRIDXOV + R ADD     *
         + TR        ERROR
         + STOP      ERRIXOVS     ERROR: TOO MANY INDEXS (MAX 34)

ERRNDIDX + R ADD     *
         + TR        ERROR
         + STOP      ERRNDIDS     ERROR: INDEX NOT ACTIVE (MISSING SET INSTR FOR THIS INDEX)
         
ERRBADTD + R ADD     *
         + TR        ERROR
         + STOP      ERRBADTS     ERROR: BAD TEST DESTINATION IN FACTOR. SHOULD BE BLANK OR A STEP NUMBER         

ERROVLOC + R ADD     *
         + TR        ERROR
         + STOP      ERROVLOS     ERROR: TOO MANY LOOP CONSTANTS IN POOL         
                          
                                  PACT OP=17 TEST   ALL THESE OPERATIONS NEEDS AN INDEX AND A VALUE

                                          OP       FACT                    S1     S2
                                  SYNTAX: TEST     DESTINATION-STEP|BLANK  INDEX  INDEX|ALFAVAR|NUM
                                  IF S2 IS A VARIABLE, ASSIGN ITS ADDRESS TO FACTORN
                                  HERE, S1 IS AN INDEX (SHOULD BE ALFA VALUE <0)
                                        S2 IS AN INDEX (ALFA VALUE <0)
                                           OR  A VAR   (ALFA VALUE <0) -> IN THIS CASE -> FACTN=ADDR OF VAR, FACTREG='V'
                                           OR  A NUMBER (>0)
                                  IF INSTR IS TEST, FACTOR CAN BE A DESTINATION STEPN

                                                   FACT                    S1     S2
                                                   DESTINATION-STEP|BLANK  INDEX  INDEX|ALFAVAR|NUM
                                           FACT    >0               0
                                           S1                              <0
                                           S2                                     <0    <0      nnn
                                           FACTN                                  0     Vnn     0


TEST     + R ADD     S1N
         + TR +      ERRNOIDX     ERROR: MISSING INDEX
         + R ADD     S2N
         + TR 0      ERRNOIDV     ERROR: MISSING INDEX VALUE

         + R ADD     *            SET VARIABLES FOR START OF LOOP STEPN TO TRANSFER TO 
         + TR        TSETN                      INDEX USED IN TEST, END OF LOOP VALUE

         + R ADD     *            GENERATE INST TO INCREMENT VECTOR/MATRIX REFERENCES THAT USES NIDX
         + TR        TMATVEC 

         + R ADD     *            GENERATE MC INSTS TO TEST END OF LOOP CONDITION
         + TR        TENDLOOP

         + R SUB     S1N          MAKE INDEX NAME POSITIVE TO SIGNAL IT IS ALREADY PROCESSED.
         + STORE     VAL          THE DATA OF INDEX STILL IN TABLE, BUT AS NAME IS POSITIVE
                                  IT WILL NOT BE FOUND WHEN SEARCHED FOR
         + R ADD     *            
         + TR        EQTBL
         + STOP      TIDXNAME     
         + STOP      NIDX
         + STOP      VAL          TIDXNAME[NIDX] = VAL = -S1N

         + R ADD     *            CLEAR SETN FIELD AS LOOP HAS FINISHED
         + TR        EQTBL        
         + STOP      TIDXSETN
         + STOP      NIDX      
         + STOP      ZERO         TIDXSETN[NIDX] = ZERO 

         + TR        NEXT         SAVE GENERATED CODE, THEN PROCEED WITH NEXT INSTR

TSETN    + ADD       TWO          SET VARIABLE SETN = THE START OF LOOP STEPN, 
         + STORE A   TSETEX                    NIDX = THE INDEX USED IN "TEST" INSTR
                                               ECONSTIX =0 IF INDEX IS "ADDRESS INDEX" TYPE, 
                                                        >0 IF INDEX IS "COUNT INDEX" TYPE, 
                                                           =ENTRY IN LOOP CONSTANT POOL FOR INDEX VALUE
         + R ADD     *
         + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         + STOP      TIDXNAME     ... INDEX NAME TABLE
         + STOP      NIDXS        ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
         + STOP      S1N          ... THE VALUE TO FIND 
        
         + TR 0      ERRNDIX1     ERROR: INDEX NOT DEFINED
         + STORE     NIDX

         + R ADD     *            READ FROM TIDX TABLES
         + TR        READTBL2
         + STOP      TIDXLOC      
         + STOP      MAXNIDXS
         + STOP      NIDX
         + STOP      ECONSTIX     = TIDXLOC [NIDX] 
         + STOP      VAL          = TIDXTYPE[NIDX] 
         + STOP      SETN         = TIDXSETN[NIDX] 
         + STOP      0000

         + R ADD     VAL          TYPE OF INDEX: 0="ADDRESS TYPE", 1="COUNT TYPE"
         + SUB       ONE
         + TR +      TSE2
         + R ADD     ZERO
         + STORE     ECONSTIX     CLEAR ECONSTIX AS INDEX TYPE IS "ADDRESS TYPE"

TSE2     + R ADD     SETN
         + TR 0      ERRNDIDX     ERROR: INDEX NOT ACTIVE (MISSING SET INSTR FOR THIS INDEX)
         + ADD       ONE
         + STORE     SETN         TEST WILL LOOP TO STEPN INMEDIATELLY FOLLOWING START OF LOOP "SET" PACT INSTR 

         + R ADD     FACT
         + TR 0      TSE1         TR IF NO EXPLICIT TEST DESTINATION -> KEEP SETN AS START OF LOOP
         + TR +      TSE0
         + TR        ERRBADTD     ERROR: BAD TEST DESTINATION IN FACTOR. SHOULD BE BLANK OR A STEP NUMBER
TSE0     + R ADD     FACTN        IF "TEST" INST HAS AN EXPLICIT DESTINATION (FACTN=DESTINATION STEPN), USE IT INSTEAD OF "SET" STEPN
         + STORE     SETN
TSE1     + NOOP      0000         HERE SETN IS THE LOOP START STEPN. 
TSETEX   + TR        /   /
   

TENDLOOP + ADD       TWO          GENERATE INSTR TO INCR LOOP INDEX AND TEST END OF LOOP CONDITION
         + STORE A   TENDLOEX
                                  DETERMINE IF END OF LOOP VALUE IS COMPUTABLE (IE A CONSTANT)

         + R SUB     ONE          INIT TO -1 TO SIGNAL NOT USED  
         + STORE     ECONSEND     = ADDR IN REG C OF END OF LOOP VALUE. 

         + R ADD     *            AN INDEX IS SEARCHED IN PARAMETERS TABLE BY ITS NAME
         + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         + STOP      TPARNAME     ... PARAMETERS NAME TABLE
         + STOP      NPARAMS      ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NPARAMS
         + STOP      S1N          ... THE VALUE TO FIND 

         + TR 0      TE2          =0 -> NO PARAM MATCHES THE INDEX NAME USED IN "TEST" INSTR
         + STORE     NPAR

         + R ADD     *            READ FROM TPARAMS TABLES
         + TR        READTBL
         + STOP      TPARTYPE
         + STOP      NPAR
         + STOP      VAL          = TPARTYPE[NPAR] 

         + R ADD     VAL          GET PARAM TYPE
         + ADD       TWO          =-2 FOR "FOR I A B INDEX LOOP START/END"?
         + TR 0      TE1          YES -> TR
         + TR        TE2          NOT AN INDEX LOOP START/END -> CONTINUE

TE1      + R ADD     *            READ FROM TPARAMS TABLES
         + TR        READTBL
         + STOP      TPARLOC1     AS TYPE=-2 (PARAM IS INDEX LOOP START/END), LOC1=ENTRY IN LOOP CONSTANTS POOL THAT CONTAINS THE END OF LOOP VALUE
         + STOP      NPAR
         + STOP      ECONSEND     = TPARLOC1[NPAR] = ADDR IN REGION C OF END OF LOOP VALUE

         + TR        TECOUNT      TR AS END OF LOOP IS A PARAM STORED IN CONST POOL (ECONSEND)
                                  -> INDEX IS "COUNT TYPE"
TE2      + R SUB     S2N
         + TR +      TECOUNT      TR AS END OF LOOP IS A VAR OR AN INDEX 
                                  -> INDEX IS "COUNT TYPE"
                             
         + R ADD     NLASTREF     LAST ADDR REFERENCE USED
         + TR 0      TECOUNT      TR AS THERE IS NO A LAST REFERENCE OF VECTOR INCR TO BE USED AS END OF LOOP 
                                  -> INDEX IS "COUNT TYPE"

         + R ADD     ECONSTIX     ECONSTIX =0 IF INDEX IS "ADDRESS TYPE", >0 IF INDEX IS "COUNT TYPE", 
         + TR 0      TEADDR       IF INDEX IS ADDRESS TYPE TR TO PERFORM END OF LOOP CHECK ON ADDRESS OF LAST VECTOR INCREMENTED
         + TR        TECOUNT      TR AS INDEX IS COUNT TYPE
                                  -> INDEX IS "COUNT TYPE"

TEADDR   + NOOP      0000         HERE END OF LOOP IS A COMPILE TIME CONSTANT VALUE (S2N) 
                                  AND INDEX IS "TYPE ADDRESS".
                                  INDEX LIMITS ARE NOT REPLACED BY A "FOR I A B" PARAM
                                  THE END OF LOOP CONSTANT CAN BE COMPUTED AS LAST VECTOR ADDRESS INCREMENTED ON LOOP (AS VECTOR IS NOT A PARAM)

         + R ADD     ZERO
         + STORE     QR           SET QR=0 IN CC RECORD TO SIGNAL INDEX IS "ADDRESS TYPE"

         + R ADD     *            READ SEVERAL VALUES FROM TREF TABLES
         + TR        READTBL2
         + STOP      TREFOP       READ THE OP/ADDR OF VARIABLE REFERENCE
         + STOP      MAXNREFS
         + STOP      NLASTREF     
         + STOP      ROP          = TREFOP  [NLASTREF]   THE OPCODE THAT APPLIES ON VECT/MATRIX
         + STOP      RADDR        = TREFADDR[NLASTREF]   THE ADDR OF VECT/MATRIX
         + STOP      0000

         + R ADD     TE3          SET THE REGION REG.V IN ROP
         + STORE A   ROP
         + R ADD     ROP
         + STORE     TE3

         + R ADD     RADDR        COMPUTE END OF LOOP ADDR = VAR ADDR + (END OF LOOP CONSTANT - 1)*2 + 2
         + ADD       S2N          LAST +2 IS NEEDED BECAUSE TEST IS DONE AFTER INCREMENTING VAR ADDR
         + ADD       S2N
         + STORE     RADDR

         + R ADD     *
         + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
TE3      + STOP      REG.V        '+RA  V 0002' -> THE MC INST THAT ACCESS THE LAST VECTOR INCREMENTED ON LOOP
         + STOP      RADDR
         + STORE     ECONST       SAVE THE ENTRY IN CONSTANTS POOL THAT CONTAINS THE CREATED END OF LOOP VALUE (0000=FIRST ENTRY)

         + R ADD     SETN         SET IN TRANFER THE STEPN OF START OF LOOP ALREADT COMPUTED
         + STORE     TRANSFER     INN = addr of stepN given in var TRANSFER = stepN of reference, TRSTLOC = location in reference stepn machine code
         + R ADD     ONE          CNN = location in region loop constants pool
         + STORE     TRSTLOC

         + R ADD     *            GENERATE THE INSTRUCTIONS TO TEST ADDRESS TYPE LOOP END
         + TR        GENINST     
         + SUB       CNN          '+S  C econst'   substract the end of loop constant
         + TR +      INN          '+TP I /  /'     if >=0 tr to start of loop
         + STOP      0000         END OF INSTR TABLE

         + TR        TENDLOEX     END OF LOOP TEST GENERATED

TECOUNT  + NOOP      0000         HERE END OF LOOP IS A VALUE FOR COUNT INDEX (ECONSTIX). 
                                  END OF LOOP VALUE CAN BE 
                                  - A VALUE PASSED AS PARAM (ECONSEND BEING >= 0)
                                  - A COMPILE TIME CONSTANT VALUE (S2N BEING >0) 
                                  - A VARIABLE (FACTREG='V')
                                  - ANOTHER INDEX

         + R ADD     ONE
         + STORE     QR           SET QR=1 IN CC RECORD TO SIGNAL INDEX IS "COUNT TYPE"

         + R ADD     *            
         + TR        MAKEIDXC     MAKE INDEX TYPE "COUNT TYPE"
         + STOP      NIDX


         + R ADD     *            READ FROM TIDX TABLES
         + TR        READTBL
         + STOP      TIDXLOC      READ THE ENTRY IN LOOP CONSTANT POOLS THAT CONTAINS THE CURRENT INDEX VALUE
         + STOP      NIDX
         + STOP      ECONSTIX     = TIDXLOC [NIDX] 

         + R ADD     ECONSTIX     
         + STORE     ECONST
       
         + R ADD     *            GENERATE THE INSTRUCTIONS TO INCR INDEX
         + TR        GENINST     
         + R ADD     CNN          '+RA C econst'   is location of index value
         + ADD       C01          '+S  C econst with value 1'  
         + STORE     CNN          '+SA C econst'   save incremented index back
         + STOP      0000         END OF INSTR TABLE

         + R ADD     ECONSEND
         + TR +      TEEPARAM     TR AS LOOP END VALUE IS A PARAM
         + R ADD     S2N
         + TR +      TECONST      TR AS LOOP END VALUE IS A CONSTANT
         + R ADD     FACTREG
         + SUB       D34          'V'
         + TR 0      TEVAR        TR AS LOOP END IS A VARIABLE
         + TR        TEINDEX      TR AS LOOP END VALUE IS ANOTHER INDEX

TEEPARAM + NOOP      0000         LOOP END VALUE PASSED AS PARAM (ECONSEND=nnnn) IN "FOR I A B" INSTR 

         + R ADD     ECONSEND     GET THE LOOP POOL ENTRY THAT HAS THE LOOP END VALUE PASSED AS PARAM
         + TR        TE11

TEVAR    + NOOP      0000         LOOP END IS A VARIABLE (FACTN=nnnn, FACTREG='V')

         + R ADD     *            GENERATE THE INSTRUCTIONS FOR ACC=END OF LOOP VALUE
         + TR        GENINST     
         + R ADD     CC.FACT      '+RA V nnnn'   is end of loop value 
         + STOP      0000         END OF INSTR TABLE

         + R ADD     NINST        SAVE IN NINCR THE LOCATION INTO STEPN OF MC INSTR THAT ACCESS THE LOOP END
         + STORE     NINCR        VARIABLE, SO IT CAN BE REPLACED LATER IF THIS VARIABLE IS A PARAM BY REFERENCE

         + TR        TESTOIDX     TR TO GENERATE INSTR TO TEST FOR END LOOP AND TR TO LOOP START

                                 
TEINDEX  + NOOP      0000         LOOP END VALUE IS ANOTHER INDEX (S2N)

         + R ADD     *
         + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         + STOP      TIDXNAME     ... INDEX NAME TABLE
         + STOP      NIDXS        ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
         + STOP      S2N          ... THE VALUE TO FIND 
        
         + TR 0      ERRNDIX2     ERROR: END OF LOOP INDEX NOT DEFINED (SHOULD BE DEFINED WITH SET, USE OR ID FOLLOWING A CALL)
         + STORE     NIDX2

         + R ADD     *            
         + TR        MAKEIDXC     MAKE INDEX TYPE "COUNT TYPE"
         + STOP      NIDX2

         + R ADD     *            READ FROM TIDX TABLES
         + TR        READTBL
         + STOP      TIDXLOC      READ THE ENTRY IN LOOP CONSTANT POOL THAT CONTAINS INDEX VALUE
         + STOP      NIDX2
         + STOP      ECONST       = TIDXLOC [NIDX2] 

         + TR        TE12


TECONST  + NOOP      0000         LOOP END VALUE IS A COMPILE TIME CONSTANT VALUE (S2N=nnnn)  IN "TEST   I B" INSTR
         + R ADD     *
         + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
         + STOP      REG.A        '+H  A nnnn' -> CONSTANT VALUE = CONTENTS OF LOOP END VALUE VAR S2N
         + STOP      S2N
TE11     + STORE     ECONST       SAVE THE ENTRY IN POOL THAT CONTAINS THE CREATED LOOP END VALUE (0000=FIRST ENTRY)

TE12     + R ADD     *            GENERATE THE INSTRUCTIONS FOR ACC=END OF LOOP VALUE
         + TR        GENINST     
         + R ADD     CNN          '+RA C econst'   is end of loop value 
         + STOP      0000         END OF INSTR TABLE

TESTOIDX + NOOP      0000         GENERATE INSTR TO TEST FOR END LOOP AND TR TO LOOP START

         + R ADD     ECONSTIX     
         + STORE     ECONST

         + R ADD     SETN         STORE IN TRANSFER THE STEPN OF START OF LOOP ALREADY COMPUTED
         + STORE     TRANSFER     INN = addr of stepN given in var TRANSFER = stepN of reference, TRSTLOC = location in reference stepn machine code
         + R ADD     ONE          CNN = location in region loop constants pool
         + STORE     TRSTLOC

         + R ADD     *            GENERATE THE INSTRUCTIONS FOR TEST AND TR TO START OF LOOP
         + TR        GENINST     
         + SUB       CNN          '+S  C econst'   is current index value 
         + TR +      INN          '+TP I /  /'     if >=0 tr to start of loop
         + STOP      0000         END OF INSTR TABLE

TENDLOEX + TR        /   /        END OF LOOP TEST GENERATED

TMATVEC  + ADD       TWO          GENERATE INST TO INCREMENT MATRIX/VECTORS REFERENCES THAT USES NIDX
         + STORE A   TMATEX

         + R ADD     ZERO         EXAMINE ALL REFERENCES TO MATRIX/VECTOR USING INDEX S1N
         + STORE     NREF
         + STORE     NLASTREF     LAST ADDR REFERENCE USED

TMLOOP1  + R ADD     NREF
         + SUB       NREFS
         + TR 0      TMATEX       ALL REFERENCES PROCESSED -> EXIT
         + R ADD     NREF
         + ADD       ONE
         + STORE     NREF

         + R ADD     *            READ VALUES FROM TREF TABLES
         + TR        READTBL2
         + STOP      TREFNAME     
         + STOP      MAXNREFS
         + STOP      NREF
         + STOP      RNAME        = TREFNAME[NREF]   REFERENCE NAME
         + STOP      RIDX1        = TREFIDX1[NREF]   <0 -> INDEX1 NAME, =0 -> NO INDEX,  >0 -> CONSTANT
         + STOP      RIDX2        = TREFIDX2[NREF]   <0 -> INDEX2 NAME, =0 -> NO INDEX,  >0 -> CONSTANT
         + STOP      RSTEPN       = TREFSTPN[NREF]   STEPN OF INSTR WHERE THE REFERENCE IS MADE
         + STOP      RINCRN       = TREFINCN[NREF]   INCRN OF REFERENCE IN THIS STEP
         + STOP      VAL          = TREFOP[NREF]   
         + STOP      RADDR        = TREFADDR[NREF]   ADDRESS OF VARIABLE/MATRIX Vnnnn
         + STOP      0000
         
         + R ADD     RNAME        IF NAME=0 -> REFERENCE ALREADY PROCESSED. SKIP IT
         + TR 0      TMLOOP1 

         + R ADD     RIDX1
         + SUB       S1N
         + TR 0      TM2          TR IF REFERENCE IS USING SAME 1ST INDEX AS IN "TEST" INSTR 
         + R ADD     RIDX2
         + SUB       S1N
         + TR 0      TM2          TR IF REFERENCE IS USING SAME 2ND INDEX AS IN "TEST" INSTR 
         
         + TR        TMLOOP1      TR TO TRY NEXT REFERENCE, AS THIS ONE IS NOT USING SAME INDEX AS IN "TEST" INSTR 

TM2      + R ADD     *            GENERATE MC CODE TO INCR THE ADDR (AT RSTEN/RINCRN) OF REFERENCE (RNAME)
         + TR        GMATVEC      ACCORDING TO ITS INDEX VALUES (RIDX1, RIDX2)

         + R ADD     *            
         + TR        EQTBL
         + STOP      TREFNAME     CLEAR THE NAME OF REFERENCE TO SIGNAL IT IS ALREADY PROCESSED -> BECOMES AN EMPTY ENTRY 
         + STOP      NREF
         + STOP      ZERO         TREFNAME[NREF] = 0

         + R ADD     *            EXAMINE REMAINING REFERENCES. GENERATE '+SA ' INSTR TO SAVE THE 
         + TR        SASAME       INCREMENTED ADDR ON REFERENCES TO SAME MATRIX WITH SAME INDEXES
         + TR        TMLOOP1      NOW TRY WITH NEXT MATRIX
         
TMATEX   + TR        /   /


GMATVEC  + ADD       TWO          GENERATE MC CODE TO INCR THE ADDR (AT RSTEN/RINCRN) OF REFERENCE (RNAME)         
         + STORE A   GMVEXIT      ACCORDING TO ITS INDEX VALUES (RIDX1, RIDX2)
                                  - IF RNAME IS A PARAM BY REFERENCE -> GET D1 PASSED AS PARAM (ELSE D1=TREFD1[NREF])
                                  - IF RIDX1=INDEX IN "TEST" INSTR -> INCR ADDR OF REF BY D1
                                  - IF RIDX2=INDEX IN "TEST" INSTR -> INCR ADDR OF REF BY D2 (ALLWAYS =2)

         + R ADD     RSTEPN       
         + STORE     TRANSFER     INN = addr of stepN given in var TRANSFER = stepN of reference, TRSTLOC = location in reference stepn machine code
         + R ADD     RINCRN       CNN = location in region loop constants pool
         + STORE     TRSTLOC

         + R ADD     *            GENERATE THE INSTRUCTIONS TO SET ACC=ADDR OF REFERENCED MATRIX ADDRESS 
         + TR        GENINST     
         + R ADD     INN          '+RA I /  /'     is location of    V nnnn    of reference
         + STOP      0000         END OF INSTR TABLE

         + R ADD     NREF         SAVE AS POSSIBLE LAST REF FOR "ADDRESS INDEX" END OF LOOP CALCULATION
         + STORE     NLASTREF

         + R ADD     *            A VARIABLE IS SEARCHED IN PARAMETERS TABLE BY ITS ADDRESS
         + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         + STOP      TPARNAME     ... CALL PARAMETERS NAME TABLE
         + STOP      NPARAMS      ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NPARAMS
         + STOP      RADDR        ... THE VALUE TO FIND 

         + TR 0      TM5          IF NOT FOUND -> REFERENCED VECTOR/MATRIX IS NOT A PARAM -> USE STANDARD VALUE D1 
         + STORE     NPAR         HERE REFERENCED VECTOR/MATRIX IS PASSED AS PARAM -> SHOULD GET THE D1 VALUE ALSO PASSED AS PARAM

         + R ADD     *            READ FROM TPARAMS TABLES
         + TR        READTBL
         + STOP      TPARLOC1     LOC1=ENTRY IN LOOP CONSTANT POOL THAT CONTAINS THE D1 VALUE PASSED AS PARAM
         + STOP      NPAR
         + STOP      ECONST       = TPARLOC1[NPAR] ENTRY IN LOOP CONSTANT POOL THAT CONTAINS THE D1 PASSED AS PARAM

         + R ADD     ZERO         THIS REFERENCE IS A PARAM, ITS ADDRESS WILL BE SET IN RUN TIME -> THIS REF IS
         + STORE     NLASTREF     NOT SUITABLE TO BE USED AS POSSIBLE LAST REF FOR "ADDRESS INDEX" END OF LOOP CALCULATION
                                  (NO NEED TO SET NLASTREF=0 IF TWO INDEXES ARE USED (MATRIX VAR), BECAUSE MATRIX REFERENCES
                                  FORCES BOTH INDEXES AS "COUNT TYPE") 
         + TR        TM6

TM5      + R ADD     *            READ FROM TREFS TABLES
         + TR        READTBL
         + STOP      TREFD1       READ D1 VALUE OF VECTOR/MATRIX REFERENCED
         + STOP      NREF
         + STOP      VAL          = TREFD1[NREF] 

         + R ADD     *            
         + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
         + STOP      REG.A        '+H  A nnnn' -> CONSTANT VALUE GIVEN IN VAL VARIABLE =D1 OF REFERENCED MATRIX
         + STOP      VAL
         + STORE     ECONST       SAVE THE ENTRY IN POOL THAT CONTAINS THE CREATED D1 VALUE (1ST ENTRY = 0000)

TM6      + R ADD     RIDX1
         + SUB       S1N
         + TR 0      TM6A         TR IF REFERENCE IS USING SAME 1ST INDEX AS IN "TEST" INSTR 
         + TR        TM6I         TR TO CHECK IF REFERENCE IS USING SAME 2ND INDEX AS IN "TEST" INSTR 

TM6A     + R ADD     *            GENERATE THE INSTRUCTIONS TO INCREMENT REFERENCED MATRIX ADDRESS ON 1ST DIMENSION
         + TR        GENINST
         + SUB       CNN          '+S  C econst'   substract D1 value (=2 or value passed as param) to instr to increment addr (as instr is negative)
         + STOP      0000         END OF INSTR TABLE

TM6I     + R ADD     RIDX2        TR IF REFERENCE IS USING SAME 2ND INDEX AS IN "TEST" INSTR. NOTE THAT 
         + SUB       S1N          "MATRIX I I" IS POSSIBLE, SO EACH INDEX CAN INCREMENT THE REFERENCED MATRIX ADDR
         + TR 0      TM6J
         + TR        TM6K         TR TO PROCEED

TM6J     + R ADD     *            GENERATE THE INSTRUCTIONS TO INCREMENT REFERENCED MATRIX ADDRESS ON 2ND DIMENSION
         + TR        GENINST     
         + SUB       C02          '+S  C econst with value 2'   substract D2 value. D2 allways is =2, no need to check if matrix is passed as param
         + STOP      0000         END OF INSTR TABLE

TM6K     + R ADD     *            GENERATE THE INSTRUCTIONS TO SAVE INCREMENTED VECTOR/MATRIX ADDRESS
         + TR        GENINST     
         + STORE A   INN          '+SA I /  /'     store back the address of reference var incremented by D1 
         + STOP      0000         END OF INSTR TABLE

GMVEXIT  + TR        /   /



SASAME   + ADD       TWO          EXAMINE REMAINING REFERENCES. GENERATE '+SA ' INSTR TO SAVE THE 
         + STORE A   SASAMEEX     INCREMENTED ADDR ON ACC TO REFERENCES TO SAME VECTOR/MATRIX
                                  WITH SAME INDEXES

         + R ADD     NREF         EXAMINE REMAINING REFERENCES. 
         + STORE     NREF2        

SALOOP2  + R ADD     NREF2
         + SUB       NREFS        GENERATE '+SA I /  /' MC INST FOR
         + TR 0      SASAMEEX     ALL REFERENCES OF SAME VECTOR/MATRIX PROCESSED
         + R ADD     NREF2
         + ADD       ONE
         + STORE     NREF2

         + R ADD     *            READ SEVERAL VALUES FROM TREF TABLES
         + TR        READTBL2
         + STOP      TREFNAME     READ THE FIRST VARIABLE REFERENCE
         + STOP      MAXNREFS
         + STOP      NREF2
         + STOP      R2NAME       = TREFNAME[NREF2]   REFERENCE NAME
         + STOP      R2IDX1       = TREFIDX1[NREF2]   INDEX1 USED BY REFERENCE 
         + STOP      R2IDX2       = TREFIDX2[NREF2]   INDEX2 USED BY REFERENCE 
         + STOP      R2STEPN      = TREFSTPN[NREF2]   STEPN OF INSTR WHERE THE REFERENCE IS MADE
         + STOP      R2INCRN      = TREFINCN[NREF2]   INCRN OF REFERENCE IN THIS STEP
         + STOP      VAL          = TREFOP  [NREF2]   
         + STOP      R2ADDR       = TREFADDR[NREF2]   ADDRESS OF VARIABLE/MATRIX Vnnnn
         + STOP      0000
         
         + R ADD     R2NAME       CHECK IF REFERENCE ALREADY PROCESSED
         + TR 0      SALOOP2      IF SO, TRY NEXT REFERENCE 
         + R ADD     R2ADDR       CHECK IF SAME MATRIX/VECTOR 
         + SUB       RADDR        IF NOT, TRY NEXT REFERENCE 
         + TR 0      SA6A
         + TR        SALOOP2
SA6A     + R ADD     R2IDX1
         + SUB       RIDX1
         + TR 0      SA6B
         + TR        SALOOP2
SA6B     + R ADD     R2IDX2
         + SUB       RIDX2
         + TR 0      SA6C
         + TR        SALOOP2
SA6C     + NOOP      0000         HERE WE HAVE ANOTHER REFERENCE TO SAME VECTOR

         + R ADD     R2STEPN       
         + STORE     TRANSFER     INN = addr of stepN given in var TRANSFER = stepN of reference, TRSTLOC = location in reference stepn machine code
         + R ADD     R2INCRN      CNN = location in region loop constants pool
         + STORE     TRSTLOC

         + R ADD     *            GENERATE THE INSTRUCTIONS TO INCREMENT THE SAME REFERENCED VECTOR ADDRESS 
         + TR        GENINST     
         + STORE A   INN          '+SA I /  /'     store back the address of reference var incremented by D1
         + STOP      0000         END OF INSTR TABLE

         + R ADD     *            
         + TR        EQTBL
         + STOP      TREFNAME     CLEAR THE NAME OF REFERENCE TO SIGNAL IT IS ALREADY PROCESSED -> BECOMES AN EMPTY ENTRY 
         + STOP      NREF2
         + STOP      ZERO         TREFNAME[NREF] = 0

         + TR        SALOOP2
SASAMEEX + TR        /   /


                                  CHECK IF STEP IS A VECTOR/MATRIX USING INDEXES
                                  IF SO, ADD TO REFERENCE TABLE TO GENERATE CODE IN "TEST" INSTR
                                  TO INCREMENT ADDRESS. 

                                          OP       FACT             S1                S2
                                  SYNTAX:          VAR|NUM          INDEX|NUM|BLANK   INDEX|NUM|BLANK
                                          FACT     <0   0            
                                          FACTN    Vnn  0    
                                          NUM      0   nnn                                        <-- if factor=num, cannot have indexes
                                  ONE     
                                  INDEX   S1N/S2N                   <0    >0    0      
                                          D1N/D2N                    2     2    0     
                                  TWO     
                                  INDEXS  S1N/S2N                   <0    >0    0     <0    >0    0      
                                          D1N/D2N                  2*D2   2*D2  0      2     2    0     <-- D2 is VAR'S Dimension 2 in matrix
                                          
                                          D1N=-1 IF MATRIX/VECTOR WITH CONSTANT SUBSCRIPTS
CHECKREF + R ADD     FACTREG
         + SUB       D34          'V'
         + TR 0      CK1
         + TR        NEXT         STEP NOT USING A VARIABLE
         
CK1      + R ADD     S1N          IF S1N <0 (ALFA BASE48 INDEX NAME) -> STORE IN REFERENCES
         + TR +      CK1A         IF S1N >=0 (NUMERIC CONSTANT/BLANK) -> IS NOT AN INDEX -> TR TO CHECK INDEX2
         + TR        CK1B

CK1A     + R ADD     S2N          IF S1N <0 (ALFA BASE48 INDEX NAME) -> STORE IN REFERENCES
         + TR +      NEXT         IF S1N >=0 (NUMERIC CONSTANT/BLANK) -> IS NEITHER AN INDEX -> NOT USING INDEXES -> TR TO PROCESS NEXT STEP
         + TR        CK1B

CK1B     + R ADD     NREFS        CREATE A NEW REFERENCE ENTRY
         + TR 0      CK1NEW       IF TABLE EMPTY -> TR TO CREATE A NEW ENTRY
                                  SEARCH FOR EMPTY (NAME=0) ENTRIES
         + R ADD     *
         + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         + STOP      TREFNAME     ... INDEX NAME TABLE
         + STOP      NREFS        ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
         + STOP      ZERO         ... THE VALUE TO FIND 

         + TR 0      CK1NEW       NO EMPTY ENTRY FOUND -> TR TO CREATE A NEW ONE
         + STORE     NREF         EMPTY ENTRY FOUND -> TR TO USE IT
         + TR        CK1NEW2

CK1NEW   + R ADD     NREFS        CHECK IF TABLE OVERLOW
         + SUB       MAXNREFS     
         + TR 0      ERROVREF     
         + R ADD     NREFS        CREATE NEW REF
         + ADD       ONE
         + STORE     NREFS
         + STORE     NREF
         
CK1NEW2  + LOAD MQ   ONE   
         + R ADD     OP           OP=40  ID for DO/LIB       ONLY APPLIES INDEX IF IT IS ACTIVE
         + SUB       OPIDDO       On ID for DO/LIB, non-active index indicates the dimension
         + TR 0      CK2A         of vector/matrix to pass as param to the called routine
         + LOAD MQ   ZERO         so flag CKIDXACT=1 -> set index S1N/S2N to -777777 octal if index not active
CK2A     + STORE MQ  CKIDXACT                                                -777776 octal if index not defined
                        
         + R ADD     S2N          IF NO 2ND INDEX -> REFERENCE TO A VECTOR -> INDEX CAN BE "ADDRESS TYPE" 
         + TR 0      CK2B         IF THERE IS A 2ND INDEX -> REFERENCE TO A MATRIX -> BOTH INDEX SHOULD BE "COUNT TYPE"
         + R ADD     ONE          
CK2B     + STORE     CKMKCNT      FLAG: =1 -> MAKE INDEX "COUNT TYPE" IF IT IS DEFINED
                  
         + R ADD     S1N          USING 1ST INDEX?
         + TR +      CK3A
         + R ADD     *            YES, CHECK IF DEFINED
         + TR        CKINDEX
         + STOP      S1N
         + TR OV     ERRNDIX1     TR TO ERROR IF 1ST INDEX IS NOT DEFINED       

CK3A     + R ADD     S2N          USING 2ND INDEX?
         + TR +      CK3B
         + R ADD     *            YES, CHECK IF DEFINED
         + TR        CKINDEX
         + STOP      S2N
         + TR OV     ERRNDIX2     TR TO ERROR IF 2ND INDEX IS NOT DEFINED       
                 
CK3B     + R ADD     NINCR        GET THE MC INSTR POINTED BY
         + TR 0      BADOP        NINCR THAT REFERENCES THE 
         + SUB       ONE          FACTOR VARIABLE
         + A LEFT    0001
         + ADD       TINSTAD
         + STORE A   CK3C
CK3C     - R ADD     /   /
         - STORE     DATA         

         + R ADD     *            STORE IN TABLES
         + TR        EQTBL2
         + STOP      TREFNAME     
         + STOP      MAXNREFS
         + STOP      NREF
         + STOP      FACT         TREFNAME[NREF] = 
         + STOP      S1N          TREFIDX1[NREF] <0 -> INDEX NAME, =0 -> NO INDEX,  >0 -> CONSTANT, *777777/6 -> NOT ACTIVE/DEFINED INDEX
         + STOP      S2N          TREFIDX2[NREF] <0 -> INDEX NAME, =0 -> NO INDEX,  >0 -> CONSTANT, *777777/6 -> NOT ACTIVE/DEFINED INDEX
         + STOP      STEPN        TREFSTEP[NREF] = 
         + STOP      NINCR        TREFINCR[NREF] = 
         + STOP      DATA         TREFOP  [NREF] = 
         + STOP      DATA2        TREFADDR[NREF] = 
         + STOP      D1N          TREFD1  [NREF] = 
         + STOP      0000

         + TR        NEXT         

CKINDEX  + ADD       TWO          CHECK IF INDEX ACTIVE OR DEFINED
         + STORE A   CKIP1        PARAM: THE INDEX VAR. 
         + ADD       ONE          RETURN OV SET IF INDEX NOT DEFINED
         + STORE A   CKIDEX

CKIP1    + R ADD     /   /        GET ADDR WHERE THE INDEX NAME IS STORED
         + STORE A   CKIP1A
         + STORE A   CKI4ST
CKIP1A   + R ADD     /   /        DERREFERENCE TO GET THE INDEX NAME (IF <0)  
         + STORE     CKIDX

         + R ADD     *
         + TR        SRCHTBL      SEARCH TABLE, RETURN ACC=FOUND ENTRY (=0 IF NOT FOUND)
         + STOP      TIDXNAME     ... INDEX NAME TABLE
         + STOP      NIDXS        ... SEARCH FROM HALF-WORD 1 UP TO (AND INCLUDING) NIDXS
         + STOP      CKIDX        ... THE VALUE TO FIND 
         
         + STORE     NIDX    
         
         + R ADD     CKIDXACT     IS =1?  
         + SUB       ONE
         + TR 0      CKI4         YES, TR TO set CC index name to -777777 octal if index not active
         
         + R ADD     NIDX
         + TR 0      CKI3ND       TR IF INDEX IS NOT DEFINED -> RETURN OV=1
                  
CKI2B    + R ADD     CKMKCNT      FLAG>0 -> MAKE INDEX COUNT TYPE IF DEFINED
         + TR 0      CKIDEX       FLAG=0 -> JUST EXIT 

         + R ADD     *            
         + TR        MAKEIDXC     MAKE INDEX TYPE "COUNT TYPE"
         + STOP      NIDX
         + TR        CKIDEX       JUST EXIT
         
CKI3ND   + NOOP      0000         HERE, INDEX IS NOT DEFINED. 
         + R ADD     ONE          
         + A LEFT    0036         SET OV FLAG TO NOTIFY INDEX NOT DEFINED AND THUS NOT ACTIVE)
         + TR        CKIDEX       EXIT 
         
CKI4     + R ADD     NIDX
         + TR 0      CKI4ND       TR IF INDEX IS NOT DEFINED -> SET CALLER'S S1N/S2N TO *777776
                                                  
         + R ADD     *            
         + TR        READTBL      CHECK IF INDEX IS ALSO ACTIVE
         + STOP      TIDXSETN     IF SETN > 0 INDEX IS ACTIVE
         + STOP      NIDX
         + STOP      SETN         = TIDXSETN[NIDX] 
         
         + R ADD     SETN
         + TR 0      CKI4NA       TR IF INDEX IS NOT ACTIVE -> SET CALLER'S S1N/S2N TO *777777
         + TR        CKI2B        INDEX IS ACTIVE -> NO WORRIES FOR OP=40 DO for DO/LIB instr -> NORMAL PROCESSING
         
CKI4ND   + R ADD     O776K        INDEX IS NOT DEFINED
         + TR        CKI4ST
CKI4NA   + R ADD     O777K        INDEX IS NOT ACTIVE    
CKI4ST   + STORE     /   /        SET INDEX NAME IN CALLER ROUTINE TO OCTAL 777777/6 THEN EXIT
CKIDEX   + TR        /   /

ERROVREF + R ADD     *
         + TR        ERROR
         + STOP      ERROVRFS     ERROR: TOO MANY REFERENCES TO MATRIX/VECTOR IN REGION (MAX 50)

ERRNDIX1 + R ADD     *
         + TR        ERROR
         + STOP      ERRNDI1S     ERROR: 1ST INDEX NOT DEFINED (TO BE USED WITH VECTOR/MATRIX INDEX SHOULD BE DEFINED WITH USE/SET)

ERRNDIX2 + R ADD     *
         + TR        ERROR
         + STOP      ERRNDI2S     ERROR: 2ND INDEX NOT DEFINED (TO BE USED WITH VECTOR/MATRIX INDEX SHOULD BE DEFINED WITH USE/SET)

MAKEIDXC + ADD       TWO          MAKE SURE IDX IS COUNT TYPE. 
         + STORE A   MKIXCP1      
         + ADD       ONE
         + STORE A   MAKEIDEX

MKIXCP1  + R ADD     /   /
         + STORE A   MKIXCP1A
MKIXCP1A + R ADD     /   /
         + STORE     MKCIDX       INDEX TO SET 
         + TR 0      MAKEIDEX     EXIT IF INDEX TO SET = 0 
         
         + R ADD     *            
         + TR        EQTBL   
         + STOP      TIDXTYPE     SET THE INDEX TYPE TO "COUNT INDEX"
         + STOP      MKCIDX       
         + STOP      ONE          TIDXTYPE[MKCIDX] = 1

MAKEIDEX + TR        /   /


ADDCONST + ADD       TWO          ADD CONSTANT TO LOOP CONSTANT POOL 
         + STORE A   ADDCP1       PARAMS: +OP    REG     <-- THE SIGNED OP AND REGION OF CONSTANT
         + ADD       ONE                   00    ADDR        THE ADDR. IF =0 -> ALLWAYS STORE A NEW CONSTANT 
         + STORE A   ADDCP2       RETURN IN ACC THE ENTRY OF ADDED CONST (FIRST ENTRY = 0000)
         + ADD       ONE                           
         + STORE A   ADDCONEX     SEARCH IF CONST ALREADY BEEN ADDED, IF SO RETURN ITS ENTRY
                                  ELSE ADD IT

ADDCP1   + R ADD     /   /        THE OP AND REGION PART OF CONSTANT
         + STORE A   ADDCP1A      SAVE THE ADDR OF VAR THAT HOLD THE REGION NUMBER 0..7
         + STORE     DATA         SAVE OP
ADDCP1A  + R ADD     /   /        READ THE REGION NUM FROM VAR 
         + STORE A   DATA         ADD TO OP. NOW OP= +/- OPCODE AND REGION 0..7

         + R ADD     NLOCONST     GET NUMBER OF ENTRIES
         + TR 0      AN1A         IF EMPTY, ADD 1ST ENTRY '+H A 0002'
         + TR        AN1Z                       2ND ENTRY '+H A 0001'
AN1A     + R ADD     TWO
         + STORE     NLOCONST     
         + A RIGHT   0018
         - STORE     TLOCONST
         + R ADD     ONE
         + A RIGHT   0018
         - STORE     TLOCONS2

AN1Z     + R ADD     ZERO
         + STORE     DATA2
ADDCP2   + R ADD     /   /        THE ADDR OF VALUE TO STORE IN ADDR PART OF CONSTANT 
         + TR 0      ADDNEW       IF ZERO -> JUST ADD A NEW ENTRY IN POOL
         + STORE A   ADDCP2A
ADDCP2A  + R ADD     /   /
         + STORE     DATA2

                                  SEARCH IF CONST ALREADY IN THE TABLE
         + R ADD     TLOCONAD     ADDR OF START OF LOOP CONSTANT TABLE
         + STORE A   ADDCLOOP 
         + R ADD     NLOCONST 
         + A LEFT    0001
         + ADD       TLOCONAD
         + STORE A   TLOCOEND     ADDR OF END OF LOOP CONSTANT TABLE

ADDCLOOP - R ADD     /   /
         - SUB       DATA
         + TR 0      ADDFND       FOUND IN LOOP CONSTANT POOL

         + R ADD     ADDCLOOP 
         + SUB       TWO
         + STORE A   ADDCLOOP 
         + SUB       TLOCOEND
         + TR 0      ADDNFND      NOT FOUND IN POOL -> JUST ADD A NEW ENTRY IN POOL
         + TR        ADDCLOOP 

ADDFND   + R SUB     ADDCLOOP     COMPUTE THE ENTRY NUMBER (FIRST ENTRY = 0000)
         + SUB       TLOCONAD     
         + STORE A   TLOCENT  
         + R ADD     TLOCENT  
         + A RIGHT   0001
         + TR        ADDCONEX 

ADDNEW   + R ADD     ZERO         NEW ENTRY IS INIT TO ZERO
         - STORE     DATA

ADDNFND  + R ADD     NLOCONST     ADD NEW ENTRY
         + SUB       MAXNCONS
         + TR 0      ERROVLOC     ERROR: TOO MANY LOOP CONSTANTS IN POOL

         + R ADD     NLOCONST     ADD NEW ENTRY
         + STORE     TLOCENT      THE ENTRY (0000=1ST ENTRY) FOR NEW CONSTANT CREATED IN POOL
         + ADD       ONE
         + STORE     NLOCONST     
         + SUB       ONE
         + A LEFT    0001
         + ADD       TLOCONAD 
         + STORE A   ADDENT
         - R ADD     DATA
ADDENT   - STORE     /   /
         + R ADD     TLOCENT      RETURN THE ENTRY
         + TR        ADDCONEX 

TLOCONAD + STOP      TLOCONST
TLOCOEND - R ADD     0000
TLOCENT  + STOP      0000

ADDCONEX + TR        /   /


GENINST  + ADD       TWO          GENERATE MACHINE CODE (MC) INSTRUCTIONS
         + STORE A   MC.TABLE     MC TABLE FOLLOWS CALL AS PARAMTERS (UNTIL -STOP 0000 INSTR)
         + R ADD     *
         + TR        GENTABLE
         + R ADD     GEN1
         + ADD       ONE

         + STORE A   GENEXIT2      
GENEXIT2 + TR        /   /


GENTBOV  + R ADD     *
         + TR        ERROR
         + STOP      ERROVINS     ERROR: TOO MANY INSTR IN THIS STEP

GENTABLE + ADD       TWO          GENERATE MACHINE CODE (MC) INSTRUCTIONS
         + STORE A   GENEXIT      MC TABLE AT LOCATION IN MC.TABLE VAR
                                  ADD THEM TO COMPACT CODE REGISTER 
         + R ADD     MC.TABLE
         + STORE A   GEN1

GEN1     + R ADD     /   /        READ MACHINE CODE TABLE
GENEXIT  + TR 0      /   /        =0 -> END OF MC.TABLE-> RETURN TO CALLER
         + STORE     MC
         + A RIGHT   0030         SAVE OPCODE ONLY
         + A LEFT    0030         (WITH SIGN)
         + STORE     MC.OP        IN MC.OP

         + R ADD     NINST        INCR NUMBER OF MC INSTRUCTIONS IN CC TABLE
         + ADD       ONE          ERROR IF > MAXIMUN ALLOWED
         + STORE     NINST
         + SUB       MAXNINST
         + TR 0      GENTBOV      ERROR: TOO MANY INSTR IN THIS STEP

         + R ADD     ZERO
         + ADD AB    MC           EXTRACT ADDR PART OF MC 
         + SUB AB    MC.OP        
         + SUB       D1000
         + TR +      GEN2
         + STOP      1111         INVALID MC.TABLE
GEN2     + ADD       ADTBL        USE THE TRANSFER TABLE TO PROCESS IT
         + STORE A   ADTBLTR
         + R ADD     ZERO
         + ADD AB    MC.OP        ON ENTRY TO ROUTINE, ACC=ABS(MC.OP). SIGN IS IN MC VARIABLE
ADTBLTR  + TR        /   /
ADTBL    + STOP      *
         + TR        GEN.FACT     factor to be replaced by V 0005 (variable), T 0010 (result of a step) or N 0012 (a number)
         + TR        GEN.INN      transfer to location n (1..199) into stepN given in var TRANSFER = stepN, TRSTLOC = location in step machine code
         + TR        GEN.CNN      C nnnn  where nnnn is the value of ECONST var
         + TR        GEN.C01      C nnnn  where nnnn is the value ONE in LOOP CONSTANTS POOL
         + TR        GEN.C02      C nnnn  where nnnn is the value TWO in LOOP CONSTANTS POOL


GENADD   + R ADD     MC           ADD A GENERATED MC INSTR TO TINST TABLE
         + TR +      GENADD1      TAKE THE SIGN OF MC AND PLACE IT IN MC.OP
         + R SUB     MC.OP
         + STORE     MC.OP
GENADD1  + R ADD     NINST        ADD NINST TWICE AS EACH MC INSTR USES TWO HALF-WORDS
         + ADD       NINST
         + SUB       TWO          
         + ADD       TINSTAD      TINSTAD=LOCATION OF TABLE WITH MC INSTRUCTIONS GENERATED FOR THE CURRENT STEP
         + STORE A   GENADD2      TINST[ (INST- 1)*2 ] =MC instr op and region
         + ADD       ONE
         + STORE A   GENADD3      TINST[ (INST- 1)*2 ] =MC instr addr
         + R ADD     MC.OP        
GENADD2  + STORE     /   /        STORE GENERATED MC INSTRUCTION MC.OP (MC.OP CAN BE >0 OR <0)
         + R ADD     MC.ADDR
GENADD3  + STORE     /   /                                       MC.ADDR (CAN BE >0 OR <0 IF HOLDS A STEPN/LOCATION PAIR)

         + R ADD     GEN1         PROCEED WITH NEXT MC INST N LIST
         + ADD       ONE
         + STORE A   GEN1
         + TR        GEN1



GEN.INN  + ADD       TRSTLOC      TRSTLOC=LOCATION INTO STEPN NUMBER THE MC INSTR HAS TO TRANSFER TO 
         + STORE     MC.OP        MC.OP   = OPCODE + LOCATION INTO STEPN
         + R SUB     TRANSFER     TRANSFER=STEPN NUMBER THE MC INSTR HAS TO TRANSFER TO 
         + STORE     MC.ADDR      MC.ADDR = STEPN (WITH MINUS SIGN, TO SIGNAL ADDR POINTS TO STEPN/LOCATION IN THIS STEP PAIR)
         + TR        GENADD       TR TO ADD INSTR TO CC TABLES

GEN.CNN  + ADD       REG.C
         + STORE     MC.OP        MC.OP   = OPCODE + REGION C
         + R ADD     ECONST
         + STORE     MC.ADDR      MC.ADDR = ADDR IN REGION C
         + TR        GENADD       TR TO ADD INSTR TO CC TABLES

GEN.C01  + ADD       REG.C
         + STORE     MC.OP        MC.OP   = OPCODE + REGION C
         + R ADD     *
         + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
         + STOP      REG.A        '+H  A 0001' -> CONSTANT VALUE 1
         + STOP      ONE
         + STORE     MC.ADDR      MC.ADDR = ADDR IN REGION C
         + TR        GENADD       TR TO ADD INSTR TO CC TABLES

GEN.C02  + ADD       REG.C
         + STORE     MC.OP        MC.OP   = OPCODE + REGION C
         + R ADD     *
         + TR        ADDCONST     ADD CONSTANT TO LOOP CONSTANT POOL 
         + STOP      REG.A        '+H  A 0002' -> CONSTANT VALUE 2
         + STOP      TWO
         + STORE     MC.ADDR      MC.ADDR = ADDR IN REGION C
         + TR        GENADD       TR TO ADD INSTR TO CC TABLES

GEN.FACT + LOAD MQ   REG.V
         + R ADD     FACTREG
         + SUB       D34          'V'
         + TR 0      GEN.FA1
         + LOAD MQ   REG.N
         + R ADD     FACTREG
         + SUB       D26          'N'
         + TR 0      GEN.FA1
         + LOAD MQ   REG.T
         + R ADD     FACTREG
         + SUB       D32          'T'
         + TR 0      GEN.FA1
         + STOP      1111         INTERNAL COMPILER ERROR: INVALID FACT REGION
GEN.FA1  + R ADD     ZERO
         + L LEFT    0035         A=MQ
         + ADD AB    MC.OP
         + STORE     MC.OP        MC.OP   = OPCODE + REGION OF FACTOR (CAN BE V, N OR T)
         + R ADD     FACTN
         + STORE     MC.ADDR      MC.ADDR = FACTN
         + R ADD     NINST   
         + STORE     NINCR        NINCR= THE LOCATION OF FACTOR MC INSTRUCTION INTO THE STEP 
         + TR        GENADD       TR TO ADD INSTR TO CC TABLES

                            
PRTMC    + ADD       TWO          PRINT TINST TABLE WITH MC INSTRUCTIONS GENERATED FOR THIS STEP
         + STORE A   PRTMCEX
         + R ADD     ZERO
         + STORE     PRTMCNUM

PMCLOOP  + R ADD     PRTMCNUM
         + SUB       NINST
         + TR 0      PRTMCEX      EXIT IF ALL NINST INSTRUCTIONS PRINTED
         + R ADD     PRTMCNUM     INCR COUNT
         + ADD       ONE
         + STORE     PRTMCNUM     GET MC INSTR FROM TINST[ (PRTMCNUM-1)*2 ]
         + ADD       PRTMCNUM
         + SUB       TWO
         + ADD       TINSTAD
         + STORE A   PMCAD1
         + ADD       ONE
         + STORE A   PMCAD2
         + R ADD     ZERO
         + STORE     MC.REG       INIT REGION REFERENCED BY MC
PMCAD1   + R ADD     /   /
         + STORE A   MC.REG
         + A RIGHT   0012
         + STORE     MC.OP        MC.OP HAS NOW THE SIGNED OPCODE -31..31 

PMCAD2   + R ADD     /   /
         + STORE     MC.ADDR
         + TR +      PMC3         IF MC.ADDR >=0 THEN MC.REG HOLDS THE REGION FOR MC.ADDR 
         + R ADD     MC.REG       IF MC.ADDR <0 THEN MC.REG VAR HOLDS THE LOCATION INTO STEPN REFERENCED BY MC.ADDR
         + STORE     TRSTLOC      LOCATION IN STEP GIVEN BY MC.ADDR
         + R SUB     MC.ADDR      MAKES MC.ADDR POSITIVE. IT IS THE DESTINATION STEP
         + STORE     MC.ADDR
         + R ADD     REG.I
         + STORE     MC.REG       SET REGION I -> MC.ADDR=THE STEPN, TRSTLOC=THE NINST REFERENCED IN THIS STEPN

PMC3     + R ADD     *            START NEW LINE TO PRINT
         + TR        CLRBUF

         + R ADD     REGCSTEP     THIS IS THE STEPN WHERE THE REG.C SITS
         + SUB       STEPN
         + TR 0      PMC3C        TR TO PRINT REG "C NNNN" INSTEAD OF STEPN.MCNUM
         + TR        PMC3Z

PMC3C    + LOAD MQ   D15          PRINT 'C'
         + R ADD     *
         + TR        PRTCHR
         + STOP      0039         AT COL 39
         + R ADD     PRTMCNUM     INST NUMBER 1..99
         + SUB       ONE          -1 -> IS THE ADDRESS IN REGION C
         + L RIGHT   0035         ACC->MQ
         + R ADD     *
         + TR        PRTINT
         + STOP      0040         AT COL 40 
         + STOP      0004         LEN=4
         + TR        PMC5SGN

PMC3Z    + LOAD MQ   STEPN        PRINT STEPN
         + R ADD     *
         + TR        PRTINT
         + STOP      0040         AT COL 40 
         + STOP      0004         LEN=4
         + LOAD MQ   D43          PRINT '.'
         + R ADD     *
         + TR        PRTCHR
         + STOP      0044         AT COL 44 
         + LOAD MQ   TWO
         + R ADD     PRTMCNUM     IF INST NUMBER < 10 PRINT IT
         + SUB       D10          WITH LEN=1, IF >= 10 USE LEN=2
         + TR +      PMC4
         + LOAD MQ   ONE
PMC4     + STORE MQ  PMC5
         + LOAD MQ   PRTMCNUM
         + R ADD     *
         + TR        PRTINT
         + STOP      0045         AT COL 45 
PMC5     + STOP      0002         LEN=1 OR 2

PMC5SGN  + LOAD MQ   D12          '+'
         + R ADD     MC.OP
         + TR +      PMC6
         + LOAD MQ   D11          '-'
PMC6     + R ADD     *            PRINT OP SIGN
         + TR        PRTCHR
         + STOP      0048         AT COL 48

         + R ADD     ZERO
         + ADD AB    MC.OP
         + ADD       TMNEAD
         + STORE A   PMC7
PMC7     + LOAD MQ   /   /
         + R ADD     *            PRINT OP MNEMONIC
         + TR        PRTALF
         + STOP      0049         AT COL 49

         + R ADD     MC.REG
         + ADD       TREGMNEA     CHARS IN TREGMNE ARE TXT ALFA VALUES  
         + STORE A   PMC8         THUS ARE NEGATIVE
PMC8     + R SUB     /   /        CHANGE SIGN BEFORE STORING IT IN MQ
         + L RIGHT   0035
         + R ADD     *            PRINT REGION LETTER V I S T A N
         + TR        PRTCHR
         + STOP      0052         AT COL 52
         
         + R ADD     MC.REG       IF MC.REG='I' THEN ...
         + SUB       REG.I        
         + TR 0      PMC9         TR TO PRINT STEPN.LOCATION
         + R ADD     MC.REG       IF MC.REG='S' THEN ...
         + SUB       REG.S
         + TR 0      PMC8B        TR TO PRINT ALFA SYMBOL TO TRANSFER TO
         
         + LOAD MQ   MC.ADDR      MC.REG IS 'V', 'T', 'A' OR 'N'
         + R ADD     *            JUST PRINT THE INST ADDRESS
         + TR        PRTINT
         + STOP      0053         AT COL 53 
         + STOP      0004         LEN=4
         + TR        PMC12

PMC8B    + LOAD MQ   D45          PRINT ALFA SYMBOL TO TRANSFER TO
         + R ADD     *            '/'
         + TR        PRTCHR
         + STOP      0054         AT COL 54
         + LOAD MQ   D45          '/'
         + R ADD     *
         + TR        PRTCHR
         + STOP      0058         AT COL 58
         + LOAD MQ   MC.ADDR      GET SYMBOL ALFA
         + R ADD     *            
         + TR        PRTALF
         + STOP      0055         AT COL 55
         + TR        PMC12

TMNEAD   + STOP      TMNE
TREGMNEA + STOP      TREGMNE

PMC9     + LOAD MQ   MC.ADDR      PRINT STEPN.TRSTLOC 
         + R ADD     *
         + TR        PRTINT
         + STOP      0053         AT COL 53 
         + STOP      0004         LEN=4
         + LOAD MQ   D43          PRINT '.'
         + R ADD     *
         + TR        PRTCHR
         + STOP      0057         AT COL 57 
         + LOAD MQ   TWO
         + R ADD     TRSTLOC      IF INST NUMBER < 10 PRINT IT
         + SUB       D10          WITH LEN=1, IF >= 10 USE LEN=2
         + TR +      PMC10
         + LOAD MQ   ONE
PMC10    + STORE MQ  PMC11
         + LOAD MQ   TRSTLOC
         + R ADD     *
         + TR        PRTINT
         + STOP      0058         AT COL 58 
PMC11    + STOP      0002         LEN=1 OR 2
PMC12    + NOOP      0000

         + R ADD     *
         + TR        PRINTCRD
         + TR        PMCLOOP    


PRTMCEX  + TR        /   /        RETURN TO CALLER

           ORG       EVEN

PACTSRC    RES       24           CARD IMAGE OF PACT SOURCE CODE CARD (12 FULL WORDS)
REGION     DEF       0
STEP       DEF       0            REGION = ALFA (<0)
OP         DEF       0            STEP   = INT (>0)
FACT       DEF       0            OP     = 0..43    =0 MEANS END OF REGION
S1         DEF       0            FACT   < 0 -> FACTOR IS AN ALFA SYMBOL (VAR, REGION, ...) 
S2         DEF       0            FACT = 0 -> BLANK FACTOR
QR         DEF       0            FACT = 0..9999 -> DESTINATION STEP FOR TRANSFER/RESULT OF STEP
QF         DEF       0            CLUE = -, R OR N
NUM        DEF       0            
           DEF       0            S1/S2 = 0 -> BLANK, >0 -> INTEGER, <0 -> ALFA 
CLUE       DEF       0
STEPN      DEF       0            QR = +/- INTEGER OR BLANK. 
FACTN      DEF       0                 IF OP=TEST THEN IF QR=0->INDEX IN GENEATED INSTR IS INDEX IS "ADDRESS TYPE", =1->IS "COUNT TYPE" 
FACTREG    DEF       0            QF = SET IF THERE IS AN INTEGER FACTOR/NUMBER IN CARD
S1N        DEF       0            STEPN = SEQUENTIAL NUMBER OF STEP            
S2N        DEF       0            IF OP IS TRANSFER -> FACTN=DESTINATION STEPN
D1N        DEF       0            FACTN=ADDR (0, 2, 4, ..) FACTREG=' ', 'T', 'V', 'N'
D2N        DEF       0            S1N/S2N=INDEX (IF <0), BLANK (IF =0), CONST (IF >0), 
NINST      DEF       0                   IF OP=40 -> =*777777 if non active index 
NINCR      DEF       0                               =*777776 if non defined index
TINST      RES       200          D1N/D2N=HALF-WORD SIZE OF EACH DIMENSION. D1N=-1 IF MATRIX/VECTOR WITH CONSTANT SUBSCRIPTS 
                                  MACHINE CODE: 1ST HALF-WORD OPCODE + REGION/LOCATION INTO STEP (FOR TRANSFERS)             
                                                2ND HALF-WORD ADDR INTO REGION                                               

CCODE      EQU       PACTSRC      LOCATION OF COMPACT CODE RECORD START
CCLEN      DEF       0044         LENGTH OF COMPACT CODE RECORD 
N          DEF       0            TEMP VAR (HERE TO MAKE TABLES START AT EVEN LOCATION)

MAXNINST   DEF       100          MAX NUMBER OF MACHINE CODE INSTRUTIONS PER STEP
VAL        DEF       0            TEMP

DATA       DEF       0            EVEN ALIGNED TEMP VAT
DATA2      DEF       0

                                  TABLES (SHOULD BE AT EVEN LOCATION)

MAXNCONS   DEF       100          MAX NUMBER OF ENTRIES IN LOOP CONSTANT POOL OF REGION
NLOCONST   DEF       0            NUM OF ENTRIES IN LOOP CONSTANT POOL OF REGION
TLOCONST   RES       2
TLOCONS2   RES       198          MACHINE CODE: 1ST HALF-WORD OPCODE + REGION
                                                2ND HALF-WORD ADDR INTO REGION

                                  TPAR TABLES AND TIDX TABLES MUST BE ONE NEXT TO THE OTHER
                                  AS THEY ARE SAVE TO TAPE AT ONCE 
                                                                    
MAXNPAR    DEF       34           MAX (34) NUMBER OF CALL PARAMETERS
NPARAMS    DEF        0           NUMBER OF PARAMS DEFINED
TPARNAME   RES       34           PARAM NAME (ALFA BASE48 <0). >0 IF VARIABLE (IS THE ADDR). =4096 IF NUMBER
TPARSTEP   RES       34           STEPN WHERE PARAM IS DEFINED
TPARTYPE   RES       34           PARAM TYPE: 
TPARFACT   RES       34           
TPARLOC1   RES       34           PACT       TYPE  FACT   LOC1   NAME       DESCR

                                  ID 3        -1   3             4096       CONSTANT. VALUE PASED AS PARAM IS STORED IN TEMP VAR
                                  ID VAR       0   FACTN         FACTN      SCALAR VAR BY REF. FACT=FACTN OF VARIABLE ON CURRENT REGION
                                  ID VECT I    1   FACTN  L(D1)  FACTN      VECTOR BY REF. FACT=FACTN OF VARIABLE. LOC1=ENTRY IN LOOP CONSTANTS POOL OF D1 VALUE PASED AS PARAM 
                                  ID MAT  I J  2   FACTN  L(D1)  FACTN      MATRIX

                                  FOR I A B   -2   L(A)   L(B)   ALFA (<0)  INDEX LOOP START/END: NAME=ALFA BASE48 (<0) WITH INDEX NAME, FACT=ENTRY IN LOOP CONSTANTS POOL OF LOOP START VALUE PASED AS PARAM, LOC1=LOOP END VALUE
                                  FOR A B C   -3   FACTN         FACTN      SCALAR VARS BY VALUE. FACTN=FACTN OF VARIABLE A. GENERATES ONE ENTRY FOR A, ONE FOR B AND ONE FOR C
                                  FOR 3 4 5   -1   3             4096       CONSTANT. VALUE PASED AS PARAM IS STORED IN TEMP VAR

MAXNIDXS   DEF       34           MAX (34) INDEXS ACTIVE AT SAME TIME
NIDXS      DEF       0            NUMBER OF INDEXES IN THIS REGION
TIDXNAME   RES       34           NAME OF ACTIVE INDEX (ALFA <0). >0 IF ENTRY IS NO LONGER IN USE
TIDXLOC    RES       34           = ENTRY IN LOOP CONSTANT POOL THAT HAS THE CURRENT INDEX VALUE
TIDXTYPE   RES       34           = 0 -> "ADDRESS INDEX" TYPE, =1 -> "COUNT INDEX" TYPE
TIDXSETN   RES       34           = 0 -> DEFINED INDEX, >0 -> ACTIVE INDEX = STEPN WHERE WHERE THE INDEX IS SET (USED TO COMPUTE START OF LOOP)
                                     

MAXNREFS   DEF       50           MAX (50) NUMBER OF VECTOR/MATRIX REFERENCES SIMULATEOUSLY ACTIVE AT A GIVEN MOMENT
NREFS      DEF       0            NUMBER OF REFERENCES IN REGION
TREFNAME   RES       50           NAME OF VECTOR/MATRIX. =0 IS ENTRY IS NOT USED       
TREFIDX1   RES       50           NAME OF INDEX1. <0->INDEX NAME,=0->NO INDEX,>0->CONSTANT,=*777777 if non active index with OP=40                   
TREFIDX2   RES       50           NAME OF INDEX2.                                      
TREFSTEP   RES       50           STEPN WHERE THIS VECTOR/MATRIX IS USED               TINST 0:  ...                        
TREFINCR   RES       50           INCRN ON PREVIOUS STEPN TO ACCESS THE VAR LOCATION   STEPN  :  ... VAR I  J                
TREFOP     RES       50           THE OPCODE THAT APPLIES ON VECT/MATRIX                     2:  ...                         
TREFADDR   RES       50           THE ADDR OF VECT/MATRIX                                    4:  +RA V 0003  <-- INCR VALUE  
TREFD1     RES       50           D1 VALUE IF REF IS A MATRIX                                    ^^^   ^^^^                  
                                                                                                 OP    ADDR OF VAR          
                                                                                                                            

                                  VARS/CONST HALF-WORD

ZERO       DEF       0
           DEF       0
ONE        DEF       1
TWO        DEF       2
D3         DEF       3
D4         DEF       4
D10        DEF       10
D11        DEF       11
D12        DEF       12
D15        DEF       15
D19        DEF       19
D24        DEF       24
D26        DEF       26
D32        DEF       32
D34        DEF       34
D40        DEF       40
D41        DEF       41
D43        DEF       43
D44        DEF       44
D45        DEF       45
D200       DEF       200
D1000      DEF       1000
D4096      DEF       4096
O776K      DEF       *777776      OCTAL ALL ONES
O777K      DEF       *777777      OCTAL ALL ONES

NREGIONS   DEF       0            NUMBER OF REGIONS PROCESSED
MC.TABLE   DEF       0            ADDRESS TO MACHINE CODE GENERATION TABLE TO USE 
TRANSFER   DEF       0            STEPN NUMBER THE MC INSTR HAS TO TRANSFER TO 
TRSTLOC    DEF       0            LOCATION INTO STEPN NUMBER THE MC INSTR HAS TO TRANSFER TO 
MC         DEF       0            MACHINE CODE INSTR TO GENERATE FROM MC TABLE
MC.OP      DEF       0            MC OPCODE GENERATED
MC.REG     DEF       0            REGION REFERENCED BY MC OPCODE GENERATED
MC.ADDR    DEF       0            MC ADDR GENERATED. BOTH WILL BE STORED IN TINST TABLE IN COMPCAT CODE RECORD
PRTMCNUM   DEF       0            NEXT INSTR TO PRINT WITH PRTMC
REGCSTEP   DEF       0            STEPN WHERE THE REG.C SITS
PRGSTEPN   DEF       0            FIRST STEPN OF PROGRAM AFTER INITIAL CALL/ID/FOR (IE STEP-1 IS CALL/ID/FOR INSTR)

NIDX       DEF       0            CURRENT INDEX NUMBER
NIDX2      DEF       0            
SETN       DEF       0            THE STEPN WHERE THE START OF LOOP "SET" PACT INSTR IS DEFINED
ECONSTIX   DEF       0            =0 IF INDEX IS "ADDRESS INDEX" TYPE, >0 IF INDEX IS "COUNT INDEX" TYPE, =ENTRY IN LOOP CONSTANT POOL FOR INDEX VALUE
ECONST     DEF       0
ECONSEND   DEF       0

NPAR       DEF       0            PARAM BEING EXAMINED
NREF       DEF       0            CURRENT REFERENCE ENTRY. REFERENCES = STEPN OF INSTR THAT USES VARS WITH INDEX. 
NREF2      DEF       0            THE ADDR OF VAR IN THSE STEPN SHOULD BE MODIFIED BY "TEST" INSTR
NLASTREF   DEF       0            
RNAME      DEF       0            REFERENCE NAME
RIDX1      DEF       0            INDEX1 USED BY REFERENCE 
RIDX2      DEF       0            INDEX2 USED BY REFERENCE 
RSTEPN     DEF       0            STEPN OF INSTR WHERE THE REFERENCE IS MADE
RINCRN     DEF       0            INCRN OF REFERENCE IN THIS STEP
ROP        DEF       0
RADDR      DEF       0
R2NAME     DEF       0            REFERENCE NAME
R2IDX1     DEF       0            INDEX1 USED BY REFERENCE 
R2IDX2     DEF       0            INDEX2 USED BY REFERENCE 
R2STEPN    DEF       0            STEPN OF INSTR WHERE THE REFERENCE IS MADE
R2INCRN    DEF       0            INCRN OF REFERENCE IN THIS STEP
R2ADDR     DEF       0
MKCIDX     DEF       0            INDEX TO SET TO "COUNT TYPE"
ECONSTMK   DEF       0            ENTRY IN CONSTANT POOL THAT CONTAINS THE VALUE OF INDEX
CKMKCNT    DEF       0            FLAG: <0 -> MAKE INDEX COUNT TYPE IF ACTIVE
CKIDX      DEF       0
CKIDXACT   DEF       0            =1 -> PROCESSING AN OP=40 ID for DO/LIB INSTR 
PNAME      DEF       0            PARAMETER NAME
PTYPE      DEF       0            PARAMETER TYPE
SVNINST    DEF       0            SAVE CURRENT NUMBER OF MC INSTR IN THE COMPACT CODE RECORD AT START OF STEP PROCESSING
SVSTEPN    DEF       0            SAVE LAST STEPN 
LEN        DEF       0

                                  TEXT

ERROVINS   TXT       "TOO MANY INSTR",0                ERROR: MAX 100
ERRNOIXS   TXT       "NO INDEX",0                      ERROR: MISSING INDEX
ERRNOIVS   TXT       "NO VALUE",0                      ERROR: MISSING INDEX VALUE
ERRDSETS   TXT       "DUPL SET",0                      ERROR: DUPLICATED SET ON SAME INDEX
ERRIXOVS   TXT       "TOO MANY INDEXES",0              ERROR: MAX 34
ERRNDIDS   TXT       "INDEX NOT ACTIVE",0              ERROR: INDEX NOT ACTIVE (MISSING SET INSTR FOR THIS INDEX)
ERRBADTS   TXT       "BAD DEST",0                      ERROR: BAD TEST DESTINATION IN FACTOR. SHOULD BE BLANK OR A STEP NUMBER         
ERROVLOS   TXT       "LOOP CONST OVERFLOW",0           ERROR: TOO MANY LOOP CONSTANTS IN POOL         
ERROVRFS   TXT       "TOO MANY REFS",0                 ERROR: TOO MANY REFERENCES TO MATRIX/VECTOR IN REGION (MAX 50)
ERRNDI1S   TXT       "1ST INDEX NOT DEF",0             ERROR: 1ST INDEX NOT DEFINED 
ERRNDI2S   TXT       "2ND INDEX NOT DEF",0             ERROR: 2ND INDEX NOT DEFINED 
ERRDPARS   TXT       "DUPL PARAM",0                    ERROR: DUPLICATED PARAMETER NAME
ERROVPAS   TXT       "TOO MANY PARAMETERS",0           ERROR: TOO MANY PARAMS DEFINED (MAX 34)
ERRNOVAR   TXT       "NO VAR",0                        ERROR: ID PARAM MUST BE A VAR (CANNOT BE A TEMP/PERISHABLE VAR)

MSGSTART   TXT       "LOOP EXPANSION PASS 1",0
MSGDONE    TXT       "REGIONS",0
HALTTXT    TXT       "HALT",0

OPUSE      EQU       D19
OPCALL     EQU       D26
OPIDDO     EQU       D40          ID for DO/LIB
OPIDCALL   EQU       D41          ID for CALL
OPFORCAL   EQU       D43          FOR for CALL
OPNCONST   EQU       D44          CONSTANT LOOP POOL (CARD OP IS PRINTED AS "HALT"

                                  REL ASSEMBLY REGION INDEXS

REG.A      DEF       0            ABSOLUTE A 0000
REG.I      DEF       1            INSTRUCTIONS CODE I 0000
REG.V      DEF       2            VARIABLES V 0000
REG.T      DEF       3            TEMPORARY T 0000
REG.N      DEF       4            NUMBER N 0000
REG.C      DEF       6            ENTRY IN LOOP CONSTANTS POOL C 0000
REG.S      DEF       7            SYMBOL S 0000

TREGMNE    TXT       '  A'
           TXT       '  I'
           TXT       '  V'
           TXT       '  T'
           TXT       '  N'
           TXT       '  P'        PERISHABLE STORAGE (=LIB LOCAL VARS/CONSTANTS)
           TXT       '  C'        LOOP CONSTANTS
           TXT       '  S'

TMNE       TXT       'H  '        STOP/HALT
           TXT       'T  '        TRANSFER
           TXT       'TF '        TRANSFER ON OVERLOF
           TXT       'TP '        TRANSFER ON PLUS
           TXT       'TZ '        TRANSFER ON ZERO
           TXT       'S  '        SUBTRACT
           TXT       'RS '        RESET AND SUBTRACT
           TXT       'SV '        SUBTRACT ABSOLUTE VALUE
           TXT       'N  '        NO OPERATION
           TXT       'A  '        ADD
           TXT       'RA '        RESET AND ADD
           TXT       'AV '        ADD ABSOLUTE VALUE
           TXT       'ST '        STORE
           TXT       'SA '        STORE ADDRESS
           TXT       'SM '        STORE MQ
           TXT       'LM '        LOAD MQ
           TXT       'M  '        MULTIPLY
           TXT       'MR '        MULTIPLY AND ROUND
           TXT       'D  '        DIVIDE
           TXT       'R  '        ROUND
           TXT       'LL '        LONG LEFT SHIFT
           TXT       'LR '        LONG RIGHT SHIFT
           TXT       'AL '        ACCUMULATOR LEFT SHIFT
           TXT       'AR '        ACCUMULATOR RIGHT SHIFT
           TXT       'RD '        READ
           TXT       'RB '        READ BACKWARDs
           TXT       'W  '        WRITE
           TXT       'WE '        WRITE END OF FILE
           TXT       'RW '        REWIND TAPE
           TXT       'SD '        SET DRUM DDR
           TXT       'SE '        SENSE
           TXT       'C  '        COPY

CC.FACT    EQU       1001         compact code factor: to be replaced by V 0005 (variable), T 0010 (result of a step) or N 0012 (a number)
INN        EQU       1002         transfer to location n (1..199) into stepN given in var TRANSFER = stepN, TRSTLOC = location in step machine code
CNN        EQU       1003         C nnnn  where nnnn is the value of ECONST var. C is LOOP CONSTANT POOL on last stenp of region (0000=FIRST ENTRY)
C01        EQU       1004         C nnnn  where nnnn is the value ONE in LOOP CONSTANTS POOL
C02        EQU       1005         C nnnn  where nnnn is the value TWO in LOOP CONSTANTS POOL

                                  TAPE ARRANGEMENT IN PACT COMPILER:
                                  701 IO       SIMH    TAPE     
                                  ADDRESS      DEV     NUMBER   USAGE 
                                  0256         MT0     TAPE 1   COMPILER PROGRAM
                                  0257         MT1     TAPE 2   WORKING DATA/GENERATED COMPACT CODE 
                                  0258         MT2     TAPE 3   WORKING DATA/GENERATED COMPACT CODE 
                                  0259         MT3     TAPE 4   WORKING DATA/GENERATED COMPACT CODE 

PACTCOMP   EQU       0256         PACT COMPILER TAPE
TAPEOUT    EQU       0257         OUTPUT TO TAPE 2 (UPDATED COMPACT CODE)
TAPEIN     EQU       0258         INPUT PACT COMPACT CODE FROM TAPE 3
TAPEOUTR   EQU       0259         OUTPUT TO TAPE 4 (PASS1 POPULATED TABLES FOR EACH REGION)



