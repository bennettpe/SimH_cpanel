NJ7P Assembler	                                                  	Page 1  
 Line  Addr Object Code	Source Code

 00001			
 00002			* 
 00003			* Loader for Smoke System Broadcasting DOS-68 Operating System
 00004			* I/O Routines for MF68 Floppy Disk
 00005			* 
 00006			* This program patches SSD DOS-68 to use MF68 instead of 
 00007			* own SSB floppy disk
 00008			*
 00009			* C(C) Roberto Sancho, Apr/2022
 00010			* Uses BC00-BD00 for loader. Once DOS is started this mem is available for any program
 00011			*      BE00-BEFF for MF60 I/O Routines.  This mem should not be overwritten/modified
 00012			*
 00013			
 00014      7F80 	SECBUF  EQU $7F80       BUFFER FOR READ DISK SECTOR 
 00015      E0E3 	MON     EQU $E0E3       SWTBUG Monitor start 
 00016			
 00017      BC00	        ORG $BC00
 00018			
 00019 BC00 BD BE3B 	START   JSR   INTDK  
 00020 BC03 86 FF	        LDA A #$FF      Init PBUF     
 00021 BC05 B7 BCB1 	        STA A PBUF   
 00022 BC08 CE E0E3 	        LDX   #$E0E3    Init jump to SWTBUG monitor  
 00023 BC0B FF BCB3 	        STX   TA        as default TA (so if loaded prog has no TA, return to monitor)
 00024 BC0E 86 08	        LDA A #08
 00025 BC10 B7 A07B 	        STA A BFDDRG    Select drive 0 
 00026 BC13 CE 8051 	        LDX   #$8051    Track and sector for DOS68 file (main OS program)
 00027 BC16 FF 7F80 	        STX   SECBUF    Set FWD Link Trk and Sect in sector buffer
 00028 BC19 CE 7F80 	        LDX   #SECBUF
 00029 BC1C FF A07E 	        STX   BFDSBU    Set addr where disc sector is to be read (=the sector buffer)
 00030 BC1F 8D 3C	RDNEXT  BSR   RDBYTE    read a byte from disk file in B
 00031 BC21 C1 42	        CMP B #$42      is data record?
 00032 BC23 27 10	        BEQ   RDDATR    yes -> branch
 00033 BC25 C1 47	        CMP B #$47      is transfer address record?
 00034 BC27 26 F6	        BNE   RDNEXT    no -> skip this byte and read next from disk 
 00035 BC29 8D 32	        BSR   RDBYTE    yes -> get transfer addr (TA) hi
 00036 BC2B F7 BCB3 	        STA B TA
 00037 BC2E 8D 2D	        BSR   RDBYTE    get transfer addr lo
 00038 BC30 F7 BCB4 	        STA B TA+1      save TA address 
 00039 BC33 20 EA	        BRA   RDNEXT
 00040			
 00041			* READ A DATA RECORD INTO MEM
 00042			
 00043 BC35 4F		RDDATR  CLR A
 00044 BC36 8D 25	        BSR   RDBYTE    B=Data record last byte used (=len-1)
 00045 BC38 5C		        INC B           B=Data Record len
 00046 BC39 37		        PSH B
 00047 BC3A 8D 21	        BSR   RDBYTE    B=Data load addr hi
 00048 BC3C F7 BCB5 	        STA B PSTORE
 00049 BC3F 8D 1C	        BSR   RDBYTE    B=Data load addr lo
 00050 BC41 F7 BCB6 	        STA B PSTORE+1
 00051 BC44 8D 17	RDDATB  BSR   RDBYTE    get record data byte
 00052 BC46 FE BCB5 	        LDX   PSTORE    load address for byte 
 00053 BC49 E7 00	        STA B 0,X       save data byte at load addr
 00054 BC4B 08		        INX 
 00055 BC4C FF BCB5 	        STX   PSTORE
 00056 BC4F 33		        PUL B           B=Bytes remaining to load
 00057 BC50 5A		        DEC B 
 00058 BC51 37		        PSH B
 00059 BC52 26 F0	        BNE   RDDATB    continue until all bytes are load
 00060 BC54 33		        PUL B
 00061 BC55 8D 06	        BSR   RDBYTE    get chksum byte  
 00062 BC57 4C		        INC A
 00063 BC58 27 C5	        BEQ   RDNEXT
 00064 BC5A 7E E0E3 	        JMP   MON       CHKSUM Error -> return to monitor
NJ7P Assembler	                                                  	Page 2  
 Line  Addr Object Code	Source Code

 00065			
 00066			* READ BYTE FROM DISK FILE, FOLLOWING FWD TRK AND SEC LINKS
 00067			* RETRUN B=BYTE READ, A=CHKSUM 
 00068			
 00069 BC5D FE BCB1 	RDBYTE  LDX   PBUF      pointer to next byte to get from disk sector buffer
 00070 BC60 2B 08	        BMI   RDTKSEC   128 bytes already read -> load next sector following FWD LINK
 00071 BC62 E6 00	        LDA B 0,X       read byte from secotr buffer
 00072 BC64 08		        INX 
 00073 BC65 FF BCB1 	        STX   PBUF
 00074 BC68 1B		        ABA             A=A+B=checksum
 00075 BC69 39		        RTS 
 00076			
 00077 BC6A FE 7F80 	RDTKSEC LDX   SECBUF    get FWD Trk and Sect to load
 00078 BC6D 27 13	        BEQ   JMPTA     If no FWD link, jumo to Transfer Address
 00079 BC6F FF A07C 	        STX   BFDTRG    TrSect to load
 00080 BC72 CE 7F84 	        LDX   #SECBUF+4 init sector buffer data address
 00081 BC75 FF BCB1 	        STX   PBUF
 00082 BC78 36		        PSH A
 00083 BC79 BD BE29 	        JSR   BFDRDS    read sector into 7f80-7fff (SECBUF)
 00084 BC7C 32		        PUL A
 00085 BC7D 27 DE	        BEQ   RDBYTE
 00086 BC7F 7E E0E3 	        JMP   MON       return to monitor if read error
 00087			
 00088 BC82 BD BC8A 	JMPTA   JSR  PATCHD     Patch the loaded system before jumping to it
 00089 BC85 FE BCB3 	        LDX  TA         Jump to transfer address to start 
 00090 BC88 6E 00	        JMP  0,X        loaded program 
 00091			
 00092			* PATCH DOS68 TO USE MF68 I/O ROUTINES (AT ADDRESS BEXX) INSTEAD OF 
 00093			* CALLING SSB FLOPPY ROM (AT ADDRESS 80XX)
 00094			
 00095 BC8A 4F		PATCHD  CLR A
 00096			
 00097			* PATCH CALL INIT ROUTINE AT NEW ADDRESS
 00098			* DDE4  7E 8026         JMP  $8026    SSB INITIALIZE PIA ROUTINE
 00099			*                   TO  JMP  $BE26    MF68 INIT
 00100 BC8B 86 BE	        LDA A #$BE
 00101 BC8D B7 DDE5 	        STA A $DDE5
 00102			        
 00103			* PATCH CALL ROUTINES AT NEW ADDRESS
 00104			* DD47  BD 8038         JSR  $8038    SSB RESTORE
 00105			* DDA0  BD 8038         JSR  $8038    SSB RESTORE
 00106			* DD30  CE 802C         LDX  #$802C   SSB WRITE SECTOR ROUTINE
 00107			* DD35  CE 8029         LDX  #$8029   SSB READ SECTOR ROUTINE 
 00108			* DD88  8C 8029         CPX  #$8029   SSB READ SECTOR ROUTINE 
 00109			*                    TO JSR  $BEXX    MF68 
 00110 BC90 86 BE	        LDA A #$BE
 00111 BC92 B7 DD48 	        STA A $DD48
 00112 BC95 B7 DDA1 	        STA A $DDA1
 00113 BC98 B7 DD31 	        STA A $DD31
 00114 BC9B B7 DD36 	        STA A $DD36
 00115 BC9E B7 DD89 	        STA A $DD89
 00116			
 00117			* Patch the whole routine
 00118			* DD51:	BD 806C         JSR  $806C     SSB Write track register
 00119			* DDB7:	BD 8072         JSR  $8072     SSB Read track register
 00120			*                   ->  JMP  $BE38    
 00121			
 00122 BCA1 CE BE38 	        LDX   #$BE38
 00123 BCA4 FF DD52 	        STX   $DD52
 00124 BCA7 FF DDB8 	        STX   $DDB8
 00125			        
 00126			* Patch fortran line printer to use the screen
 00127			* D2B8:	7E D283 ZLP     JMP  ZWARMS   FORTRAN LINE PRINTER OUTPUT VECTOR (Points to DOS68 WARM START)
 00128			*    -> 7E D286 ZOUTCH  JMP  ZOUTEE   
NJ7P Assembler	                                                  	Page 3  
 Line  Addr Object Code	Source Code

 00129			
 00130 BCAA CE D286 	        LDX   #$D286
 00131 BCAD FF D2B9 	        STX   $D2B9
 00132			        
 00133 BCB0 39		        RTS
 00134			        
 00135 BCB1 0002	PBUF    RMB 2           POINTER TO NEXT BYTE TO GET FROM READ DISK SECTOR BUFFER
 00136 BCB3 0002	TA      RMB 2           TRANSFER ADDRESS (=COLD START ADDR OF OPERATING SYSTEM)
 00137 BCB5 0002	PSTORE  RMB 2           POINTER WHERE THE BYTE READ FROM DISK IS TO BE STORED IN MEM
 00138			      
 00139			        
 00140			*
 00141			* SSB Smoke Signal Broadcasting BFD-68 disk drive ROM replacement.
 00142			* Allows to use MF68 TSC Disk Drive
 00143			*
 00144			
 00145      A07B 	BFDDRG EQU $A07B  Drive Register  (8-> select drive 0, $10 drive 1, $20 drive 2)
 00146      A07C 	BFDTRG EQU $A07C  Track Register  ($80..$A2)
 00147      A07D 	BFDSRG EQU $A07D  Sector Register ($40..$53)
 00148      A07E 	BFDSBU EQU $A07E  Sector Buffer Pointer
 00149			
 00150			*
 00151			* The following is the original entry for SSB ROM
 00152			* as listed in 68'Micro Journal, Volumne 1 issue 1, feb 1979, p13-20
 00153			* 
 00154			* BFDCLD EQU $8020  SSB Cold Start
 00155			* BFDWRM EQU $8023  SSB Warm Start
 00156			* BFDINT EQU $8026  SSB Initialize PIA routine
 00157			* BFDRDS EQU $8029  SSB Read Sector routine 
 00158			* BFDWRS EQU $802C  SSB Write Sector routine
 00159			* BFDRDT EQU $802F  SSB Read Track routine
 00160			* BFDWRT EQU $8032  SSB Write Track routine
 00161			* BFDSEK EQU $8035  SSB Seek routine
 00162			* BFDRST EQU $8038  SSB Restore routine  
 00163			*
 00164			*            $8060      Send command
 00165			*            $8063      Operation complete
 00166			*            $8066      Clean up & return
 00167			*            $8069      Write sector register
 00168			*            $806C      Write track register
 00169			*            $806F      Write track number
 00170			*            $8072      Read track register
 00171			*            $8075      Step in
 00172			*            $8078      Step out
 00173			*            $807B      Step
 00174			*
 00175			
 00176			*
 00177			* THE MEM AREA BE00-BFFF HOLDS THE SSB BFD-68 ROM REPLACEMENT
 00178			* SSB ROM ENTRY POINTS STARTS AT $8020
 00179			* REPLACEMENT ENTRY POINTS STARTS AT $BE20
 00180			
 00181      BE00	       ORG $BE00
 00182			
 00183 BE00 0004	CTRK0  RMB 4  TRACK STATE TABLE
 00184 BE04 0001	RCNT   RMB 1  RETRY COUNT
 00185			
 00186      BE20	       ORG $BE20
 00187			
 00188 BE20 7E E0E3 	BFDCLD JMP MON    SSB Cold Start
 00189 BE23 7E E0E3 	BFDWRM JMP MON    SSB Warm Start
 00190 BE26 7E BE3B 	BFDINT JMP INTDK  SSB Initialize 
 00191 BE29 7E BE4A 	BFDRDS JMP RDSEC  SSB Read Sector routine  
 00192 BE2C 7E BE59 	BFDWRS JMP WRSEC  SSB Write Sector routine
NJ7P Assembler	                                                  	Page 4  
 Line  Addr Object Code	Source Code

 00193 BE2F 7E E0E3 	BFDRDT JMP MON    SSB Read Track routine
 00194 BE32 7E E0E3 	BFDWRT JMP MON    SSB Write Track routine
 00195 BE35 7E E0E3 	BFDSEK JMP MON    SSB Seek routine
 00196 BE38 7E BE49 	BFDRST JMP DUMMY  SSB Restore routine (Dummy)
 00197			
 00198			*
 00199			* DISK DRIVERS FOR SOUTHWEST TECHNICAL PRODUCTOS
 00200			*
 00201			* COMMANDS
 00202			*
 00203      000B 	FDRSC  EQU $0B    RESTORE
 00204      001B 	FDSKI  EQU $1B    SEEK
 00205      008C 	FDRDC  EQU $8C    READ A SECTOR
 00206      00AC 	FDWRC  EQU $AC    WRITE A SECTOR
 00207			*
 00208      8014 	DRVREG EQU $8014
 00209      8018 	CMDREG EQU $8018
 00210      8019 	TRKREG EQU $8019
 00211      801A 	SECREG EQU $801A
 00212      801B 	DATREG EQU $801B
 00213			*
 00214			* FCB DEFINITIONS:
 00215			*
 00216      0005 	FCBSTA EQU 5  STATUS 
 00217      0007 	FCBDBA EQU 7  DATA BUFFER ADDRESS
 00218      0009 	FCBDRV EQU 9  DRIVE#
 00219      000A 	FCBTRK EQU 10 TRACK# 
 00220      000B 	FCBSCT EQU 11 SECTOR# 
 00221			*
 00222			* INIT THE DISK SYSTEM
 00223			*
 00224 BE3B 86 FF	INTDK  LDA A #$FF
 00225 BE3D B7 BE00 	       STA A CTRK0       
 00226 BE40 B7 BE01 	       STA A CTRK0+1
 00227 BE43 B7 BE02 	       STA A CTRK0+2       
 00228 BE46 B7 BE03 	       STA A CTRK0+3
 00229 BE49 39		DUMMY  RTS       
 00230			
 00231			*
 00232			* READ A SECTOR
 00233			*
 00234			* drive in $A07B: $08=drive 0, $10=drive 1, $20=drive 2
 00235			* track in $A07C ($80..$A2)
 00236			* sector in $A07D ($40..$51)
 00237			* Sector Buffer in $A07E/F
 00238			* return A=0 if ok, <>0 if error
 00239			*
 00240 BE4A BD BF0E 	RDSEC  JSR SELDRV 
 00241 BE4D BD BE68 	RDSEC1 JSR READ       GET A SECTOR
 00242 BE50 27 15	       BEQ QUIT10     OK
 00243 BE52 7A BE04 	       DEC RCNT       RETRY AGAIN?
 00244 BE55 26 F6	       BNE RDSEC1     YES
 00245 BE57 20 0D	       BRA QERR
 00246			*
 00247			* WRITE A SECTOR
 00248			*
 00249			* drive in $A07B: $08=drive 0, $10=drive 1, $20=drive 2
 00250			* track in $A07C ($80..$A2)
 00251			* sector in $A07D ($40..$51)
 00252			* Sector Buffer in $A07E/F
 00253			* return A=0 if ok, <>0 if error
 00254			*
 00255 BE59 BD BF0E 	WRSEC  JSR SELDRV 
 00256 BE5C BD BE9B 	WTSEC1 JSR WRITE
NJ7P Assembler	                                                  	Page 5  
 Line  Addr Object Code	Source Code

 00257 BE5F 27 06	       BEQ QUIT10     OK
 00258 BE61 7A BE04 	       DEC RCNT       TRY AGAIN?
 00259 BE64 26 F6	       BNE WTSEC1     YES
 00260 BE66 4D		QERR   TST A          A HAS THE STATUS BITS WIITH ERROR 
 00261 BE67 39		QUIT10 RTS
 00262			*
 00263			* READ A SECTOR (A=TRK, B=SECTOR, X=CTRKx)
 00264			*
 00265 BE68 BD BEC7 	READ   JSR SEEK
 00266 BE6B 86 8C	       LDA A #FDRDC   READ
 00267 BE6D B7 8018 	       STA A CMDREG
 00268 BE70 BD BEE6 	       JSR DEL30U     DELAY
 00269 BE73 FE A07E 	       LDX BFDSBU     GET BUFFER ADDRESS
 00270 BE76 C6 80	       LDA B #128     128 BYTES/SECTOR     
 00271 BE78 B6 8018 	READ1  LDA A CMDREG
 00272 BE7B 85 02	       BIT A #$02     DATA REG FULL?
 00273 BE7D 26 06	       BNE READ2      YES
 00274 BE7F 85 01	       BIT A #1       BUSY?
 00275 BE81 26 F5	       BNE READ1      YES
 00276 BE83 20 0B	       BRA READ3      ERROR
 00277 BE85 B6 801B 	READ2  LDA A DATREG   GET A BYTE
 00278 BE88 A7 00	       STA A 0,X      STORE IN BUFFER
 00279 BE8A 08		       INX
 00280 BE8B 5A		       DEC B
 00281 BE8C 26 EA	       BNE READ1      DO AGAIN
 00282 BE8E 8D 03	       BSR WBUSY      WAIT TILL DONE
 00283 BE90 84 1C	READ3  AND A #$1C     MASK OF STATUS BITS
 00284 BE92 39		       RTS
 00285			*
 00286 BE93 B6 8018 	WBUSY  LDA A CMDREG
 00287 BE96 85 01	       BIT A #1       BUSY?
 00288 BE98 26 F9	       BNE WBUSY      YES
 00289 BE9A 39		       RTS
 00290			*
 00291			* WRITE A SECTOR (A=TRK, B=SECTOR, X=CTRKx)
 00292			*
 00293 BE9B BD BEC7 	WRITE  JSR SEEK
 00294 BE9E 86 AC	       LDA A #FDWRC   WRITE COMMAND
 00295 BEA0 B7 8018 	       STA A CMDREG
 00296 BEA3 BD BEE6 	       JSR DEL30U
 00297 BEA6 FE A07E 	       LDX BFDSBU     GET BUFFER ADDRESS
 00298 BEA9 C6 80	       LDA B #128     128 BYTES/SECTOR
 00299 BEAB B6 8018 	WRITE1 LDA A CMDREG
 00300 BEAE 85 02	       BIT A #2       REG EMPTY?
 00301 BEB0 26 06	       BNE WRITE2     YES
 00302 BEB2 85 01	       BIT A #1       BUSY?
 00303 BEB4 26 F5	       BNE WRITE1     YES
 00304 BEB6 20 AE	       BRA QERR       ERROR
 00305 BEB8 A6 00	WRITE2 LDA A 0,X      GET A BYTE
 00306 BEBA B7 801B 	       STA A DATREG
 00307 BEBD 08		       INX
 00308 BEBE 5A		       DEC B
 00309 BEBF 26 EA	       BNE WRITE1     DO AGAIN
 00310 BEC1 BD BE93 	       JSR WBUSY      WAIT FOR BUSY
 00311 BEC4 84 5C	WRITE3 AND A #$5C     MASK OFF STATUS BITS
 00312 BEC6 39		       RTS
 00313			*
 00314			* SEEK A=TRACK, B=SECTOR, X=CTRKx
 00315			*
 00316 BEC7 B1 8019 	SEEK   CMP A TRKREG   ON TRACK?
 00317 BECA 27 13	       BEQ SEEK2      YES
 00318 BECC B7 801B 	       STA A DATREG   NO, STORE TRACK#
 00319 BECF BD BEE6 	       JSR DEL30U
 00320 BED2 A7 00	       STA A 0,X      SAVE CURRENT TRACK OF DRIVE
NJ7P Assembler	                                                  	Page 6  
 Line  Addr Object Code	Source Code

 00321 BED4 86 1B	       LDA A #FDSKI   SEEK COMMAND
 00322 BED6 B7 8018 	       STA A CMDREG
 00323 BED9 BD BEE6 	       JSR DEL30U
 00324 BEDC BD BE93 	       JSR WBUSY      WAIT FOR BUSY
 00325 BEDF F7 801A 	SEEK2  STA B SECREG   SET SECTOR
 00326 BEE2 BD BEE6 	       JSR DEL30U
 00327 BEE5 39		       RTS
 00328			*
 00329			* DELAY 30 USECS
 00330			*
 00331 BEE6 08		DEL30U INX
 00332 BEE7 09		       DEX
 00333 BEE8 08		       INX
 00334 BEE9 09		       DEX
 00335 BEEA 08		       INX
 00336 BEEB 09		       DEX
 00337 BEEC 08		       INX
 00338 BEED 09		       DEX
 00339 BEEE 39		       RTS
 00340			*
 00341			* DRIVE SELECT (A=DRIVE#, return X=CTRKx)
 00342			*
 00343 BEEF B7 8014 	DRIVE  STA A DRVREG   INIT REGISTER
 00344 BEF2 BD BEE6 	       JSR DEL30U
 00345 BEF5 CE BE00 	       LDX #CTRK0     POINT TO TABLE
 00346 BEF8 16		       TAB
 00347 BEF9 27 04	       BEQ DSEL3
 00348 BEFB 08		DSEL2  INX
 00349 BEFC 5A		       DEC B
 00350 BEFD 26 FC	       BNE DSEL2
 00351 BEFF 39		DSEL3  RTS
 00352			*
 00353			* RESTORE SEEK TRACK0 (X=CTRKx)
 00354			*
 00355 BF00 86 0B	RESTOR LDA A #FDRSC   RESTORE COMMAND
 00356 BF02 B7 8018 	       STA A CMDREG
 00357 BF05 BD BEE6 	       JSR DEL30U
 00358 BF08 BD BE93 	       JSR WBUSY
 00359 BF0B 6F 00	       CLR 0,X        CTRKx:=00
 00360 BF0D 39		       RTS
 00361			*
 00362			* SELECT DRIVE, HANDLE SSB STYLE PARAMS
 00363			* SELECT THE DRIVE
 00364			* RETURN A=TRACK, B=SECTOR, X=CTRKx
 00365			*
 00366 BF0E B6 A07B 	SELDRV LDA A BFDDRG   SSB SELECTED DRIVE 
 00367 BF11 47		       ASR A
 00368 BF12 47		       ASR A
 00369 BF13 47		       ASR A
 00370 BF14 47		       ASR A
 00371 BF15 84 03	       AND A #$03
 00372 BF17 8D D6	       BSR DRIVE      SELECT DRIVE, SET X=CTRKx
 00373 BF19 E6 00	       LDA B 0,X      A=CURRENT DRIVE TRACK
 00374 BF1B C1 FF	       CMP B #$FF     INITIALIZED?
 00375 BF1D 26 03	       BNE SELD1      YES
 00376 BF1F BD BF00 	       JSR RESTOR     SEEK TRACK0
 00377 BF22 86 05	SELD1  LDA A #5       SET RETRY COUNT
 00378 BF24 B7 BE04 	       STA A RCNT
 00379 BF27 B6 A07C 	       LDA A BFDTRG   GET SSB TRACK#        
 00380 BF2A 80 80	       SUB A #$80     MF68 FLEX1 DISK FORMAT HAS TRACKS RANGING FROM 0..34
 00381 BF2C F6 A07D 	       LDA B BFDSRG   GET SECTOR 
 00382 BF2F C0 3F	       SUB B #$3F     MF68 FLEX1 DISK FORMAT HAS SECTORS RANGING FROM 1..18
 00383 BF31 39		       RTS
 00384			*
NJ7P Assembler	                                                  	Page 7  
 Line  Addr Object Code	Source Code

 00385 BF32		       END
 00386			
 00387			
 00388			


End of Assembly
No errors found
NJ7P Assembler	                                                  	Page 8  
          Symbol Addr Seg Flg           Symbol Addr Seg Flg

          BFDCLD BE20  A  A             BFDDRG A07B  A  A*  
          BFDINT BE26  A  A             BFDRDS BE29  A  A*  
          BFDRDT BE2F  A  A             BFDRST BE38  A  A   
          BFDSBU A07E  A  A*            BFDSEK BE35  A  A   
          BFDSRG A07D  A  A*            BFDTRG A07C  A  A*  
          BFDWRM BE23  A  A             BFDWRS BE2C  A  A   
          BFDWRT BE32  A  A             CMDREG 8018  A  A*  
           CTRK0 BE00  A  A*            DATREG 801B  A  A*  
          DEL30U BEE6  A  A*             DRIVE BEEF  A  A*  
          DRVREG 8014  A  A*             DSEL2 BEFB  A  A*  
           DSEL3 BEFF  A  A*             DUMMY BE49  A  A*  
          FCBDBA 0007  A  AD            FCBDRV 0009  A  AD  
          FCBSCT 000B  A  AD            FCBSTA 0005  A  AD  
          FCBTRK 000A  A  AD             FDRDC 008C  A  AD  
           FDRSC 000B  A  AD             FDSKI 001B  A  AD  
           FDWRC 00AC  A  AD             INTDK BE3B  A  A*  
           JMPTA BC82  A  A*               MON E0E3  A  A*  
          PATCHD BC8A  A  A*              PBUF BCB1  A  A*  
          PSTORE BCB5  A  A*              QERR BE66  A  A*  
          QUIT10 BE67  A  A*              RCNT BE04  A  A*  
          RDBYTE BC5D  A  A*            RDDATB BC44  A  A*  
          RDDATR BC35  A  A*            RDNEXT BC1F  A  A*  
           RDSEC BE4A  A  A*            RDSEC1 BE4D  A  A*  
         RDTKSEC BC6A  A  A*              READ BE68  A  A*  
           READ1 BE78  A  A*             READ2 BE85  A  A*  
           READ3 BE90  A  A*            RESTOR BF00  A  A*  
          SECBUF 7F80  A  A*            SECREG 801A  A  A*  
            SEEK BEC7  A  A*             SEEK2 BEDF  A  A*  
           SELD1 BF22  A  A*            SELDRV BF0E  A  A*  
           START BC00  A  A                 TA BCB3  A  A*  
          TRKREG 8019  A  A*             WBUSY BE93  A  A*  
           WRITE BE9B  A  A*            WRITE1 BEAB  A  A*  
          WRITE2 BEB8  A  A*            WRITE3 BEC4  A  A   
           WRSEC BE59  A  A*            WTSEC1 BE5C  A  A*  

