



ASM/6800 1.4A0: 0000                    
08/16/82 00:00:00; Page 1; Form 0       
IOSWTPC6800.ASM
  0001            1: RAM64K   EQU  1 




ASM/6800 1.4A0: 0000                    
08/16/82 00:00:00; Page 2; Form 1       
IOSWTPC6800.ASM
                  1: 
                  2: ;*              I/O Package Configuraton for SimH SWTPC 6800 Simulator
                  3: ;*              should work on real hw too
                  4: 
                  5: ;*              (C) Roberto Sancho, Jun 2022
                  6: ;*              based on SSB I/O Package
                  7: 
                  8: ;*              features implemented: 
                  9: ;                            mapalg: Only supports mapping algorith 0001
                 10: ;                            I/O Implemented using active wait (no interruption based)
                 11: ;                            no clock interrupt
                 12: ;                            no vt terminal driver. Just a minimal subset
                 13: ;                                              BackSpace, Tab (converted to 8 spaces) 
                 14: ;                                              ^C to discard current input 
                 15: ;                                              ^C^C to kill current program
                 16: ;                                              <CR> is the only activation key allowed (cannot be changed)
                 17: ;                                              ^Z to signal end of file
                 18: ;                                              ^D to call monitor, J A080 to return to SDOS
                 19: ;                                              basic debug keys ^B, ^T, ^G, ^V
                 20: ;                            support for 4 floppy disk
                 21: ;                            only supported disk geometry: 5'25 floppy 2 sides x 35tr x 18 sec x 128 bytes
                 22: ;                            supports for HLE 5MB Hard Disk
                 23: ;                            PORT: device to read from PTR/punch to PTP
                 24: ;                           
                 25: 
  0004           26: NDRIVES         equ     4
  0013           27: NIOCHANNELS     equ     16+3    ; number of files that can be opened at same time
                 28: 
                 29:                                 ; SWTBUG ROM entry points
                 30: 
                 31:                 ; conditional assembly for SWTPC with 64K ram and
                 32:                 ; I/O address at FF00..FF1F instead of 8000..801F  
                 33: 
  0001           34:              if ram64k=1
                 35: 
                 36:                                 ; Memory Map
                 37:                                 ; 0000..B3FF User RAM (46080 BYTES = 45 kB)
  B400           38: DRIVERBASE      set     $B400   ; B400..BFFF SDOS I/O Driver for SWTPC 6800 
  C080           39: IOBUF           EQU     $C080   ; C080..CDFF BUFFERS FOR I/O DRIVER
  CE00           40: IOBUFEND        EQU     $CE00
  CE00           41: SDOS            EQU     $CE00   ; CE00..EFFF SDOS Operating System (64K compile version)
                 42:                                 ; FF00..FF1F IO MAPED MEMORY
  FFF8           43: IRQVECTOR       equ     $FFF8   ; IRQ VECTOR IN HIGH MEM IS RAM
                 44: 
  0001           45:               else
 *S*             46:                                 ; Memory Map
 *S*             47:                                 ; 0000..6FFF User RAM
 *S*             48: DRIVERBASE      EQU     $7000   ; 7000..7FFF SDOS I/O Driver for SWTPC 6800
 *S*             49:                                 ; 8000..9FFF IO MAPED MEMORY
 *S*             50:                                 ; A000..A07F 6810 RAM (128 BYTES), used by SWTBUG ROM
 *S*             51: IOBUF           EQU     $A080   ; A080..ADFF BUFFERS FOR I/O DRIVER
 *S*             52: IOBUFEND        EQU     $AE00   ;
 *S*             53: SDOS            EQU     $AE00   ; AE00..DFFF SDOS Operating System (56K compile version)
 *S*             54:                                 ; E000..E7FF SWTBUG ROM
 *S*             55:                                 ; E800..FFFF EPROM




ASM/6800 1.4A0: 0000                    
08/16/82 00:00:00; Page 3; Form 1       
IOSWTPC6800.ASM
 *S*             56: 
 *S*             57: OUTEEE          EQU     $E1D1   ; OUTPUT A CHAR USING SWTPC 6800 SWTBUG ROM
 *S*             58: INEEE           equ     $E1AC   ; INPUT A CHAR (BLOCKING) USING SWTPC 6800 SWTBUG ROM
 *S*             59: SWTMON          EQU     $E0D0   ; SWTBUG COLD START ENTRY POINT
 *S*             60: RDON            equ     $E334+3 ; reader on (skip echo setting in rom)
 *S*             61: RDOFF           equ     $E347   ; reader off
 *S*             62: PNCHON          equ     $E34d   ; punch on 
 *S*             63: PNCHOFF         equ     $E353   ; punch off
 *S*             64: PORECH          equ     $A00C   ; swtbug echo flag (=0 -> echo, $FF -> no echo)
 *S*             65: IRQVECTOR       equ     $A000   ; ON SWTBUG, A000=IRQ VECTOR IN RAM
 *S*             66: 
                 67:              fin
                 68: 
                 69: 
                 70: ;*              Fill in the SDOS-TO-IOPACKAGE COMMUNICATION REGION
                 71: 
  CE00           72:                 ORG     SDOS
                 73: 
CE00 11          74:                 FCB     $11                  ; SDOS:VERSIONNUMBER SDOS VERSION NUMBER (=$AE00)
CE01 0000        75:                 FDB     0                    ; SDOS:LASTERROR    LAST ERROR ENCOUNTERED
CE03 B403        76:                 FDB     CNFGTABLE            ; SDOS:CONFIGURATION TELL SDOS WHERE ALL THE GOODIES ARE
CE05 0000        77:                 FDB     0                    ; SDOS:SERIALNUMBER SERIAL NUMBER
CE07 0000        78:                 FDB     0                    ; SDOS:IOBLOCKPTR   IOBLOCKPTR
CE09 0000        79:                 FDB     0                    ; SDOS:IOCBPOINTER  IOCB POINTER (FOR FILE-TYPE DEVICE DRIVERS)
CE0B 000000      80:                 FCB     0,0,0                ; SET CLOCK TO "MIDNITE"
CE0E 10          81:                 FCB     16                   ; DAY, LET COMMAND INTERPRETER KNOW
CE0F 08          82:                 FCB     8                    ; MONTH, THAT THE TIME HASN'T BEEN SET
CE10 82          83:                 FCB     $82                  ; YEAR 
                 84: 
                 85: 
                 86: ;* patches SDOSINIT AND SDOS O/S
                 87: 
  2000           88: OFS             EQU     SDOS-$AE00      ; Offset for pathing (0=for 56k compile)
                 89: 
  0001           90:              if ram64k=1                
                 91:                 ; No need to apply any patch to loaded SDOS11G64K file. It is generated by 
                 92:                 ; assembling SDOS11G.ASM and has already been edited to disable all the checksum/serial number
                 93:                 ; validations
  0001           94:              else
 *S*             95:                 ; patch the loaded original unmodified SDOS11G56K file, it is the build
 *S*             96:                 ; for 56K RAM machine that comes from CHM and is generated by 
 *S*             97:                 ; assembling SDOS11GPART1.ASM and SDOS11GPART2.ASM and    
 *S*             98: 
 *S*             99:                 ORG $2027
 *S*            100:                 NOP             ; SKIP CHECKSUM VERIFICATION. WILL NOT WORK BECAUSE
 *S*            101:                 NOP             ; SDOS IS BEING PATCHED AND ... WE TRUST THE HW!
 *S*            102:                 ORG $23E9
 *S*            103:                 NOP             ; REMOVE STACK MESSED UP IF START CODE CHECKSUM
 *S*            104:                 NOP             ; IS NOT ZERO BECAUSE IT HAS BEEN PATCHED, AS WE ARE DOING NOW!
 *S*            105:                 ORG $2031
 *S*            106:                 NOP             ; PATCH ROM SERIAL NUMBER CHECHING TO DO NOTHING
 *S*            107:                 NOP
 *S*            108:                 ORG $217A
 *S*            109:                 RTS             ; INMEDIATE RETURN ON CALL TO WRITERANDOM (DO NOT CHECK)
 *S*            110:                 ORG $B00F+OFS




ASM/6800 1.4A0: CE10                    
08/16/82 00:00:00; Page 4; Form 1       
IOSWTPC6800.ASM
 *S*            111:                 DES             ; PATCH SAFEGUARD ROUTINE TO ITS FINAL FORM
 *S*            112:                 INS             ; AS IF IT WAS SET-UP BY SERIALNUMBER.SYS 
 *S*            113:                 RTS             ; THIS ALLOWS TO BYPASS SERIALNUMBER.SYS EXECUTION
 *S*            114:                 RTI
 *S*            115:                 RTI
 *S*            116:                 RTI
 *S*            117:                 RTI
 *S*            118:                 ORG $B408+OFS
 *S*            119:                 LDAA #$01       ; SET CHECKSUM ON COPYRIGHT STRING AS ALLWAYS OK
 *S*            120:                 ORG $DD82+OFS
 *S*            121:                 NOP             ; PATCH TASK USER STACK POINTER 
 *S*            122:                 NOP             ; SO IT NOT GET MESSED UP IF CHECKSUM DOES NOT MATCH
 *S*            123:                 NOP
 *S*            124:                 NOP
 *S*            125:                 NOP
 *S*            126:                 NOP
 *S*            127:                 ORG $B844+OFS   ; PATCH SerialNumberLocation to Point to SerialNumber 
 *S*            128:                 FDB $FFF0
 *S*            129:                 ORG $B837+OFS   ; PATCH EXITCKSUML ROUTINE TO IGNORE CHECKSUM
 *S*            130:                 CLRA
 *S*            131:                 ORG $C6F1+OFS   ; PATCH ERRBOOTCKSUMFAIL, SO BOOT CHECKSUM IS IGNORED
 *S*            132:                 NOP
 *S*            133:                 NOP
 *S*            134:                 ORG $2138       ; PATCH TO ALLOW LOAD A NON-ENCRYPTED SERIALNUMBER.SYS (OR WAHTERES IS THE FIRS
 *S*            135:                 NOP
 *S*            136:                 NOP
 *S*            137:                 ORG $2736       ; PATH  FCC "SERIALNUMBER.SYS" FILENAME
 *S*            138:                 FCC "DEFAULTPROGRAM  "
 *S*            139:                                 ; INSTEAD OF RUNNING SERIALNUMBER.SYS ON STARTUP
 *S*            140:                                 ; JUST RUN DEFAULTPROGRAM (HOPEFULLY BEING A COPY 
 *S*            141:                                 ; OF SDOS USER COMMAND PROCESSOR)
                142:               fin
                143:               
  2000          144:                 ORG $2000       ; PATCH MAIN ENTRY POINT TO SET-UP PROPERLY 
2000 7E3000     145:                 JMP SWTPCINIT   ; DRIVER MEM
                146:                 
  0007          147: SDOS.IOBLOCKPTR EQU $07         ; POINTER TO I/O REQUEST (PASSED TO DRIVERS)
  0015          148: SDOS.RTI        equ $15         ; JMP TO "RETURN FROM INTERRUPT; NO EVENT"
  002D          149: SDOS.ERROR      equ $2D         ; ERROR SUBROUTINE; INLINE 2 BYTE ERROR CODE 
  0030          150: SDOS.ERRORSAVE  equ $30         ; ERROR CODE SAVE ROUTINE; SAVES (X) AS ERROR CODE 
  0033          151: SDOS.ERRORED    equ $33         ; "ERROR CAN'T BE HANDLED BY ME" ENTRY 
  002A          152: SDOS.WAITEVENT  equ $2A         ; JMP TO WAIT FOR EVENT SELECTED BY (X)
  0036          153: SDOS.CHECKRDLEN EQU $36
  000B          154: SDOS.CLOCK      EQU $0B
                155: 
  0000          156: SCBLK.OPCODE    equ $00         ; PRIMARY SYSCALL FUNCTION (OPEN, READ, ETC.)    
  0001          157: SCBLK.WLEN      equ $01         ; WAIT FLAG BIT (0=WAIT) AND SYSCALL BLOCK LENGTH (0..127)      
  0002          158: SCBLK.PARAMS    equ $02         ; PARAMETER BYTES TO OPCODE (SECONDARY OPCODE, CHANNEL #)    
  0004          159: SCBLK.WRBUF     equ $04         ; POINTER TO WRITE DATA BUFFER     
  0006          160: SCBLK.WRLEN     equ $06         ; NUMBER OF BYTES IN WRITE DATA BUFFER
  0008          161: SCBLK.RPLEN     equ $08         ; LENGTH OF REPLY (RESULT OF SYSCALL)    
  000A          162: SCBLK.RDBUF     equ $0A         ; POINTER TO READ DATA BUFFER (WHERE RESULT GOES)     
  000C          163: SCBLK.RDLEN     equ $0C         ; CEILING ON SIZE OF REPLY (READ DATA BUFFER)
  000E          164: SCBLK.DATA      EQU $0E         ; OTHER PARAMETERS FOR SYSCALL; UP TO 127-12 BYTES
                165:  




ASM/6800 1.4A0: 2000                    
08/16/82 00:00:00; Page 5; Form 1       
IOSWTPC6800.ASM
  0082          166: SPECIALFN.CLEAR equ $0082            
  0083          167: SPECIALFN.EEOL  equ $0083            
  0081          168: SPECIALFN.POSN  equ $0081
                169: 
  002B          170: DSKINFO.SECTORDB        EQU $2B
  003C          171: DSKINFO.OPSCOUNT        equ $3c
                172: 
                173: 
  001A          174: FCB.SIZE        equ $001A
  0022          175: IOCB.SIZE       EQU $0022
  0002          176: NMAGICFCBS      EQU     2       ; FOR ERRMSGFCB, SYSFCB
                177: 
                178: 
                179: ;*
                180: ;*      device errors 
                181: ;*
  03E9          182: ERR.EOFHIT                      EQU 1001
  040A          183: ERR.ILLDEVICEOP                 equ 1034
  0411          184: err.programkilled               EQU 1041
  0412          185: ERR.DEVICETIMEDOUT              equ 1042
  0415          186: ERR.DISKREAD                    equ 1045
  0416          187: ERR.DISKWRITE                   equ 1046
  0417          188: ERR.DISKSEEK                    equ 1047
  0418          189: ERR.DSKWRTPROT                  equ 1048                  
  0424          190: ERR.DEVICENOTREADY              equ 1060
  076E          191: ERR.WRONGDISKTYPE               equ 1902
  0773          192: ERR.ACTIVATIONNOTINBUFFER       EQU 1907
  0775          193: err.activationreceived          equ 1909
                194: 
                195: ;*
                196: ;*      DEVICE CONTROL BLOCK DISPLACEMENTS
                197: ;*
  0000          198: DCB.DONEFLAG    EQU     0       ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
  0001          199: DCB.LASTERROR   equ     1       ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NONE )
  0003          200: DCB.NAME        EQU     3       ; POINTER TO DEVICE NAME STRING TERMINATED BY ZERO BYTE
  0005          201: DCB.NEXTDCB     EQU     5       ; POINTER TO NEXT DCB IN LIST OR ZERO
  0007          202: DCB.DRIVER      EQU     7       ; POINTER TO DRIVER ENTRY POINT LIST
  0043          203: dcb.fdunit      equ     $43                     
                204: 
  0013          205: dcb.oilquiescent        equ     $13
  0028          206: dcb.profile             equ     $28
  004D          207: dcb.ringinbase          equ     $4d
  0059          208: dcb.ringoutbase         equ     $59
  005D          209: dcb.ringoutthreshold    equ     $5d
  0067          210: dcb.linebuf             equ     $67
  007A          211: dcb.linebuflen          equ     $7a
  007D          212: DCB.TLBUFFER            equ     $7D
  00A1          213: dcb.outputtoblk         equ     $a1
  00A9          214: dcb.inputtoblk          equ     $a9
  00B1          215: dcb.tcb                 equ     $b1
  00B3          216: dcb.taskstack           equ     $b3
  00B5          217: DCB.RESET               EQU     $B5
  00CA          218: dcb.clearin             equ     $ca
  00FD          219: dcb.vtsize              equ     $fd
                220: 




ASM/6800 1.4A0: 2000                    
08/16/82 00:00:00; Page 6; Form 1       
IOSWTPC6800.ASM
  0006          221: DCBPOINTER              EQU     $06     ; POINTER TO DEVICE CONTROL BLOCK
                222: 
                223: 
  0000          224: DVTYP.TYPE              EQU     $00
  000B          225: DVTYP.CLOCK             EQU     $0B
  0002          226: DVTYP.STAPE             equ     $02
                227: 
  0000          228: RDSI.DISKINFO           EQU     $00
  0002          229: RDSI.LSN                EQU     $02  
  0005          230: RDSI.SECTORBASE         EQU     $05           
  0007          231: RDSI.FLINK              EQU     $07                 
  0009          232: RDSI.BLINK              EQU     $09                 
  000B          233: RDSI.MODIFIED           EQU     $0B             
  000C          234: RDSI.STATE              EQU     $0C                 
  000D          235: RDSI.RETRYCOUNT         EQU     $0D            
  000E          236: RDSI.SECTOR             EQU     $0E
  0010          237: RDSI.TRACK              EQU     $10                
  0012          238: RDSI.CYLINDER           EQU     $12             
  0014          239: RDSI.SIZE               EQU     $14 
                240: 
  0000          241: RDSISTATE.IDLE          EQU     $00
  0001          242: RDSISTATE.READING       EQU     $01         
  0003          243: RDSISTATE.VERIFYING     EQU     $03        
  0002          244: RDSISTATE.WRITING       EQU     $02         
                245: 
  0011          246: CC.DISMOUNTDISK         EQU     $11     ; DEVICE CONTROL OPS: DISMOUNT THE DISK
  001D          247: cc.activationck         EQU     $1D
  0010          248: CC.ECHO                 EQU     $10
  0011          249: CC.NOECHO               EQU     $11
  0014          250: cc.SETACTBLOCK          EQU     $14
                251: 
                252: 
  0004          253: SC.GETTYPE              EQU     $04
  002C          254: SC.GETLINEFLAGS         EQU     $2C
  0001          255: SC.GETCOL               equ     $01
  0002          256: sc.geteof               equ     $02
                257: 
  0000          258: SYSCALL.OPEN            EQU     $00
  0001          259: SYSCALL.CREATE          EQU     $01            
  0002          260: SYSCALL.CLOSE           EQU     $02
  0003          261: SYSCALL.RENAME          EQU     $03
  0004          262: SYSCALL.DELETE          EQU     $04            
  0006          263: SYSCALL.CHAIN           EQU     $06             
  000A          264: SYSCALL.READA           EQU     $0A             
  000B          265: SYSCALL.READB           EQU     $0B             
  000C          266: SYSCALL.WRITEA          EQU     $0C
  000D          267: SYSCALL.WRITEB          EQU     $0D             
  000E          268: SYSCALL.CONTROL         EQU     $0E           
  000F          269: SYSCALL.STATUS          EQU     $0F            
  0011          270: SYSCALL.EXIT            EQU     $11              
  0012          271: SYSCALL.ERROREXIT       EQU     $12         
  0013          272: SYSCALL.SETERROR        EQU     $13
  0014          273: SYSCALL.GETERROR        EQU     $14
  0015          274: SYSCALL.DISPERROR       EQU     $15
  0018          275: SYSCALL.DEBUG           EQU     $18             




ASM/6800 1.4A0: 2000                    
08/16/82 00:00:00; Page 7; Form 1       
IOSWTPC6800.ASM
                276: 
  0008          277: GOBIT                   EQU     $08     ; GO FROM BREAKPOINT/SINGLE STEP
  0010          278: SSTEPBIT                EQU     $10     ; SINGLE STEP REQUEST
  0020          279: BREAKBIT                EQU     $20     ; REQUEST LINE NUMBER BREAKPOINT
  0040          280: TRACEBIT                EQU     $40     ; REQUEST LINE NUMBER TRACE
  0080          281: ABORTBIT                EQU     $80     ; REQUEST PROGRAM ABORT
                282: 
                283: ;*
                284: ;* ONE TIME START-UP INITIALIZATION 
                285: ;* FOR SWTPC 6800. NEEDED BECAUSE 
                286: ;* WE MUST INIT FCB/IOCBS TO ZERO
                287: ;* WE MUST SET UP IOCBPOINTERS PROPERLY
                288: 
  3000          289:                         ORG     $3000
                290: 
3000 CEC081     291: SWTPCINIT       LDX     #FCBS           ; FCB/IOCBS TO ZERO
3003 6F00       292: SINIT1          CLR     0,X
3005 08         293:                 INX
3006 8CC5F9     294:                 CPX     #IOCBPOINTERS   
3009 26F8       295:                 BNE     SINIT1  
300B 86C3       296:                 LDAA    #(IOCBS/256)    ; SET UP IOCBPOINTERS PROPERLY
300D C673       297:                 LDAB    #(IOCBS&$FF)    ; EACH IOCBPOINTER POINTS TO
300F A700       298: SINIT2          STAA    0,X             ; THE CORRESPONDING IOCB
3011 E701       299:                 STAB    1,X
3013 CB22       300:                 ADDB    #(IOCB.SIZE&$FF)
3015 8900       301:                 ADCA    #(IOCB.SIZE/256)
3017 08         302:                 INX
3018 08         303:                 INX
3019 8CC61F     304:                 CPX     #INTERRUPTSTACK
301C 26F1       305:                 BNE     SINIT2
301E 7FC080     306:                 CLR     BASICDEBUGFLAGS
                307:                 ; INIT DONE, RETURN TO SDOSINIT 
3021 FECE03     308:                 LDX     $AE03+OFS       ; $AE03=CODE+SDOS:CONFIGURATION GET THE STACK POINTER
3024 7E2003     309:                 JMP     $2003
                310: 
                311: ;*              BUFFERS FOR I/O DRIVER
                312: ;*              MUST BE INITIALIZED!
                313: 
  C080          314:                 ORG     IOBUF           ; A080..AE00 
                315: 
  0001          316:              if ram64k=1
                317:                 ; ^D not available on RAM64K. SWTBUG ROM not present
  0001          318:              else
 *S*            319: swtgo           jmp     swtret          ; return address from SWTBUG MONITOR
 *S*            320:                                         ; ^D -> enter to monitor, JA080 | JE480 return to sdos
                321:              fin
C080 00         322: BASICDEBUGFLAGS fcb     0               ; set basic debug flags  A083 | E483
                323: 
                324: 
C081 02F2       325: FCBS            RMB     FCB.SIZE*(NIOCHANNELS+2*NDRIVES+NMAGICFCBS) ; MUST PRECEDE IOCBS
C373 0286       326: IOCBS           RMB     IOCB.SIZE*NIOCHANNELS
C5F9 0026       327: IOCBPOINTERS    RMB     NIOCHANNELS*2
C61F 0040       328: INTERRUPTSTACK  RMB     $40     ; STACK SPACE FOR INTERRUPT ROUTINES
C65F 00         329: INTSTACKTOP     FCB     0
C660 00         330: DSKBUFFERPOOL   fcb     0




ASM/6800 1.4A0: C660                    
08/16/82 00:00:00; Page 8; Form 1       
IOSWTPC6800.ASM
  079E          331: DSKPOOLSIZE     equ     IOBUFEND-DSKBUFFERPOOL-2
                332: 
  B400          333:                 ORG     DRIVERBASE      
                334: 
                335:                                 ; THIS IS CODE+SDOS:CONFIGURATION ADDRESS    ; 
                336: 
B400 7EB400     337: SYSCALLIO       JMP     SYSCALLIO       ; SDOS SETS JMP ADDR TO ITS ENTRY POINT
                338: 
B403 BB2D       339: CNFGTABLE       FDB     DISKDCBS        ; CNFG:DISKDCBS         DEFAULT DISK MUST BE FIRST
B405 B493       340:                 FDB     DCB.TTY         ; CNFG:DEVICEDCBS        CONSOLE MUST BE FIRST
B407 C5F9       341:                 FDB     IOCBPOINTERS    ; CNFG:IOCBPOINTERS     POINTER LIST TO IOCB'S
B409 13         342:                 FCB     NIOCHANNELS     ; CNFG:NIOCHANNELS      NUMBER OF I/O CHANNELS
B40A C660       343:                 FDB     DSKBUFFERPOOL   ; CNFG:DSKBUFFERPOOL    POINTER TO THE DISK BUFFER POOL
B40C 079E       344:                 FDB     DSKPOOLSIZE     ; CNFG:DSKPOOLSIZE      SIZE OF THE BUFFER POOL
B40E C021       345:                 FDB     ATTNCHECK       ; CNFG:ATTNCHECK        ADDRESS OF ATTENTION CHECK ROUTINE
B410 C021       346:                 FDB     DEBUGSYSCALL    ; CNFG:DEBUGGER RMB     ADDRESS OF DEBUGGER (0 IF NONE)
B412 B400       347:                 FDB     DRIVERBASE      ; CNFG:DRIVERBASE       LOWEST ADDRESS USED BY DRIVERS = END OF USER RA
B414 B427       348:                 FDB     INTSETUP        ; CNFG:INTSETUP         POINTER TO INTERRUPT SYSTEM SETUP ROUTINE
B416 7EB43A     349:                 JMP     INTDISABLE      ; CNFG:INTDISABLE       SUBROUTINE (OR "JMP") TO DISABLE ALL INTERRUPTS
B419 7EB43C     350:                 JMP     INTENABLE       ; CNFG:INTENABLE        SUBROUTINE (OR "JMP") TO ENABLE ALL INTERRUPTS
B41C 7EB43F     351:                 JMP     INTRTI          ; CNFG:INTRTI           CODE TO ENABLE PRIORITY INTERRUPT AND DO RTI (U
B41F C65F       352:                 FDB     INTSTACKTOP     ; CNFG:INTERRUPTSTACK   POINTER TO LAST BYTE OF INTERRUPT STACK SPACE
B421 B440       353:                 FDB     IOINTPOLL       ; CNFG:IOINTPOLL        POINTER TO I/O INTERRUPT SERVICE DEVICE POLL RO
B423 B45C       354:                 FDB     TASKQUEUE       ; CNFG:TASKQUEUE        POINTER TO FIRST TASK IN TASK QUEUE
B425 B450       355:                 FDB     TIMEOUTQUEUE    ; CNFG:TIMEOUTLIST      POINTER TO CHAINED LIST OF TIMEOUT BLOCKS
                356: 
                357: 
B427 CEB43E     358: INTSETUP        LDX #IRQINT
B42A FFFFF8     359:                 STX IRQVECTOR           ; ON SWTBUG, A000=IRQ VECTOR IN RAM
B42D BDBD52     360:                 JSR INTDK               ; INIT THE DISK SYSTEM
B430 CEB4CA     361:                 ldx     #InputBuf       ; init Input buf head and and pointerd
B433 FFB5C4     362:                 stx     InputBufP0      ; to set as no chars has been typed yet (empty buf)
B436 FFB5C6     363:                 stx     InputBufP1
B439 39         364:                 RTS
B43A 0F         365: INTDISABLE      SEI
B43B 39         366:                 RTS
B43C 0E         367: INTENABLE       CLI
B43D 39         368:                 RTS
B43E 01         369: IRQINT          NOP
B43F 3B         370: INTRTI          RTI     
                371: 
B440 4F         372: IOINTPOLL       CLRA
                373:                 ; LDA $8xxx                     ; No MP-T TIMER INTERRUPT
B441 46         374:                 RORA
B442 2400       375:                 BCC     NOTIMERINT
                376:                 ; LDX   #CLOCKDCB
                377:                 ; JMP   CLOCKSTATE
B444 FEB44E     378: NOTIMERINT      LDX     BADINTERRUPTCOUNT       ; CAN'T FIGURE OUT WHO IT IS...
B447 08         379:                 INX                             ; BUMP CRAZY INTERRRUPT COUNTER
B448 FFB44E     380:                 STX     BADINTERRUPTCOUNT   
B44B 7ECE15     381:                 JMP     SDOS+SDOS.RTI           ; AND HOPE IT WENT AWAY !   
                382: 
B44E 0000       383: BADINTERRUPTCOUNT       FDB     0               ; # OF INTERRUPTS FROM UNKNOWN DEVICES
                384: 
B450 0000       385: TIMEOUTQUEUE    FDB     0                       ; TIMEOUT:LINK   POINTER TO NEXT TIMEOUTBLOCK




ASM/6800 1.4A0: B452                    
08/16/82 00:00:00; Page 9; Form 1       
IOSWTPC6800.ASM
B452 0000       386:                 FDB     0                       ; TIMEOUT:FUSE.  16 BIT TIMEOUT COUNT (1/60 SEC UNITS); 0--> NO
B454 B458       387:                 FDB     FUSEBURNEDUP            ; TIMEOUT:ROUTINE POINTER TO TIMEOUT INTERRUPT ROUTINE FOR DEVI
B456 B493       388:                 FDB     DCB.TTY                 ; TIMEOUT:DCB    POINTER TO DCB BEING TIMED OUT
                389: 
B458 01         390: FUSEBURNEDUP    NOP
                391:                 ; BSR     ABORTQUANTUM
B459 7ECE15     392:                 JMP     SDOS+SDOS.RTI
                393: 
  0000          394: IGN             EQU     0                       ; IGNORE VALUE
                395: 
B45C 0000       396: TASKQUEUE       FDB     0                       ; TCB:LNK        POINTER TO NEXT TCB IN QUEUE
B45E B478       397:                 FDB     TASKSTACKINIT           ; TCB:STACK      STACK POINTER FOR TASK
B460 0000       398:                 FDB     0                       ; TCB:COND       TASK'S WAKE UP ROUTINE
B462 0000       399:                 FDB     0                       ; TCB:PARAM      PARAMETER TO TCB:COND ROUTINE
B464 00000000   400:                 FCB     0,0,0,0,0,0,0,0         ; TCB:SCRATCHPAD SPACE FOR TASK'S SCRATCHPAD (LOCATIONS 0-7)
B46C B493       401:                 FDB     DCB.TTY                 
B46E 000A       402:                 RMB     10
B478 00000000   403: TASKSTACKINIT   FCB     0,0,IGN,IGN,IGN,IGN     ; ZERO CC SO INTERRUPTS ARE ENABLED
B47E B482       404:                 FDB     TASKSETUP               ; INITIAL PC OF FIRST TASK
B480 00         405: TASKSTACKTOP    FCB     0               
B481 00         406: TASKWAKEUPFLAG  FCB     0                       ; TASK IS SLEEPING
B482 CEB481     407: TASKSETUP       LDX     #TASKWAKEUPFLAG
B485 BDCE2A     408:                 JSR     SDOS+SDOS.WAITEVENT     ; WAIT FOR EVENT (X) TO GO NON-ZERO
B488 20F8       409:                 BRA     TASKSETUP
                410: 
                411: 
                412: ; DEVICE CONTROL BLOCK FOR TTY CONSOLE
                413: 
B48A 434F4E53   414: dcbname.tty     fcc     'CONSOLE:'
B492 00         415:                 fcb     0
                416: 
B493 01         417: DCB.TTY         FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
B494 0000       418:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
B496 B48A       419:                 FDB     dcbname.tty             ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
B498 B94C       420:                 FDB     DCB.PORT                ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
B49A B49C       421:                 FDB     CONSOLEDRIVER           ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
                422: 
                423: ; DEVICE DRIVER BLOCK FOR TTY CONSOLE
                424: 
B49C B656       425: CONSOLEDRIVER   FDB     OPEN.TTY        ; DRIVER:OPEN   OPEN FILE
B49E B67A       426:                 FDB     CLOSE.TTY       ; DRIVER:CLOSE  CLOSE FILE
B4A0 B754       427:                 FDB     READA.TTY       ; DRIVER:READA  READ ASCII
B4A2 B8BF       428:                 FDB     WRITEA.TTY      ; DRIVER:WRITEA WRITE ASCII
B4A4 B732       429:                 FDB     READB.TTY       ; DRIVER:READB  READ BINARY
B4A6 B8C9       430:                 FDB     WRITEB.TTY      ; DRIVER:WRITEB WRITE BINARY
B4A8 B656       431:                 FDB     OPEN.TTY        ; DRIVER:CREATE CREATE FILE
B4AA B4B8       432:                 FDB     ILLDEVICEOP     ; DRIVER:RENAME RENAME FILE
B4AC B4B8       433:                 FDB     ILLDEVICEOP     ; DRIVER:DELETE DELETE FILE
B4AE B6AE       434:                 FDB     CONTROL.TTY     ; DRIVER:CONTROL        DO CONTROL OPERATION
B4B0 B67D       435:                 FDB     STATUS.TTY      ; DRIVER:STATUS READ DEVICE (DRIVER) STATUS
B4B2 B6C3       436:                 FDB     RESET.TTY       ; DRIVER:RESET  RESET DRIVER (ON BOOT)
B4B4 B4B8       437:                 FDB     ILLDEVICEOP     ; DRIVER:STARTIO        power-fail restart--dream on!
                438: 
B4B6 0C         439: OKRTS           CLC
B4B7 39         440:                 RTS




ASM/6800 1.4A0: B4B7                    
08/16/82 00:00:00; Page 10; Form 1      
IOSWTPC6800.ASM
                441: 
B4B8 BDCE2D     442: ILLDEVICEOP     JSR     SDOS+SDOS.ERROR
B4BB 040A       443:                 FDB     ERR.ILLDEVICEOP
B4BD BDCE30     444: ERRETX          JSR     SDOS+SDOS.ERRORSAVE
B4C0 7ECE33     445:                 JMP     SDOS+SDOS.ERRORED
                446: 
                447: 
B4C3 0001       448: LMODE           RMB     1               ; =0 -> reada in non-line mode, >0 -> reada line mode 
B4C4 0002       449: LEN             RMB     2               ; DATA BUFFER LENGTH
B4C6 0002       450: PDATA           RMB     2               ; ADDR OF DATA 
B4C8 0002       451: RPLEN           RMB     2               ; REPLY DATA BUFFER LENGTH
                452: 
  00FA          453: InputBufLen     EQU     250             ; length of input buffer (max 255)
B4CA 00FA       454: InputBuf        RMB     InputBufLen     ; input buffer ADDR
B5C4 0002       455: InputBufP0      RMB     2               ; addr of next char into InputBuffer TO BE PROCESSED (HEAD OF BUFFER)
B5C6 0002       456: InputBufP1      RMB     2               ; addr of next free char into InputBuffer (END OF BUFFER)
                457: 
B5C8 0001       458: EOFFLAG         RMB     1               ; =1 -> EOF = input line processed
B5C9 0001       459: ECHOFLAG        rmb     1               ; =0 -> NO ECHO 
B5CA 0001       460: ncol            rmb     1               ; number of chars printed in the current line
B5CB 0001       461: basicflags      rmb     1               ; flags for basic control chars for debugging
B5CC 0001       462: CTRLCNUM        RMB     1               ; NUMBER OF CONTROL-C TYPED IN SEQUENCE
B5CD 0001       463: expandtabflag   rmb     1
B5CE 0001       464: crflag          rmb     1               ;1=if prev char recv in port: was a <CR>
                465: 
B5CF 0010       466: ACTIVATIONCHARSVECTOR   RMB 16          ; Activation Chars vector
B5DF 0001       467: ActivationCharSensed    rmb 1           ; Activation Char typed by user
                468: 
  0001          469:              if ram64k=1
                470:                 ; on 64K RAM machine, SWTBUG rom not present. Here goes the console I/O routines
  FF04          471: ACIAPORT        EQU     $FF04   ; ACIA PORT IN SWTBUG 64K RAM
B5E0 00         472: PORECH          FCB     0       ; ECHO (=0 -> echo, $FF -> no echo)
                473: 
                474:                 ; *OUTPUT ONE CHARACTER
B5E1 37         475: OUTEEE          PSHB            ; SAVE ACC B
B5E2 DF00       476:                 STX     $00     ; STORE INDEX REGISTER
B5E4 CEFF04     477:                 LDX     #ACIAPORT
B5E7 E601       478:                 LDAB    1,X
B5E9 E103       479:                 CMPB    3,X
B5EB C611       480: ACIOUT          LDAB    #$11
B5ED E700       481:                 STAB    0,X
B5EF E600       482: ACIOU1          LDAB    0,X
B5F1 57         483:                 ASRB
B5F2 57         484:                 ASRB
B5F3 24FA       485:                 BCC     ACIOU1  ; ACIA NOT READY
B5F5 A701       486:                 STAA    1,X     ; OUTPUT CHARACTER **log OUTCH:A
B5F7 33         487: RES             PULB            ; RESTORE ACC B
B5F8 DE00       488:                 LDX     $00
B5FA 39         489:                 RTS
                490: 
                491:                 ; *INPUT ONE CHAR INTO ACC B
B5FB 37         492: INEEE           PSHB            ; SAVE ACC B
B5FC DF00       493:                 STX     $00     ; STORE INDEX REGISTER
B5FE CEFF04     494:                 LDX     #ACIAPORT
B601 E601       495:                 LDAB    1,X




ASM/6800 1.4A0: B603                    
08/16/82 00:00:00; Page 11; Form 1      
IOSWTPC6800.ASM
B603 E103       496:                 CMPB    3,X
B605 8615       497:                 LDAA    #$15    ; RECONFIG FOR 8 BIT, 1 SB
B607 A700       498:                 STAA    0,X     ;             **troff
B609 A600       499: ACIAIN          LDAA    0,X
B60B 47         500:                 ASRA
B60C 24FB       501:                 BCC     ACIAIN  ; NOT READY
B60E A601       502:                 LDAA    1,X     ; LOAD CHAR   **tron
B610 F6B5E0     503:                 LDAB    PORECH
B613 27D6       504:                 BEQ     ACIOUT  ; ECHO
B615 20E0       505:                 BRA     RES     ; DON'T ECHO
                506: 
B617 8611       507: RDON            LDAA    #$11    ; RON CHAR.
B619 20C6       508:                 BRA     OUTEEE
B61B 8613       509: RDOFF           LDAA    #$13    ; TURN READER OFF
B61D 20C2       510:                 BRA     OUTEEE
B61F 8612       511: PNCHON          LDAA    #$12    ; punch on 
B621 20BE       512:                 BRA     OUTEEE
B623 8614       513: PNCHOFF         LDAA    #$14    ; punch off
B625 20BA       514:                 BRA     OUTEEE
                515:                 
  0001          516:              else
 *S*            517:                 ; use SWTBUG rom for INEEE and OUTEEE, and so ... 
                518:              fin
                519: 
                520:                 ; print a char 
                521: 
B627 810D       522: prtch           cmpa    #13             ; <CR> RESET COLUMN COUNT
B629 270E       523:                 beq     prt1
B62B 8108       524:                 cmpa    #8              ; backSpace
B62D 2712       525:                 beq     prt4            
B62F 853C       526:                 bita    #60             ; DO NOT INCR NCOL ON CONTROL CHARS
B631 2703       527:                 BEQ     PRT3
B633 7CB5CA     528: prt2            inc     ncol            ; INCR NCOL ON REGULAR $20-$7F
B636 7EB5E1     529: prt3            jmp     outeee
B639 7FB5CA     530: prt1            clr     ncol
B63C 7AB5CA     531:                 dec     ncol
B63F 20F5       532:                 bra     prt3
B641 BDB5E1     533: prt4            jsr     outeee
B644 8620       534:                 ldaa    #32
B646 BDB5E1     535:                 jsr     outeee
B649 7AB5CA     536:                 dec     ncol
B64C 8608       537:                 ldaa    #8
B64E 7EB5E1     538:                 jmp     outeee
                539: 
                540:                 ; read keyboard key pressed 
                541: 
B651 01         542: inch            nop                             ; **troff
B652 BDB5FB     543:                 jsr     ineee                   ; read the keyboard (blocking)
B655 39         544:                 rts                             ; **tron
                545: 
B656 7FB5C8     546: OPEN.TTY        CLR     EOFFLAG         ; RESET EOF FLAG
B659 8601       547:                 LDAA    #1
B65B B7B5C9     548:                 STAA    ECHOFLAG        ; set ECHO ON (to be done by this iopackage)
B65E 86FF       549:                 ldaa    #255
B660 B7B5E0     550:                 staa    PORECH          ; DISABLE ECHO into swtbug 




ASM/6800 1.4A0: B663                    
08/16/82 00:00:00; Page 12; Form 1      
IOSWTPC6800.ASM
B663 7FB5CA     551:                 clr     ncol            ; init numbers of chars printed in line
B666 CEB5CF     552:                 LDX     #ACTIVATIONCHARSVECTOR
B669 8610       553:                 LDAA    #16
B66B 6F00       554: OPEN.TTY1       CLR     0,X             ; reset the 16 bytes of Activation Char vector
B66D 08         555:                 INX
B66E 4A         556:                 DECA
B66F 26FA       557:                 BNE     OPEN.TTY1       
B671 7FB5CC     558:                 CLR     CTRLCNUM        ; INIT ^c COUNT
B674 7FB5CB     559:                 clr     basicflags
B677 7EB4B6     560:                 JMP     OKRTS           ; TTY IS ALWAYS OPEN
                561: 
B67A 7EB4B6     562: CLOSE.TTY       JMP     OKRTS           ; AND TTY CANNOT BE CLOSED
                563: 
                564: 
B67D FECE07     565: STATUS.TTY      ldx     SDOS+SDOS.IOBLOCKPTR
B680 8600       566:                 ldaa    #0  ; vt:sclen
B682 E603       567:                 ldab    scblk.params+1,x        ; get sc status opcode
B684 C12C       568:                 cmpb    #SC.GETLINEFLAGS
B686 260B       569:                 bne     st0
B688 B6B5CB     570:                 ldaa    basicflags              ; get the basic flags
                571: 
B68B BAC080     572:                 oraa    BASICDEBUGFLAGS         ; or basic debug flags 
                573: ;               oraa #TRACEBIT                  ; turn on basic trace 
                574: 
B68E 7FB5CB     575:                 clr     basicflags              ; ans clear them
B691 2014       576:                 bra     statusret1
B693 C101       577: st0             cmpb    #SC.GETCOL
B695 2605       578:                 bne     st1
B697 B6B5CA     579:                 ldaa    ncol                    ; get the number of columns used in current line
B69A 200B       580:                 bra     statusret1
B69C C102       581: st1             cmpb    #sc.geteof
B69E 2605       582:                 bne     st2             
B6A0 B6B5C8     583:                 ldaa    eofflag
B6A3 2002       584:                 bra     statusret1
B6A5 8600       585: st2             ldaa    #0                      ; any other request returns 0
B6A7 EE0A       586: statusret1      LDX     scblk.rdbuf,x           ; return 1 byte status
B6A9 A700       587:                 staa    0,X                     ; STORE IN RDBUF
B6AB 7EB4B6     588:                 JMP     OKRTS 
                589: 
B6AE FECE07     590: CONTROL.TTY     ldx     sdos+sdos.ioblockptr
B6B1 E603       591:                 ldab    scblk.params+1,x
B6B3 C11D       592:                 cmpb    #cc.activationck
B6B5 271D       593:                 beq     dactivationck
B6B7 C110       594:                 cmpb    #cc.ECHO
B6B9 270B       595:                 beq     dECHO
B6BB C111       596:                 cmpb    #cc.NOECHO
B6BD 270F       597:                 beq     dnoecho
B6BF C114       598:                 cmpb    #cc.SETACTBLOCK
B6C1 2721       599:                 beq     dsetactivation
B6C3 7EB4B6     600: RESET.TTY       JMP     OKRTS           ; TTY DOES NOT NEED RESET
                601: 
B6C6 8601       602: DECHO           LDAA    #1
B6C8 B7B5C9     603:                 STAA    ECHOFLAG
B6CB 7EB4B6     604:                 JMP     OKRTS
B6CE 7FB5C9     605: DNOECHO         CLR     ECHOFLAG




ASM/6800 1.4A0: B6D1                    
08/16/82 00:00:00; Page 13; Form 1      
IOSWTPC6800.ASM
B6D1 7EB4B6     606:                 JMP     OKRTS           
                607:                 
B6D4 FEB5C4     608: dactivationck   ldx     InputBufp0              ; Is input Buf empty?
B6D7 BCB5C6     609:                 cpx     InputBufP1
B6DA 2705       610:                 beq     dactivation1            ; br if so (reada will block)
B6DC BDCE2D     611:                 jsr     sdos+sdos.error         ; something in input buffer
B6DF 0775       612:                 fdb     err.activationreceived  ; signal it (reada will not block)
B6E1 7EB4B6     613: dactivation1    JMP     OKRTS                   
                614: 
                615: 
B6E4 BDB8AE     616: dsetactivation  jsr     GETWRITEPARAMS          ; set the activation chars vector
B6E7 CEB5CF     617:                 ldx     #ACTIVATIONCHARSVECTOR  
B6EA FFBD49     618:                 stx     ddata
B6ED C610       619:                 ldab    #16
B6EF FEB4C6     620: dsetact1        ldx     pdata
B6F2 A600       621:                 ldaa    0,x
B6F4 08         622:                 inx
B6F5 FFB4C6     623:                 stx     pdata
B6F8 FEBD49     624:                 ldx     ddata
B6FB A700       625:                 staa    0,x     
B6FD 08         626:                 inx
B6FE FFBD49     627:                 stx     ddata
B701 5A         628:                 decb
B702 26EB       629:                 bne     dsetact1
B704 7EB4B6     630:                 jmp     okrts
                631: 
                632:                 ; read params from READA/B SYSCALL
                633:                 ; set LMODE, PDATA, LEN, clears RPLEN
                634: 
B707 FECE07     635: getreadparams   ldx     sdos+sdos.ioblockptr
B70A A603       636:                 ldaa    scblk.params+1,x        ; if LMODE=0 -> reada in non-line mode, >0 -> reada line mode 
B70C B7B4C3     637:                 staa    LMODE
B70F EE0C       638:                 LDX     scblk.rdlen,x           ; LEN=reada/B SYSCALL buffer length
B711 FFB4C4     639:                 stX     LEN
B714 FECE07     640:                 LDX     SDOS+SDOS.IOBLOCKPTR    ; INIT RPLEN TO ZERO (ACTUAL CHARS READ INTO SYSCALL BUFFER)
B717 6F08       641:                 CLR     scblk.RPLEN,x
B719 6F09       642:                 CLR     scblk.RPLEN+1,x
B71B FECE07     643:                 LDX     SDOS+SDOS.IOBLOCKPTR    ; PDATA=addr of INPUT buffer 
B71E EE0A       644:                 LDX     scblk.rdbuf,x
B720 FFB4C6     645:                 STX     PDATA
B723 39         646:                 rts
                647:                 
                648:                 ; save x-reg as rplen (numb of chars read) as syscall return 
B724 DF00       649: setrplen        stx     $00
B726 9600       650:                 ldaa    $00
B728 D601       651:                 ldab    $01
B72A FECE07     652:                 LDX     SDOS+SDOS.IOBLOCKPTR    
B72D A708       653:                 staa    scblk.RPLEN,x
B72F E709       654:                 stab    scblk.RPLEN+1,x
B731 39         655:                 rts
                656: 
B732 BDB707     657: readb.TTY       jsr     getreadparams           ; get syscall params
B735 FEB4C4     658:                 ldx     len                     ; readb will read
B738 BDB724     659:                 jsr     setrplen                ; exactly len chars from keyboard
B73B FEB4C4     660: readb1          ldx     len                     ; input buf full? (remaining len=0)




ASM/6800 1.4A0: B73E                    
08/16/82 00:00:00; Page 14; Form 1      
IOSWTPC6800.ASM
B73E 2712       661:                 beq     readb2                  ; br if buf full
B740 09         662:                 dex                             ; no, decr remaining len
B741 FFB4C4     663:                 stx     len
B744 BDB651     664:                 jsr     inch                    ; read char from keyboard
B747 FEB4C6     665:                 ldx     pdata                   ; input buf addr
B74A A700       666:                 staa    0,x                     ; store into input buf
B74C 08         667:                 inx
B74D FFB4C6     668:                 stx     pdata
B750 20E9       669:                 bra     readb1
B752 0C         670: readb2          clc
B753 39         671:                 rts             
                672: 
B754 BDB707     673: reada.TTY       jsr     getreadparams           ; get syscall params
B757 B6B4C3     674:                 LDAA    LMODE                   ; CHECK IF NON-LINE MODE READ BUT BUF LEN > 0
B75A 2608       675:                 BNE     reada1                  ; BR BECAUSE IN LINE MODE
B75C FEB4C4     676:                 LDX     LEN
B75F 2703       677:                 BEQ     reada1
B761 7EB4B8     678:                 jmp     ILLDEVICEOP             ; ERROR BECAUSE NON-LINE MODE READ BUT BUF LEN > 0
B764 FEB4C4     679: reada1          LDX     LEN                     ; IS BUFFER IS ZERO BYTES
B767 2605       680:                 BNE     READA2                  ; THE JUST RETURN FROM READ 
B769 BDCE2D     681:                 jsr     sdos+sdos.error         ; signaling "Activation not in buffer" error
B76C 0773       682:                 fdb     ERR.ACTIVATIONNOTINBUFFER                 
B76E FEB5C4     683: READA2          ldx     InputBufp0              ; LEN IS >0 -> CHECK Is input Buf empty?
B771 BCB5C6     684:                 cpx     InputBufP1
B774 2603       685:                 bne     reada3                  ; br if not
B776 BDB7D4     686:                 jsr     readInputBuf            ; input buffer empty -> read it from keyboard
B779 CE0000     687: reada3          LDX     #0
B77C FFB4C8     688:                 STX     RPLEN                   ; INIT RPLEN
B77F FEB5C4     689: READA4          LDX     iNPUTBUFP0              ; CHECK IF INPUT BUF IS EMPTY
B782 BCB5C6     690:                 CPX     iNPUTBUFP1              
B785 2743       691:                 BEq     READA6                  ; BR IF EMPTY 
B787 FEB5C4     692:                 LDX     iNPUTBUFP0              ; GET CHAR FROM INPUT BUFFER
B78A A600       693:                 LDAA    0,X                                     
B78C 08         694:                 INX
B78D FFB5C4     695:                 STX     INPUTBUFP0
B790 811A       696:                 cmpa    #26                     ; char is ^Z ? 
B792 2736       697:                 beq     reada6                  ; br if so to signal eof
B794 FEB4C6     698:                 LDX     PDATA                   ; STORE CHAR IN SYSCALL BUFFER
B797 A700       699:                 STAA    0,X
B799 08         700:                 INX     
B79A FFB4C6     701:                 STX     PDATA
B79D 810D       702:                 cmpa    #13                     ; <cr> resets ncol to 0
B79F 2605       703:                 bne     rd1ncol
B7A1 7FB5CA     704:                 clr     ncol
B7A4 2003       705:                 bra     rd2ncol
B7A6 7CB5CA     706: rd1ncol         inc     ncol                    ; incr ncol chars processed    
B7A9 FEB4C8     707: rd2ncol         LDX     RPLEN                   ; INCR RPLEN NUM OF BYTES STORED
B7AC 08         708:                 INX                             ; IN SYSCALL BUFFER
B7AD FFB4C8     709:                 STX     RPLEN
B7B0 36         710:                 psha
B7B1 BDB724     711:                 JSR     setrplen                
B7B4 32         712:                 pula
B7B5 B1B5DF     713:                 CMPA    ActivationCharSensed    ; CHAR IS activation char sensed ?
B7B8 2603       714:                 BNE     READA5                  ; BR IF NOT
B7BA 7EB4B6     715:                 JMP     OKRTS                   ; YES! ACTIVATION CHAR IN READ BUFFER -> EXIT FROM SYSCALL, NO 




ASM/6800 1.4A0: B7BD                    
08/16/82 00:00:00; Page 15; Form 1      
IOSWTPC6800.ASM
B7BD FEB4C8     716: READA5          LDX     RPLEN                   ; CHECK IF SYSCALL BUFFER
B7C0 BCB4C4     717:                 CPX     LEN                     ; IS FULL
B7C3 26BA       718:                 BNE     READA4                  ; BR IF NOT ...
B7C5 BDCE2D     719:                 jsr     sdos+sdos.error         ; BUFFER IS FULL -> RETURN FROM SYSCALL 
B7C8 0773       720:                 fdb     ERR.ACTIVATIONNOTINBUFFER ; signaling "Activation not in buffer" error
B7CA 8601       721: READA6          LDAA    #1                      ; SIGNAL EOF FLAG
B7CC B7B5C8     722:                 STAA    EOFFLAG
B7CF BDCE2D     723:                 jsr     sdos+sdos.error         ; NO MORE CHARS IN INPUT BUFFER
B7D2 03E9       724:                 fdb     err.eofhit              ; return from read signaling eof CONDITION
                725:                 
                726:                 
B7D4 7FB5CC     727: ReadInputBuf    CLR     CTRLCNUM
B7D7 7FB5DF     728:                 CLR     ActivationCharSensed    ; no activation char sensed
B7DA 7FB5CD     729:                 clr     expandtabflag           ; tabs should be echoed as ^I if echo is enabled
B7DD CEB4CA     730: RINBUF          ldx     #InputBuf               ; init Input buf head and and pointer
B7E0 FFB5C4     731:                 stx     InputBufP0              ; to set as no chars has been typed yet (empty buf)
B7E3 FFB5C6     732:                 stx     InputBufP1
B7E6 BDB651     733: RINCH           jsr     inch                    ; READ KEY FROM KEYBOARD
B7E9 B7B970     734:                 staa    ch                      ; save
B7EC 8103       735:                 CMPa    #3                      ; is ^C (BREAK)
B7EE 2612       736:                 BNE     RI1
B7F0 BDB8F8     737: RCTRLC          jsr     write.chcr.echo         ; if echo set, write ^C on screen, then <cr><LF>
B7F3 7CB5CC     738:                 INC     CTRLCNUM                ; INC COUNTER OF ^c'S ISSUED
B7F6 B6B5CC     739:                 LDAA    CTRLCNUM
B7F9 8102       740:                 CMPA    #2      
B7FB 26E0       741:                 BNE     rINBUF                  ; BR IF IS THE FIRST ONE: DISCARD CURRENT LINE
B7FD BDCE2D     742:                 jsr     sdos+sdos.error         ; TWO ^C IN SEQUENCE
B800 0411       743:                 FDB     err.programkilled       ; KILL THE CURRENT PROGRAM
B802 7FB5CC     744: RI1             CLR     CTRLCNUM                ; KEY READ IS NOT ^c -> RESET COUNT
B805 8108       745:                 CMPA    #8                      ; IS ^H (BACKSPACE)
B807 2704       746:                 BEQ     RBACKSPACE
B809 817F       747:                 CMPA    #127                    ; OR IS ROUBOUT/DEL
B80B 2605       748:                 BNE     RI2                     ;    BR IF NOT
B80D BDB88C     749: RBACKSPACE      JSR     BACKSPACE               ; DEL LAST TYPED CHAR FROM INPUTBUF AND (IF ECHO ENABLED) FROM 
B810 20D4       750:                 BRA     RINCH                   ; IF SO, IGNORE THE BACKSPACE KEY AND BR TO KEEP READING KEYBOA
B812 8104       751: RI2             CMPA    #4                      ; IS ^D ? (GO TO DEBUG MONITOR)   
B814 2606       752:                 BNE     RI3
B816 BDB8F8     753: RCTRLD          jsr     write.chcr.echo         ; if echo set, write ^D on screen, then <cr><LF>
  0001          754:              if ram64k=1
B819 7EB7E6     755:                 JMP     RINCH                   ; RAM64K does not uses SWTBUG ROM, so ^D does nothing
  0001          756:              else
 *S*            757:                 STS     SWTRET+1                ; SAVE STACK POINTER
 *S*            758:                 JMP     SWTMON                  ; JUMP TO SWTBUG monitor. return from monitor with JA080 comman
 *S*            759: SWTRET          LDS     #$A07F                  ; SWTBUG MONITOR GO COMMAND RETURNS HERE. RESTORE STACK POINTER
 *S*            760:                 ldaa    #255
 *S*            761:                 staa    PORECH                  ; DISABLE ECHO FOR ACIA
 *S*            762:                 JMP     RINCH                   ; JMP TO KEEP READING KEYBOARD AS NOTHING HAPPEND
                763:              fin
B81C C620       764: RI3             ldab    #BREAKBIT               ; 
B81E 8102       765:                 CMPA    #2                      ; IS ^B? (REQUEST LINE NUMBER BREAKPOINT in a basic program)
B820 2712       766:                 BEQ     Rbas                    ;    br if SO ...
B822 C610       767:                 ldab    #SSTEPBIT       
B824 8116       768:                 cmpa    #$16                    ; IS ^V? (REQUEST SINGLE STEP in a basic program)
B826 270C       769:                 BEQ     Rbas                    ;    br if SO ...
B828 C640       770:                 ldab    #TRACEBIT               




ASM/6800 1.4A0: B82A                    
08/16/82 00:00:00; Page 16; Form 1      
IOSWTPC6800.ASM
B82A 8114       771:                 cmpa    #$14                    ; IS ^T? (REQUEST LINE NUMBER TRACE in a basic program)
B82C 2706       772:                 BEQ     Rbas                    ;    br if SO ...
B82E C608       773:                 ldab    #GOBIT          
B830 8107       774:                 cmpa    #7                      ; IS ^G? (GO FROM BREAKPOINT/SINGLE STEP in a basic program)
B832 2608       775:                 Bne     RI4                     ;    br if SO ...
B834 FAB5CB     776: RBAS            orab    basicflags              ; add current basic flags
B837 CA01       777:                 orab    #1                      ; SET BASIC KEYB POLL ACTIVE ON SC:GETLINEFLAGS
B839 F7B5CB     778:                 stab    basicflags              ; store back
  B83C          779: RI4                                             
B83C FEB5C6     780:                 LDX     INPUTBUFP1              ; CHECK IF INPUTBUF IS FULL
B83F 8CB5C3     781:                 CPX     #INPUTBUF+INPUTBUFLEN-1
B842 2605       782:                 BNE     RSTORECH                ; BR IF BUF HAS ROOM LEFT TO STORE THE TYPED CHAR
B844 36         783:                 PSHA                            ; IF INPUTBUF FULL, THEN ...
B845 BDB88C     784:                 JSR     BACKSPACE               ; ... DEL LAST TYPED CHAR FROM INPUTBUF AND (IF ECHO ENABLED) F
B848 32         785:                 PULA                            ; TO REPLACE IT WITH NEW TYPED CHAR
B849 FEB5C6     786: RSTORECH        LDX     INPUTBUFP1              
B84C A700       787:                 STAA    0,X                     ; STORE CHAR IN INPUTBUF
B84E 08         788:                 inx
B84F FFB5C6     789:                 stx     inputbufp1
B852 36         790:                 psha
B853 BDB8FD     791:                 JSR     WRITEA.CH.echo          ; ECHO IT TO SCREEN 
B856 32         792:                 pula
B857 810D       793:                 CMPa    #13                     ; IS <CR> ? 
B859 272A       794:                 BEQ     ActivChar               ;   BR IF SO ...
B85B 811A       795:                 CMPa    #26                     ; IS ^Z ? 
B85D 2605       796:                 bne     ri5                     ;   BR IF NOT ...
B85F BDB8FB     797:                 jsr     write.cr.echo           ; write a <cr> after ^Z
B862 2027       798:                 Bra     Rendofinput             ; then end reading the line
B864 36         799: ri5             psha                            ; now check if the char in a-reg is an activation char
B865 8407       800:                 anda    #7
B867 C601       801:                 ldab    #1                      ; set to 1 the bit number
B869 4D         802: ri6             tsta                            ; corresponding to (char & 7)
B86A 2704       803:                 beq     ri7
B86C 58         804:                 aslb            
B86D 4A         805:                 deca
B86E 20F9       806:                 bra     ri6
B870 32         807: ri7             pula
B871 47         808:                 asra                            ; a=byte index on ACTIVATIONCHARSVECTOR
B872 47         809:                 asra                            ; b=bit mask 
B873 47         810:                 asra
B874 B7B87B     811:                 staa    ActivByte+1     
B877 CEB5CF     812:                 ldx     #ACTIVATIONCHARSVECTOR  ; check ACTIVATIONCHARSVECTOR to 
B87A A600       813: ActivByte       ldaa    0,X                     ; determine if char is an activation char
B87C D700       814:                 stab    $00
B87E 9400       815:                 anda    $00
B880 2603       816:                 bne     ActivChar               ; BR if char is an activation char
B882 7EB7E6     817:                 JMP     RINCH
B885 B6B970     818: ActivChar       ldaa    ch
B888 B7B5DF     819:                 staa    ActivationCharSensed    ; save the activation char sensed
B88B 39         820: Rendofinput     RTS                             ; > READ LINE FROM KEYBOARD TERMINATED
                821:                 
                822:                 
                823: 
B88C FEB5C6     824: BACKSPACE       LDX     InputBufP1              ; DEL LAST TYPED CHAR FROM INPUTBUF AND (IF ECHO ENABLED) FROM 
B88F 8CB4CA     825:                 CPX     #iNPUTbUF               




ASM/6800 1.4A0: B892                    
08/16/82 00:00:00; Page 17; Form 1      
IOSWTPC6800.ASM
B892 2719       826:                 BEQ     BACKSPC2
B894 09         827:                 DEX
B895 FFB5C6     828:                 STX     iNPUTBUFP1              ; BACKSPACE TO ERASE LAST CHAR TYPED FROM INPUTBUF
B898 7DB5C9     829:                 TST     ECHOflag
B89B 2710       830:                 BEQ     BACKSPC2                ; IF NO ECHO, BR TO KEEP READING KEYBOARD
B89D A600       831:                 LDAA    0,X                     ; GET CHAR THAT HAS BEEN ERASED
B89F 8120       832:                 CMPA    #32                     ; IS A CONTROL CHAR?
B8A1 2405       833:                 BCC     BACKSPC1                ; BR IF A >= 32 
B8A3 8608       834:                 LDAA    #8                      ; IS A CONTROL CHAR -> ISSUE TWO BACKSPACES
B8A5 BDB627     835:                 JSR     PRTCH                   ; TO DELETE ^x FROM SCREEN
B8A8 8608       836: BACKSPC1        LDAA    #8
B8AA BDB627     837:                 JSR     PRTCH
B8AD 39         838: BACKSPC2        RTS
                839: 
B8AE FECE07     840: GETWRITEPARAMS  LDX     SDOS+SDOS.IOBLOCKPTR    ; get number of chars to write form syscall
B8B1 EE06       841:                 LDX     scblk.wrlen,x           
B8B3 FFB4C4     842:                 STX     LEN                     
B8B6 FECE07     843:                 LDX     SDOS+SDOS.IOBLOCKPTR    ; get addr of chars to write
B8B9 EE04       844:                 LDX     scblk.wrbuf,x
B8BB FFB4C6     845:                 STX     PDATA
B8BE 39         846:                 RTS
                847: 
                848: 
B8BF 8601       849: WRITEA.TTY      LDAa    #1
B8C1 B7B8E1     850:                 STaA    write.MODE+1
B8C4 B7B5CD     851:                 staa    expandtabflag           ; signal tabs should be expanded to spaces
B8C7 2006       852:                 BRA     WRITE.0
B8C9 7FB8E1     853: WRITEB.TTY      CLR     write.MODE+1
B8CC 7FB5CA     854:                 clr     ncol
B8CF BDB8AE     855: WRITE.0         JSR     GETWRITEPARAMS 
B8D2 FEB4C4     856:                 LDX     LEN                     
B8D5 271E       857:                 BEQ     WRITE.9                 ; exit because writing zero chars
B8D7 FEB4C6     858: WRITE.1         LDX     PDATA                   ; get next char to write.
B8DA A600       859:                 LDAA    0,X
B8DC 08         860:                 INX                             ; .*echo wrtch:a
B8DD FFB4C6     861:                 STX     PDATA
B8E0 C600       862: write.MODE      ldab    #0                      ; if not ascii mode (that means, we are executing a writeb)
B8E2 2705       863:                 BEQ     WRITE.2                 ; br to print char without any further processing  
B8E4 BDB903     864:                 JSR     WRITEA.CH               ; convert char <CR> -> <CR><LF>, ctrol char -> ^X
B8E7 2003       865:                 bra     write.3
B8E9 BDB627     866: WRITE.2         JSR     prtch                   ; send char to console via swtbug
B8EC FEB4C4     867: write.3         LDX     LEN
B8EF 09         868:                 DEX
B8F0 FFB4C4     869:                 STX     LEN
B8F3 26E2       870:                 BNE     WRITE.1
B8F5 7EB4B6     871: WRITE.9         JMP     OKRTS
                872: 
                873: 
B8F8 BDB8FD     874: write.chcr.echo jsr     WRITEA.CH.echo  
B8FB 860D       875: write.cr.echo   ldaa    #13
B8FD 7DB5C9     876: WRITEA.CH.echo  tst     echoflag                ; write char only if echo set and expand tabs. 
B900 2609       877:                 bne     writea.ch1              ; this is called from ReadInputBuf
B902 39         878:                 rts
B903 810C       879: WRITEA.CH       cmpa    #12                     ; ^L -> do not print
B905 273E       880:                 beq     WRITEA.CH4




ASM/6800 1.4A0: B907                    
08/16/82 00:00:00; Page 18; Form 1      
IOSWTPC6800.ASM
B907 8107       881:                 cmpa    #7                      ; ^G -> do not print
B909 273A       882:                 beq     WRITEA.CH4
B90B 847F       883: writea.ch1      andA    #$7f            
B90D 810D       884:                 CMPA    #13
B90F 2607       885:                 BNE     WRITEA.CH2              ; SEND A <LF> AFTER EACH <CR>
B911 BDB627     886:                 JSR     prtch
B914 860A       887:                 LDAA    #10
B916 202A       888:                 bra     WRITEA.CH3      
B918 8109       889: WRITEA.CH2      cmpa    #9                      ; check for <TAB> (char 9 dec)
B91A 2619       890:                 bne     WRITEA.CH2b
B91C 7DB5CD     891:                 tst     expandtabflag           ; tabs should be expanded to spaces?
B91F 2718       892:                 beq     WRITEA.CH2c             ; br if not to print tab as ^I
B921 F6B5CA     893:                 ldab    ncol                    ; tab converted to 1-8 spaces depending on ncol
B924 C407       894:                 andb    #7
B926 8608       895:                 ldaa    #8
B928 10         896:                 sba
B929 16         897:                 tab                             ; b=spaces that replaces tab=8-ncol
B92A 37         898: WRITEA.CH2a     pshb
B92B 8620       899:                 ldaa    #32
B92D BDB627     900:                 jsr     prtch
B930 33         901:                 pulb
B931 5A         902:                 decb
B932 26F6       903:                 bne     WRITEA.CH2a
B934 39         904:                 rts
B935 8120       905: WRITEA.CH2b     cmpa    #32                     ; if ch < 32, print it as control char "^ch"
B937 2409       906:                 bcC     WRITEA.CH3              ; BR IF A-REG >= 32
B939 36         907: WRITEA.CH2c     psha
B93A 865E       908:                 ldaa    #'^
B93C BDB627     909:                 JSR     prtch
B93F 32         910:                 pula
B940 8B40       911:                 adda    #'@
B942 BDB627     912: WRITEA.CH3      jsr     prtch
B945 39         913: WRITEA.CH4      RTS
                914:                 
                915: ; DEVICE CONTROL BLOCK FOR SIMH IO VIRTUAL PORT
                916: 
B946 504F5254   917: dcbname.port    fcc     'PORT:'
B94B 00         918:                 fcb     0
                919: 
B94C 01         920: DCB.PORT        FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
B94D 0000       921:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
B94F B946       922:                 FDB     dcbname.port            ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
B951 BF76       923:                 FDB     CLOCKDCB                ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
B953 B955       924:                 FDB     PORTDRIVER              ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
                925: 
                926: ; DEVICE DRIVER FOR IO PORT (for simh PTR and PTP)
                927: 
B955 B991       928: PORTDRIVER      FDB     OPEN.PORT       ; DRIVER:OPEN   OPEN FILE
B957 B999       929:                 FDB     CLOSE.PORT      ; DRIVER:CLOSE  CLOSE FILE
B959 B9FE       930:                 FDB     READA.PORT      ; DRIVER:READA  READ ASCII
B95B BAAA       931:                 FDB     WRITEA.PORT     ; DRIVER:WRITEA WRITE ASCII
B95D BA05       932:                 FDB     READB.PORT      ; DRIVER:READB  READ BINARY
B95F BAB4       933:                 FDB     WRITEB.PORT     ; DRIVER:WRITEB WRITE BINARY
B961 B991       934:                 FDB     OPEN.PORT       ; DRIVER:CREATE CREATE FILE
B963 B4B8       935:                 FDB     ILLDEVICEOP     ; DRIVER:RENAME RENAME FILE




ASM/6800 1.4A0: B965                    
08/16/82 00:00:00; Page 19; Form 1      
IOSWTPC6800.ASM
B965 B4B8       936:                 FDB     ILLDEVICEOP     ; DRIVER:DELETE DELETE FILE
B967 B971       937:                 FDB     control.port    ; DRIVER:CONTROL        DO CONTROL OPERATION
B969 B97B       938:                 FDB     status.port     ; DRIVER:STATUS READ DEVICE (DRIVER) STATUS
B96B B4B6       939:                 FDB     OKRTS           ; DRIVER:RESET  RESET DRIVER (ON BOOT)
B96D B4B8       940:                 FDB     ILLDEVICEOP     ; DRIVER:STARTIO        power-fail restart--dream on!
                941: 
B96F FF         942: PORTMODE        FCB     $FF             ; =1 -> READING FROM PTR, =2 -> READING FROM PTP
B970 0001       943: ch              rmb     1               ; char read/write
                944: 
B971 FECE07     945: control.port    ldx     sdos+sdos.ioblockptr
B974 E603       946:                 ldab    scblk.params+1,x
B976 C11D       947:                 cmpb    #cc.activationck
B978 7EB4B6     948:                 jmp     okrts
                949: 
B97B FECE07     950: status.port     ldx     SDOS+SDOS.IOBLOCKPTR
B97E E603       951:                 ldab    scblk.params+1,x        ; get sc status opcode
B980 C104       952:                 cmpb    #sc.gettype
B982 2604       953:                 bne     stpo1
B984 8602       954:                 ldaa    #DVTYP.STAPE
B986 2002       955:                 bra     stpo2
B988 8600       956: stpo1           ldaa    #0                      ; any other request returns 0
B98A EE0A       957: stpo2           LDX     scblk.rdbuf,x           ; return 1 byte status
B98C A700       958:                 staa    0,X                     ; STORE IN RDBUF
B98E 7EB4B6     959:                 JMP     OKRTS 
                960: 
                961: 
B991 8600       962: OPEN.PORT       LDAA    #0
B993 B7B96F     963:                 STAA    PORTMODE        ; =0 -> ready for read/write
B996 7EB4B6     964:                 JMP     OKRTS
                965: 
B999 B6B96F     966: CLOSE.PORT      ldaa    portmode
B99C 2603       967:                 bne     cl1
B99E 7EB4B6     968:                 jmp     okrts           ; just close after open
B9A1 8101       969: cl1             cmpa    #1              
B9A3 260B       970:                 bne     cl2
                971:                                         ; close ptr
B9A5 BDB61B     972:                 jsr     RDOFF           ; PTR off (^S)
B9A8 86FF       973:                 ldaa    #$ff            ; set mode as closed
B9AA B7B96F     974:                 staa    portmode
B9AD 7EB4B6     975:                 JMP     OKRTS
  B9B0          976: cl2                                     
B9B0 8102       977:                 cmpa    #2
B9B2 260E       978:                 bne     cl3
                979:                                         ; close ptp
B9B4 BDB623     980:                 jsr     PNCHOFF         ; PTR off (^T)
B9B7 86FF       981:                 ldaa    #$ff            ; set mode as closed
B9B9 B7B96F     982:                 staa    portmode
B9BC 7EB4B6     983:                 JMP     OKRTS
                984: 
B9BF 7EB4B6     985:                 JMP     OKRTS
B9C2 7EB4B8     986: cl3             JMP     ILLDEVICEOP     
                987: 
B9C5 CE0032     988: delay1k         ldx     #50             ; **troff
B9C8 09         989: delay1kb        dex
B9C9 26FD       990:                 bne     delay1kb




ASM/6800 1.4A0: B9CB                    
08/16/82 00:00:00; Page 20; Form 1      
IOSWTPC6800.ASM
B9CB 39         991:                 rts                     ; **tron
                992: 
B9CC BDB9C5     993: innyble         jsr     delay1k         ; RECEIVE A BYTE FROM PTR AS TWO ASCII NYBLLES TO FORM A BYTE
B9CF BDB651     994:                 jsr     inch            ; EXAMPLE: RECIVE CHARS "3A" -> RECV BYTE = $3A
B9D2 8130       995:                 cmpa    #'0             ; .*echo inch:a
B9D4 2406       996:                 BCC     innyb1          ; BR IF A >= '0'
B9D6 811A       997:                 cmpa    #26
B9D8 26F2       998:                 bne     innyble         ; invalid char -> read next 
B9DA 0D         999:                 sec                     ; RECEIVED ^Z
B9DB 39        1000:                 rts                     ; return carry set -> eof
B9DC 8030      1001: innyb1          suba    #'0
B9DE 810A      1002:                 cmpa    #10
B9E0 2402      1003:                 bcc     innyb4          ; br if a >= 10
B9E2 0C        1004:                 clc
B9E3 39        1005:                 rts                     ; return nyble 0..9
B9E4 8007      1006: innyb4          suba    #7
B9E6 8110      1007:                 cmpa    #16
B9E8 24E2      1008:                 bcc     innyble         ; br if a >= 16 -> invalid nyble -> read next
B9EA 0C        1009:                 clc
B9EB 39        1010:                 rts
               1011: 
B9EC BDB9C5    1012: INBYTE          jsr     delay1k         ; RECEIVE AN ASCII CHAR FROM PTR 
B9EF BDB651    1013:                 jsr     inch            
B9F2 8100      1014:                 CMPA    #0              ; RECV $00 CHAR -> END OF FILE
B9F4 2706      1015:                 BEQ     INBYTEEOF
B9F6 811A      1016:                 CMPA    #26             ; RECV ^Z -> END OF FILE
B9F8 2702      1017:                 BEQ     INBYTEEOF
B9FA 0C        1018:                 CLC
B9FB 39        1019:                 RTS
B9FC 0D        1020: INBYTEEOF       SEC                     ; SET CARRY TO SIGNAL END OF FILE TO CALLER
B9FD 39        1021:                 RTS
               1022: 
               1023: 
B9FE 8601      1024: READA.PORT      LDAa    #1
BA00 B7BA47    1025:                 STaA    APORT.MODE+1
BA03 2003      1026:                 BRA     READ.PORT
BA05 7FBA47    1027: READB.PORT      CLR     APORT.MODE+1
BA08 BDB707    1028: READ.PORT       jsr     getreadparams   ; get syscall params
BA0B CE0000    1029:                 ldx     #0
BA0E BDB724    1030:                 jsr     setrplen        ; set reply len size
BA11 B6B96F    1031:                 LDAA    PORTMODE
BA14 2617      1032:                 BNE     RP1
BA16 8601      1033:                 LDAA    #1              ; start reading from ptr
BA18 B7B96F    1034:                 STAA    PORTMODE        ; 
BA1B 7FB5CE    1035:                 clr     crflag
BA1E BDB617    1036:                 jsr     RDON            ; ACTIVATE PTR on (^Q)
BA21 B6BA47    1037:                 LDAA    APORT.MODE+1    ; GET PORT READA/READB MODE
BA24 260E      1038:                 BNE     rp1start        ; BR IF READA
BA26 8681      1039:                 LDAA    #129            ; ACTIVATE PTR bin mode (129)
BA28 BDB627    1040:                 JSR     PRTCH   
BA2B 2007      1041:                 bra     rp1start
BA2D 8101      1042: rp1             cmpa    #1
BA2F 2703      1043:                 beq     rp1start        ; br read port input
BA31 7EB4B8    1044:                 jmp     ILLDEVICEOP     
BA34 CE0000    1045: rp1start        ldx     #0




ASM/6800 1.4A0: BA37                    
08/16/82 00:00:00; Page 21; Form 1      
IOSWTPC6800.ASM
BA37 FFB4C8    1046:                 stx     rplen
BA3A FEB4C4    1047: rpin            ldx     len
BA3D 2603      1048:                 bne     rp1a
BA3F 7EB4B6    1049:                 jmp     okrts           ; input buffer full -> terminate read
BA42 09        1050: rp1a            dex
BA43 FFB4C4    1051:                 stx     len
BA46 8600      1052: APORT.MODE      LDAA    #0
BA48 272F      1053:                 BEQ     READBPORT
BA4A BDB9EC    1054: READAPORT       JSR     INBYTE  
BA4D 2556      1055:                 bcs     rp1eof          ; br if eof
               1056:                 ; now handle the end of line: DOS <CR><LF>, Unix <LF>, Mac/SDOS <CR>
BA4F 810D      1057:                 cmpa    #13
BA51 2607      1058:                 bne     cr1             ; if <CR> -> set crflag
BA53 C601      1059:                 ldab    #1
BA55 F7B5CE    1060:                 stab    crflag
BA58 2012      1061:                 bra     cr0
BA5A 810A      1062: cr1             cmpa    #10             ; if <LF> after a <CR> -> ignore <LF>
BA5C 2609      1063:                 bne     cr2             ; if <LF> NOT after a <CR> -> convert to <CR>
BA5E 7DB5CE    1064:                 tst     crflag
BA61 26E7      1065:                 bne     READAPORT       
BA63 860D      1066:                 ldaa    #13
BA65 2005      1067:                 bra     cr0
BA67 7FB5CE    1068: cr2             clr     crflag          ; not <cr>/<l> -> clear cr flag 
BA6A 2024      1069:                 bra     SAVEREADPORTCH  ; and br to store char
BA6C 7DB4C3    1070: cr0             tst     lmode
BA6F 271F      1071:                 beq     SAVEREADPORTCH  ; if not line mode br to store char
BA71 7FB4C4    1072:                 clr     len             ; recv <cR> in line more -> set len to zero so reada is terminated
BA74 7FB4C5    1073:                 clr     len+1
BA77 2017      1074:                 BRA     SAVEREADPORTCH
BA79 BDB9CC    1075: READBPORT       jsr     innyble
BA7C 2527      1076:                 bcs     rp1eof          ; br if eof
BA7E 48        1077:                 asla
BA7F 48        1078:                 asla
BA80 48        1079:                 asla
BA81 48        1080:                 asla
BA82 B7B970    1081:                 staa    ch              ; save hi nyble
BA85 BDB9CC    1082:                 jsr     innyble
BA88 251B      1083:                 bcs     rp1eof          ; br if eof
BA8A BBB970    1084:                 adda    ch
BA8D B7B970    1085:                 staa    ch              ; binary char composed
BA90 FEB4C6    1086: SAVEREADPORTCH  ldx     pdata           ; input buf addr
BA93 A700      1087:                 staa    0,x             ; store into input buf
BA95 08        1088:                 inx                     ; .*echo inbyte:a
BA96 FFB4C6    1089:                 stx     pdata
BA99 FEB4C8    1090:                 ldx     rplen
BA9C 08        1091:                 inx
BA9D FFB4C8    1092:                 stx     rplen
BAA0 BDB724    1093:                 jsr     setrplen        ; set reply len size = num of bytes read
BAA3 2095      1094:                 bra     rpin
               1095: 
BAA5 BDCE2D    1096: rp1eof          jsr     sdos+sdos.error ; .*echo eof
BAA8 03E9      1097:                 fdb     err.eofhit      ; return from read signaling eof CONDITION
               1098: 
BAAA 8601      1099: WRITEA.PORT     LDAa    #1
BAAC B7BA47    1100:                 STaA    APORT.MODE+1




ASM/6800 1.4A0: BAAF                    
08/16/82 00:00:00; Page 22; Form 1      
IOSWTPC6800.ASM
BAAF B7B5CD    1101:                 staa    expandtabflag   ; signal tabs should be expanded to spaces
BAB2 2003      1102:                 BRA     WRITE.PORT
BAB4 7FBA47    1103: WRITEB.PORT     CLR     APORT.MODE+1
BAB7 BDB8AE    1104: WRITE.PORT      JSR     GETWRITEPARAMS 
BABA B6B96F    1105:                 LDAA    PORTMODE
BABD 2625      1106:                 BNE     WP1
BABF 8602      1107:                 LDAA    #2              ; start WRITING AT ptP
BAC1 B7B96F    1108:                 STAA    PORTMODE        ; 
BAC4 BDB61F    1109:                 jsr     PNCHON          ; ACTIVATE PTP on (^R)
BAC7 8682      1110:                 ldaa    #130            ; ACTIVATE PTP ascii (130)
BAC9 F6BA47    1111:                 LDAb    APORT.MODE+1    ; GET PORT WRITEA/WRITEB MODE
BACC 2611      1112:                 BNE     Wp0             ; BR IF writeA
BACE 8683      1113:                 LDAA    #131            ; ACTIVATE PTP bin mode (131)
BAD0 BDB627    1114:                 JSR     PRTCH   
BAD3 8620      1115:                 LDAA    #32
BAD5 BDB627    1116:                 JSR     PRTCH           ; SEND A SPACEs TO SYNC
BAD8 8620      1117:                 LDAA    #32
BADA BDB627    1118:                 JSR     PRTCH           
BADD 8620      1119:                 LDAA    #32
BADF BDB627    1120: wp0             JSR     PRTCH           
BAE2 2007      1121:                 bra     Wp1start
BAE4 8102      1122: Wp1             cmpa    #2
BAE6 2703      1123:                 beq     Wp1start        ; br read port input
BAE8 7EB4B8    1124:                 jmp     ILLDEVICEOP     
  BAEB         1125: Wp1start        
BAEB FEB4C4    1126: WpOUT           ldx     len
BAEE 2603      1127:                 bne     Wp1a
BAF0 7EB4B6    1128:                 jmp     okrts           ; input buffer full -> terminate read
BAF3 09        1129: Wp1a            dex
BAF4 FFB4C4    1130:                 stx     len
BAF7 FEB4C6    1131:                 LDX     PDATA           ; get next char to write.
BAFA A600      1132:                 LDAA    0,X
BAFC 08        1133:                 INX                     ; .*echo wrtch:a
BAFD FFB4C6    1134:                 STX     PDATA
BB00 F6BA47    1135:                 LDAB    APORT.MODE+1
BB03 2705      1136:                 BEQ     WRITEBPORT
BB05 BDB903    1137: WRITEAPORT      JSR     WRITEA.CH       ; convert char <CR> -> <CR><LF>, cTRol char -> ^X
BB08 20E1      1138:                 BRA     WPOUT
BB0A B7B970    1139: WRITEBPORT      STAA    CH
BB0D 44        1140:                 LSRA
BB0E 44        1141:                 LSRA
BB0F 44        1142:                 LSRA
BB10 44        1143:                 LSRA
BB11 BDBB1E    1144:                 JSR     OUTNYBLE
BB14 B6B970    1145:                 LDAA    CH
BB17 840F      1146:                 ANDa    #$0F
BB19 BDBB1E    1147:                 JSR     OUTNYBLE
BB1C 20CD      1148:                 BRA     WPOUT
               1149: 
BB1E 8B30      1150: OUTNYBLE        ADDA    #'0
BB20 813A      1151:                 CMPA    #'9+1
BB22 2502      1152:                 BCS     OUTNYBLE1       ; BR IF A<'9'+1
BB24 8B07      1153:                 ADDA    #7              ; 7='A'-'0'-10
BB26 7EB627    1154: OUTNYBLE1       jMP     PRTCH
               1155: 




ASM/6800 1.4A0: BB26                    
08/16/82 00:00:00; Page 23; Form 1      
IOSWTPC6800.ASM
               1156: 
               1157: 
               1158: 
               1159: 
               1160: 
               1161: 
               1162: 
               1163: ; DEVICE CONTROL BLOCK FOR MF-68 FLOPPY DISK
               1164: 
  0003         1165: LSN.SIZE        EQU     3       ; # BYTES OCCUPIED BY AN LSN
  0002         1166: LCN.SIZE        EQU     2       ; # BYTES OCCUPIED BY AN LCN
               1167: 
BB29 44303A    1168: dcbname.D0      fcc     'D0:'
BB2C 00        1169:                 fcb     0
  BB2D         1170: DISKDCBS        
BB2D 01        1171: DCB.D0          FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
BB2E 0000      1172:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
BB30 BB29      1173:                 FDB     dcbname.D0              ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
BB32 BB75      1174:                 FDB     dcb.d1                  ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
BB34 BC49      1175:                 FDB     DSKDRIVER               ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
               1176: 
               1177:                                                                 ; DISK GEOMETRY
BB36 0080      1178:                 FDB     128                     ; DSKINFO:NBPS  ; NUMBER OF BYTES PER SECTOR
BB38 0012      1179:                 FDB     18                      ; DSKINFO:NSPT  ; NUMBER OF SECTORS PER TRACK
BB3A 0002      1180:                 FDB     2                       ; DSKINFO:NTPC  ; NUMBER OF TRACKS PER CYLINDER
BB3C 0023      1181:                 FDB     35                      ; DSKINFO:NCYL  ; NUMBER OF CYLINDERS PER DRIVE
               1182: 
               1183:                                                                 ; THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
BB3E 0001      1184:                 RMB     1                       ; DSKINFO:NSPC   NUMBER OF SECTORS PER CLUSTER
BB3F 0002      1185:                 RMB     LCN.SIZE                ; DSKINFO:MINALLOC ALLOCATION MINIMUM FOR NEW FILES
BB41 0002      1186:                 RMB     LCN.SIZE                ; DSKINFO:MIDALLOC ALLOCATION MIN FOR FILE EXTENSION
BB43 0002      1187:                 RMB     2                       ; DSKINFO:MAPALGORITHM CODE TO SELECT LOGICAL TO PHYSICAL SECTO
               1188: 
               1189:                                                                 ; CONTAINS DISK ID FOR MOUNTED DISKS
BB45 0001      1190:                 RMB     1                       ; DSKINFO:LOG2NBPS LOG BASE 2 OF DSKINFO:NBPS
BB46 0002      1191:                 RMB     2                       ; DSKINFO:NBPSM1 = NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
BB48 0003      1192:                 RMB     LSN.SIZE                ; DSKINFO:NLSN   NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
BB4B 0002      1193:                 RMB     LCN.SIZE                ; DSKINFO:NLCN   NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
BB4D 0002      1194:                 RMB     2                       ; DSKINFO:NBPC   NUMBER OF BYTES PER CLUSTER
BB4F 0002      1195:                 RMB     LCN.SIZE                ; DSKINFO:RANDMAP "RANDOM" LCN TO DISTRIBUTE NEW FILES
BB51 0003      1196:                 RMB     LSN.SIZE                ; DSKINFO:MAPLSN LSN OF 1ST SECTOR IN DISK...
               1197: 
               1198:                                                                 ; ALLOCATION MAP CLUSTER
BB54 0002      1199:                 RMB     2                       ; DSKINFO:DIRFCB POINTER TO FCB FOR $DIRECTORY FILE
BB56 0002      1200:                 RMB     2                       ; DSKINFO:MAPFCB POINTER TO FCB FOR $DISKMAP FILE
BB58 0002      1201:                 RMB     2                       ; DSKINFO:SECTORDB POINTER TO RDSI CONTAINING LSN, ADDRESS PARA
BB5A 0003      1202:                 RMB     LSN.SIZE                ; DSKINFO:BADLSN LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SE
BB5D 0000      1203:                 FDB     0                       ; DSKINFO:SEEKERRCNT # SEEK ERRORS SINCE MOUNT
BB5F 0000      1204:                 FDB     0                       ; DSKINFO:SEEKERRSTS 16 BITS OF LAST "SEEK" STATUS IN ERROR
BB61 0000      1205:                 FDB     0                       ; DSKINFO:WRITEERRCNT # WRITE ERRORS SINCE MOUNT
BB63 0000      1206:                 FDB     0                       ; DSKINFO:WRITEERRSTS 16 BITS OF LAST "WRITE" STATUS IN ERROR
BB65 0000      1207:                 FDB     0                       ; DSKINFO:READERRCNT # READ ERRORS SINCE MOUNT
BB67 0000      1208:                 FDB     0                       ; DSKINFO:READERRSTS 16 BITS OF LAST "READ" STATUS IN ERROR
BB69 000000    1209:                 FCB     0,0,0                   ; DSKINFO:OPSCOUNT 24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
BB6C 0003      1210:                 RMB     LSN.SIZE                ; DSKINFO:ERRLSN LSN CAUSING ANY SOFT OR HARD ERROR




ASM/6800 1.4A0: BB6F                    
08/16/82 00:00:00; Page 24; Form 1      
IOSWTPC6800.ASM
BB6F 0001      1211:                 RMB     1                       ; DSKINFO:WRITEPROTSTATE 0 --> WRITEABLE
BB70 00        1212:                 FCB     0                       ; FDUNIT         Drive number 
               1213: 
BB71 44313A    1214: dcbname.D1      fcc     'D1:'
BB74 00        1215:                 fcb     0
BB75 01        1216: DCB.D1          FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
BB76 0000      1217:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
BB78 BB71      1218:                 FDB     dcbname.D1              ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
BB7A BBBD      1219:                 FDB     dcb.d2                  ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
BB7C BC49      1220:                 FDB     DSKDRIVER               ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
               1221: 
               1222:                                                                 ; DISK GEOMETRY
BB7E 0080      1223:                 FDB     128                     ; DSKINFO:NBPS  ; NUMBER OF BYTES PER SECTOR
BB80 0012      1224:                 FDB     18                      ; DSKINFO:NSPT  ; NUMBER OF SECTORS PER TRACK
BB82 0002      1225:                 FDB     2                       ; DSKINFO:NTPC  ; NUMBER OF TRACKS PER CYLINDER
BB84 0023      1226:                 FDB     35                      ; DSKINFO:NCYL  ; NUMBER OF CYLINDERS PER DRIVE
               1227: 
               1228:                                                                 ; THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
BB86 0001      1229:                 RMB     1                       ; DSKINFO:NSPC   NUMBER OF SECTORS PER CLUSTER
BB87 0002      1230:                 RMB     LCN.SIZE                ; DSKINFO:MINALLOC ALLOCATION MINIMUM FOR NEW FILES
BB89 0002      1231:                 RMB     LCN.SIZE                ; DSKINFO:MIDALLOC ALLOCATION MIN FOR FILE EXTENSION
BB8B 0002      1232:                 RMB     2                       ; DSKINFO:MAPALGORITHM CODE TO SELECT LOGICAL TO PHYSICAL SECTO
               1233: 
               1234:                                                                 ; CONTAINS DISK ID FOR MOUNTED DISKS
BB8D 0001      1235:                 RMB     1                       ; DSKINFO:LOG2NBPS LOG BASE 2 OF DSKINFO:NBPS
BB8E 0002      1236:                 RMB     2                       ; DSKINFO:NBPSM1 = NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
BB90 0003      1237:                 RMB     LSN.SIZE                ; DSKINFO:NLSN   NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
BB93 0002      1238:                 RMB     LCN.SIZE                ; DSKINFO:NLCN   NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
BB95 0002      1239:                 RMB     2                       ; DSKINFO:NBPC   NUMBER OF BYTES PER CLUSTER
BB97 0002      1240:                 RMB     LCN.SIZE                ; DSKINFO:RANDMAP "RANDOM" LCN TO DISTRIBUTE NEW FILES
BB99 0003      1241:                 RMB     LSN.SIZE                ; DSKINFO:MAPLSN LSN OF 1ST SECTOR IN DISK...
               1242: 
               1243:                                                                 ; ALLOCATION MAP CLUSTER
BB9C 0002      1244:                 RMB     2                       ; DSKINFO:DIRFCB POINTER TO FCB FOR $DIRECTORY FILE
BB9E 0002      1245:                 RMB     2                       ; DSKINFO:MAPFCB POINTER TO FCB FOR $DISKMAP FILE
BBA0 0002      1246:                 RMB     2                       ; DSKINFO:SECTORDB POINTER TO RDSI CONTAINING LSN, ADDRESS PARA
BBA2 0003      1247:                 RMB     LSN.SIZE                ; DSKINFO:BADLSN LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SE
BBA5 0000      1248:                 FDB     0                       ; DSKINFO:SEEKERRCNT # SEEK ERRORS SINCE MOUNT
BBA7 0000      1249:                 FDB     0                       ; DSKINFO:SEEKERRSTS 16 BITS OF LAST "SEEK" STATUS IN ERROR
BBA9 0000      1250:                 FDB     0                       ; DSKINFO:WRITEERRCNT # WRITE ERRORS SINCE MOUNT
BBAB 0000      1251:                 FDB     0                       ; DSKINFO:WRITEERRSTS 16 BITS OF LAST "WRITE" STATUS IN ERROR
BBAD 0000      1252:                 FDB     0                       ; DSKINFO:READERRCNT # READ ERRORS SINCE MOUNT
BBAF 0000      1253:                 FDB     0                       ; DSKINFO:READERRSTS 16 BITS OF LAST "READ" STATUS IN ERROR
BBB1 000000    1254:                 FCB     0,0,0                   ; DSKINFO:OPSCOUNT 24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
BBB4 0003      1255:                 RMB     LSN.SIZE                ; DSKINFO:ERRLSN LSN CAUSING ANY SOFT OR HARD ERROR
BBB7 0001      1256:                 RMB     1                       ; DSKINFO:WRITEPROTSTATE 0 --> WRITEABLE
BBB8 01        1257:                 FCB     1                       ; FDUNIT         Drive number 
               1258: 
BBB9 44323A    1259: dcbname.D2      fcc     'D2:'
BBBC 00        1260:                 fcb     0
BBBD 01        1261: DCB.D2          FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
BBBE 0000      1262:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
BBC0 BBB9      1263:                 FDB     dcbname.D2              ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
BBC2 BC05      1264:                 FDB     dcb.d3                  ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
BBC4 BC49      1265:                 FDB     DSKDRIVER               ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST




ASM/6800 1.4A0: BBC4                    
08/16/82 00:00:00; Page 25; Form 1      
IOSWTPC6800.ASM
               1266: 
               1267:                                                                 ; DISK GEOMETRY
BBC6 0080      1268:                 FDB     128                     ; DSKINFO:NBPS  ; NUMBER OF BYTES PER SECTOR
BBC8 0012      1269:                 FDB     18                      ; DSKINFO:NSPT  ; NUMBER OF SECTORS PER TRACK
BBCA 0002      1270:                 FDB     2                       ; DSKINFO:NTPC  ; NUMBER OF TRACKS PER CYLINDER
BBCC 0023      1271:                 FDB     35                      ; DSKINFO:NCYL  ; NUMBER OF CYLINDERS PER DRIVE
               1272: 
               1273:                                                                 ; THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
BBCE 0001      1274:                 RMB     1                       ; DSKINFO:NSPC   NUMBER OF SECTORS PER CLUSTER
BBCF 0002      1275:                 RMB     LCN.SIZE                ; DSKINFO:MINALLOC ALLOCATION MINIMUM FOR NEW FILES
BBD1 0002      1276:                 RMB     LCN.SIZE                ; DSKINFO:MIDALLOC ALLOCATION MIN FOR FILE EXTENSION
BBD3 0002      1277:                 RMB     2                       ; DSKINFO:MAPALGORITHM CODE TO SELECT LOGICAL TO PHYSICAL SECTO
               1278: 
               1279:                                                                 ; CONTAINS DISK ID FOR MOUNTED DISKS
BBD5 0001      1280:                 RMB     1                       ; DSKINFO:LOG2NBPS LOG BASE 2 OF DSKINFO:NBPS
BBD6 0002      1281:                 RMB     2                       ; DSKINFO:NBPSM1 = NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
BBD8 0003      1282:                 RMB     LSN.SIZE                ; DSKINFO:NLSN   NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
BBDB 0002      1283:                 RMB     LCN.SIZE                ; DSKINFO:NLCN   NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
BBDD 0002      1284:                 RMB     2                       ; DSKINFO:NBPC   NUMBER OF BYTES PER CLUSTER
BBDF 0002      1285:                 RMB     LCN.SIZE                ; DSKINFO:RANDMAP "RANDOM" LCN TO DISTRIBUTE NEW FILES
BBE1 0003      1286:                 RMB     LSN.SIZE                ; DSKINFO:MAPLSN LSN OF 1ST SECTOR IN DISK...
               1287: 
               1288:                                                                 ; ALLOCATION MAP CLUSTER
BBE4 0002      1289:                 RMB     2                       ; DSKINFO:DIRFCB POINTER TO FCB FOR $DIRECTORY FILE
BBE6 0002      1290:                 RMB     2                       ; DSKINFO:MAPFCB POINTER TO FCB FOR $DISKMAP FILE
BBE8 0002      1291:                 RMB     2                       ; DSKINFO:SECTORDB POINTER TO RDSI CONTAINING LSN, ADDRESS PARA
BBEA 0003      1292:                 RMB     LSN.SIZE                ; DSKINFO:BADLSN LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SE
BBED 0000      1293:                 FDB     0                       ; DSKINFO:SEEKERRCNT # SEEK ERRORS SINCE MOUNT
BBEF 0000      1294:                 FDB     0                       ; DSKINFO:SEEKERRSTS 16 BITS OF LAST "SEEK" STATUS IN ERROR
BBF1 0000      1295:                 FDB     0                       ; DSKINFO:WRITEERRCNT # WRITE ERRORS SINCE MOUNT
BBF3 0000      1296:                 FDB     0                       ; DSKINFO:WRITEERRSTS 16 BITS OF LAST "WRITE" STATUS IN ERROR
BBF5 0000      1297:                 FDB     0                       ; DSKINFO:READERRCNT # READ ERRORS SINCE MOUNT
BBF7 0000      1298:                 FDB     0                       ; DSKINFO:READERRSTS 16 BITS OF LAST "READ" STATUS IN ERROR
BBF9 000000    1299:                 FCB     0,0,0                   ; DSKINFO:OPSCOUNT 24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
BBFC 0003      1300:                 RMB     LSN.SIZE                ; DSKINFO:ERRLSN LSN CAUSING ANY SOFT OR HARD ERROR
BBFF 0001      1301:                 RMB     1                       ; DSKINFO:WRITEPROTSTATE 0 --> WRITEABLE
BC00 02        1302:                 FCB     2                       ; FDUNIT         Drive number 
               1303: 
               1304: 
BC01 44333A    1305: dcbname.D3      fcc     'D3:'
BC04 00        1306:                 fcb     0
BC05 01        1307: DCB.D3          FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
BC06 0000      1308:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
BC08 BC01      1309:                 FDB     dcbname.D3              ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
BC0A BE5D      1310:                 FDB     DCB.HD                  ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
BC0C BC49      1311:                 FDB     DSKDRIVER               ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
               1312: 
               1313:                                                                 ; DISK GEOMETRY
BC0E 0080      1314:                 FDB     128                     ; DSKINFO:NBPS  ; NUMBER OF BYTES PER SECTOR
BC10 0012      1315:                 FDB     18                      ; DSKINFO:NSPT  ; NUMBER OF SECTORS PER TRACK
BC12 0002      1316:                 FDB     2                       ; DSKINFO:NTPC  ; NUMBER OF TRACKS PER CYLINDER
BC14 0023      1317:                 FDB     35                      ; DSKINFO:NCYL  ; NUMBER OF CYLINDERS PER DRIVE
               1318: 
               1319:                                                                 ; THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
BC16 0001      1320:                 RMB     1                       ; DSKINFO:NSPC   NUMBER OF SECTORS PER CLUSTER




ASM/6800 1.4A0: BC17                    
08/16/82 00:00:00; Page 26; Form 1      
IOSWTPC6800.ASM
BC17 0002      1321:                 RMB     LCN.SIZE                ; DSKINFO:MINALLOC ALLOCATION MINIMUM FOR NEW FILES
BC19 0002      1322:                 RMB     LCN.SIZE                ; DSKINFO:MIDALLOC ALLOCATION MIN FOR FILE EXTENSION
BC1B 0002      1323:                 RMB     2                       ; DSKINFO:MAPALGORITHM CODE TO SELECT LOGICAL TO PHYSICAL SECTO
               1324: 
               1325:                                                                 ; CONTAINS DISK ID FOR MOUNTED DISKS
BC1D 0001      1326:                 RMB     1                       ; DSKINFO:LOG2NBPS LOG BASE 2 OF DSKINFO:NBPS
BC1E 0002      1327:                 RMB     2                       ; DSKINFO:NBPSM1 = NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
BC20 0003      1328:                 RMB     LSN.SIZE                ; DSKINFO:NLSN   NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
BC23 0002      1329:                 RMB     LCN.SIZE                ; DSKINFO:NLCN   NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
BC25 0002      1330:                 RMB     2                       ; DSKINFO:NBPC   NUMBER OF BYTES PER CLUSTER
BC27 0002      1331:                 RMB     LCN.SIZE                ; DSKINFO:RANDMAP "RANDOM" LCN TO DISTRIBUTE NEW FILES
BC29 0003      1332:                 RMB     LSN.SIZE                ; DSKINFO:MAPLSN LSN OF 1ST SECTOR IN DISK...
               1333: 
               1334:                                                                 ; ALLOCATION MAP CLUSTER
BC2C 0002      1335:                 RMB     2                       ; DSKINFO:DIRFCB POINTER TO FCB FOR $DIRECTORY FILE
BC2E 0002      1336:                 RMB     2                       ; DSKINFO:MAPFCB POINTER TO FCB FOR $DISKMAP FILE
BC30 0002      1337:                 RMB     2                       ; DSKINFO:SECTORDB POINTER TO RDSI CONTAINING LSN, ADDRESS PARA
BC32 0003      1338:                 RMB     LSN.SIZE                ; DSKINFO:BADLSN LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SE
BC35 0000      1339:                 FDB     0                       ; DSKINFO:SEEKERRCNT # SEEK ERRORS SINCE MOUNT
BC37 0000      1340:                 FDB     0                       ; DSKINFO:SEEKERRSTS 16 BITS OF LAST "SEEK" STATUS IN ERROR
BC39 0000      1341:                 FDB     0                       ; DSKINFO:WRITEERRCNT # WRITE ERRORS SINCE MOUNT
BC3B 0000      1342:                 FDB     0                       ; DSKINFO:WRITEERRSTS 16 BITS OF LAST "WRITE" STATUS IN ERROR
BC3D 0000      1343:                 FDB     0                       ; DSKINFO:READERRCNT # READ ERRORS SINCE MOUNT
BC3F 0000      1344:                 FDB     0                       ; DSKINFO:READERRSTS 16 BITS OF LAST "READ" STATUS IN ERROR
BC41 000000    1345:                 FCB     0,0,0                   ; DSKINFO:OPSCOUNT 24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
BC44 0003      1346:                 RMB     LSN.SIZE                ; DSKINFO:ERRLSN LSN CAUSING ANY SOFT OR HARD ERROR
BC47 0001      1347:                 RMB     1                       ; DSKINFO:WRITEPROTSTATE 0 --> WRITEABLE
BC48 03        1348:                 FCB     3                       ; FDUNIT         Drive number 
               1349: 
               1350:                 
               1351: ; DEVICE DRIVER BLOCK FOR FLOPPY DISK
               1352: 
BC49 BD41      1353: DSKDRIVER       FDB     DSKRESTORE              ; DRIVER:DISKRESET RESET THIS DISK DRIVER
BC4B BCFF      1354:                 FDB     DSKREAD                 ; DRIVER:DISKREAD INITIATE A DISK SECTOR READ
BC4D BD0C      1355:                 FDB     DSKWRITE                ; DRIVER:DISKWRITE INITIATE A DISK SECTOR WRITE
BC4F BD41      1356:                 FDB     DSKWAITDONE             ; DRIVER:DISKWAIT WAIT FOR DISK I/O COMPLETE
BC51 B4B8      1357:                 FDB     ILLDEVICEOP             ; DRIVER:DISKSTATUS STATUS handled completely by SDOS1.1
BC53 BC5B      1358:                 FDB     DSKCONTROL              ; DRIVER:DISKCONTROL PERFORM DISK-SPECIFIC CONTROL OPERATION
BC55 B4B8      1359:                 FDB     ILLDEVICEOP             ; DRIVER:DISKWRITEPROTQ DETERMINE IF DISK IS WRITE PROTECTED
BC57 B4B8      1360:                 FDB     ILLDEVICEOP             ; DRIVER:DISKVERIFY INITIATE A DISK SECTOR VERIFY
BC59 B4B8      1361:                 FDB     ILLDEVICEOP             ; DRIVER:DISKLSNTOPSN CONVERT LSN TO PHYSICAL CYLINDER, TRACK A
               1362: 
               1363: ; FLOPPY DISK LOW LEVEL I/O
               1364: 
BC5B 8111      1365: DSKCONTROL      CMPA    #CC.DISMOUNTDISK        ; SINCE SDOS PASSES THIS THRU
BC5D 2703      1366:                 BEQ     DSKDISMOUNT             ; B/ ITS A DISMOUNT!
BC5F 7EB4B8    1367:                 JMP     ILLDEVICEOP             ; NOT A LEGAL CONTROL CALL
BC62 5F        1368: DSKDISMOUNT     CLRB                            ; CLEAR THE CARRY
BC63 39        1369:                 RTS
               1370:                 
               1371: ;
               1372: ;       Take RDSI:LSN and split it up into RDSI:CYLINDER,
               1373: ;       RDSI:TRACK, and RDSI:SECTOR, 
               1374: ;       mapalg NOT IMPLEMENTED 
               1375: ;




ASM/6800 1.4A0: BC64                    
08/16/82 00:00:00; Page 27; Form 1      
IOSWTPC6800.ASM
BC64 FEBD43    1376: FDTEARLSN       LDX     RDSIPOINTER
BC67 6F0E      1377:                 CLR     RDSI.SECTOR,X           ; CLEAR MSB OF SECTOR, TRACK AND CYL
BC69 6F10      1378:                 CLR     RDSI.TRACK,X
BC6B 6F11      1379:                 CLR     RDSI.TRACK+1,X
BC6D 6F12      1380:                 CLR     RDSI.CYLINDER,X
               1381: 
               1382: ;        ASSERT RDSI:LSN ALREADY CHECKED FOR LEGAL BY SDOS
               1383: ; 
               1384: ;        The formulae for computing the DCB parameters as a function
               1385: ;        of number of sides, single density (SD) or double density (DD)
               1386: ;        first track, SD or DD on other than first track, and number of
               1387: ;        tracks on the drive are:
               1388: ; 
               1389: ;                SS/SD   NBPS = 128 bytes per sector
               1390: ;                        NSPT = 18  sectors per track
               1391: ;                        NTPC = 1 (See note 1) tracks per cylinder
               1392: ;                        NCYL = #sides * #tracks (See note 2)
               1393: ; 
               1394: ;                note 1: This is a lie to SDOS in the case of a double
               1395: ;                        sided disk, but it makes the NLSN (NSPT*NTPC*NCYL)
               1396: ;                        work out to be correct.
               1397: ;                note 2: #tracks is the number of tracks on the disk, including
               1398: ;                        double tracks on a double track disk.
               1399: ; 
               1400: ;      +-------------------------------------------+
               1401: ;      |        5" DRIVE       |   SINGLE SIDED    |
               1402: ;      | # TRACKS ON DRIVE --> | 35   40   70   80 |
               1403: ;      |         NSPT NBPS NTPC|NCYL NCYL NCYL NCYL|
               1404: ;      |-----------------------+-------------------+
               1405: ;      |   SS/SD  18   128    1| 35   40   70   80 |
               1406: ;      |   DS/SD              2|                   |
               1407: ;      +-------------------------------------------+
               1408: ; 
               1409: ;       To compute the sector, track and cylinder, use this formula:
               1410: ;                LSN/18 --> REM --> SECTOR#
               1411: ;                       --> /2  --> REM -> TRACK (HEAD)
               1412: ;                               --> CYLINDER
               1413: ;       where REM is the remainder from the previous step. 
               1414: 
BC6F A603      1415:                 LDAA    RDSI.LSN+1,X            ; SO DISCARD HIGHER LSN BYTE
BC71 E604      1416:                 LDAB    RDSI.LSN+2,X            
BC73 01        1417:                 NOP                             ; .*echo Read_LSN:D
BC74 BDBC80    1418:                 JSR     DIV18                   ; GO DO THE FAST DIVIDE BY NSPT
BC77 4C        1419:                 INCA                            ; SECTORS ON PHYSICAL DISK ARE NUMBERED 1..18
BC78 A70F      1420:                 STAA    RDSI.SECTOR+1,X         ; A CONTAINS SECTOR = (LSN MOD 18)+1
BC7A 54        1421:                 LSRB                            ; B CONTAINS CYL = INT(LSN/18) / 2, bit0 -> carry
BC7B E713      1422:                 STAB    RDSI.CYLINDER+1,X       
BC7D 6911      1423:                 ROL     RDSI.TRACK+1,X          ; TRACK (HEAD) = INT(LSN/18) MOD 2, head<-carry 0/1
BC7F 39        1424:                 RTS
               1425: ;
               1426: ;       Fancy divide algorithm takes (A,B) and divides by NSPT (18).
               1427: ;       If we have 35 track, double side,
               1428: ;       18 sectors/track this is 35*2*18 LSNs =0..1259, with a max
               1429: ;       quotient of 69.
               1430: ;




ASM/6800 1.4A0: BC7F                    
08/16/82 00:00:00; Page 28; Form 1      
IOSWTPC6800.ASM
               1431: ;       Divide (A,B) by 18 (NSPT), quotient in B, remainder in A
               1432: ;
BC80 58        1433: DIV18           ASLB
BC81 49        1434:                 ROLA
BC82 8BEE      1435:                 ADDA    #-18                    ; ADD -NSPT TO GENERATE QUOTIENT BIT
BC84 2502      1436:                 BCS     DIV18.1                 ; B/ Q BIT IS ONE
BC86 80EE      1437:                 SUBA    #-18                    ; RESTORE BY ADDING DIVISOR; LEAVE CARRY=0
BC88 59        1438: DIV18.1         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
BC89 49        1439:                 ROLA
BC8A 8BEE      1440:                 ADDA    #-18
BC8C 2502      1441:                 BCS     DIV18.2
BC8E 80EE      1442:                 SUBA    #-18
BC90 59        1443: DIV18.2         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
BC91 49        1444:                 ROLA
BC92 8BEE      1445:                 ADDA    #-18
BC94 2502      1446:                 BCS     DIV18.3
BC96 80EE      1447:                 SUBA    #-18
BC98 59        1448: DIV18.3         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
BC99 49        1449:                 ROLA
BC9A 8BEE      1450:                 ADDA    #-18
BC9C 2502      1451:                 BCS     DIV18.4
BC9E 80EE      1452:                 SUBA    #-18
BCA0 59        1453: DIV18.4         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
BCA1 49        1454:                 ROLA
BCA2 8BEE      1455:                 ADDA    #-18
BCA4 2502      1456:                 BCS     DIV18.5
BCA6 80EE      1457:                 SUBA    #-18
BCA8 59        1458: DIV18.5         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
BCA9 49        1459:                 ROLA
BCAA 8BEE      1460:                 ADDA    #-18
BCAC 2502      1461:                 BCS     DIV18.6
BCAE 80EE      1462:                 SUBA    #-18
BCB0 59        1463: DIV18.6         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
BCB1 49        1464:                 ROLA
BCB2 8BEE      1465:                 ADDA    #-18
BCB4 2502      1466:                 BCS     DIV18.7
BCB6 80EE      1467:                 SUBA    #-18
BCB8 59        1468: DIV18.7         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
BCB9 49        1469:                 ROLA
BCBA 8BEE      1470:                 ADDA    #-18
BCBC 2502      1471:                 BCS     DIV18.8
BCBE 80EE      1472:                 SUBA    #-18
BCC0 59        1473: DIV18.8         ROLB
BCC1 39        1474:                 RTS
               1475: 
BCC2 6C3E      1476: DSKOPSCOUNT     INC     DSKINFO.OPSCOUNT+2,X    ; COUNT # OPERATIONS ISSUED TO disk
BCC4 2606      1477:                 BNE     DSKOPSCOUNT1
BCC6 6C3D      1478:                 INC     DSKINFO.OPSCOUNT+1,X
BCC8 2602      1479:                 BNE     DSKOPSCOUNT1
BCCA 6C3C      1480:                 INC     DSKINFO.OPSCOUNT,X
BCCC 39        1481: DSKOPSCOUNT1    rts
               1482: 
               1483: ; PREPARE A SINGLE SECTOR TRANSFER
               1484: 
BCCD DE06      1485: DSKPREP         LDX     DCBPOINTER              ; GET DCB POINTER




ASM/6800 1.4A0: BCCF                    
08/16/82 00:00:00; Page 29; Form 1      
IOSWTPC6800.ASM
BCCF BDBCC2    1486:                 jsr     DSKOPSCOUNT             ; incr count of I/O operations done
BCD2 A643      1487:                 LDAA    dcb.fdunit,X            ; get this dcb drive number
BCD4 B7BD45    1488:                 STAA    DRV
BCD7 6F01      1489:                 CLR     DCB.LASTERROR,X         ; CLEAR ANY ERROR
BCD9 6F02      1490:                 CLR     DCB.LASTERROR+1,X
BCDB EE2B      1491:                 LDX     DSKINFO.SECTORDB,X      ; GET RDSI POINTER
BCDD FFBD43    1492:                 STX     RDSIPOINTER             ; SAVE IT
BCE0 BDBC64    1493:                 JSR     FDTEARLSN               ; CONVERT RDSI:LSR -> RDSI:TRACK/CYLINDER/SECTOR
BCE3 A605      1494:                 LDAA    RDSI.SECTORBASE,X       ; POINTER TO ACTUAL SECTOR CONTENTS
BCE5 E606      1495:                 LDAB    RDSI.SECTORBASE+1,X
BCE7 B7BD49    1496:                 STAA    DDATA
BCEA F7BD4A    1497:                 STAB    DDATA+1
BCED A613      1498:                 LDAA    RDSI.CYLINDER+1,X       
BCEF B7BD46    1499:                 STAA    TRK
BCF2 A60F      1500:                 LDAA    RDSI.SECTOR+1,X 
BCF4 B7BD47    1501:                 STAA    SECT
BCF7 A611      1502:                 LDAA    RDSI.TRACK+1,X  
BCF9 B7BD48    1503:                 STAA    SIDE
BCFC 6F0C      1504:                 CLR     RDSI.STATE,X            ; RESET SECTOR STATE TO "IDLE"
BCFE 39        1505:                 RTS
               1506:                 
               1507: ; READ/WRITE -- DO SINGLE SECTOR TRANSFER
               1508: 
BCFF BDBCCD    1509: DSKREAD         JSR     DSKPREP
BD02 BDBD64    1510:                 JSR     RDSEC                   ; DO I/O OPERATION WITH ACTIVE WAIT: NO INTERRUPTS :-(
BD05 2612      1511:                 BNE     DSKERR
BD07 FEBD49    1512:                 LDX     DDATA                   
BD0A 0C        1513:                 CLC                             ; .*mX-80:RdSec
BD0B 39        1514:                 RTS
               1515: 
BD0C BDBCCD    1516: DSKWRITE        JSR     DSKPREP
BD0F BDBD73    1517:                 JSR     WRSEC                   ; DO I/O OPERATION WITH ACTIVE WAIT: NO INTERRUPTS :-(
BD12 2605      1518:                 BNE     DSKERR
BD14 FEBD49    1519:                 LDX     DDATA                   
BD17 0C        1520:                 CLC                             ; .*mX-80:WrSec
BD18 39        1521:                 RTS
               1522:                 
BD19 CE0417    1523: DSKERR          LDX     #ERR.DISKSEEK
BD1C 8510      1524:                 BITA    #$10
BD1E 2611      1525:                 bne     dskerr1                 ; seek error reported by controler status reg
BD20 CE0416    1526:                 LDX     #ERR.DISKWRITE
BD23 8520      1527:                 BITA    #$20                    
BD25 260A      1528:                 bne     dskerr1                 ; WRITE FAULT reported by controler status reg
BD27 CE0418    1529:                 LDX     #ERR.DSKWRTPROT
BD2A 8540      1530:                 BITA    #$40                    
BD2C 2603      1531:                 bne     dskerr1                 ; WRITE PROTECT reported by controler status reg
BD2E CE0415    1532:                 LDX     #ERR.DISKREAD           ; ELSE ASUME LOST DATA OR CRC ERROR HAS BEEN reported by contro
BD31 DF00      1533: DSKERR1         STX     $00                     ; TXAB X=SDOS ERROR CODE (16 BITS) -> (A,B)
BD33 9600      1534:                 LDAA    $00
BD35 D601      1535:                 LDAB    $01             
BD37 DE06      1536:                 LDX     DCBPOINTER              ; GET DCB POINTER
BD39 A701      1537:                 STAA    DCB.LASTERROR,X         ; SAVE THE ERROR
BD3B E702      1538:                 STAB    DCB.LASTERROR+1,X
BD3D DE00      1539:                 LDX     $00                     ; GET BACK ERROR IN X-REG
BD3F 0D        1540:                 SEC




ASM/6800 1.4A0: BD40                    
08/16/82 00:00:00; Page 30; Form 1      
IOSWTPC6800.ASM
BD40 39        1541:                 RTS     
               1542:         
  BD41         1543: DSKRESTORE
  BD41         1544: DSKWAITDONE
BD41 5F        1545:                 CLRB                           ; CLEAR THE CARRY
BD42 39        1546:                 RTS
               1547: 
               1548: 
BD43 0002      1549: RDSIPOINTER     RMB     2
               1550: 
               1551: 
               1552: ; DISK DRIVERS FOR SOUTHWEST TECHNICAL PRODUCTS MF-68
               1553: 
               1554: ; INPUT PARAMS
               1555: 
BD45 0001      1556: DRV    RMB 1         ; DRIVE TO OPERATE ON
BD46 0001      1557: TRK    RMB 1         ; TRACK TO READ/WRITE
BD47 0001      1558: SECT   RMB 1         ; SECTOR TO READ/WRITE
BD48 0001      1559: SIDE   RMB 1         ; SIDE TO READ/WRITE
BD49 0002      1560: DDATA  RMB 2         ; POINTER TO DATA BUFFER (MUST HAVE 128 BYTES)
               1561: 
               1562: ; COMMANDS FOR WD1771 CONTROLLER CHIP
               1563: ;
  000B         1564: FDRSC  EQU $0B       ; RESTORE
  001B         1565: FDSKI  EQU $1B       ; SEEK
  008C         1566: FDRDC  EQU $8C       ; READ A SECTOR
  00AC         1567: FDWRC  EQU $AC       ; WRITE A SECTOR
               1568: 
               1569: ; ADDR OF WD1771 CONTROLLER CHIP REGISTERS 
               1570: 
  0001         1571:         if RAM64K=1
               1572: 
  FF14         1573: DRVREG set $ff14
  FF18         1574: CMDREG set $ff18
  FF19         1575: TRKREG set $ff19
  FF1A         1576: SECREG set $ff1A
  FF1B         1577: DATREG set $ff1B
               1578: 
  0001         1579:         else
 *S*           1580:         
 *S*           1581: DRVREG EQU $8014
 *S*           1582: CMDREG EQU $8018
 *S*           1583: TRKREG EQU $8019
 *S*           1584: SECREG EQU $801A
 *S*           1585: DATREG EQU $801B
 *S*           1586: 
               1587:         fin
               1588: 
               1589: ; DRIVER VARS
               1590: 
BD4B FF        1591: CURDRV FCB $FF       ; PRESENTLY SELECTED DRIVE #
BD4C 0004      1592: CTRK0  RMB 4         ; TRACK STATE TABLE
BD50 0001      1593: RCNT   RMB 1         ; RETRY COUNT
BD51 0001      1594: SIDEBT RMB 1         ; SIDE SELECTION BIT
               1595: 




ASM/6800 1.4A0: BD51                    
08/16/82 00:00:00; Page 31; Form 1      
IOSWTPC6800.ASM
               1596: ; INIT THE DISK SYSTEM
               1597: 
BD52 7FBD4B    1598: INTDK  CLR CURDRV    ; ASSUME DRIVE 0 BOOTED
BD55 86FF      1599:        LDAA #$FF
BD57 B7BD4C    1600:        STAA CTRK0       
BD5A B7BD4D    1601:        STAA CTRK0+1
BD5D B7BD4E    1602:        STAA CTRK0+2       
BD60 B7BD4F    1603:        STAA CTRK0+3
BD63 39        1604: DUMMY  RTS       
               1605: 
               1606: ; READ A SECTOR
               1607: ;
BD64 BDBE30    1608: RDSEC  JSR SELDRV 
BD67 BDBD82    1609: RDSEC1 JSR READ       ; GETA SECTOR
BD6A 2715      1610:        BEQ QUIT10     ; OK
BD6C 7ABD50    1611:        DEC RCNT       ; RETRY AGAIN?
BD6F 26F6      1612:        BNE RDSEC1     ; YES
BD71 200D      1613:        BRA QERR
               1614: 
               1615: ; WRITE A SECTOR
               1616: ;
BD73 BDBE30    1617: WRSEC  JSR SELDRV 
BD76 BDBDB8    1618: WTSEC1 JSR WRITE
BD79 2706      1619:        BEQ QUIT10     ; OK
BD7B 7ABD50    1620:        DEC RCNT       ; TRY AGAIN?
BD7E 26F6      1621:        BNE WTSEC1     ; YES
BD80 4D        1622: QERR   TSTA           ; A HAS THE STATUS BITS WITH ERROR 
BD81 39        1623: QUIT10 RTS
               1624: 
               1625: ; READ A SECTOR (A=TRK, B=SECTOR, X=CTRKx)
               1626: ;
BD82 BDBDE7    1627: READ   JSR SEEK
BD85 868C      1628:        LDAA #FDRDC    ; READ
BD87 BBBD51    1629:        ADDA SIDEBT
BD8A B7FF18    1630:        STAA CMDREG     
BD8D BDBE10    1631:        JSR DEL56U     ; DELAY
BD90 FEBD49    1632:        LDX DDATA      ; GET BUFFER ADDRESS
BD93 C680      1633:        LDAB #128      ; 128 BYTES/SECTOR     
BD95 B6FF18    1634: READ1  LDAA CMDREG     
BD98 8502      1635:        BITA #$02      ; DATA REG FULL?
BD9A 2606      1636:        BNE READ2      ; YES
BD9C 8501      1637:        BITA #1        ; BUSY?
BD9E 26F5      1638:        BNE READ1      ; YES
BDA0 200B      1639:        BRA READ3      ; ERROR
BDA2 B6FF1B    1640: READ2  LDAA DATREG    ; GET A BYTE
BDA5 A700      1641:        STAA 0,X       ; STORE IN BUFFER
BDA7 08        1642:        INX             
BDA8 5A        1643:        DECB            
BDA9 26EA      1644:        BNE READ1      ; DO AGAIN
BDAB 8D03      1645:        BSR WBUSY      ; WAIT TILL DONE
BDAD 841C      1646: READ3  ANDA #$1C      ; MASK OF STATUS BITS
BDAF 39        1647:        RTS             
               1648:                        
BDB0 B6FF18    1649: WBUSY  LDAA CMDREG     
BDB3 8501      1650:        BITA #1        ; BUSY?




ASM/6800 1.4A0: BDB5                    
08/16/82 00:00:00; Page 32; Form 1      
IOSWTPC6800.ASM
BDB5 26F9      1651:        BNE WBUSY      ; YES
BDB7 39        1652:        RTS
               1653: 
               1654: ; WRITE A SECTOR (A=TRK, B=SECTOR, X=CTRKx)
               1655: 
BDB8 BDBDE7    1656: WRITE  JSR SEEK
BDBB 86AC      1657:        LDAA #FDWRC    ; WRITE COMMAND
BDBD BBBD51    1658:        ADDA SIDEBT
BDC0 B7FF18    1659:        STAA CMDREG     
BDC3 BDBE10    1660:        JSR DEL56U      
BDC6 FEBD49    1661:        LDX DDATA      ; GET BUFFER ADDRESS
BDC9 C680      1662:        LDAB #128      ; 128 BYTES/SECTOR
BDCB B6FF18    1663: WRITE1 LDAA CMDREG     
BDCE 8502      1664:        BITA #2        ; REG EMPTY?
BDD0 2606      1665:        BNE WRITE2     ; YES
BDD2 8501      1666:        BITA #1        ; BUSY?
BDD4 26F5      1667:        BNE WRITE1     ; YES
BDD6 20A8      1668:        BRA QERR       ; ERROR
BDD8 A600      1669: WRITE2 LDAA 0,X       ; GET A BYTE
BDDA B7FF1B    1670:        STAA DATREG     
BDDD 08        1671:        INX             
BDDE 5A        1672:        DECB            
BDDF 26EA      1673:        BNE WRITE1     ; DO AGAIN
BDE1 BDBDB0    1674:        JSR WBUSY      ; WAIT FOR BUSY
BDE4 847C      1675: WRITE3 ANDA #$7C      ; MASK OFF STATUS BITS
BDE6 39        1676:        RTS
               1677: 
               1678: ; SEEK A=TRACK, B=SECTOR, X=CTRKx
               1679: 
BDE7 B1FF19    1680: SEEK   CMPA TRKREG    ; ON TRACK?
BDEA 2713      1681:        BEQ SEEK2      ; YES
BDEC B7FF1B    1682:        STAA DATREG    ; NO, STORE TRACK#
BDEF BDBE10    1683:        JSR DEL56U      
BDF2 A700      1684:        STAA 0,X       ; SAVE CURRENT TRACK OF DRIVE
BDF4 861B      1685:        LDAA #FDSKI    ; SEEK COMMAND
BDF6 B7FF18    1686:        STAA CMDREG     
BDF9 BDBE10    1687:        JSR DEL56U      
BDFC BDBDB0    1688:        JSR WBUSY      ; WAIT FOR BUSY
BDFF F7FF1A    1689: SEEK2  STAB SECREG    ; SET SECTOR
BE02 BDBE10    1690:        JSR DEL56U
BE05 B6BD48    1691:        LDAA SIDE
BE08 2702      1692:        BEQ SEEK3
BE0A 8608      1693:        LDAA #$08      ; SELECT SIDE 1
BE0C B7BD51    1694: SEEK3  STAA SIDEBT       
BE0F 39        1695:        RTS
               1696: 
               1697: ; DEL56U- DELAY 56us INCLUDING THE CALL TO DELAY56U
               1698: 
BE10 BDBE13    1699: DEL56U JSR DELAY2
BE13 BDBE16    1700: DELAY2 JSR DELAY3
BE16 39        1701: DELAY3 RTS
               1702: 
               1703: ; FIND TRACK- RETURN X->TRACK TABLE FOR CURDRV
               1704: 
BE17 CEBD4C    1705: FNDTRK LDX #CTRK0     ; POINT TO TABLE




ASM/6800 1.4A0: BE1A                    
08/16/82 00:00:00; Page 33; Form 1      
IOSWTPC6800.ASM
BE1A B6BD4B    1706:        LDAA CURDRV
BE1D 2704      1707:        BEQ FNDTK3
BE1F 08        1708: FNDTK2 INX
BE20 4A        1709:        DECA
BE21 26FC      1710:        BNE FNDTK2
BE23 39        1711: FNDTK3 RTS
               1712: 
               1713: ; RESTORE SEEK TRACK0
               1714: 
BE24 860B      1715: RESTOR LDAA #FDRSC    ; RESTORE COMMAND
BE26 B7FF18    1716:        STAA CMDREG
BE29 BDBE10    1717:        JSR DEL56U
BE2C BDBDB0    1718:        JSR WBUSY
BE2F 39        1719:        RTS
               1720: 
               1721: ; SELECT THE DRIVE
               1722: ; RETURN A=TRACK, B=SECTOR, X=CTRKx
               1723: 
BE30 8DE5      1724: SELDRV BSR FNDTRK     ; SAVE TRACK FOR CURRENT DRIVE
BE32 B6FF19    1725:        LDAA TRKREG     
BE35 A700      1726:        STAA 0,X        
BE37 B6BD45    1727:        LDAA DRV       ; GET DRIVE 
BE3A B7BD4B    1728:        STAA CURDRV     
BE3D B7FF14    1729:        STAA DRVREG    ; SELECT THE DRIVE
BE40 8DD5      1730:        BSR FNDTRK     ; LOAD TRACK FOR NEW DRIVE
BE42 A600      1731:        LDAA 0,X       ; A=CURRENT DRIVE TRACK
BE44 B7FF19    1732:        STAA TRKREG     
BE47 81FF      1733:        CMPA #$FF      ; INITIALIZED?
BE49 2602      1734:        BNE SELD1      ; YES
BE4B 8DD7      1735:        BSR RESTOR     ; SEEK TRACK0
BE4D 8605      1736: SELD1  LDAA #5        ; SET RETRY COUNT
BE4F B7BD50    1737:        STAA RCNT       
BE52 B6BD46    1738:        LDAA TRK       ; GET TRACK#        
BE55 F6BD47    1739:        LDAB SECT      ; GET SECTOR#
BE58 39        1740:        RTS            
               1741: 
               1742: 
               1743: ; High level EMULATOR (HLE) for swtpc 6800 harddisk with
               1744: ; XIBEX S1410 Winchester Disk Controller and
               1745: ; TANDOM TM-602S 5MB DRIVE
               1746: 
               1747: 
BE59 48443A    1748: dcbname.hd      fcc     'HD:'
BE5C 00        1749:                 fcb     0
BE5D 01        1750: DCB.HD          FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
BE5E 0000      1751:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
BE60 BE59      1752:                 FDB     dcbname.HD              ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
BE62 0000      1753:                 FDB     0                       ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
BE64 BEA1      1754:                 FDB     HDDRIVER                ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
               1755: 
               1756:                                                                 ; DISK GEOMETRY
BE66 0080      1757:                 FDB     128                     ; DSKINFO:NBPS  ; NUMBER OF BYTES PER SECTOR
BE68 0040      1758:                 FDB     64                      ; DSKINFO:NSPT  ; NUMBER OF SECTORS PER TRACK
BE6A 0004      1759:                 FDB     4                       ; DSKINFO:NTPC  ; NUMBER OF TRACKS PER CYLINDER (=surfaces)
BE6C 0099      1760:                 FDB     153                     ; DSKINFO:NCYL  ; NUMBER OF CYLINDERS PER DRIVE




ASM/6800 1.4A0: BE6C                    
08/16/82 00:00:00; Page 34; Form 1      
IOSWTPC6800.ASM
               1761: 
               1762:                                                                 ; THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
BE6E 0001      1763:                 RMB     1                       ; DSKINFO:NSPC   NUMBER OF SECTORS PER CLUSTER
BE6F 0002      1764:                 RMB     LCN.SIZE                ; DSKINFO:MINALLOC ALLOCATION MINIMUM FOR NEW FILES
BE71 0002      1765:                 RMB     LCN.SIZE                ; DSKINFO:MIDALLOC ALLOCATION MIN FOR FILE EXTENSION
BE73 0002      1766:                 RMB     2                       ; DSKINFO:MAPALGORITHM CODE TO SELECT LOGICAL TO PHYSICAL SECTO
               1767: 
               1768:                                                                 ; CONTAINS DISK ID FOR MOUNTED DISKS
BE75 0001      1769:                 RMB     1                       ; DSKINFO:LOG2NBPS LOG BASE 2 OF DSKINFO:NBPS
BE76 0002      1770:                 RMB     2                       ; DSKINFO:NBPSM1 = NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
BE78 0003      1771:                 RMB     LSN.SIZE                ; DSKINFO:NLSN   NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
BE7B 0002      1772:                 RMB     LCN.SIZE                ; DSKINFO:NLCN   NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
BE7D 0002      1773:                 RMB     2                       ; DSKINFO:NBPC   NUMBER OF BYTES PER CLUSTER
BE7F 0002      1774:                 RMB     LCN.SIZE                ; DSKINFO:RANDMAP "RANDOM" LCN TO DISTRIBUTE NEW FILES
BE81 0003      1775:                 RMB     LSN.SIZE                ; DSKINFO:MAPLSN LSN OF 1ST SECTOR IN DISK...
               1776: 
               1777:                                                                 ; ALLOCATION MAP CLUSTER
BE84 0002      1778:                 RMB     2                       ; DSKINFO:DIRFCB POINTER TO FCB FOR $DIRECTORY FILE
BE86 0002      1779:                 RMB     2                       ; DSKINFO:MAPFCB POINTER TO FCB FOR $DISKMAP FILE
BE88 0002      1780:                 RMB     2                       ; DSKINFO:SECTORDB POINTER TO RDSI CONTAINING LSN, ADDRESS PARA
BE8A 0003      1781:                 RMB     LSN.SIZE                ; DSKINFO:BADLSN LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SE
BE8D 0000      1782:                 FDB     0                       ; DSKINFO:SEEKERRCNT # SEEK ERRORS SINCE MOUNT
BE8F 0000      1783:                 FDB     0                       ; DSKINFO:SEEKERRSTS 16 BITS OF LAST "SEEK" STATUS IN ERROR
BE91 0000      1784:                 FDB     0                       ; DSKINFO:WRITEERRCNT # WRITE ERRORS SINCE MOUNT
BE93 0000      1785:                 FDB     0                       ; DSKINFO:WRITEERRSTS 16 BITS OF LAST "WRITE" STATUS IN ERROR
BE95 0000      1786:                 FDB     0                       ; DSKINFO:READERRCNT # READ ERRORS SINCE MOUNT
BE97 0000      1787:                 FDB     0                       ; DSKINFO:READERRSTS 16 BITS OF LAST "READ" STATUS IN ERROR
BE99 000000    1788:                 FCB     0,0,0                   ; DSKINFO:OPSCOUNT 24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
BE9C 0003      1789:                 RMB     LSN.SIZE                ; DSKINFO:ERRLSN LSN CAUSING ANY SOFT OR HARD ERROR
BE9F 0001      1790:                 RMB     1                       ; DSKINFO:WRITEPROTSTATE 0 --> WRITEABLE
BEA0 00        1791:                 FCB     0                       ; FDUNIT         Drive number 
               1792: 
               1793: 
               1794: ; DEVICE DRIVER BLOCK FOR HARD DISK
               1795: 
BEA1 BD41      1796: HDDRIVER        FDB     DSKRESTORE              ; DRIVER:DISKRESET RESET THIS DISK DRIVER
BEA3 BF41      1797:                 FDB     HDREAD                  ; DRIVER:DISKREAD INITIATE A DISK SECTOR READ
BEA5 BF5B      1798:                 FDB     HDWRITE                 ; DRIVER:DISKWRITE INITIATE A DISK SECTOR WRITE
BEA7 BD41      1799:                 FDB     DSKWAITDONE             ; DRIVER:DISKWAIT WAIT FOR DISK I/O COMPLETE
BEA9 B4B8      1800:                 FDB     ILLDEVICEOP             ; DRIVER:DISKSTATUS STATUS handled completely by SDOS1.1
BEAB BC5B      1801:                 FDB     DSKCONTROL              ; DRIVER:DISKCONTROL PERFORM DISK-SPECIFIC CONTROL OPERATION
BEAD B4B8      1802:                 FDB     ILLDEVICEOP             ; DRIVER:DISKWRITEPROTQ DETERMINE IF DISK IS WRITE PROTECTED
BEAF B4B8      1803:                 FDB     ILLDEVICEOP             ; DRIVER:DISKVERIFY INITIATE A DISK SECTOR VERIFY
BEB1 B4B8      1804:                 FDB     ILLDEVICEOP             ; DRIVER:DISKLSNTOPSN CONVERT LSN TO PHYSICAL CYLINDER, TRACK A
               1805: 
  0001         1806: HDCMD.HEARTBEAT EQU     $01
  0002         1807: HDCMD.SELDRV    EQU     $02
  0003         1808: HDCMD.SETSECT   EQU     $03
  0004         1809: HDCMD.SETSURF   EQU     $04
  0005         1810: HDCMD.SETTRACK  EQU     $05
  0006         1811: HDCMD.SETADDRH  EQU     $06
  0007         1812: HDCMD.SETADDRL  EQU     $07
  0008         1813: HDCMD.READ      EQU     $08
  0009         1814: HDCMD.WRITE     EQU     $09
               1815: 




ASM/6800 1.4A0: BEB1                    
08/16/82 00:00:00; Page 35; Form 1      
IOSWTPC6800.ASM
               1816: 
  0001         1817:                 if ram64k=1
               1818: 
  FF10         1819: HDCMD           EQU     $FF10   ; PORTS FOR HARD DISK HIGH LEVEL EMULATOR INTERFACE
  FF11         1820: HDDATA          EQU     $FF11           
               1821: 
  0001         1822:                 else
 *S*           1823: 
 *S*           1824: HDCMD           EQU     $8010   ; PORTS FOR HARD DISK HIGH LEVEL EMULATOR INTERFACE
 *S*           1825: HDDATA          EQU     $8011           
 *S*           1826: 
               1827:                 fin
               1828: 
               1829: 
BEB3 8655      1830: HDPREP          LDAA    #$55                    ; TEST IF HD HLE CONTROLER IS RESPONDING
BEB5 B7FF11    1831:                 STAA    HDDATA
BEB8 8601      1832:                 LDAA    #HDCMD.HEARTBEAT        
BEBA B7FF10    1833:                 STAA    HDCMD
BEBD B6FF11    1834:                 LDAA    HDDATA
BEC0 8167      1835:                 CMPa    #$67                    ; SHOULD GET THIS REPLY 
BEC2 2705      1836:                 BEQ     HDHLEOK
BEC4 CE0424    1837:                 LDX     #ERR.DEVICENOTREADY     ; WE ARE RUNNING WITH HD DISABLED OR IN ANOTHER SIMULATOR 
BEC7 0D        1838:                 SEC                             ; WITHOUT HLE HARD DRIVE EMULATOR, OR EVEN IN REAL HW!
BEC8 39        1839:                 RTS                             ; IN ANY CASE, THERE IS NO HARD DISK -> SIGNALS DEVICE NOT READ
BEC9 DE06      1840: HDHLEOK         LDX     DCBPOINTER              ; GET DCB POINTER
BECB BDBCC2    1841:                 jsr     DSKOPSCOUNT             ; incr count of I/O operations done
BECE A643      1842:                 LDAA    dcb.fdunit,X            ; get this dcb drive number
BED0 C602      1843:                 LDAB    #HDCMD.SELDRV           ; HD COMMAND: SELECT DRIVE
BED2 F7FF10    1844:                 STAB    HDCMD
BED5 B7FF11    1845:                 STAA    HDDATA
BED8 6F01      1846:                 CLR     DCB.LASTERROR,X         ; CLEAR ANY ERROR
BEDA 6F02      1847:                 CLR     DCB.LASTERROR+1,X
BEDC EE2B      1848:                 LDX     DSKINFO.SECTORDB,X      ; GET RDSI POINTER
BEDE FFBD43    1849:                 STX     RDSIPOINTER             ; SAVE IT
               1850:                                                 ; CONVERT RDSI:LSR -> RDSI:CYLINDER/SECTOR
BEE1 FEBD43    1851:                 LDX     RDSIPOINTER
BEE4 6F0E      1852:                 CLR     RDSI.SECTOR,X           ; CLEAR MSB OF SECTOR, TRACK 
BEE6 6F10      1853:                 CLR     RDSI.TRACK,X
BEE8 6F12      1854:                 CLR     RDSI.CYLINDER,X 
               1855: 
BEEA A603      1856:                 LDAA    RDSI.LSN+1,X            ; DISCARD HIGHER LSN BYTE
BEEC E604      1857:                 LDAB    RDSI.LSN+2,X            
BEEE 37        1858:                 PSHB
BEEF C43F      1859:                 ANDB    #63                     ; SECTOR = LSN AND 63
BEF1 E70F      1860:                 STAB    RDSI.SECTOR+1,X         ; B CONTAINS SECTOR = 0..63
BEF3 F7FF11    1861:                 STAB    HDDATA
BEF6 C603      1862:                 LDAB    #HDCMD.SETSECT          ; HD COMMAND: SET SECTOR
BEF8 F7FF10    1863:                 STAB    HDCMD
BEFB 33        1864:                 PULB
BEFC 44        1865:                 LSRA                            ; LSN = LSN DIV 64
BEFD 56        1866:                 RORB
BEFE 44        1867:                 LSRA                            
BEFF 56        1868:                 RORB
BF00 44        1869:                 LSRA                            
BF01 56        1870:                 RORB




ASM/6800 1.4A0: BF02                    
08/16/82 00:00:00; Page 36; Form 1      
IOSWTPC6800.ASM
BF02 44        1871:                 LSRA                            
BF03 56        1872:                 RORB
BF04 44        1873:                 LSRA                            
BF05 56        1874:                 RORB
BF06 44        1875:                 LSRA                            
BF07 56        1876:                 RORB
BF08 37        1877:                 PSHB
BF09 C403      1878:                 ANDB    #3                      ; SURFACE = LSN AND 3
BF0B E711      1879:                 STAB    RDSI.TRACK+1,X          ; B CONTAINS SURFACE = 0..3
BF0D F7FF11    1880:                 STAB    HDDATA
BF10 C604      1881:                 LDAB    #HDCMD.SETSURF          ; HD COMMAND: SET SURFACE
BF12 F7FF10    1882:                 STAB    HDCMD
BF15 33        1883:                 PULB                            ; LSN = LSN DIV 4
BF16 44        1884:                 LSRA                            
BF17 56        1885:                 RORB
BF18 44        1886:                 LSRA                            
BF19 56        1887:                 RORB
BF1A E713      1888:                 STAB    RDSI.CYLINDER+1,X       ; B CONTAINS TRACK 0..152
BF1C F7FF11    1889:                 STAB    HDDATA
BF1F C605      1890:                 LDAB    #HDCMD.SETTRACK         ; HD COMMAND: SET TRACK
BF21 F7FF10    1891:                 STAB    HDCMD
               1892: 
BF24 A605      1893:                 LDAA    RDSI.SECTORBASE,X       ; POINTER TO ACTUAL SECTOR CONTENTS
BF26 B7BD49    1894:                 STAA    DDATA
BF29 B7FF11    1895:                 STAA    HDDATA
BF2C 8606      1896:                 LDAA    #HDCMD.SETADDRH         ; HD COMMAND: SET ADDR (MSB)
BF2E B7FF10    1897:                 STAA    HDCMD
BF31 E606      1898:                 LDAB    RDSI.SECTORBASE+1,X     ; POINTER TO ACTUAL SECTOR CONTENTS
BF33 F7BD4A    1899:                 STAB    DDATA+1
BF36 F7FF11    1900:                 STAB    HDDATA
BF39 C607      1901:                 LDAB    #HDCMD.SETADDRL         ; HD COMMAND: SET ADDR (LSB)
BF3B F7FF10    1902:                 STAB    HDCMD
               1903: 
BF3E 6F0C      1904:                 CLR     RDSI.STATE,X            ; RESET SECTOR STATE TO "IDLE"
BF40 39        1905:                 RTS
               1906: 
BF41 BDBEB3    1907: HDREAD          JSR     HDPREP
BF44 250D      1908:                 BCS     HDERR
BF46 8608      1909:                 LDAA    #HDCMD.READ             ; HD COMMAND: READ SECTOR
BF48 B7FF10    1910:                 STAA    HDCMD
BF4B B6FF11    1911:                 LDAA    HDDATA                  ; retried status of hd operation
BF4E 2706      1912:                 BEQ     HDRDOK
BF50 CE0415    1913:                 LDX     #ERR.DISKREAD
BF53 7EBD31    1914: HDERR           JMP     DSKERR1
BF56 FEBD49    1915: HDRDOK          LDX     DDATA                   
BF59 0C        1916:                 CLC                             ; .*mX-80:HdSec
BF5A 39        1917:                 RTS
               1918:                 
BF5B BDBEB3    1919: HDWRITE         JSR     HDPREP
BF5E 25F3      1920:                 BCS     HDERR
BF60 8609      1921:                 LDAA    #HDCMD.WRITE            ; HD COMMAND: WRITE SECTOR
BF62 B7FF10    1922:                 STAA    HDCMD
BF65 B6FF11    1923:                 LDAA    HDDATA
BF68 27EC      1924:                 BEQ     HDRDOK
BF6A CE0416    1925:                 LDX     #ERR.DISKWRITE




ASM/6800 1.4A0: BF6D                    
08/16/82 00:00:00; Page 37; Form 1      
IOSWTPC6800.ASM
BF6D 20E4      1926:                 BRA     HDERR
               1927:                 
               1928: 
               1929: 
               1930: ; DEVICE CONTROL BLOCK FOR CLOCK 
               1931: 
BF6F 434C4F43  1932: CLOCKSTR        FCC     'CLOCK:'
BF75 00        1933:                 fcb     0
               1934: 
BF76 01        1935: CLOCKDCB        FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE.
BF77 0000      1936:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
BF79 BF6F      1937:                 FDB     CLOCKSTR                ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
BF7B 0000      1938:                 FDB     0                       ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
BF7D BF7F      1939:                 FDB     CLOCKDRIVER             ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
               1940: 
               1941: ; DEVICE DRIVER BLOCK FOR CLOCK CONSOLE
               1942: 
BF7F BF99      1943: CLOCKDRIVER     FDB     CLOCKOPEN       ; DRIVER:OPEN   OPEN FILE
BF81 BF99      1944:                 FDB     CLOCKCLOSE      ; DRIVER:CLOSE  CLOSE FILE
BF83 BFD9      1945:                 FDB     CLOCKREADA      ; DRIVER:READA  READ ASCII
BF85 B4B8      1946:                 FDB     ILLDEVICEOP     ; DRIVER:WRITEA WRITE ASCII WRITEA IS A NO-NO
BF87 BFB7      1947:                 FDB     CLOCKREADB      ; DRIVER:READB  READ BINARY
BF89 BFB4      1948:                 FDB     CLOCKWRITEB     ; DRIVER:WRITEB WRITE BINARY
BF8B B4B8      1949:                 FDB     ILLDEVICEOP     ; DRIVER:CREATE CREATE FILE YOU UPDATE THE CLOCK, NOT REBUILD IT (CREAT
BF8D B4B8      1950:                 FDB     ILLDEVICEOP     ; DRIVER:RENAME RENAME FILE RENAME IT TO WHAT? CLOCK-RADIO: ???
BF8F B4B8      1951:                 FDB     ILLDEVICEOP     ; DRIVER:DELETE DELETE FILE YOU CAN'T GET RID OF THE CLOCK, NEITHER
BF91 B4B8      1952:                 FDB     ILLDEVICEOP     ; DRIVER:CONTROL NO CONTROL FUNCTIONS
BF93 BF9F      1953:                 FDB     CLOCKSTATUS     ; DRIVER:STATUS READ DEVICE (DRIVER) STATUS SAY "I'M A CLOCK, TICK-TOCK
BF95 BFB4      1954:                 FDB     CLOCKRESET      ; DRIVER:RESET  RESET DRIVER (ON BOOT)
BF97 BF99      1955:                 FDB     CLOCKPFRESTART  ; DRIVER:STARTIO        WHO UNPLUGGED ME???
               1956: 
  0000         1957: TEMPX           EQU     0
               1958: 
  BF99         1959: CLOCKOPEN       EQU     *               ; HOW ABOUT LOOKING AT YOUR $9 TI CHEAPIE, MAC!
  BF99         1960: CLOCKCLOSE      EQU     *               ; WHAT AM I SUPPOSED TO DO, PUT THE CLOCK AWAY??
  BF99         1961: CLOCKPFRESTART  EQU     *               ; AM I SUPPOSED TO KEEP TIME WITH NO POWER???
BF99 7EB4B6    1962:                 JMP     OKRTS           ; TOUGH!
               1963: 
BF9C 7EB4B8    1964: CLOCKSPRUNG     JMP     ILLDEVICEOP
BF9F 8104      1965: CLOCKSTATUS     CMPA    #SC.GETTYPE     ; The only status syscall accepted is SC:GETTYP, which returns DVTYF.CL
BFA1 26F9      1966:                 BNE     CLOCKSPRUNG     ; 
BFA3 FECE07    1967:                 LDX     SDOS+SDOS.IOBLOCKPTR
BFA6 BDCE36    1968:                 JSR     SDOS+SDOS.CHECKRDLEN    ; HAS HE GOT A BYTE SPACE
BFA9 0001      1969:                 FDB     1
BFAB EE0A      1970:                 LDX     SCBLK.RDBUF,X   ; GET THE BUFFER POINTER (where syscall return values are to be set)
BFAD 860B      1971:                 LDAA    #DVTYP.CLOCK    ; I'M ALIVE AND TICKING (HOPEFULLY!)
BFAF A700      1972:                 STAA    0,X     
BFB1 7EB4B6    1973:                 JMP     OKRTS
  BFB4         1974: CLOCKWRITEB     EQU     *
  BFB4         1975: CLOCKRESET      EQU     *
BFB4 7EB4B6    1976:                 JMP     OKRTS
               1977: 
BFB7 BDCE36    1978: CLOCKREADB      JSR     SDOS+SDOS.CHECKRDLEN
BFBA 0006      1979:                 FDB     6               ; HE BETTER HAVE 6 BYTES AT LEAST
BFBC CECE00    1980:                 LDX     #SDOS           ; READ CURRENT CLOCK SETTING




ASM/6800 1.4A0: BFBF                    
08/16/82 00:00:00; Page 38; Form 1      
IOSWTPC6800.ASM
BFBF C606      1981:                 LDAB    #6              ; TO STACK
BFC1 A60B      1982: CLOCKRB1        LDAA    SDOS.CLOCK,X
BFC3 08        1983:                 INX
BFC4 36        1984:                 PSHA
BFC5 5A        1985:                 DECB
BFC6 26F9      1986:                 BNE     CLOCKRB1
BFC8 FECE07    1987:                 LDX     SDOS+SDOS.IOBLOCKPTR
BFCB EE0A      1988:                 LDX     SCBLK.RDBUF,X
BFCD C606      1989:                 LDAB    #6              ; PUT CLOCK IN READ BUFFER
BFCF 32        1990: CLOCKRB2        PULA
BFD0 A705      1991:                 STAA    5,X
BFD2 09        1992:                 DEX
BFD3 5A        1993:                 DECB
BFD4 26F9      1994:                 BNE     CLOCKRB2
BFD6 7EB4B6    1995:                 JMP     OKRTS
               1996: 
BFD9 BDCE36    1997: CLOCKREADA      JSR     SDOS+SDOS.CHECKRDLEN
BFDC 0011      1998:                 FDB     17              ; ENOUGH FOR HH:MM:SS MM/DD/YY
BFDE FECE07    1999:                 LDX     SDOS+SDOS.IOBLOCKPTR
BFE1 A60C      2000:                 LDAA    SCBLK.RDLEN,X   ; SEE IF ENOUGH SPACE FOR CR
BFE3 2606      2001:                 BNE     CLOCKREADA0
BFE5 E60D      2002:                 LDAB    SCBLK.RDLEN+1,X 
BFE7 C112      2003:                 CMPB    #18
BFE9 2502      2004:                 BLO     CLOCKREADA1     ; B/ NO
BFEB 6C09      2005: CLOCKREADA0     INC     SCBLK.RPLEN+1,X ; YES, INCLUDE THE CR IN THE COUNT
BFED EE0A      2006: CLOCKREADA1     LDX     SCBLK.RDBUF,X
BFEF 2504      2007:                 BLO     CLOCKREADA2     ; B/ CR NOT INCLUDED
BFF1 860D      2008:                 LDAA    #13             ; <CR>
BFF3 A711      2009:                 STAA    17,X
BFF5 8611      2010: CLOCKREADA2     LDAA    #17
BFF7 DF00      2011:                 STX     TEMPX
BFF9 CEC010    2012:                 LDX     #TIMESTR
BFFC E600      2013: CLOCKREADA3     LDAB    0,X
BFFE 08        2014:                 INX
BFFF DF02      2015:                 STX     TEMPX+2
C001 DE00      2016:                 LDX     TEMPX
C003 E700      2017:                 STAB    0,X
C005 08        2018:                 INX
C006 DF00      2019:                 STX     TEMPX
C008 DE02      2020:                 LDX     TEMPX+2
C00A 4A        2021:                 DECA
C00B 26EF      2022:                 BNE     CLOCKREADA3
C00D 7EB4B6    2023:                 JMP     OKRTS
               2024: 
C010 30303A30  2025: TIMESTR         FCC     '00:00:00 08/16/82'
               2026:   
  C021         2027: ATTNCHECK       
  C021         2028: DEBUGSYSCALL    
C021 7EB4B6    2029:                 jmp     okrts
               2030: 
               2031: 
  0000         2032:                 if *>>IOBUF
 *S*           2033:                 ? IO package too big! overlaps IOBUF
               2034:                 fin
               2035:                 




ASM/6800 1.4A0: C021                    
08/16/82 00:00:00; Page 39; Form 1      
IOSWTPC6800.ASM
               2036:                 end




ASM/6800 1.4A0: C021                    
08/16/82 00:00:00; Page 40; Form 1      Symbols Sorted by Name
IOSWTPC6800.ASM
Symbols Sorted by Name:

*ABORTBIT/0080   ACIAIN/B609     ACIAPORT/FF04   ACIOU1/B5EF     ACIOUT/B5EB     ACTIVATIONCHARSENSED/B5DF
 ACTIVATIONCHARSVECTOR/B5CF      ACTIVBYTE/B87A  ACTIVCHAR/B885  APORT.MODE/BA46                 ATTNCHECK/C021  BACKSPACE/B88C
 BACKSPC1/B8A8   BACKSPC2/B8AD   BADINTERRUPTCOUNT/B44E          BASICDEBUGFLAGS/C080            BASICFLAGS/B5CB
 BREAKBIT/0020   CC.ACTIVATIONCK/001D            CC.DISMOUNTDISK/0011            CC.ECHO/0010    CC.NOECHO/0011  CC.SETACTBLOCK/0014
 CH/B970         CL1/B9A1        CL2/B9B0        CL3/B9C2        CLOCKCLOSE/BF99                 CLOCKDCB/BF76   CLOCKDRIVER/BF7F
 CLOCKOPEN/BF99  CLOCKPFRESTART/BF99             CLOCKRB1/BFC1   CLOCKRB2/BFCF   CLOCKREADA/BFD9                 CLOCKREADA0/BFEB
 CLOCKREADA1/BFED                CLOCKREADA2/BFF5                CLOCKREADA3/BFFC                CLOCKREADB/BFB7
 CLOCKRESET/BFB4                 CLOCKSPRUNG/BF9C                CLOCKSTATUS/BF9F                CLOCKSTR/BF6F   CLOCKWRITEB/BFB4
 CLOSE.PORT/B999                 CLOSE.TTY/B67A  CMDREG/FF18     CNFGTABLE/B403  CONSOLEDRIVER/B49C              CONTROL.PORT/B971
 CONTROL.TTY/B6AE                CR0/BA6C        CR1/BA5A        CR2/BA67        CRFLAG/B5CE     CTRK0/BD4C      CTRLCNUM/B5CC
 CURDRV/BD4B     DACTIVATION1/B6E1               DACTIVATIONCK/B6D4              DATREG/FF1B    *DCB.CLEARIN/00CA
*DCB.D0/BB2D     DCB.D1/BB75     DCB.D2/BBBD     DCB.D3/BC05    *DCB.DONEFLAG/0000              *DCB.DRIVER/0007
 DCB.FDUNIT/0043                 DCB.HD/BE5D    *DCB.INPUTTOBLK/00A9             DCB.LASTERROR/0001             *DCB.LINEBUF/0067
*DCB.LINEBUFLEN/007A            *DCB.NAME/0003  *DCB.NEXTDCB/0005               *DCB.OILQUIESCENT/0013
*DCB.OUTPUTTOBLK/00A1            DCB.PORT/B94C  *DCB.PROFILE/0028               *DCB.RESET/00B5 *DCB.RINGINBASE/004D
*DCB.RINGOUTBASE/0059           *DCB.RINGOUTTHRESHOLD/005D      *DCB.TASKSTACK/00B3             *DCB.TCB/00B1   *DCB.TLBUFFER/007D
 DCB.TTY/B493   *DCB.VTSIZE/00FD                 DCBNAME.D0/BB29                 DCBNAME.D1/BB71                 DCBNAME.D2/BBB9
 DCBNAME.D3/BC01                 DCBNAME.HD/BE59                 DCBNAME.PORT/B946               DCBNAME.TTY/B48A
 DCBPOINTER/0006                 DDATA/BD49      DEBUGSYSCALL/C021               DECHO/B6C6      DEL56U/BE10     DELAY1K/B9C5
 DELAY1KB/B9C8   DELAY2/BE13     DELAY3/BE16     DISKDCBS/BB2D   DIV18/BC80      DIV18.1/BC88    DIV18.2/BC90    DIV18.3/BC98
 DIV18.4/BCA0    DIV18.5/BCA8    DIV18.6/BCB0    DIV18.7/BCB8    DIV18.8/BCC0    DNOECHO/B6CE    DRIVERBASE/B400
 DRV/BD45        DRVREG/FF14     DSETACT1/B6EF   DSETACTIVATION/B6E4             DSKBUFFERPOOL/C660              DSKCONTROL/BC5B
 DSKDISMOUNT/BC62                DSKDRIVER/BC49  DSKERR/BD19     DSKERR1/BD31    DSKINFO.OPSCOUNT/003C
 DSKINFO.SECTORDB/002B           DSKOPSCOUNT/BCC2                DSKOPSCOUNT1/BCCC               DSKPOOLSIZE/079E
 DSKPREP/BCCD    DSKREAD/BCFF    DSKRESTORE/BD41                 DSKWAITDONE/BD41                DSKWRITE/BD0C  *DUMMY/BD63
 DVTYP.CLOCK/000B                DVTYP.STAPE/0002               *DVTYP.TYPE/0000                 ECHOFLAG/B5C9   EOFFLAG/B5C8
 ERR.ACTIVATIONNOTINBUFFER/0773  ERR.ACTIVATIONRECEIVED/0775     ERR.DEVICENOTREADY/0424        *ERR.DEVICETIMEDOUT/0412
 ERR.DISKREAD/0415               ERR.DISKSEEK/0417               ERR.DISKWRITE/0416              ERR.DSKWRTPROT/0418
 ERR.EOFHIT/03E9                 ERR.ILLDEVICEOP/040A            ERR.PROGRAMKILLED/0411         *ERR.WRONGDISKTYPE/076E
*ERRETX/B4BD     EXPANDTABFLAG/B5CD              FCB.SIZE/001A   FCBS/C081       FDRDC/008C      FDRSC/000B      FDSKI/001B
 FDTEARLSN/BC64  FDWRC/00AC      FNDTK2/BE1F     FNDTK3/BE23     FNDTRK/BE17     FUSEBURNEDUP/B458               GETREADPARAMS/B707
 GETWRITEPARAMS/B8AE             GOBIT/0008      HDCMD/FF10      HDCMD.HEARTBEAT/0001            HDCMD.READ/0008
 HDCMD.SELDRV/0002               HDCMD.SETADDRH/0006             HDCMD.SETADDRL/0007             HDCMD.SETSECT/0003
 HDCMD.SETSURF/0004              HDCMD.SETTRACK/0005             HDCMD.WRITE/0009                HDDATA/FF11     HDDRIVER/BEA1
 HDERR/BF53      HDHLEOK/BEC9    HDPREP/BEB3     HDRDOK/BF56     HDREAD/BF41     HDWRITE/BF5B    IGN/0000        ILLDEVICEOP/B4B8
 INBYTE/B9EC     INBYTEEOF/B9FC  INCH/B651       INEEE/B5FB      INNYB1/B9DC     INNYB4/B9E4     INNYBLE/B9CC    INPUTBUF/B4CA
 INPUTBUFLEN/00FA                INPUTBUFP0/B5C4                 INPUTBUFP1/B5C6                 INTDISABLE/B43A
 INTDK/BD52      INTENABLE/B43C  INTERRUPTSTACK/C61F             INTRTI/B43F     INTSETUP/B427   INTSTACKTOP/C65F
 IOBUF/C080      IOBUFEND/CE00   IOCB.SIZE/0022  IOCBPOINTERS/C5F9               IOCBS/C373      IOINTPOLL/B440  IRQINT/B43E
 IRQVECTOR/FFF8  LCN.SIZE/0002   LEN/B4C4        LMODE/B4C3      LSN.SIZE/0003  *M6800/0001     *M6801/0000     *M6809/0000
 NCOL/B5CA       NDRIVES/0004    NIOCHANNELS/0013                NMAGICFCBS/0002                 NOTIMERINT/B444
 OFS/2000        OKRTS/B4B6      OPEN.PORT/B991  OPEN.TTY/B656   OPEN.TTY1/B66B  OUTEEE/B5E1     OUTNYBLE/BB1E   OUTNYBLE1/BB26
 PDATA/B4C6      PNCHOFF/B623    PNCHON/B61F     PORECH/B5E0     PORTDRIVER/B955                 PORTMODE/B96F   PRT1/B639
*PRT2/B633       PRT3/B636       PRT4/B641       PRTCH/B627      QERR/BD80       QUIT10/BD81     RAM64K/0001     RBACKSPACE/B80D
 RBAS/B834       RCNT/BD50      *RCTRLC/B7F0    *RCTRLD/B816     RD1NCOL/B7A6    RD2NCOL/B7A9    RDOFF/B61B      RDON/B617
 RDSEC/BD64      RDSEC1/BD67    *RDSI.BLINK/0009                 RDSI.CYLINDER/0012             *RDSI.DISKINFO/0000
*RDSI.FLINK/0007                 RDSI.LSN/0002  *RDSI.MODIFIED/000B             *RDSI.RETRYCOUNT/000D            RDSI.SECTOR/000E
 RDSI.SECTORBASE/0005           *RDSI.SIZE/0014  RDSI.STATE/000C                 RDSI.TRACK/0010                 RDSIPOINTER/BD43
*RDSISTATE.IDLE/0000            *RDSISTATE.READING/0001         *RDSISTATE.VERIFYING/0003       *RDSISTATE.WRITING/0002
 READ/BD82       READ.PORT/BA08  READ1/BD95      READ2/BDA2      READ3/BDAD      READA.PORT/B9FE                 READA.TTY/B754
 READA1/B764     READA2/B76E     READA3/B779     READA4/B77F     READA5/B7BD     READA6/B7CA     READAPORT/BA4A  READB.PORT/BA05
 READB.TTY/B732  READB1/B73B     READB2/B752     READBPORT/BA79  READINPUTBUF/B7D4               RENDOFINPUT/B88B
 RES/B5F7        RESET.TTY/B6C3  RESTOR/BE24     RI1/B802        RI2/B812        RI3/B81C        RI4/B83C        RI5/B864




ASM/6800 1.4A0: C021                    
08/16/82 00:00:00; Page 41; Form 1      Symbols Sorted by Name
IOSWTPC6800.ASM
 RI6/B869        RI7/B870        RINBUF/B7DD     RINCH/B7E6      RP1/BA2D        RP1A/BA42       RP1EOF/BAA5     RP1START/BA34
 RPIN/BA3A       RPLEN/B4C8      RSTORECH/B849   SAVEREADPORTCH/BA90             SC.GETCOL/0001  SC.GETEOF/0002
 SC.GETLINEFLAGS/002C            SC.GETTYPE/0004                *SCBLK.DATA/000E                *SCBLK.OPCODE/0000
 SCBLK.PARAMS/0002               SCBLK.RDBUF/000A                SCBLK.RDLEN/000C                SCBLK.RPLEN/0008
*SCBLK.WLEN/0001                 SCBLK.WRBUF/0004                SCBLK.WRLEN/0006                SDOS/CE00
 SDOS.CHECKRDLEN/0036            SDOS.CLOCK/000B                 SDOS.ERROR/002D                 SDOS.ERRORED/0033
 SDOS.ERRORSAVE/0030             SDOS.IOBLOCKPTR/0007            SDOS.RTI/0015   SDOS.WAITEVENT/002A             SECREG/FF1A
 SECT/BD47       SEEK/BDE7       SEEK2/BDFF      SEEK3/BE0C      SELD1/BE4D      SELDRV/BE30     SETRPLEN/B724   SIDE/BD48
 SIDEBT/BD51     SINIT1/3003     SINIT2/300F    *SPECIALFN.CLEAR/0082           *SPECIALFN.EEOL/0083            *SPECIALFN.POSN/0081
 SSTEPBIT/0010   ST0/B693        ST1/B69C        ST2/B6A5        STATUS.PORT/B97B                STATUS.TTY/B67D
 STATUSRET1/B6A7                 STPO1/B988      STPO2/B98A      SWTPCINIT/3000 *SYSCALL.CHAIN/0006             *SYSCALL.CLOSE/0002
*SYSCALL.CONTROL/000E           *SYSCALL.CREATE/0001            *SYSCALL.DEBUG/0018             *SYSCALL.DELETE/0004
*SYSCALL.DISPERROR/0015         *SYSCALL.ERROREXIT/0012         *SYSCALL.EXIT/0011              *SYSCALL.GETERROR/0014
*SYSCALL.OPEN/0000              *SYSCALL.READA/000A             *SYSCALL.READB/000B             *SYSCALL.RENAME/0003
*SYSCALL.SETERROR/0013          *SYSCALL.STATUS/000F            *SYSCALL.WRITEA/000C            *SYSCALL.WRITEB/000D
 SYSCALLIO/B400  TASKQUEUE/B45C  TASKSETUP/B482  TASKSTACKINIT/B478             *TASKSTACKTOP/B480               TASKWAKEUPFLAG/B481
 TEMPX/0000      TIMEOUTQUEUE/B450               TIMESTR/C010    TRACEBIT/0040   TRK/BD46        TRKREG/FF19     WBUSY/BDB0
 WP0/BADF        WP1/BAE4        WP1A/BAF3       WP1START/BAEB   WPOUT/BAEB      WRITE/BDB8      WRITE.0/B8CF    WRITE.1/B8D7
 WRITE.2/B8E9    WRITE.3/B8EC    WRITE.9/B8F5    WRITE.CHCR.ECHO/B8F8            WRITE.CR.ECHO/B8FB              WRITE.MODE/B8E0
 WRITE.PORT/BAB7                 WRITE1/BDCB     WRITE2/BDD8    *WRITE3/BDE4     WRITEA.CH/B903  WRITEA.CH.ECHO/B8FD
 WRITEA.CH1/B90B                 WRITEA.CH2/B918                 WRITEA.CH2A/B92A                WRITEA.CH2B/B935
 WRITEA.CH2C/B939                WRITEA.CH3/B942                 WRITEA.CH4/B945                 WRITEA.PORT/BAAA
 WRITEA.TTY/B8BF                *WRITEAPORT/BB05                 WRITEB.PORT/BAB4                WRITEB.TTY/B8C9
 WRITEBPORT/BB0A                 WRSEC/BD73      WTSEC1/BD76




ASM/6800 1.4A0: C021                    
08/16/82 00:00:00; Page 42; Form 1      Symbols Sorted by Value
IOSWTPC6800.ASM
Symbols Sorted by Value:

*DCB.DONEFLAG/0000              *DVTYP.TYPE/0000                 IGN/0000       *M6801/0000     *M6809/0000     *RDSI.DISKINFO/0000
*RDSISTATE.IDLE/0000            *SCBLK.OPCODE/0000              *SYSCALL.OPEN/0000               TEMPX/0000      DCB.LASTERROR/0001
 HDCMD.HEARTBEAT/0001           *M6800/0001      RAM64K/0001    *RDSISTATE.READING/0001          SC.GETCOL/0001 *SCBLK.WLEN/0001
*SYSCALL.CREATE/0001             DVTYP.STAPE/0002                HDCMD.SELDRV/0002               LCN.SIZE/0002   NMAGICFCBS/0002
 RDSI.LSN/0002  *RDSISTATE.WRITING/0002          SC.GETEOF/0002  SCBLK.PARAMS/0002              *SYSCALL.CLOSE/0002
*DCB.NAME/0003   HDCMD.SETSECT/0003              LSN.SIZE/0003  *RDSISTATE.VERIFYING/0003       *SYSCALL.RENAME/0003
 HDCMD.SETSURF/0004              NDRIVES/0004    SC.GETTYPE/0004                 SCBLK.WRBUF/0004               *SYSCALL.DELETE/0004
*DCB.NEXTDCB/0005                HDCMD.SETTRACK/0005             RDSI.SECTORBASE/0005            DCBPOINTER/0006
 HDCMD.SETADDRH/0006             SCBLK.WRLEN/0006               *SYSCALL.CHAIN/0006             *DCB.DRIVER/0007
 HDCMD.SETADDRL/0007            *RDSI.FLINK/0007                 SDOS.IOBLOCKPTR/0007            GOBIT/0008      HDCMD.READ/0008
 SCBLK.RPLEN/0008                HDCMD.WRITE/0009               *RDSI.BLINK/0009                 SCBLK.RDBUF/000A
*SYSCALL.READA/000A              DVTYP.CLOCK/000B                FDRSC/000B     *RDSI.MODIFIED/000B              SDOS.CLOCK/000B
*SYSCALL.READB/000B              RDSI.STATE/000C                 SCBLK.RDLEN/000C               *SYSCALL.WRITEA/000C
*RDSI.RETRYCOUNT/000D           *SYSCALL.WRITEB/000D             RDSI.SECTOR/000E               *SCBLK.DATA/000E
*SYSCALL.CONTROL/000E           *SYSCALL.STATUS/000F             CC.ECHO/0010    RDSI.TRACK/0010                 SSTEPBIT/0010
 CC.DISMOUNTDISK/0011            CC.NOECHO/0011 *SYSCALL.EXIT/0011               RDSI.CYLINDER/0012
*SYSCALL.ERROREXIT/0012         *DCB.OILQUIESCENT/0013           NIOCHANNELS/0013               *SYSCALL.SETERROR/0013
 CC.SETACTBLOCK/0014            *RDSI.SIZE/0014 *SYSCALL.GETERROR/0014           SDOS.RTI/0015  *SYSCALL.DISPERROR/0015
*SYSCALL.DEBUG/0018              FCB.SIZE/001A   FDSKI/001B      CC.ACTIVATIONCK/001D            BREAKBIT/0020   IOCB.SIZE/0022
*DCB.PROFILE/0028                SDOS.WAITEVENT/002A             DSKINFO.SECTORDB/002B           SC.GETLINEFLAGS/002C
 SDOS.ERROR/002D                 SDOS.ERRORSAVE/0030             SDOS.ERRORED/0033               SDOS.CHECKRDLEN/0036
 DSKINFO.OPSCOUNT/003C           TRACEBIT/0040   DCB.FDUNIT/0043                *DCB.RINGINBASE/004D
*DCB.RINGOUTBASE/0059           *DCB.RINGOUTTHRESHOLD/005D      *DCB.LINEBUF/0067               *DCB.LINEBUFLEN/007A
*DCB.TLBUFFER/007D              *ABORTBIT/0080  *SPECIALFN.POSN/0081            *SPECIALFN.CLEAR/0082           *SPECIALFN.EEOL/0083
 FDRDC/008C     *DCB.OUTPUTTOBLK/00A1           *DCB.INPUTTOBLK/00A9             FDWRC/00AC     *DCB.TCB/00B1   *DCB.TASKSTACK/00B3
*DCB.RESET/00B5 *DCB.CLEARIN/00CA                INPUTBUFLEN/00FA               *DCB.VTSIZE/00FD                 ERR.EOFHIT/03E9
 ERR.ILLDEVICEOP/040A            ERR.PROGRAMKILLED/0411         *ERR.DEVICETIMEDOUT/0412         ERR.DISKREAD/0415
 ERR.DISKWRITE/0416              ERR.DISKSEEK/0417               ERR.DSKWRTPROT/0418             ERR.DEVICENOTREADY/0424
*ERR.WRONGDISKTYPE/076E          ERR.ACTIVATIONNOTINBUFFER/0773  ERR.ACTIVATIONRECEIVED/0775     DSKPOOLSIZE/079E
 OFS/2000        SWTPCINIT/3000  SINIT1/3003     SINIT2/300F     DRIVERBASE/B400                 SYSCALLIO/B400  CNFGTABLE/B403
 INTSETUP/B427   INTDISABLE/B43A                 INTENABLE/B43C  IRQINT/B43E     INTRTI/B43F     IOINTPOLL/B440  NOTIMERINT/B444
 BADINTERRUPTCOUNT/B44E          TIMEOUTQUEUE/B450               FUSEBURNEDUP/B458               TASKQUEUE/B45C  TASKSTACKINIT/B478
*TASKSTACKTOP/B480               TASKWAKEUPFLAG/B481             TASKSETUP/B482  DCBNAME.TTY/B48A                DCB.TTY/B493
 CONSOLEDRIVER/B49C              OKRTS/B4B6      ILLDEVICEOP/B4B8               *ERRETX/B4BD     LMODE/B4C3      LEN/B4C4
 PDATA/B4C6      RPLEN/B4C8      INPUTBUF/B4CA   INPUTBUFP0/B5C4                 INPUTBUFP1/B5C6                 EOFFLAG/B5C8
 ECHOFLAG/B5C9   NCOL/B5CA       BASICFLAGS/B5CB                 CTRLCNUM/B5CC   EXPANDTABFLAG/B5CD              CRFLAG/B5CE
 ACTIVATIONCHARSVECTOR/B5CF      ACTIVATIONCHARSENSED/B5DF       PORECH/B5E0     OUTEEE/B5E1     ACIOUT/B5EB     ACIOU1/B5EF
 RES/B5F7        INEEE/B5FB      ACIAIN/B609     RDON/B617       RDOFF/B61B      PNCHON/B61F     PNCHOFF/B623    PRTCH/B627
*PRT2/B633       PRT3/B636       PRT1/B639       PRT4/B641       INCH/B651       OPEN.TTY/B656   OPEN.TTY1/B66B  CLOSE.TTY/B67A
 STATUS.TTY/B67D                 ST0/B693        ST1/B69C        ST2/B6A5        STATUSRET1/B6A7                 CONTROL.TTY/B6AE
 RESET.TTY/B6C3  DECHO/B6C6      DNOECHO/B6CE    DACTIVATIONCK/B6D4              DACTIVATION1/B6E1               DSETACTIVATION/B6E4
 DSETACT1/B6EF   GETREADPARAMS/B707              SETRPLEN/B724   READB.TTY/B732  READB1/B73B     READB2/B752     READA.TTY/B754
 READA1/B764     READA2/B76E     READA3/B779     READA4/B77F     RD1NCOL/B7A6    RD2NCOL/B7A9    READA5/B7BD     READA6/B7CA
 READINPUTBUF/B7D4               RINBUF/B7DD     RINCH/B7E6     *RCTRLC/B7F0     RI1/B802        RBACKSPACE/B80D
 RI2/B812       *RCTRLD/B816     RI3/B81C        RBAS/B834       RI4/B83C        RSTORECH/B849   RI5/B864        RI6/B869
 RI7/B870        ACTIVBYTE/B87A  ACTIVCHAR/B885  RENDOFINPUT/B88B                BACKSPACE/B88C  BACKSPC1/B8A8   BACKSPC2/B8AD
 GETWRITEPARAMS/B8AE             WRITEA.TTY/B8BF                 WRITEB.TTY/B8C9                 WRITE.0/B8CF    WRITE.1/B8D7
 WRITE.MODE/B8E0                 WRITE.2/B8E9    WRITE.3/B8EC    WRITE.9/B8F5    WRITE.CHCR.ECHO/B8F8            WRITE.CR.ECHO/B8FB
 WRITEA.CH.ECHO/B8FD             WRITEA.CH/B903  WRITEA.CH1/B90B                 WRITEA.CH2/B918                 WRITEA.CH2A/B92A
 WRITEA.CH2B/B935                WRITEA.CH2C/B939                WRITEA.CH3/B942                 WRITEA.CH4/B945
 DCBNAME.PORT/B946               DCB.PORT/B94C   PORTDRIVER/B955                 PORTMODE/B96F   CH/B970         CONTROL.PORT/B971
 STATUS.PORT/B97B                STPO1/B988      STPO2/B98A      OPEN.PORT/B991  CLOSE.PORT/B999                 CL1/B9A1
 CL2/B9B0        CL3/B9C2        DELAY1K/B9C5    DELAY1KB/B9C8   INNYBLE/B9CC    INNYB1/B9DC     INNYB4/B9E4     INBYTE/B9EC




ASM/6800 1.4A0: C021                    
08/16/82 00:00:00; Page 43; Form 1      Symbols Sorted by Value
IOSWTPC6800.ASM
 INBYTEEOF/B9FC  READA.PORT/B9FE                 READB.PORT/BA05                 READ.PORT/BA08  RP1/BA2D        RP1START/BA34
 RPIN/BA3A       RP1A/BA42       APORT.MODE/BA46                 READAPORT/BA4A  CR1/BA5A        CR2/BA67        CR0/BA6C
 READBPORT/BA79  SAVEREADPORTCH/BA90             RP1EOF/BAA5     WRITEA.PORT/BAAA                WRITEB.PORT/BAB4
 WRITE.PORT/BAB7                 WP0/BADF        WP1/BAE4        WP1START/BAEB   WPOUT/BAEB      WP1A/BAF3      *WRITEAPORT/BB05
 WRITEBPORT/BB0A                 OUTNYBLE/BB1E   OUTNYBLE1/BB26  DCBNAME.D0/BB29                *DCB.D0/BB2D     DISKDCBS/BB2D
 DCBNAME.D1/BB71                 DCB.D1/BB75     DCBNAME.D2/BBB9                 DCB.D2/BBBD     DCBNAME.D3/BC01
 DCB.D3/BC05     DSKDRIVER/BC49  DSKCONTROL/BC5B                 DSKDISMOUNT/BC62                FDTEARLSN/BC64  DIV18/BC80
 DIV18.1/BC88    DIV18.2/BC90    DIV18.3/BC98    DIV18.4/BCA0    DIV18.5/BCA8    DIV18.6/BCB0    DIV18.7/BCB8    DIV18.8/BCC0
 DSKOPSCOUNT/BCC2                DSKOPSCOUNT1/BCCC               DSKPREP/BCCD    DSKREAD/BCFF    DSKWRITE/BD0C   DSKERR/BD19
 DSKERR1/BD31    DSKRESTORE/BD41                 DSKWAITDONE/BD41                RDSIPOINTER/BD43                DRV/BD45
 TRK/BD46        SECT/BD47       SIDE/BD48       DDATA/BD49      CURDRV/BD4B     CTRK0/BD4C      RCNT/BD50       SIDEBT/BD51
 INTDK/BD52     *DUMMY/BD63      RDSEC/BD64      RDSEC1/BD67     WRSEC/BD73      WTSEC1/BD76     QERR/BD80       QUIT10/BD81
 READ/BD82       READ1/BD95      READ2/BDA2      READ3/BDAD      WBUSY/BDB0      WRITE/BDB8      WRITE1/BDCB     WRITE2/BDD8
*WRITE3/BDE4     SEEK/BDE7       SEEK2/BDFF      SEEK3/BE0C      DEL56U/BE10     DELAY2/BE13     DELAY3/BE16     FNDTRK/BE17
 FNDTK2/BE1F     FNDTK3/BE23     RESTOR/BE24     SELDRV/BE30     SELD1/BE4D      DCBNAME.HD/BE59                 DCB.HD/BE5D
 HDDRIVER/BEA1   HDPREP/BEB3     HDHLEOK/BEC9    HDREAD/BF41     HDERR/BF53      HDRDOK/BF56     HDWRITE/BF5B    CLOCKSTR/BF6F
 CLOCKDCB/BF76   CLOCKDRIVER/BF7F                CLOCKCLOSE/BF99                 CLOCKOPEN/BF99  CLOCKPFRESTART/BF99
 CLOCKSPRUNG/BF9C                CLOCKSTATUS/BF9F                CLOCKRESET/BFB4                 CLOCKWRITEB/BFB4
 CLOCKREADB/BFB7                 CLOCKRB1/BFC1   CLOCKRB2/BFCF   CLOCKREADA/BFD9                 CLOCKREADA0/BFEB
 CLOCKREADA1/BFED                CLOCKREADA2/BFF5                CLOCKREADA3/BFFC                TIMESTR/C010    ATTNCHECK/C021
 DEBUGSYSCALL/C021               BASICDEBUGFLAGS/C080            IOBUF/C080      FCBS/C081       IOCBS/C373      IOCBPOINTERS/C5F9
 INTERRUPTSTACK/C61F             INTSTACKTOP/C65F                DSKBUFFERPOOL/C660              IOBUFEND/CE00   SDOS/CE00
 ACIAPORT/FF04   HDCMD/FF10      HDDATA/FF11     DRVREG/FF14     CMDREG/FF18     TRKREG/FF19     SECREG/FF1A     DATREG/FF1B
 IRQVECTOR/FFF8

434 Symbols.


 *** No Assembly Errors.
