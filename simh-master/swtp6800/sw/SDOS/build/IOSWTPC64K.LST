



ASM/6800 1.4A0: 0000                    
08/16/82 00:00:00; Page 1; Form 0       
IOSWTPC6800.ASM
  0001            1: RAM64K   EQU  1 




ASM/6800 1.4A0: 0000                    
08/16/82 00:00:00; Page 2; Form 1       
IOSWTPC6800.ASM
                  1: 
                  2: ;*              I/O Package Configuraton for SimH SWTPC 6800 Simulator
                  3: ;*              should work on real hw too
                  4: 
                  5: ;*              (C) Roberto Sancho, Jun 2022
                  6: ;*              based on SSB I/O Package
                  7: 
                  8: ;*              features implemented: 
                  9: ;                            mapalg: Only supports 0001
                 10: ;                            I/O Implemented using active wait (no interruption based)
                 11: ;                            no clock interrupt
                 12: ;                            no vt terminal driver. Just a minimal subset
                 13: ;                                              BackSpace, Tab (converted to 8 spaces) 
                 14: ;                                              ^C to discard current input 
                 15: ;                                              ^C^C to kill current program
                 16: ;                                              <CR> is the only activation key allowed (cannot be changed)
                 17: ;                                              ^Z to signal end of file
                 18: ;                                              ^D to call monitor, J A080 to return to SDOS
                 19: ;                                              basic debug keys ^B, ^T, ^G, ^V
                 20: ;                            only supported disk geometry: 5'25 floppy 2 sides x 35tr x 18 sec x 128 bytes
                 21: ;                            supports for HLE 5MB Hard Disk
                 22: ;                            PORT: device to read from PTR/punch to PTP
                 23: ;                           
                 24: 
  0004           25: NDRIVES         equ     4
  0013           26: NIOCHANNELS     equ     16+3    ; number of files that can be opened at same time
                 27: 
                 28:                                 ; SWTBUG ROM entry points
                 29: 
                 30:                 ; conditional assembly for SWTPC with 64K ram and
                 31:                 ; I/O address at FF00..FF1F instead of 8000..801F  
                 32: 
  0001           33:              if ram64k=1
                 34: 
                 35:                                 ; Memory Map
                 36:                                 ; 0000..B3FF User RAM (46080 BYTES = 45 kB)
  B400           37: DRIVERBASE      set     $B400   ; B400..BFFF SDOS I/O Driver for SWTPC 6800 
  C080           38: IOBUF           EQU     $C080   ; C080..CDFF BUFFERS FOR I/O DRIVER
  CE00           39: IOBUFEND        EQU     $CE00
  CE00           40: SDOS            EQU     $CE00   ; CE00..EFFF SDOS Operating System (64K compile version)
                 41:                                 ; FF00..FF1F IO MAPED MEMORY
  FFF8           42: IRQVECTOR       equ     $FFF8   ; IRQ VECTOR IN HIGH MEM IS RAM
                 43: 
  0001           44:               else
 *S*             45:                                 ; Memory Map
 *S*             46:                                 ; 0000..6FFF User RAM
 *S*             47: DRIVERBASE      EQU     $7000   ; 7000..7FFF SDOS I/O Driver for SWTPC 6800
 *S*             48:                                 ; 8000..9FFF IO MAPED MEMORY
 *S*             49:                                 ; A000..A07F 6810 RAM (128 BYTES), used by SWTBUG ROM
 *S*             50: IOBUF           EQU     $A080   ; A080..ADFF BUFFERS FOR I/O DRIVER
 *S*             51: IOBUFEND        EQU     $AE00   ;
 *S*             52: SDOS            EQU     $AE00   ; AE00..DFFF SDOS Operating System (56K compile version)
 *S*             53:                                 ; E000..E7FF SWTBUG ROM
 *S*             54:                                 ; E800..FFFF EPROM
 *S*             55: 




ASM/6800 1.4A0: 0000                    
08/16/82 00:00:00; Page 3; Form 1       
IOSWTPC6800.ASM
 *S*             56: OUTEEE          EQU     $E1D1   ; OUTPUT A CHAR USING SWTPC 6800 SWTBUG ROM
 *S*             57: INEEE           equ     $E1AC   ; INPUT A CHAR (BLOCKING) USING SWTPC 6800 SWTBUG ROM
 *S*             58: SWTMON          EQU     $E0D0   ; SWTBUG COLD START ENTRY POINT
 *S*             59: RDON            equ     $E334+3 ; reader on (skip echo setting in rom)
 *S*             60: RDOFF           equ     $E347   ; reader off
 *S*             61: PNCHON          equ     $E34d   ; punch on 
 *S*             62: PNCHOFF         equ     $E353   ; punch off
 *S*             63: PORECH          equ     $A00C   ; swtbug echo flag (=0 -> echo, $FF -> no echo)
 *S*             64: IRQVECTOR       equ     $A000   ; ON SWTBUG, A000=IRQ VECTOR IN RAM
 *S*             65: 
                 66:              fin
                 67: 
                 68: 
                 69: ;*              Fill in the SDOS-TO-IOPACKAGE COMMUNICATION REGION
                 70: 
  CE00           71:                 ORG     SDOS
                 72: 
CE00 11          73:                 FCB     $11                  ; SDOS:VERSIONNUMBER SDOS VERSION NUMBER (=$AE00)
CE01 0000        74:                 FDB     0                    ; SDOS:LASTERROR    LAST ERROR ENCOUNTERED
CE03 B403        75:                 FDB     CNFGTABLE            ; SDOS:CONFIGURATION TELL SDOS WHERE ALL THE GOODIES ARE
CE05 0000        76:                 FDB     0                    ; SDOS:SERIALNUMBER SERIAL NUMBER
CE07 0000        77:                 FDB     0                    ; SDOS:IOBLOCKPTR   IOBLOCKPTR
CE09 0000        78:                 FDB     0                    ; SDOS:IOCBPOINTER  IOCB POINTER (FOR FILE-TYPE DEVICE DRIVERS)
CE0B 000000      79:                 FCB     0,0,0                ; SET CLOCK TO "MIDNITE"
CE0E 10          80:                 FCB     16                   ; DAY, LET COMMAND INTERPRETER KNOW
CE0F 08          81:                 FCB     8                    ; MONTH, THAT THE TIME HASN'T BEEN SET
CE10 82          82:                 FCB     $82                  ; YEAR 
                 83: 
                 84: 
                 85: ;* patches SDOSINIT AND SDOS O/S
                 86: 
  2000           87: OFS             EQU     SDOS-$AE00      ; Offset for pathing (0=for 56k compile)
                 88: 
  0001           89:              if ram64k=1                
                 90:                 ; No need to apply any patch to loaded SDOS11G64K file. It is generated by 
                 91:                 ; assembling SDOS11G.ASM and has already been edited to disable all the checksum/serial number
                 92:                 ; validations
  0001           93:              else
 *S*             94:                 ; patch the loaded original unmodified SDOS11G56K file, it is the build
 *S*             95:                 ; for 56K RAM machine that comes from CHM and is generated by 
 *S*             96:                 ; assembling SDOS11GPART1.ASM and SDOS11GPART2.ASM and    
 *S*             97: 
 *S*             98:                 ORG $2027
 *S*             99:                 NOP             ; SKIP CHECKSUM VERIFICATION. WILL NOT WORK BECAUSE
 *S*            100:                 NOP             ; SDOS IS BEING PATCHED AND ... WE TRUST THE HW!
 *S*            101:                 ORG $23E9
 *S*            102:                 NOP             ; REMOVE STACK MESSED UP IF START CODE CHECKSUM
 *S*            103:                 NOP             ; IS NOT ZERO BECAUSE IT HAS BEEN PATCHED, AS WE ARE DOING NOW!
 *S*            104:                 ORG $2031
 *S*            105:                 NOP             ; PATCH ROM SERIAL NUMBER CHECHING TO DO NOTHING
 *S*            106:                 NOP
 *S*            107:                 ORG $217A
 *S*            108:                 RTS             ; INMEDIATE RETURN ON CALL TO WRITERANDOM (DO NOT CHECK)
 *S*            109:                 ORG $B00F+OFS
 *S*            110:                 DES             ; PATCH SAFEGUARD ROUTINE TO ITS FINAL FORM




ASM/6800 1.4A0: CE10                    
08/16/82 00:00:00; Page 4; Form 1       
IOSWTPC6800.ASM
 *S*            111:                 INS             ; AS IF IT WAS SET-UP BY SERIALNUMBER.SYS 
 *S*            112:                 RTS             ; THIS ALLOWS TO BYPASS SERIALNUMBER.SYS EXECUTION
 *S*            113:                 RTI
 *S*            114:                 RTI
 *S*            115:                 RTI
 *S*            116:                 RTI
 *S*            117:                 ORG $B408+OFS
 *S*            118:                 LDAA #$01       ; SET CHECKSUM ON COPYRIGHT STRING AS ALLWAYS OK
 *S*            119:                 ORG $DD82+OFS
 *S*            120:                 NOP             ; PATCH TASK USER STACK POINTER 
 *S*            121:                 NOP             ; SO IT NOT GET MESSED UP IF CHECKSUM DOES NOT MATCH
 *S*            122:                 NOP
 *S*            123:                 NOP
 *S*            124:                 NOP
 *S*            125:                 NOP
 *S*            126:                 ORG $B844+OFS   ; PATCH SerialNumberLocation to Point to SerialNumber 
 *S*            127:                 FDB $FFF0
 *S*            128:                 ORG $B837+OFS   ; PATCH EXITCKSUML ROUTINE TO IGNORE CHECKSUM
 *S*            129:                 CLRA
 *S*            130:                 ORG $C6F1+OFS   ; PATCH ERRBOOTCKSUMFAIL, SO BOOT CHECKSUM IS IGNORED
 *S*            131:                 NOP
 *S*            132:                 NOP
 *S*            133:                 ORG $2138       ; PATCH TO ALLOW LOAD A NON-ENCRYPTED SERIALNUMBER.SYS (OR WAHTERES IS THE FIRS
 *S*            134:                 NOP
 *S*            135:                 NOP
 *S*            136:                 ORG $2736       ; PATH  FCC "SERIALNUMBER.SYS" FILENAME
 *S*            137:                 FCC "DEFAULTPROGRAM  "
 *S*            138:                                 ; INSTEAD OF RUNNING SERIALNUMBER.SYS ON STARTUP
 *S*            139:                                 ; JUST RUN DEFAULTPROGRAM (HOPEFULLY BEING A COPY 
 *S*            140:                                 ; OF SDOS USER COMMAND PROCESSOR)
                141:               fin
                142:               
  2000          143:                 ORG $2000       ; PATCH MAIN ENTRY POINT TO SET-UP PROPERLY 
2000 7E3000     144:                 JMP SWTPCINIT   ; DRIVER MEM
                145:                 
  0007          146: SDOS.IOBLOCKPTR EQU $07         ; POINTER TO I/O REQUEST (PASSED TO DRIVERS)
  0015          147: SDOS.RTI        equ $15         ; JMP TO "RETURN FROM INTERRUPT; NO EVENT"
  002D          148: SDOS.ERROR      equ $2D         ; ERROR SUBROUTINE; INLINE 2 BYTE ERROR CODE 
  0030          149: SDOS.ERRORSAVE  equ $30         ; ERROR CODE SAVE ROUTINE; SAVES (X) AS ERROR CODE 
  0033          150: SDOS.ERRORED    equ $33         ; "ERROR CAN'T BE HANDLED BY ME" ENTRY 
  002A          151: SDOS.WAITEVENT  equ $2A         ; JMP TO WAIT FOR EVENT SELECTED BY (X)
  0036          152: SDOS.CHECKRDLEN EQU $36
  000B          153: SDOS.CLOCK      EQU $0B
                154: 
  0000          155: SCBLK.OPCODE    equ $00         ; PRIMARY SYSCALL FUNCTION (OPEN, READ, ETC.)    
  0001          156: SCBLK.WLEN      equ $01         ; WAIT FLAG BIT (0=WAIT) AND SYSCALL BLOCK LENGTH (0..127)      
  0002          157: SCBLK.PARAMS    equ $02         ; PARAMETER BYTES TO OPCODE (SECONDARY OPCODE, CHANNEL #)    
  0004          158: SCBLK.WRBUF     equ $04         ; POINTER TO WRITE DATA BUFFER     
  0006          159: SCBLK.WRLEN     equ $06         ; NUMBER OF BYTES IN WRITE DATA BUFFER
  0008          160: SCBLK.RPLEN     equ $08         ; LENGTH OF REPLY (RESULT OF SYSCALL)    
  000A          161: SCBLK.RDBUF     equ $0A         ; POINTER TO READ DATA BUFFER (WHERE RESULT GOES)     
  000C          162: SCBLK.RDLEN     equ $0C         ; CEILING ON SIZE OF REPLY (READ DATA BUFFER)
  000E          163: SCBLK.DATA      EQU $0E         ; OTHER PARAMETERS FOR SYSCALL; UP TO 127-12 BYTES
                164:  
  0082          165: SPECIALFN.CLEAR equ $0082            




ASM/6800 1.4A0: 2000                    
08/16/82 00:00:00; Page 5; Form 1       
IOSWTPC6800.ASM
  0083          166: SPECIALFN.EEOL  equ $0083            
  0081          167: SPECIALFN.POSN  equ $0081
                168: 
  002B          169: DSKINFO.SECTORDB        EQU $2B
  003C          170: DSKINFO.OPSCOUNT        equ $3c
                171: 
                172: 
  001A          173: FCB.SIZE        equ $001A
  0022          174: IOCB.SIZE       EQU $0022
  0002          175: NMAGICFCBS      EQU     2       ; FOR ERRMSGFCB, SYSFCB
                176: 
                177: 
                178: ;*
                179: ;*      device errors 
                180: ;*
  03E9          181: ERR.EOFHIT                      EQU 1001
  040A          182: ERR.ILLDEVICEOP                 equ 1034
  0411          183: err.programkilled               EQU 1041
  0412          184: ERR.DEVICETIMEDOUT              equ 1042
  0415          185: ERR.DISKREAD                    equ 1045
  0416          186: ERR.DISKWRITE                   equ 1046
  0417          187: ERR.DISKSEEK                    equ 1047
  0418          188: ERR.DSKWRTPROT                  equ 1048                  
  0424          189: ERR.DEVICENOTREADY              equ 1060
  076E          190: ERR.WRONGDISKTYPE               equ 1902
  0773          191: ERR.ACTIVATIONNOTINBUFFER       EQU 1907
  0775          192: err.activationreceived          equ 1909
                193: 
                194: ;*
                195: ;*      DEVICE CONTROL BLOCK DISPLACEMENTS
                196: ;*
  0000          197: DCB.DONEFLAG    EQU     0       ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
  0001          198: DCB.LASTERROR   equ     1       ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NONE )
  0003          199: DCB.NAME        EQU     3       ; POINTER TO DEVICE NAME STRING TERMINATED BY ZERO BYTE
  0005          200: DCB.NEXTDCB     EQU     5       ; POINTER TO NEXT DCB IN LIST OR ZERO
  0007          201: DCB.DRIVER      EQU     7       ; POINTER TO DRIVER ENTRY POINT LIST
  0043          202: dcb.fdunit      equ     $43                     
                203: 
  0013          204: dcb.oilquiescent        equ     $13
  0028          205: dcb.profile             equ     $28
  004D          206: dcb.ringinbase          equ     $4d
  0059          207: dcb.ringoutbase         equ     $59
  005D          208: dcb.ringoutthreshold    equ     $5d
  0067          209: dcb.linebuf             equ     $67
  007A          210: dcb.linebuflen          equ     $7a
  007D          211: DCB.TLBUFFER            equ     $7D
  00A1          212: dcb.outputtoblk         equ     $a1
  00A9          213: dcb.inputtoblk          equ     $a9
  00B1          214: dcb.tcb                 equ     $b1
  00B3          215: dcb.taskstack           equ     $b3
  00B5          216: DCB.RESET               EQU     $B5
  00CA          217: dcb.clearin             equ     $ca
  00FD          218: dcb.vtsize              equ     $fd
                219: 
  0006          220: DCBPOINTER              EQU     $06     ; POINTER TO DEVICE CONTROL BLOCK




ASM/6800 1.4A0: 2000                    
08/16/82 00:00:00; Page 6; Form 1       
IOSWTPC6800.ASM
                221: 
                222: 
  0000          223: DVTYP.TYPE              EQU     $00
  000B          224: DVTYP.CLOCK             EQU     $0B
  0002          225: DVTYP.STAPE             equ     $02
                226: 
  0000          227: RDSI.DISKINFO           EQU     $00
  0002          228: RDSI.LSN                EQU     $02  
  0005          229: RDSI.SECTORBASE         EQU     $05           
  0007          230: RDSI.FLINK              EQU     $07                 
  0009          231: RDSI.BLINK              EQU     $09                 
  000B          232: RDSI.MODIFIED           EQU     $0B             
  000C          233: RDSI.STATE              EQU     $0C                 
  000D          234: RDSI.RETRYCOUNT         EQU     $0D            
  000E          235: RDSI.SECTOR             EQU     $0E
  0010          236: RDSI.TRACK              EQU     $10                
  0012          237: RDSI.CYLINDER           EQU     $12             
  0014          238: RDSI.SIZE               EQU     $14 
                239: 
  0000          240: RDSISTATE.IDLE          EQU     $00
  0001          241: RDSISTATE.READING       EQU     $01         
  0003          242: RDSISTATE.VERIFYING     EQU     $03        
  0002          243: RDSISTATE.WRITING       EQU     $02         
                244: 
  0011          245: CC.DISMOUNTDISK         EQU     $11     ; DEVICE CONTROL OPS: DISMOUNT THE DISK
  001D          246: cc.activationck         EQU     $1D
  0010          247: CC.ECHO                 EQU     $10
  0011          248: CC.NOECHO               EQU     $11
  0014          249: cc.SETACTBLOCK          EQU     $14
                250: 
                251: 
  0004          252: SC.GETTYPE              EQU     $04
  002C          253: SC.GETLINEFLAGS         EQU     $2C
  0001          254: SC.GETCOL               equ     $01
  0002          255: sc.geteof               equ     $02
                256: 
  0000          257: SYSCALL.OPEN            EQU     $00
  0001          258: SYSCALL.CREATE          EQU     $01            
  0002          259: SYSCALL.CLOSE           EQU     $02
  0003          260: SYSCALL.RENAME          EQU     $03
  0004          261: SYSCALL.DELETE          EQU     $04            
  0006          262: SYSCALL.CHAIN           EQU     $06             
  000A          263: SYSCALL.READA           EQU     $0A             
  000B          264: SYSCALL.READB           EQU     $0B             
  000C          265: SYSCALL.WRITEA          EQU     $0C
  000D          266: SYSCALL.WRITEB          EQU     $0D             
  000E          267: SYSCALL.CONTROL         EQU     $0E           
  000F          268: SYSCALL.STATUS          EQU     $0F            
  0011          269: SYSCALL.EXIT            EQU     $11              
  0012          270: SYSCALL.ERROREXIT       EQU     $12         
  0013          271: SYSCALL.SETERROR        EQU     $13
  0014          272: SYSCALL.GETERROR        EQU     $14
  0015          273: SYSCALL.DISPERROR       EQU     $15
  0018          274: SYSCALL.DEBUG           EQU     $18             
                275: 




ASM/6800 1.4A0: 2000                    
08/16/82 00:00:00; Page 7; Form 1       
IOSWTPC6800.ASM
  0008          276: GOBIT                   EQU     $08     ; GO FROM BREAKPOINT/SINGLE STEP
  0010          277: SSTEPBIT                EQU     $10     ; SINGLE STEP REQUEST
  0020          278: BREAKBIT                EQU     $20     ; REQUEST LINE NUMBER BREAKPOINT
  0040          279: TRACEBIT                EQU     $40     ; REQUEST LINE NUMBER TRACE
  0080          280: ABORTBIT                EQU     $80     ; REQUEST PROGRAM ABORT
                281: 
                282: ;*
                283: ;* ONE TIME START-UP INITIALIZATION 
                284: ;* FOR SWTPC 6800. NEEDED BECAUSE 
                285: ;* WE MUST INIT FCB/IOCBS TO ZERO
                286: ;* WE MUST SET UP IOCBPOINTERS PROPERLY
                287: 
  3000          288:                         ORG     $3000
                289: 
3000 CEC081     290: SWTPCINIT       LDX     #FCBS           ; FCB/IOCBS TO ZERO
3003 6F00       291: SINIT1          CLR     0,X
3005 08         292:                 INX
3006 8CC5F9     293:                 CPX     #IOCBPOINTERS   
3009 26F8       294:                 BNE     SINIT1  
300B 86C3       295:                 LDAA    #(IOCBS/256)    ; SET UP IOCBPOINTERS PROPERLY
300D C673       296:                 LDAB    #(IOCBS&$FF)    ; EACH IOCBPOINTER POINTS TO
300F A700       297: SINIT2          STAA    0,X             ; THE CORRESPONDING IOCB
3011 E701       298:                 STAB    1,X
3013 CB22       299:                 ADDB    #(IOCB.SIZE&$FF)
3015 8900       300:                 ADCA    #(IOCB.SIZE/256)
3017 08         301:                 INX
3018 08         302:                 INX
3019 8CC61F     303:                 CPX     #INTERRUPTSTACK
301C 26F1       304:                 BNE     SINIT2
301E 7FC080     305:                 CLR     BASICDEBUGFLAGS
                306:                 ; INIT DONE, RETURN TO SDOSINIT 
3021 FECE03     307:                 LDX     $AE03+OFS       ; $AE03=CODE+SDOS:CONFIGURATION GET THE STACK POINTER
3024 7E2003     308:                 JMP     $2003
                309: 
                310: ;*              BUFFERS FOR I/O DRIVER
                311: ;*              MUST BE INITIALIZED!
                312: 
  C080          313:                 ORG     IOBUF           ; A080..AE00 
                314: 
  0001          315:              if ram64k=1
                316:                 ; ^D not available on RAM64K. SWTBUG ROM not present
  0001          317:              else
 *S*            318: swtgo           jmp     swtret          ; return address from SWTBUG MONITOR
 *S*            319:                                         ; ^D -> enter to monitor, JA080 | JE480 return to sdos
                320:              fin
C080 00         321: BASICDEBUGFLAGS fcb     0               ; set basic debug flags  A083 | E483
                322: 
                323: 
C081 02F2       324: FCBS            RMB     FCB.SIZE*(NIOCHANNELS+2*NDRIVES+NMAGICFCBS) ; MUST PRECEDE IOCBS
C373 0286       325: IOCBS           RMB     IOCB.SIZE*NIOCHANNELS
C5F9 0026       326: IOCBPOINTERS    RMB     NIOCHANNELS*2
C61F 0040       327: INTERRUPTSTACK  RMB     $40     ; STACK SPACE FOR INTERRUPT ROUTINES
C65F 00         328: INTSTACKTOP     FCB     0
C660 00         329: DSKBUFFERPOOL   fcb     0
  079E          330: DSKPOOLSIZE     equ     IOBUFEND-DSKBUFFERPOOL-2




ASM/6800 1.4A0: C660                    
08/16/82 00:00:00; Page 8; Form 1       
IOSWTPC6800.ASM
                331: 
  B400          332:                 ORG     DRIVERBASE      
                333: 
                334:                                 ; THIS IS CODE+SDOS:CONFIGURATION ADDRESS    ; 
                335: 
B400 7EB400     336: SYSCALLIO       JMP     SYSCALLIO       ; SDOS SETS JMP ADDR TO ITS ENTRY POINT
                337: 
B403 BB46       338: CNFGTABLE       FDB     DISKDCBS        ; CNFG:DISKDCBS         DEFAULT DISK MUST BE FIRST
B405 B493       339:                 FDB     DCB.TTY         ; CNFG:DEVICEDCBS        CONSOLE MUST BE FIRST
B407 C5F9       340:                 FDB     IOCBPOINTERS    ; CNFG:IOCBPOINTERS     POINTER LIST TO IOCB'S
B409 13         341:                 FCB     NIOCHANNELS     ; CNFG:NIOCHANNELS      NUMBER OF I/O CHANNELS
B40A C660       342:                 FDB     DSKBUFFERPOOL   ; CNFG:DSKBUFFERPOOL    POINTER TO THE DISK BUFFER POOL
B40C 079E       343:                 FDB     DSKPOOLSIZE     ; CNFG:DSKPOOLSIZE      SIZE OF THE BUFFER POOL
B40E C03A       344:                 FDB     ATTNCHECK       ; CNFG:ATTNCHECK        ADDRESS OF ATTENTION CHECK ROUTINE
B410 C03A       345:                 FDB     DEBUGSYSCALL    ; CNFG:DEBUGGER RMB     ADDRESS OF DEBUGGER (0 IF NONE)
B412 B400       346:                 FDB     DRIVERBASE      ; CNFG:DRIVERBASE       LOWEST ADDRESS USED BY DRIVERS = END OF USER RA
B414 B427       347:                 FDB     INTSETUP        ; CNFG:INTSETUP         POINTER TO INTERRUPT SYSTEM SETUP ROUTINE
B416 7EB43A     348:                 JMP     INTDISABLE      ; CNFG:INTDISABLE       SUBROUTINE (OR "JMP") TO DISABLE ALL INTERRUPTS
B419 7EB43C     349:                 JMP     INTENABLE       ; CNFG:INTENABLE        SUBROUTINE (OR "JMP") TO ENABLE ALL INTERRUPTS
B41C 7EB43F     350:                 JMP     INTRTI          ; CNFG:INTRTI           CODE TO ENABLE PRIORITY INTERRUPT AND DO RTI (U
B41F C65F       351:                 FDB     INTSTACKTOP     ; CNFG:INTERRUPTSTACK   POINTER TO LAST BYTE OF INTERRUPT STACK SPACE
B421 B440       352:                 FDB     IOINTPOLL       ; CNFG:IOINTPOLL        POINTER TO I/O INTERRUPT SERVICE DEVICE POLL RO
B423 B45C       353:                 FDB     TASKQUEUE       ; CNFG:TASKQUEUE        POINTER TO FIRST TASK IN TASK QUEUE
B425 B450       354:                 FDB     TIMEOUTQUEUE    ; CNFG:TIMEOUTLIST      POINTER TO CHAINED LIST OF TIMEOUT BLOCKS
                355: 
                356: 
B427 CEB43E     357: INTSETUP        LDX #IRQINT
B42A FFFFF8     358:                 STX IRQVECTOR           ; ON SWTBUG, A000=IRQ VECTOR IN RAM
B42D BDBD6B     359:                 JSR INTDK               ; INIT THE DISK SYSTEM
B430 CEB4CA     360:                 ldx     #InputBuf       ; init Input buf head and and pointerd
B433 FFB5C4     361:                 stx     InputBufP0      ; to set as no chars has been typed yet (empty buf)
B436 FFB5C6     362:                 stx     InputBufP1
B439 39         363:                 RTS
B43A 0F         364: INTDISABLE      SEI
B43B 39         365:                 RTS
B43C 0E         366: INTENABLE       CLI
B43D 39         367:                 RTS
B43E 01         368: IRQINT          NOP
B43F 3B         369: INTRTI          RTI     
                370: 
B440 4F         371: IOINTPOLL       CLRA
                372:                 ; LDA $8xxx                     ; No MP-T TIMER INTERRUPT
B441 46         373:                 RORA
B442 2400       374:                 BCC     NOTIMERINT
                375:                 ; LDX   #CLOCKDCB
                376:                 ; JMP   CLOCKSTATE
B444 FEB44E     377: NOTIMERINT      LDX     BADINTERRUPTCOUNT       ; CAN'T FIGURE OUT WHO IT IS...
B447 08         378:                 INX                             ; BUMP CRAZY INTERRRUPT COUNTER
B448 FFB44E     379:                 STX     BADINTERRUPTCOUNT   
B44B 7ECE15     380:                 JMP     SDOS+SDOS.RTI           ; AND HOPE IT WENT AWAY !   
                381: 
B44E 0000       382: BADINTERRUPTCOUNT       FDB     0               ; # OF INTERRUPTS FROM UNKNOWN DEVICES
                383: 
B450 0000       384: TIMEOUTQUEUE    FDB     0                       ; TIMEOUT:LINK   POINTER TO NEXT TIMEOUTBLOCK
B452 0000       385:                 FDB     0                       ; TIMEOUT:FUSE.  16 BIT TIMEOUT COUNT (1/60 SEC UNITS); 0--> NO




ASM/6800 1.4A0: B454                    
08/16/82 00:00:00; Page 9; Form 1       
IOSWTPC6800.ASM
B454 B458       386:                 FDB     FUSEBURNEDUP            ; TIMEOUT:ROUTINE POINTER TO TIMEOUT INTERRUPT ROUTINE FOR DEVI
B456 B493       387:                 FDB     DCB.TTY                 ; TIMEOUT:DCB    POINTER TO DCB BEING TIMED OUT
                388: 
B458 01         389: FUSEBURNEDUP    NOP
                390:                 ; BSR     ABORTQUANTUM
B459 7ECE15     391:                 JMP     SDOS+SDOS.RTI
                392: 
  0000          393: IGN             EQU     0                       ; IGNORE VALUE
                394: 
B45C 0000       395: TASKQUEUE       FDB     0                       ; TCB:LNK        POINTER TO NEXT TCB IN QUEUE
B45E B478       396:                 FDB     TASKSTACKINIT           ; TCB:STACK      STACK POINTER FOR TASK
B460 0000       397:                 FDB     0                       ; TCB:COND       TASK'S WAKE UP ROUTINE
B462 0000       398:                 FDB     0                       ; TCB:PARAM      PARAMETER TO TCB:COND ROUTINE
B464 00000000   399:                 FCB     0,0,0,0,0,0,0,0         ; TCB:SCRATCHPAD SPACE FOR TASK'S SCRATCHPAD (LOCATIONS 0-7)
B46C B493       400:                 FDB     DCB.TTY                 
B46E 000A       401:                 RMB     10
B478 00000000   402: TASKSTACKINIT   FCB     0,0,IGN,IGN,IGN,IGN     ; ZERO CC SO INTERRUPTS ARE ENABLED
B47E B482       403:                 FDB     TASKSETUP               ; INITIAL PC OF FIRST TASK
B480 00         404: TASKSTACKTOP    FCB     0               
B481 00         405: TASKWAKEUPFLAG  FCB     0                       ; TASK IS SLEEPING
B482 CEB481     406: TASKSETUP       LDX     #TASKWAKEUPFLAG
B485 BDCE2A     407:                 JSR     SDOS+SDOS.WAITEVENT     ; WAIT FOR EVENT (X) TO GO NON-ZERO
B488 20F8       408:                 BRA     TASKSETUP
                409: 
                410: 
                411: ; DEVICE CONTROL BLOCK FOR TTY CONSOLE
                412: 
B48A 434F4E53   413: dcbname.tty     fcc     'CONSOLE:'
B492 00         414:                 fcb     0
                415: 
B493 01         416: DCB.TTY         FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
B494 0000       417:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
B496 B48A       418:                 FDB     dcbname.tty             ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
B498 B965       419:                 FDB     DCB.PORT                ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
B49A B49C       420:                 FDB     CONSOLEDRIVER           ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
                421: 
                422: ; DEVICE DRIVER BLOCK FOR TTY CONSOLE
                423: 
B49C B653       424: CONSOLEDRIVER   FDB     OPEN.TTY        ; DRIVER:OPEN   OPEN FILE
B49E B677       425:                 FDB     CLOSE.TTY       ; DRIVER:CLOSE  CLOSE FILE
B4A0 B751       426:                 FDB     READA.TTY       ; DRIVER:READA  READ ASCII
B4A2 B8BC       427:                 FDB     WRITEA.TTY      ; DRIVER:WRITEA WRITE ASCII
B4A4 B72F       428:                 FDB     READB.TTY       ; DRIVER:READB  READ BINARY
B4A6 B8C6       429:                 FDB     WRITEB.TTY      ; DRIVER:WRITEB WRITE BINARY
B4A8 B653       430:                 FDB     OPEN.TTY        ; DRIVER:CREATE CREATE FILE
B4AA B4B8       431:                 FDB     ILLDEVICEOP     ; DRIVER:RENAME RENAME FILE
B4AC B4B8       432:                 FDB     ILLDEVICEOP     ; DRIVER:DELETE DELETE FILE
B4AE B6AB       433:                 FDB     CONTROL.TTY     ; DRIVER:CONTROL        DO CONTROL OPERATION
B4B0 B67A       434:                 FDB     STATUS.TTY      ; DRIVER:STATUS READ DEVICE (DRIVER) STATUS
B4B2 B6C0       435:                 FDB     RESET.TTY       ; DRIVER:RESET  RESET DRIVER (ON BOOT)
B4B4 B4B8       436:                 FDB     ILLDEVICEOP     ; DRIVER:STARTIO        power-fail restart--dream on!
                437: 
B4B6 0C         438: OKRTS           CLC
B4B7 39         439:                 RTS
                440: 




ASM/6800 1.4A0: B4B8                    
08/16/82 00:00:00; Page 10; Form 1      
IOSWTPC6800.ASM
B4B8 BDCE2D     441: ILLDEVICEOP     JSR     SDOS+SDOS.ERROR
B4BB 040A       442:                 FDB     ERR.ILLDEVICEOP
B4BD BDCE30     443: ERRETX          JSR     SDOS+SDOS.ERRORSAVE
B4C0 7ECE33     444:                 JMP     SDOS+SDOS.ERRORED
                445: 
                446: 
B4C3 0001       447: LMODE           RMB     1               ; =0 -> reada in non-line mode, >0 -> reada line mode 
B4C4 0002       448: LEN             RMB     2               ; DATA BUFFER LENGTH
B4C6 0002       449: PDATA           RMB     2               ; ADDR OF DATA 
B4C8 0002       450: RPLEN           RMB     2               ; REPLY DATA BUFFER LENGTH
                451: 
  00FA          452: InputBufLen     EQU     250             ; length of input buffer (max 255)
B4CA 00FA       453: InputBuf        RMB     InputBufLen     ; input buffer ADDR
B5C4 0002       454: InputBufP0      RMB     2               ; addr of next char into InputBuffer TO BE PROCESSED (HEAD OF BUFFER)
B5C6 0002       455: InputBufP1      RMB     2               ; addr of next free char into InputBuffer (END OF BUFFER)
                456: 
B5C8 0001       457: EOFFLAG         RMB     1               ; =1 -> EOF = input line processed
B5C9 0001       458: ECHOFLAG        rmb     1               ; =0 -> NO ECHO 
B5CA 0001       459: ncol            rmb     1               ; number of chars printed in the current line
B5CB 0001       460: basicflags      rmb     1               ; flags for basic control chars for debugging
B5CC 0001       461: CTRLCNUM        RMB     1               ; NUMBER OF CONTROL-C TYPED IN SEQUENCE
B5CD 0001       462: expandtabflag   rmb     1
B5CE 0001       463: crflag          rmb     1               ;1=if prev char recv in port: was a <CR>
                464: 
B5CF 0010       465: ACTIVATIONCHARSVECTOR   RMB 16          ; Activation Chars vector
B5DF 0001       466: ActivationCharSensed    rmb 1           ; Activation Char typed by user
                467: 
  0001          468:              if ram64k=1
                469:                 ; on 64K RAM machine, SWTBUG rom not present. Here goes the console I/O routines
  FF04          470: ACIAPORT        EQU     $FF04   ; ACIA PORT IN SWTBUG 64K RAM
B5E0 00         471: PORECH          FCB     0       ; ECHO (=0 -> echo, $FF -> no echo)
                472: 
                473:                 ; *OUTPUT ONE CHARACTER
B5E1 37         474: OUTEEE          PSHB            ; SAVE ACC B
B5E2 DF00       475:                 STX     $00     ; STORE INDEX REGISTER
B5E4 CEFF04     476:                 LDX     #ACIAPORT
B5E7 E601       477:                 LDAB    1,X
B5E9 E103       478:                 CMPB    3,X
B5EB C611       479: ACIOUT          LDAB    #$11
B5ED E700       480:                 STAB    0,X
B5EF E600       481: ACIOU1          LDAB    0,X
B5F1 57         482:                 ASRB
B5F2 57         483:                 ASRB
B5F3 24FA       484:                 BCC     ACIOU1  ; ACIA NOT READY
B5F5 A701       485:                 STAA    1,X     ; OUTPUT CHARACTER **log OUTCH:A
B5F7 33         486: RES             PULB            ; RESTORE ACC B
B5F8 DE00       487:                 LDX     $00
B5FA 39         488:                 RTS
                489: 
                490:                 ; *INPUT ONE CHAR INTO ACC B
B5FB 37         491: INEEE           PSHB            ; SAVE ACC B
B5FC DF00       492:                 STX     $00     ; STORE INDEX REGISTER
B5FE CEFF04     493:                 LDX     #ACIAPORT
B601 E601       494:                 LDAB    1,X
B603 E103       495:                 CMPB    3,X




ASM/6800 1.4A0: B605                    
08/16/82 00:00:00; Page 11; Form 1      
IOSWTPC6800.ASM
B605 8615       496:                 LDAA    #$15    ; RECONFIG FOR 8 BIT, 1 SB
B607 A700       497:                 STAA    0,X     ;             **troff
B609 A600       498: ACIAIN          LDAA    0,X
B60B 47         499:                 ASRA
B60C 24FB       500:                 BCC     ACIAIN  ; NOT READY
B60E A601       501:                 LDAA    1,X     ; LOAD CHAR   **tron
B610 F6B5E0     502:                 LDAB    PORECH
B613 27D6       503:                 BEQ     ACIOUT  ; ECHO
B615 20E0       504:                 BRA     RES     ; DON'T ECHO
                505: 
B617 8611       506: RDON            LDAA    #$11    ; RON CHAR.
B619 20C6       507:                 BRA     OUTEEE
B61B 8613       508: RDOFF           LDAA    #$13    ; TURN READER OFF
B61D 20C2       509:                 BRA     OUTEEE
B61F 8612       510: PNCHON          LDAA    #$12    ; punch on 
B621 20BE       511:                 BRA     OUTEEE
B623 8614       512: PNCHOFF         LDAA    #$14    ; punch off
B625 20BA       513:                 BRA     OUTEEE
                514:                 
  0001          515:              else
 *S*            516:                 ; use SWTBUG rom for INEEE and OUTEEE, and so ... 
                517:              fin
                518: 
                519:                 ; print a char 
                520: 
B627 810D       521: prtch           cmpa    #13             ; <CR> RESET COLUMN COUNT
B629 270E       522:                 beq     prt1
B62B 8108       523:                 cmpa    #8              ; backSpace
B62D 2712       524:                 beq     prt4            
B62F 853C       525:                 bita    #60             ; DO NOT INCR NCOL ON CONTROL CHARS
B631 2703       526:                 BEQ     PRT3
B633 7CB5CA     527: prt2            inc     ncol            ; INCR NCOL ON REGULAR $20-$7F
B636 7EB5E1     528: prt3            jmp     outeee
B639 7FB5CA     529: prt1            clr     ncol
B63C 7AB5CA     530:                 dec     ncol
B63F 20F5       531:                 bra     prt3
B641 BDB5E1     532: prt4            jsr     outeee
B644 8620       533:                 ldaa    #32
B646 BDB5E1     534:                 jsr     outeee
B649 8608       535:                 ldaa    #8
B64B 7EB5E1     536:                 jmp     outeee
                537: 
                538:                 ; read keyboard key pressed 
                539: 
B64E 01         540: inch            nop                             ; **troff
B64F BDB5FB     541:                 jsr     ineee                   ; read the keyboard (blocking)
B652 39         542:                 rts                             ; **tron
                543: 
B653 7FB5C8     544: OPEN.TTY        CLR     EOFFLAG         ; RESET EOF FLAG
B656 8601       545:                 LDAA    #1
B658 B7B5C9     546:                 STAA    ECHOFLAG        ; set ECHO ON (to be done by this iopackage)
B65B 86FF       547:                 ldaa    #255
B65D B7B5E0     548:                 staa    PORECH          ; DISABLE ECHO into swtbug 
B660 7FB5CA     549:                 clr     ncol            ; init numbers of chars printed in line
B663 CEB5CF     550:                 LDX     #ACTIVATIONCHARSVECTOR




ASM/6800 1.4A0: B666                    
08/16/82 00:00:00; Page 12; Form 1      
IOSWTPC6800.ASM
B666 8610       551:                 LDAA    #16
B668 6F00       552: OPEN.TTY1       CLR     0,X             ; reset the 16 bytes of Activation Char vector
B66A 08         553:                 INX
B66B 4A         554:                 DECA
B66C 26FA       555:                 BNE     OPEN.TTY1       
B66E 7FB5CC     556:                 CLR     CTRLCNUM        ; INIT ^c COUNT
B671 7FB5CB     557:                 clr     basicflags
B674 7EB4B6     558:                 JMP     OKRTS           ; TTY IS ALWAYS OPEN
                559: 
B677 7EB4B6     560: CLOSE.TTY       JMP     OKRTS           ; AND TTY CANNOT BE CLOSED
                561: 
                562: 
B67A FECE07     563: STATUS.TTY      ldx     SDOS+SDOS.IOBLOCKPTR
B67D 8600       564:                 ldaa    #0  ; vt:sclen
B67F E603       565:                 ldab    scblk.params+1,x        ; get sc status opcode
B681 C12C       566:                 cmpb    #SC.GETLINEFLAGS
B683 260B       567:                 bne     st0
B685 B6B5CB     568:                 ldaa    basicflags              ; get the basic flags
                569: 
B688 BAC080     570:                 oraa    BASICDEBUGFLAGS         ; or basic debug flags 
                571: ;               oraa #TRACEBIT                  ; turn on basic trace 
                572: 
B68B 7FB5CB     573:                 clr     basicflags              ; ans clear them
B68E 2014       574:                 bra     statusret1
B690 C101       575: st0             cmpb    #SC.GETCOL
B692 2605       576:                 bne     st1
B694 B6B5CA     577:                 ldaa    ncol                    ; get the bumber of columns used in current line
B697 200B       578:                 bra     statusret1
B699 C102       579: st1             cmpb    #sc.geteof
B69B 2605       580:                 bne     st2             
B69D B6B5C8     581:                 ldaa    eofflag
B6A0 2002       582:                 bra     statusret1
B6A2 8600       583: st2             ldaa    #0                      ; any other request returns 0
B6A4 EE0A       584: statusret1      LDX     scblk.rdbuf,x           ; return 1 byte status
B6A6 A700       585:                 staa    0,X                     ; STORE IN RDBUF
B6A8 7EB4B6     586:                 JMP     OKRTS 
                587: 
B6AB FECE07     588: CONTROL.TTY     ldx     sdos+sdos.ioblockptr
B6AE E603       589:                 ldab    scblk.params+1,x
B6B0 C11D       590:                 cmpb    #cc.activationck
B6B2 271D       591:                 beq     dactivationck
B6B4 C110       592:                 cmpb    #cc.ECHO
B6B6 270B       593:                 beq     dECHO
B6B8 C111       594:                 cmpb    #cc.NOECHO
B6BA 270F       595:                 beq     dnoecho
B6BC C114       596:                 cmpb    #cc.SETACTBLOCK
B6BE 2721       597:                 beq     dsetactivation
B6C0 7EB4B6     598: RESET.TTY       JMP     OKRTS           ; TTY DOES NOT NEED RESET
                599: 
B6C3 8601       600: DECHO           LDAA    #1
B6C5 B7B5C9     601:                 STAA    ECHOFLAG
B6C8 7EB4B6     602:                 JMP     OKRTS
B6CB 7FB5C9     603: DNOECHO         CLR     ECHOFLAG
B6CE 7EB4B6     604:                 JMP     OKRTS           
                605:                 




ASM/6800 1.4A0: B6D1                    
08/16/82 00:00:00; Page 13; Form 1      
IOSWTPC6800.ASM
B6D1 FEB5C4     606: dactivationck   ldx     InputBufp0              ; Is input Buf empty?
B6D4 BCB5C6     607:                 cpx     InputBufP1
B6D7 2705       608:                 beq     dactivation1            ; br if so (reada will block)
B6D9 BDCE2D     609:                 jsr     sdos+sdos.error         ; something in input buffer
B6DC 0775       610:                 fdb     err.activationreceived  ; signal it (reada will not block)
B6DE 7EB4B6     611: dactivation1    JMP     OKRTS                   
                612: 
                613: 
B6E1 BDB8AB     614: dsetactivation  jsr     GETWRITEPARAMS          ; set the activation chars vector
B6E4 CEB5CF     615:                 ldx     #ACTIVATIONCHARSVECTOR  
B6E7 FFBD62     616:                 stx     ddata
B6EA C610       617:                 ldab    #16
B6EC FEB4C6     618: dsetact1        ldx     pdata
B6EF A600       619:                 ldaa    0,x
B6F1 08         620:                 inx
B6F2 FFB4C6     621:                 stx     pdata
B6F5 FEBD62     622:                 ldx     ddata
B6F8 A700       623:                 staa    0,x     
B6FA 08         624:                 inx
B6FB FFBD62     625:                 stx     ddata
B6FE 5A         626:                 decb
B6FF 26EB       627:                 bne     dsetact1
B701 7EB4B6     628:                 jmp     okrts
                629: 
                630:                 ; read params from READA/B SYSCALL
                631:                 ; set LMODE, PDATA, LEN, clears RPLEN
                632: 
B704 FECE07     633: getreadparams   ldx     sdos+sdos.ioblockptr
B707 A603       634:                 ldaa    scblk.params+1,x        ; if LMODE=0 -> reada in non-line mode, >0 -> reada line mode 
B709 B7B4C3     635:                 staa    LMODE
B70C EE0C       636:                 LDX     scblk.rdlen,x           ; LEN=reada/B SYSCALL buffer length
B70E FFB4C4     637:                 stX     LEN
B711 FECE07     638:                 LDX     SDOS+SDOS.IOBLOCKPTR    ; INIT RPLEN TO ZERO (ACTUAL CHARS READ INTO SYSCALL BUFFER)
B714 6F08       639:                 CLR     scblk.RPLEN,x
B716 6F09       640:                 CLR     scblk.RPLEN+1,x
B718 FECE07     641:                 LDX     SDOS+SDOS.IOBLOCKPTR    ; PDATA=addr of INPUT buffer 
B71B EE0A       642:                 LDX     scblk.rdbuf,x
B71D FFB4C6     643:                 STX     PDATA
B720 39         644:                 rts
                645:                 
                646:                 ; save x-reg as rplen (numb of chars read) as syscall return 
B721 DF00       647: setrplen        stx     $00
B723 9600       648:                 ldaa    $00
B725 D601       649:                 ldab    $01
B727 FECE07     650:                 LDX     SDOS+SDOS.IOBLOCKPTR    
B72A A708       651:                 staa    scblk.RPLEN,x
B72C E709       652:                 stab    scblk.RPLEN+1,x
B72E 39         653:                 rts
                654: 
B72F BDB704     655: readb.TTY       jsr     getreadparams           ; get syscall params
B732 FEB4C4     656:                 ldx     len                     ; readb will read
B735 BDB721     657:                 jsr     setrplen                ; exactly len chars from keyboard
B738 FEB4C4     658: readb1          ldx     len                     ; input buf full? (remaining len=0)
B73B 2712       659:                 beq     readb2                  ; br if buf full
B73D 09         660:                 dex                             ; no, decr remaining len




ASM/6800 1.4A0: B73E                    
08/16/82 00:00:00; Page 14; Form 1      
IOSWTPC6800.ASM
B73E FFB4C4     661:                 stx     len
B741 BDB64E     662:                 jsr     inch                    ; read char from keyboard
B744 FEB4C6     663:                 ldx     pdata                   ; input buf addr
B747 A700       664:                 staa    0,x                     ; store into input buf
B749 08         665:                 inx
B74A FFB4C6     666:                 stx     pdata
B74D 20E9       667:                 bra     readb1
B74F 0C         668: readb2          clc
B750 39         669:                 rts             
                670: 
B751 BDB704     671: reada.TTY       jsr     getreadparams           ; get syscall params
B754 B6B4C3     672:                 LDAA    LMODE                   ; CHECK IF NON-LINE MODE READ BUT BUF LEN > 0
B757 2608       673:                 BNE     reada1                  ; BR BECAUSE IN LINE MODE
B759 FEB4C4     674:                 LDX     LEN
B75C 2703       675:                 BEQ     reada1
B75E 7EB4B8     676:                 jmp     ILLDEVICEOP             ; ERROR BECAUSE NON-LINE MODE READ BUT BUF LEN > 0
B761 FEB4C4     677: reada1          LDX     LEN                     ; IS BUFFER IS ZERO BYTES
B764 2605       678:                 BNE     READA2                  ; THE JUST RETURN FROM READ 
B766 BDCE2D     679:                 jsr     sdos+sdos.error         ; signaling "Activation not in buffer" error
B769 0773       680:                 fdb     ERR.ACTIVATIONNOTINBUFFER                 
B76B FEB5C4     681: READA2          ldx     InputBufp0              ; LEN IS >0 -> CHECK Is input Buf empty?
B76E BCB5C6     682:                 cpx     InputBufP1
B771 2603       683:                 bne     reada3                  ; br if not
B773 BDB7D1     684:                 jsr     readInputBuf            ; input buffer empty -> read it from keyboard
B776 CE0000     685: reada3          LDX     #0
B779 FFB4C8     686:                 STX     RPLEN                   ; INIT RPLEN
B77C FEB5C4     687: READA4          LDX     iNPUTBUFP0              ; CHECK IF INPUT BUF IS EMPTY
B77F BCB5C6     688:                 CPX     iNPUTBUFP1              
B782 2743       689:                 BEq     READA6                  ; BR IF EMPTY 
B784 FEB5C4     690:                 LDX     iNPUTBUFP0              ; GET CHAR FROM INPUT BUFFER
B787 A600       691:                 LDAA    0,X                                     
B789 08         692:                 INX
B78A FFB5C4     693:                 STX     INPUTBUFP0
B78D 811A       694:                 cmpa    #26                     ; char is ^Z ? 
B78F 2736       695:                 beq     reada6                  ; br if so to signal eof
B791 FEB4C6     696:                 LDX     PDATA                   ; STORE CHAR IN SYSCALL BUFFER
B794 A700       697:                 STAA    0,X
B796 08         698:                 INX     
B797 FFB4C6     699:                 STX     PDATA
B79A 810D       700:                 cmpa    #13                     ; <cr> resets ncol to 0
B79C 2605       701:                 bne     rd1ncol
B79E 7FB5CA     702:                 clr     ncol
B7A1 2003       703:                 bra     rd2ncol
B7A3 7CB5CA     704: rd1ncol         inc     ncol                    ; incr ncol chars processed    
B7A6 FEB4C8     705: rd2ncol         LDX     RPLEN                   ; INCR RPLEN NUM OF BYTES STORED
B7A9 08         706:                 INX                             ; IN SYSCALL BUFFER
B7AA FFB4C8     707:                 STX     RPLEN
B7AD 36         708:                 psha
B7AE BDB721     709:                 JSR     setrplen                
B7B1 32         710:                 pula
B7B2 B1B5DF     711:                 CMPA    ActivationCharSensed    ; CHAR IS activation char sensed ?
B7B5 2603       712:                 BNE     READA5                  ; BR IF NOT
B7B7 7EB4B6     713:                 JMP     OKRTS                   ; YES! ACTIVATION CHAR IN READ BUFFER -> EXIT FROM SYSCALL, NO 
B7BA FEB4C8     714: READA5          LDX     RPLEN                   ; CHECK IF SYSCALL BUFFER
B7BD BCB4C4     715:                 CPX     LEN                     ; IS FULL




ASM/6800 1.4A0: B7C0                    
08/16/82 00:00:00; Page 15; Form 1      
IOSWTPC6800.ASM
B7C0 26BA       716:                 BNE     READA4                  ; BR IF NOT ...
B7C2 BDCE2D     717:                 jsr     sdos+sdos.error         ; BUFFER IS FULL -> RETURN FROM SYSCALL 
B7C5 0773       718:                 fdb     ERR.ACTIVATIONNOTINBUFFER ; signaling "Activation not in buffer" error
B7C7 8601       719: READA6          LDAA    #1                      ; SIGNAL EOF FLAG
B7C9 B7B5C8     720:                 STAA    EOFFLAG
B7CC BDCE2D     721:                 jsr     sdos+sdos.error         ; NO MORE CHARS IN INPUT BUFFER
B7CF 03E9       722:                 fdb     err.eofhit              ; return from read signaling eof CONDITION
                723:                 
                724:                 
B7D1 7FB5CC     725: ReadInputBuf    CLR     CTRLCNUM
B7D4 7FB5DF     726:                 CLR     ActivationCharSensed    ; no activation char sensed
B7D7 7FB5CD     727:                 clr     expandtabflag           ; tabs should be echoed as ^I if echo is enabled
B7DA CEB4CA     728: RINBUF          ldx     #InputBuf               ; init Input buf head and and pointer
B7DD FFB5C4     729:                 stx     InputBufP0              ; to set as no chars has been typed yet (empty buf)
B7E0 FFB5C6     730:                 stx     InputBufP1
B7E3 BDB64E     731: RINCH           jsr     inch                    ; READ KEY FROM KEYBOARD
B7E6 B7B989     732:                 staa    ch                      ; save
B7E9 8103       733:                 CMPa    #3                      ; is ^C (BREAK)
B7EB 2612       734:                 BNE     RI1
B7ED BDB8F5     735: RCTRLC          jsr     write.chcr.echo         ; if echo set, write ^C on screen, then <cr><LF>
B7F0 7CB5CC     736:                 INC     CTRLCNUM                ; INC COUNTER OF ^c'S ISSUED
B7F3 B6B5CC     737:                 LDAA    CTRLCNUM
B7F6 8102       738:                 CMPA    #2      
B7F8 26E0       739:                 BNE     rINBUF                  ; BR IF IS THE FIRST ONE: DISCARD CURRENT LINE
B7FA BDCE2D     740:                 jsr     sdos+sdos.error         ; TWO ^C IN SEQUENCE
B7FD 0411       741:                 FDB     err.programkilled       ; KILL THE CURRENT PROGRAM
B7FF 7FB5CC     742: RI1             CLR     CTRLCNUM                ; KEY READ IS NOT ^c -> RESET COUNT
B802 8108       743:                 CMPA    #8                      ; IS ^H (BACKSPACE)
B804 2704       744:                 BEQ     RBACKSPACE
B806 817F       745:                 CMPA    #127                    ; OR IS ROUBOUT/DEL
B808 2605       746:                 BNE     RI2                     ;    BR IF NOT
B80A BDB889     747: RBACKSPACE      JSR     BACKSPACE               ; DEL LAST TYPED CHAR FROM INPUTBUF AND (IF ECHO ENABLED) FROM 
B80D 20D4       748:                 BRA     RINCH                   ; IF SO, IGNORE THE BACKSPACE KEY AND BR TO KEEP READING KEYBOA
B80F 8104       749: RI2             CMPA    #4                      ; IS ^D ? (GO TO DEBUG MONITOR)   
B811 2606       750:                 BNE     RI3
B813 BDB8F5     751: RCTRLD          jsr     write.chcr.echo         ; if echo set, write ^D on screen, then <cr><LF>
  0001          752:              if ram64k=1
B816 7EB7E3     753:                 JMP     RINCH                   ; RAM64K does not uses SWTBUG ROM, so ^D does nothing
  0001          754:              else
 *S*            755:                 STS     SWTRET+1                ; SAVE STACK POINTER
 *S*            756:                 JMP     SWTMON                  ; JUMP TO SWTBUG monitor. return from monitor with JA080 comman
 *S*            757: SWTRET          LDS     #$A07F                  ; SWTBUG MONITOR GO COMMAND RETURNS HERE. RESTORE STACK POINTER
 *S*            758:                 ldaa    #255
 *S*            759:                 staa    PORECH                  ; DISABLE ECHO FOR ACIA
 *S*            760:                 JMP     RINCH                   ; JMP TO KEEP READING KEYBOARD AS NOTHING HAPPEND
                761:              fin
B819 C620       762: RI3             ldab    #BREAKBIT               ; 
B81B 8102       763:                 CMPA    #2                      ; IS ^B? (REQUEST LINE NUMBER BREAKPOINT in a basic program)
B81D 2712       764:                 BEQ     Rbas                    ;    br if SO ...
B81F C610       765:                 ldab    #SSTEPBIT       
B821 8116       766:                 cmpa    #$16                    ; IS ^V? (REQUEST SINGLE STEP in a basic program)
B823 270C       767:                 BEQ     Rbas                    ;    br if SO ...
B825 C640       768:                 ldab    #TRACEBIT               
B827 8114       769:                 cmpa    #$14                    ; IS ^T? (REQUEST LINE NUMBER TRACE in a basic program)
B829 2706       770:                 BEQ     Rbas                    ;    br if SO ...




ASM/6800 1.4A0: B82B                    
08/16/82 00:00:00; Page 16; Form 1      
IOSWTPC6800.ASM
B82B C608       771:                 ldab    #GOBIT          
B82D 8107       772:                 cmpa    #7                      ; IS ^G? (GO FROM BREAKPOINT/SINGLE STEP in a basic program)
B82F 2608       773:                 Bne     RI4                     ;    br if SO ...
B831 FAB5CB     774: RBAS            orab    basicflags              ; add current basic flags
B834 CA01       775:                 orab    #1                      ; SET BASIC KEYB POLL ACTIVE ON SC:GETLINEFLAGS
B836 F7B5CB     776:                 stab    basicflags              ; store back
  B839          777: RI4                                             
B839 FEB5C6     778:                 LDX     INPUTBUFP1              ; CHECK IF INPUTBUF IS FULL
B83C 8CB5C3     779:                 CPX     #INPUTBUF+INPUTBUFLEN-1
B83F 2605       780:                 BNE     RSTORECH                ; BR IF BUF HAS ROOM LEFT TO STORE THE TYPED CHAR
B841 36         781:                 PSHA                            ; IF INPUTBUF FULL, THEN ...
B842 BDB889     782:                 JSR     BACKSPACE               ; ... DEL LAST TYPED CHAR FROM INPUTBUF AND (IF ECHO ENABLED) F
B845 32         783:                 PULA                            ; TO REPLACE IT WITH NEW TYPED CHAR
B846 FEB5C6     784: RSTORECH        LDX     INPUTBUFP1              
B849 A700       785:                 STAA    0,X                     ; STORE CHAR IN INPUTBUF
B84B 08         786:                 inx
B84C FFB5C6     787:                 stx     inputbufp1
B84F 36         788:                 psha
B850 BDB8FA     789:                 JSR     WRITEA.CH.echo          ; ECHO IT TO SCREEN 
B853 32         790:                 pula
B854 810D       791:                 CMPa    #13                     ; IS <CR> ? 
B856 272A       792:                 BEQ     ActivChar               ;   BR IF SO ...
B858 811A       793:                 CMPa    #26                     ; IS ^Z ? 
B85A 2605       794:                 bne     ri5                     ;   BR IF NOT ...
B85C BDB8F8     795:                 jsr     write.cr.echo           ; write a <cr> after ^Z
B85F 2027       796:                 Bra     Rendofinput             ; then end reading the line
B861 36         797: ri5             psha                            ; now check if the char in a-reg is an activation char
B862 8407       798:                 anda    #7
B864 C601       799:                 ldab    #1                      ; set to 1 the bit number
B866 4D         800: ri6             tsta                            ; corresponding to (char & 7)
B867 2704       801:                 beq     ri7
B869 58         802:                 aslb            
B86A 4A         803:                 deca
B86B 20F9       804:                 bra     ri6
B86D 32         805: ri7             pula
B86E 47         806:                 asra                            ; a=byte index on ACTIVATIONCHARSVECTOR
B86F 47         807:                 asra                            ; b=bit mask 
B870 47         808:                 asra
B871 B7B878     809:                 staa    ActivByte+1     
B874 CEB5CF     810:                 ldx     #ACTIVATIONCHARSVECTOR  ; check ACTIVATIONCHARSVECTOR to 
B877 A600       811: ActivByte       ldaa    0,X                     ; determine if char is an activation char
B879 D700       812:                 stab    $00
B87B 9400       813:                 anda    $00
B87D 2603       814:                 bne     ActivChar               ; BR if char is an activation char
B87F 7EB7E3     815:                 JMP     RINCH
B882 B6B989     816: ActivChar       ldaa    ch
B885 B7B5DF     817:                 staa    ActivationCharSensed    ; save the activation char sensed
B888 39         818: Rendofinput     RTS                             ; > READ LINE FROM KEYBOARD TERMINATED
                819:                 
                820:                 
                821: 
B889 FEB5C6     822: BACKSPACE       LDX     InputBufP1              ; DEL LAST TYPED CHAR FROM INPUTBUF AND (IF ECHO ENABLED) FROM 
B88C 8CB4CA     823:                 CPX     #iNPUTbUF               
B88F 2719       824:                 BEQ     BACKSPC2
B891 09         825:                 DEX




ASM/6800 1.4A0: B892                    
08/16/82 00:00:00; Page 17; Form 1      
IOSWTPC6800.ASM
B892 FFB5C6     826:                 STX     iNPUTBUFP1              ; BACKSPACE TO ERASE LAST CHAR TYPED FROM INPUTBUF
B895 7DB5C9     827:                 TST     ECHOflag
B898 2710       828:                 BEQ     BACKSPC2                ; IF NO ECHO, BR TO KEEP READING KEYBOARD
B89A A600       829:                 LDAA    0,X                     ; GET CHAR THAT HAS BEEN ERASED
B89C 8120       830:                 CMPA    #32                     ; IS A CONTROL CHAR?
B89E 2405       831:                 BCC     BACKSPC1                ; BR IF A >= 32 
B8A0 8608       832:                 LDAA    #8                      ; IS A CONTROL CHAR -> ISSUE TWO BACKSPACES
B8A2 BDB627     833:                 JSR     PRTCH                   ; TO DELETE ^x FROM SCREEN
B8A5 8608       834: BACKSPC1        LDAA    #8
B8A7 BDB627     835:                 JSR     PRTCH
B8AA 39         836: BACKSPC2        RTS
                837: 
B8AB FECE07     838: GETWRITEPARAMS  LDX     SDOS+SDOS.IOBLOCKPTR    ; get number of chars to write form syscall
B8AE EE06       839:                 LDX     scblk.wrlen,x           
B8B0 FFB4C4     840:                 STX     LEN                     
B8B3 FECE07     841:                 LDX     SDOS+SDOS.IOBLOCKPTR    ; get addr of chars to write
B8B6 EE04       842:                 LDX     scblk.wrbuf,x
B8B8 FFB4C6     843:                 STX     PDATA
B8BB 39         844:                 RTS
                845: 
                846: 
B8BC 8601       847: WRITEA.TTY      LDAa    #1
B8BE B7B8DE     848:                 STaA    write.MODE+1
B8C1 B7B5CD     849:                 staa    expandtabflag           ; signal tabs should be expanded to spaces
B8C4 2006       850:                 BRA     WRITE.0
B8C6 7FB8DE     851: WRITEB.TTY      CLR     write.MODE+1
B8C9 7FB5CA     852:                 clr     ncol
B8CC BDB8AB     853: WRITE.0         JSR     GETWRITEPARAMS 
B8CF FEB4C4     854:                 LDX     LEN                     
B8D2 271E       855:                 BEQ     WRITE.9                 ; exit because writing zero chars
B8D4 FEB4C6     856: WRITE.1         LDX     PDATA                   ; get next char to write.
B8D7 A600       857:                 LDAA    0,X
B8D9 08         858:                 INX                             ; .*echo wrtch:a
B8DA FFB4C6     859:                 STX     PDATA
B8DD C600       860: write.MODE      ldab    #0                      ; if not ascii mode (that means, we are executing a writeb)
B8DF 2705       861:                 BEQ     WRITE.2                 ; br to print char without any further processing  
B8E1 BDB900     862:                 JSR     WRITEA.CH               ; convert char <CR> -> <CR><LF>, ctrol char -> ^X
B8E4 2003       863:                 bra     write.3
B8E6 BDB943     864: WRITE.2         JSR     prtch2                  ; send char to console via swtbug
B8E9 FEB4C4     865: write.3         LDX     LEN
B8EC 09         866:                 DEX
B8ED FFB4C4     867:                 STX     LEN
B8F0 26E2       868:                 BNE     WRITE.1
B8F2 7EB4B6     869: WRITE.9         JMP     OKRTS
                870: 
                871: 
B8F5 BDB8FA     872: write.chcr.echo jsr     WRITEA.CH.echo  
B8F8 860D       873: write.cr.echo   ldaa    #13
B8FA 7DB5C9     874: WRITEA.CH.echo  tst     echoflag                ; write char only if echo set and expand tabs. 
B8FD 2609       875:                 bne     writea.ch1              ; this is called from ReadInputBuf
B8FF 39         876:                 rts
B900 810C       877: WRITEA.CH       cmpa    #12                     ; ^L -> do not print
B902 273E       878:                 beq     WRITEA.CH4
B904 8107       879:                 cmpa    #7                      ; ^G -> do not print
B906 273A       880:                 beq     WRITEA.CH4




ASM/6800 1.4A0: B908                    
08/16/82 00:00:00; Page 18; Form 1      
IOSWTPC6800.ASM
B908 847F       881: writea.ch1      andA    #$7f            
B90A 810D       882:                 CMPA    #13
B90C 2607       883:                 BNE     WRITEA.CH2              ; SEND A <LF> AFTER EACH <CR>
B90E BDB943     884:                 JSR     prtch2
B911 860A       885:                 LDAA    #10
B913 202A       886:                 bra     WRITEA.CH3      
B915 8109       887: WRITEA.CH2      cmpa    #9                      ; check for <TAB> (char 9 dec)
B917 2619       888:                 bne     WRITEA.CH2b
B919 7DB5CD     889:                 tst     expandtabflag           ; tabs should be expanded to spaces?
B91C 2718       890:                 beq     WRITEA.CH2c             ; br if not to print tab as ^I
B91E F6B5CA     891:                 ldab    ncol                    ; tab converted to 1-8 spaces depending on ncol
B921 C407       892:                 andb    #7
B923 8608       893:                 ldaa    #8
B925 10         894:                 sba
B926 16         895:                 tab                             ; b=spaces that replaces tab=8-ncol
B927 37         896: WRITEA.CH2a     pshb
B928 8620       897:                 ldaa    #32
B92A BDB943     898:                 jsr     prtch2
B92D 33         899:                 pulb
B92E 5A         900:                 decb
B92F 26F6       901:                 bne     WRITEA.CH2a
B931 39         902:                 rts
B932 8120       903: WRITEA.CH2b     cmpa    #32                     ; if ch < 32, print it as control char "^ch"
B934 2409       904:                 bcC     WRITEA.CH3              ; BR IF A-REG >= 32
B936 36         905: WRITEA.CH2c     psha
B937 865E       906:                 ldaa    #'^
B939 BDB943     907:                 JSR     prtch2
B93C 32         908:                 pula
B93D 8B40       909:                 adda    #'@
B93F BDB943     910: WRITEA.CH3      jsr     prtch2
B942 39         911: WRITEA.CH4      RTS
                912:                 
B943 810D       913: prtch2          cmpa    #13                     ; handle ncol computing
B945 270E       914:                 beq     wr3ncol                 ; for writea.tty
B947 8108       915:                 cmpa    #8
B949 270F       916:                 beq     wr4ncol
B94B 810A       917:                 cmpa    #10
B94D 2703       918:                 beq     wr2ncol                 ; <LF> does not change ncol (char is ignored)
B94F 7CB5CA     919: wr1ncol         inc     ncol
B952 7EB627     920: wr2ncol         jmp     prtch
B955 7FB5CA     921: wr3ncol         clr     ncol                    ; <CR> resets ncol
B958 20F5       922:                 bra     wr1ncol
B95A 7AB5CA     923: wr4ncol         dec     ncol                    ; <BackSpace> ^H decr ncol
B95D 20F3       924:                 bra     wr2ncol                         
                925:                 
                926:                 
                927: ; DEVICE CONTROL BLOCK FOR SIMH IO VIRTUAL PORT
                928: 
B95F 504F5254   929: dcbname.port    fcc     'PORT:'
B964 00         930:                 fcb     0
                931: 
B965 01         932: DCB.PORT        FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
B966 0000       933:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
B968 B95F       934:                 FDB     dcbname.port            ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
B96A BF8F       935:                 FDB     CLOCKDCB                ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO




ASM/6800 1.4A0: B96C                    
08/16/82 00:00:00; Page 19; Form 1      
IOSWTPC6800.ASM
B96C B96E       936:                 FDB     PORTDRIVER              ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
                937: 
                938: ; DEVICE DRIVER FOR IO PORT (for simh PTR and PTP)
                939: 
B96E B9AA       940: PORTDRIVER      FDB     OPEN.PORT       ; DRIVER:OPEN   OPEN FILE
B970 B9B2       941:                 FDB     CLOSE.PORT      ; DRIVER:CLOSE  CLOSE FILE
B972 BA17       942:                 FDB     READA.PORT      ; DRIVER:READA  READ ASCII
B974 BAC3       943:                 FDB     WRITEA.PORT     ; DRIVER:WRITEA WRITE ASCII
B976 BA1E       944:                 FDB     READB.PORT      ; DRIVER:READB  READ BINARY
B978 BACD       945:                 FDB     WRITEB.PORT     ; DRIVER:WRITEB WRITE BINARY
B97A B9AA       946:                 FDB     OPEN.PORT       ; DRIVER:CREATE CREATE FILE
B97C B4B8       947:                 FDB     ILLDEVICEOP     ; DRIVER:RENAME RENAME FILE
B97E B4B8       948:                 FDB     ILLDEVICEOP     ; DRIVER:DELETE DELETE FILE
B980 B98A       949:                 FDB     control.port    ; DRIVER:CONTROL        DO CONTROL OPERATION
B982 B994       950:                 FDB     status.port     ; DRIVER:STATUS READ DEVICE (DRIVER) STATUS
B984 B4B6       951:                 FDB     OKRTS           ; DRIVER:RESET  RESET DRIVER (ON BOOT)
B986 B4B8       952:                 FDB     ILLDEVICEOP     ; DRIVER:STARTIO        power-fail restart--dream on!
                953: 
B988 FF         954: PORTMODE        FCB     $FF             ; =1 -> READING FROM PTR, =2 -> READING FROM PTP
B989 0001       955: ch              rmb     1               ; char read/write
                956: 
B98A FECE07     957: control.port    ldx     sdos+sdos.ioblockptr
B98D E603       958:                 ldab    scblk.params+1,x
B98F C11D       959:                 cmpb    #cc.activationck
B991 7EB4B6     960:                 jmp     okrts
                961: 
B994 FECE07     962: status.port     ldx     SDOS+SDOS.IOBLOCKPTR
B997 E603       963:                 ldab    scblk.params+1,x        ; get sc status opcode
B999 C104       964:                 cmpb    #sc.gettype
B99B 2604       965:                 bne     stpo1
B99D 8602       966:                 ldaa    #DVTYP.STAPE
B99F 2002       967:                 bra     stpo2
B9A1 8600       968: stpo1           ldaa    #0                      ; any other request returns 0
B9A3 EE0A       969: stpo2           LDX     scblk.rdbuf,x           ; return 1 byte status
B9A5 A700       970:                 staa    0,X                     ; STORE IN RDBUF
B9A7 7EB4B6     971:                 JMP     OKRTS 
                972: 
                973: 
B9AA 8600       974: OPEN.PORT       LDAA    #0
B9AC B7B988     975:                 STAA    PORTMODE        ; =0 -> ready for read/write
B9AF 7EB4B6     976:                 JMP     OKRTS
                977: 
B9B2 B6B988     978: CLOSE.PORT      ldaa    portmode
B9B5 2603       979:                 bne     cl1
B9B7 7EB4B6     980:                 jmp     okrts           ; just close after open
B9BA 8101       981: cl1             cmpa    #1              
B9BC 260B       982:                 bne     cl2
                983:                                         ; close ptr
B9BE BDB61B     984:                 jsr     RDOFF           ; PTR off (^S)
B9C1 86FF       985:                 ldaa    #$ff            ; set mode as closed
B9C3 B7B988     986:                 staa    portmode
B9C6 7EB4B6     987:                 JMP     OKRTS
  B9C9          988: cl2                                     
B9C9 8102       989:                 cmpa    #2
B9CB 260E       990:                 bne     cl3




ASM/6800 1.4A0: B9CB                    
08/16/82 00:00:00; Page 20; Form 1      
IOSWTPC6800.ASM
                991:                                         ; close ptp
B9CD BDB623     992:                 jsr     PNCHOFF         ; PTR off (^T)
B9D0 86FF       993:                 ldaa    #$ff            ; set mode as closed
B9D2 B7B988     994:                 staa    portmode
B9D5 7EB4B6     995:                 JMP     OKRTS
                996: 
B9D8 7EB4B6     997:                 JMP     OKRTS
B9DB 7EB4B8     998: cl3             JMP     ILLDEVICEOP     
                999: 
B9DE CE0032    1000: delay1k         ldx     #50             ; **troff
B9E1 09        1001: delay1kb        dex
B9E2 26FD      1002:                 bne     delay1kb
B9E4 39        1003:                 rts                     ; **tron
               1004: 
B9E5 BDB9DE    1005: innyble         jsr     delay1k         ; RECEIVE A BYTE FROM PTR AS TWO ASCII NYBLLES TO FORM A BYTE
B9E8 BDB64E    1006:                 jsr     inch            ; EXAMPLE: RECIVE CHARS "3A" -> RECV BYTE = $3A
B9EB 8130      1007:                 cmpa    #'0             ; .*echo inch:a
B9ED 2406      1008:                 BCC     innyb1          ; BR IF A >= '0'
B9EF 811A      1009:                 cmpa    #26
B9F1 26F2      1010:                 bne     innyble         ; invalid char -> read next 
B9F3 0D        1011:                 sec                     ; RECEIVED ^Z
B9F4 39        1012:                 rts                     ; return carry set -> eof
B9F5 8030      1013: innyb1          suba    #'0
B9F7 810A      1014:                 cmpa    #10
B9F9 2402      1015:                 bcc     innyb4          ; br if a >= 10
B9FB 0C        1016:                 clc
B9FC 39        1017:                 rts                     ; return nyble 0..9
B9FD 8007      1018: innyb4          suba    #7
B9FF 8110      1019:                 cmpa    #16
BA01 24E2      1020:                 bcc     innyble         ; br if a >= 16 -> invalid nyble -> read next
BA03 0C        1021:                 clc
BA04 39        1022:                 rts
               1023: 
BA05 BDB9DE    1024: INBYTE          jsr     delay1k         ; RECEIVE AN ASCII CHAR FROM PTR 
BA08 BDB64E    1025:                 jsr     inch            
BA0B 8100      1026:                 CMPA    #0              ; RECV $00 CHAR -> END OF FILE
BA0D 2706      1027:                 BEQ     INBYTEEOF
BA0F 811A      1028:                 CMPA    #26             ; RECV ^Z -> END OF FILE
BA11 2702      1029:                 BEQ     INBYTEEOF
BA13 0C        1030:                 CLC
BA14 39        1031:                 RTS
BA15 0D        1032: INBYTEEOF       SEC                     ; SET CARRY TO SIGNAL END OF FILE TO CALLER
BA16 39        1033:                 RTS
               1034: 
               1035: 
BA17 8601      1036: READA.PORT      LDAa    #1
BA19 B7BA60    1037:                 STaA    APORT.MODE+1
BA1C 2003      1038:                 BRA     READ.PORT
BA1E 7FBA60    1039: READB.PORT      CLR     APORT.MODE+1
BA21 BDB704    1040: READ.PORT       jsr     getreadparams   ; get syscall params
BA24 CE0000    1041:                 ldx     #0
BA27 BDB721    1042:                 jsr     setrplen        ; set reply len size
BA2A B6B988    1043:                 LDAA    PORTMODE
BA2D 2617      1044:                 BNE     RP1
BA2F 8601      1045:                 LDAA    #1              ; start reading from ptr




ASM/6800 1.4A0: BA31                    
08/16/82 00:00:00; Page 21; Form 1      
IOSWTPC6800.ASM
BA31 B7B988    1046:                 STAA    PORTMODE        ; 
BA34 7FB5CE    1047:                 clr     crflag
BA37 BDB617    1048:                 jsr     RDON            ; ACTIVATE PTR on (^Q)
BA3A B6BA60    1049:                 LDAA    APORT.MODE+1    ; GET PORT READA/READB MODE
BA3D 260E      1050:                 BNE     rp1start        ; BR IF READA
BA3F 8681      1051:                 LDAA    #129            ; ACTIVATE PTR bin mode (129)
BA41 BDB627    1052:                 JSR     PRTCH   
BA44 2007      1053:                 bra     rp1start
BA46 8101      1054: rp1             cmpa    #1
BA48 2703      1055:                 beq     rp1start        ; br read port input
BA4A 7EB4B8    1056:                 jmp     ILLDEVICEOP     
BA4D CE0000    1057: rp1start        ldx     #0
BA50 FFB4C8    1058:                 stx     rplen
BA53 FEB4C4    1059: rpin            ldx     len
BA56 2603      1060:                 bne     rp1a
BA58 7EB4B6    1061:                 jmp     okrts           ; input buffer full -> terminate read
BA5B 09        1062: rp1a            dex
BA5C FFB4C4    1063:                 stx     len
BA5F 8600      1064: APORT.MODE      LDAA    #0
BA61 272F      1065:                 BEQ     READBPORT
BA63 BDBA05    1066: READAPORT       JSR     INBYTE  
BA66 2556      1067:                 bcs     rp1eof          ; br if eof
               1068:                 ; now handle the end of line: DOS <CR><LF>, Unix <LF>, Mac/SDOS <CR>
BA68 810D      1069:                 cmpa    #13
BA6A 2607      1070:                 bne     cr1             ; if <CR> -> set crflag
BA6C C601      1071:                 ldab    #1
BA6E F7B5CE    1072:                 stab    crflag
BA71 2012      1073:                 bra     cr0
BA73 810A      1074: cr1             cmpa    #10             ; if <LF> after a <CR> -> ignore <LF>
BA75 2609      1075:                 bne     cr2             ; if <LF> NOT after a <CR> -> convert to <CR>
BA77 7DB5CE    1076:                 tst     crflag
BA7A 26E7      1077:                 bne     READAPORT       
BA7C 860D      1078:                 ldaa    #13
BA7E 2005      1079:                 bra     cr0
BA80 7FB5CE    1080: cr2             clr     crflag          ; not <cr>/<l> -> clear cr flag 
BA83 2024      1081:                 bra     SAVEREADPORTCH  ; and br to store char
BA85 7DB4C3    1082: cr0             tst     lmode
BA88 271F      1083:                 beq     SAVEREADPORTCH  ; if not line mode br to store char
BA8A 7FB4C4    1084:                 clr     len             ; recv <cR> in line more -> set len to zero so reada is terminated
BA8D 7FB4C5    1085:                 clr     len+1
BA90 2017      1086:                 BRA     SAVEREADPORTCH
BA92 BDB9E5    1087: READBPORT       jsr     innyble
BA95 2527      1088:                 bcs     rp1eof          ; br if eof
BA97 48        1089:                 asla
BA98 48        1090:                 asla
BA99 48        1091:                 asla
BA9A 48        1092:                 asla
BA9B B7B989    1093:                 staa    ch              ; save hi nyble
BA9E BDB9E5    1094:                 jsr     innyble
BAA1 251B      1095:                 bcs     rp1eof          ; br if eof
BAA3 BBB989    1096:                 adda    ch
BAA6 B7B989    1097:                 staa    ch              ; binary char composed
BAA9 FEB4C6    1098: SAVEREADPORTCH  ldx     pdata           ; input buf addr
BAAC A700      1099:                 staa    0,x             ; store into input buf
BAAE 08        1100:                 inx                     ; .*echo inbyte:a




ASM/6800 1.4A0: BAAF                    
08/16/82 00:00:00; Page 22; Form 1      
IOSWTPC6800.ASM
BAAF FFB4C6    1101:                 stx     pdata
BAB2 FEB4C8    1102:                 ldx     rplen
BAB5 08        1103:                 inx
BAB6 FFB4C8    1104:                 stx     rplen
BAB9 BDB721    1105:                 jsr     setrplen        ; set reply len size = num of bytes read
BABC 2095      1106:                 bra     rpin
               1107: 
BABE BDCE2D    1108: rp1eof          jsr     sdos+sdos.error ; .*echo eof
BAC1 03E9      1109:                 fdb     err.eofhit      ; return from read signaling eof CONDITION
               1110: 
BAC3 8601      1111: WRITEA.PORT     LDAa    #1
BAC5 B7BA60    1112:                 STaA    APORT.MODE+1
BAC8 B7B5CD    1113:                 staa    expandtabflag   ; signal tabs should be expanded to spaces
BACB 2003      1114:                 BRA     WRITE.PORT
BACD 7FBA60    1115: WRITEB.PORT     CLR     APORT.MODE+1
BAD0 BDB8AB    1116: WRITE.PORT      JSR     GETWRITEPARAMS 
BAD3 B6B988    1117:                 LDAA    PORTMODE
BAD6 2625      1118:                 BNE     WP1
BAD8 8602      1119:                 LDAA    #2              ; start WRITING AT ptP
BADA B7B988    1120:                 STAA    PORTMODE        ; 
BADD BDB61F    1121:                 jsr     PNCHON          ; ACTIVATE PTP on (^R)
BAE0 8682      1122:                 ldaa    #130            ; ACTIVATE PTP ascii (130)
BAE2 F6BA60    1123:                 LDAb    APORT.MODE+1    ; GET PORT WRITEA/WRITEB MODE
BAE5 2611      1124:                 BNE     Wp0             ; BR IF writeA
BAE7 8683      1125:                 LDAA    #131            ; ACTIVATE PTP bin mode (131)
BAE9 BDB627    1126:                 JSR     PRTCH   
BAEC 8620      1127:                 LDAA    #32
BAEE BDB627    1128:                 JSR     PRTCH           ; SEND A SPACEs TO SYNC
BAF1 8620      1129:                 LDAA    #32
BAF3 BDB627    1130:                 JSR     PRTCH           
BAF6 8620      1131:                 LDAA    #32
BAF8 BDB627    1132: wp0             JSR     PRTCH           
BAFB 2007      1133:                 bra     Wp1start
BAFD 8102      1134: Wp1             cmpa    #2
BAFF 2703      1135:                 beq     Wp1start        ; br read port input
BB01 7EB4B8    1136:                 jmp     ILLDEVICEOP     
  BB04         1137: Wp1start        
BB04 FEB4C4    1138: WpOUT           ldx     len
BB07 2603      1139:                 bne     Wp1a
BB09 7EB4B6    1140:                 jmp     okrts           ; input buffer full -> terminate read
BB0C 09        1141: Wp1a            dex
BB0D FFB4C4    1142:                 stx     len
BB10 FEB4C6    1143:                 LDX     PDATA           ; get next char to write.
BB13 A600      1144:                 LDAA    0,X
BB15 08        1145:                 INX                     ; .*echo wrtch:a
BB16 FFB4C6    1146:                 STX     PDATA
BB19 F6BA60    1147:                 LDAB    APORT.MODE+1
BB1C 2705      1148:                 BEQ     WRITEBPORT
BB1E BDB900    1149: WRITEAPORT      JSR     WRITEA.CH       ; convert char <CR> -> <CR><LF>, cTRol char -> ^X
BB21 20E1      1150:                 BRA     WPOUT
BB23 B7B989    1151: WRITEBPORT      STAA    CH
BB26 44        1152:                 LSRA
BB27 44        1153:                 LSRA
BB28 44        1154:                 LSRA
BB29 44        1155:                 LSRA




ASM/6800 1.4A0: BB2A                    
08/16/82 00:00:00; Page 23; Form 1      
IOSWTPC6800.ASM
BB2A BDBB37    1156:                 JSR     OUTNYBLE
BB2D B6B989    1157:                 LDAA    CH
BB30 840F      1158:                 ANDa    #$0F
BB32 BDBB37    1159:                 JSR     OUTNYBLE
BB35 20CD      1160:                 BRA     WPOUT
               1161: 
BB37 8B30      1162: OUTNYBLE        ADDA    #'0
BB39 813A      1163:                 CMPA    #'9+1
BB3B 2502      1164:                 BCS     OUTNYBLE1       ; BR IF A<'9'+1
BB3D 8B07      1165:                 ADDA    #7              ; 7='A'-'0'-10
BB3F 7EB627    1166: OUTNYBLE1       jMP     PRTCH
               1167: 
               1168: 
               1169: 
               1170: 
               1171: 
               1172: 
               1173: 
               1174: 
               1175: ; DEVICE CONTROL BLOCK FOR MF-68 FLOPPY DISK
               1176: 
  0003         1177: LSN.SIZE        EQU     3       ; # BYTES OCCUPIED BY AN LSN
  0002         1178: LCN.SIZE        EQU     2       ; # BYTES OCCUPIED BY AN LCN
               1179: 
BB42 44303A    1180: dcbname.D0      fcc     'D0:'
BB45 00        1181:                 fcb     0
  BB46         1182: DISKDCBS        
BB46 01        1183: DCB.D0          FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
BB47 0000      1184:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
BB49 BB42      1185:                 FDB     dcbname.D0              ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
BB4B BB8E      1186:                 FDB     dcb.d1                  ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
BB4D BC62      1187:                 FDB     DSKDRIVER               ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
               1188: 
               1189:                                                                 ; DISK GEOMETRY
BB4F 0080      1190:                 FDB     128                     ; DSKINFO:NBPS  ; NUMBER OF BYTES PER SECTOR
BB51 0012      1191:                 FDB     18                      ; DSKINFO:NSPT  ; NUMBER OF SECTORS PER TRACK
BB53 0002      1192:                 FDB     2                       ; DSKINFO:NTPC  ; NUMBER OF TRACKS PER CYLINDER
BB55 0023      1193:                 FDB     35                      ; DSKINFO:NCYL  ; NUMBER OF CYLINDERS PER DRIVE
               1194: 
               1195:                                                                 ; THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
BB57 0001      1196:                 RMB     1                       ; DSKINFO:NSPC   NUMBER OF SECTORS PER CLUSTER
BB58 0002      1197:                 RMB     LCN.SIZE                ; DSKINFO:MINALLOC ALLOCATION MINIMUM FOR NEW FILES
BB5A 0002      1198:                 RMB     LCN.SIZE                ; DSKINFO:MIDALLOC ALLOCATION MIN FOR FILE EXTENSION
BB5C 0002      1199:                 RMB     2                       ; DSKINFO:MAPALGORITHM CODE TO SELECT LOGICAL TO PHYSICAL SECTO
               1200: 
               1201:                                                                 ; CONTAINS DISK ID FOR MOUNTED DISKS
BB5E 0001      1202:                 RMB     1                       ; DSKINFO:LOG2NBPS LOG BASE 2 OF DSKINFO:NBPS
BB5F 0002      1203:                 RMB     2                       ; DSKINFO:NBPSM1 = NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
BB61 0003      1204:                 RMB     LSN.SIZE                ; DSKINFO:NLSN   NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
BB64 0002      1205:                 RMB     LCN.SIZE                ; DSKINFO:NLCN   NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
BB66 0002      1206:                 RMB     2                       ; DSKINFO:NBPC   NUMBER OF BYTES PER CLUSTER
BB68 0002      1207:                 RMB     LCN.SIZE                ; DSKINFO:RANDMAP "RANDOM" LCN TO DISTRIBUTE NEW FILES
BB6A 0003      1208:                 RMB     LSN.SIZE                ; DSKINFO:MAPLSN LSN OF 1ST SECTOR IN DISK...
               1209: 
               1210:                                                                 ; ALLOCATION MAP CLUSTER




ASM/6800 1.4A0: BB6D                    
08/16/82 00:00:00; Page 24; Form 1      
IOSWTPC6800.ASM
BB6D 0002      1211:                 RMB     2                       ; DSKINFO:DIRFCB POINTER TO FCB FOR $DIRECTORY FILE
BB6F 0002      1212:                 RMB     2                       ; DSKINFO:MAPFCB POINTER TO FCB FOR $DISKMAP FILE
BB71 0002      1213:                 RMB     2                       ; DSKINFO:SECTORDB POINTER TO RDSI CONTAINING LSN, ADDRESS PARA
BB73 0003      1214:                 RMB     LSN.SIZE                ; DSKINFO:BADLSN LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SE
BB76 0000      1215:                 FDB     0                       ; DSKINFO:SEEKERRCNT # SEEK ERRORS SINCE MOUNT
BB78 0000      1216:                 FDB     0                       ; DSKINFO:SEEKERRSTS 16 BITS OF LAST "SEEK" STATUS IN ERROR
BB7A 0000      1217:                 FDB     0                       ; DSKINFO:WRITEERRCNT # WRITE ERRORS SINCE MOUNT
BB7C 0000      1218:                 FDB     0                       ; DSKINFO:WRITEERRSTS 16 BITS OF LAST "WRITE" STATUS IN ERROR
BB7E 0000      1219:                 FDB     0                       ; DSKINFO:READERRCNT # READ ERRORS SINCE MOUNT
BB80 0000      1220:                 FDB     0                       ; DSKINFO:READERRSTS 16 BITS OF LAST "READ" STATUS IN ERROR
BB82 000000    1221:                 FCB     0,0,0                   ; DSKINFO:OPSCOUNT 24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
BB85 0003      1222:                 RMB     LSN.SIZE                ; DSKINFO:ERRLSN LSN CAUSING ANY SOFT OR HARD ERROR
BB88 0001      1223:                 RMB     1                       ; DSKINFO:WRITEPROTSTATE 0 --> WRITEABLE
BB89 00        1224:                 FCB     0                       ; FDUNIT         Drive number 
               1225: 
BB8A 44313A    1226: dcbname.D1      fcc     'D1:'
BB8D 00        1227:                 fcb     0
BB8E 01        1228: DCB.D1          FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
BB8F 0000      1229:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
BB91 BB8A      1230:                 FDB     dcbname.D1              ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
BB93 BBD6      1231:                 FDB     dcb.d2                  ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
BB95 BC62      1232:                 FDB     DSKDRIVER               ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
               1233: 
               1234:                                                                 ; DISK GEOMETRY
BB97 0080      1235:                 FDB     128                     ; DSKINFO:NBPS  ; NUMBER OF BYTES PER SECTOR
BB99 0012      1236:                 FDB     18                      ; DSKINFO:NSPT  ; NUMBER OF SECTORS PER TRACK
BB9B 0002      1237:                 FDB     2                       ; DSKINFO:NTPC  ; NUMBER OF TRACKS PER CYLINDER
BB9D 0023      1238:                 FDB     35                      ; DSKINFO:NCYL  ; NUMBER OF CYLINDERS PER DRIVE
               1239: 
               1240:                                                                 ; THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
BB9F 0001      1241:                 RMB     1                       ; DSKINFO:NSPC   NUMBER OF SECTORS PER CLUSTER
BBA0 0002      1242:                 RMB     LCN.SIZE                ; DSKINFO:MINALLOC ALLOCATION MINIMUM FOR NEW FILES
BBA2 0002      1243:                 RMB     LCN.SIZE                ; DSKINFO:MIDALLOC ALLOCATION MIN FOR FILE EXTENSION
BBA4 0002      1244:                 RMB     2                       ; DSKINFO:MAPALGORITHM CODE TO SELECT LOGICAL TO PHYSICAL SECTO
               1245: 
               1246:                                                                 ; CONTAINS DISK ID FOR MOUNTED DISKS
BBA6 0001      1247:                 RMB     1                       ; DSKINFO:LOG2NBPS LOG BASE 2 OF DSKINFO:NBPS
BBA7 0002      1248:                 RMB     2                       ; DSKINFO:NBPSM1 = NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
BBA9 0003      1249:                 RMB     LSN.SIZE                ; DSKINFO:NLSN   NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
BBAC 0002      1250:                 RMB     LCN.SIZE                ; DSKINFO:NLCN   NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
BBAE 0002      1251:                 RMB     2                       ; DSKINFO:NBPC   NUMBER OF BYTES PER CLUSTER
BBB0 0002      1252:                 RMB     LCN.SIZE                ; DSKINFO:RANDMAP "RANDOM" LCN TO DISTRIBUTE NEW FILES
BBB2 0003      1253:                 RMB     LSN.SIZE                ; DSKINFO:MAPLSN LSN OF 1ST SECTOR IN DISK...
               1254: 
               1255:                                                                 ; ALLOCATION MAP CLUSTER
BBB5 0002      1256:                 RMB     2                       ; DSKINFO:DIRFCB POINTER TO FCB FOR $DIRECTORY FILE
BBB7 0002      1257:                 RMB     2                       ; DSKINFO:MAPFCB POINTER TO FCB FOR $DISKMAP FILE
BBB9 0002      1258:                 RMB     2                       ; DSKINFO:SECTORDB POINTER TO RDSI CONTAINING LSN, ADDRESS PARA
BBBB 0003      1259:                 RMB     LSN.SIZE                ; DSKINFO:BADLSN LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SE
BBBE 0000      1260:                 FDB     0                       ; DSKINFO:SEEKERRCNT # SEEK ERRORS SINCE MOUNT
BBC0 0000      1261:                 FDB     0                       ; DSKINFO:SEEKERRSTS 16 BITS OF LAST "SEEK" STATUS IN ERROR
BBC2 0000      1262:                 FDB     0                       ; DSKINFO:WRITEERRCNT # WRITE ERRORS SINCE MOUNT
BBC4 0000      1263:                 FDB     0                       ; DSKINFO:WRITEERRSTS 16 BITS OF LAST "WRITE" STATUS IN ERROR
BBC6 0000      1264:                 FDB     0                       ; DSKINFO:READERRCNT # READ ERRORS SINCE MOUNT
BBC8 0000      1265:                 FDB     0                       ; DSKINFO:READERRSTS 16 BITS OF LAST "READ" STATUS IN ERROR




ASM/6800 1.4A0: BBCA                    
08/16/82 00:00:00; Page 25; Form 1      
IOSWTPC6800.ASM
BBCA 000000    1266:                 FCB     0,0,0                   ; DSKINFO:OPSCOUNT 24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
BBCD 0003      1267:                 RMB     LSN.SIZE                ; DSKINFO:ERRLSN LSN CAUSING ANY SOFT OR HARD ERROR
BBD0 0001      1268:                 RMB     1                       ; DSKINFO:WRITEPROTSTATE 0 --> WRITEABLE
BBD1 01        1269:                 FCB     1                       ; FDUNIT         Drive number 
               1270: 
BBD2 44323A    1271: dcbname.D2      fcc     'D2:'
BBD5 00        1272:                 fcb     0
BBD6 01        1273: DCB.D2          FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
BBD7 0000      1274:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
BBD9 BBD2      1275:                 FDB     dcbname.D2              ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
BBDB BC1E      1276:                 FDB     dcb.d3                  ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
BBDD BC62      1277:                 FDB     DSKDRIVER               ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
               1278: 
               1279:                                                                 ; DISK GEOMETRY
BBDF 0080      1280:                 FDB     128                     ; DSKINFO:NBPS  ; NUMBER OF BYTES PER SECTOR
BBE1 0012      1281:                 FDB     18                      ; DSKINFO:NSPT  ; NUMBER OF SECTORS PER TRACK
BBE3 0002      1282:                 FDB     2                       ; DSKINFO:NTPC  ; NUMBER OF TRACKS PER CYLINDER
BBE5 0023      1283:                 FDB     35                      ; DSKINFO:NCYL  ; NUMBER OF CYLINDERS PER DRIVE
               1284: 
               1285:                                                                 ; THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
BBE7 0001      1286:                 RMB     1                       ; DSKINFO:NSPC   NUMBER OF SECTORS PER CLUSTER
BBE8 0002      1287:                 RMB     LCN.SIZE                ; DSKINFO:MINALLOC ALLOCATION MINIMUM FOR NEW FILES
BBEA 0002      1288:                 RMB     LCN.SIZE                ; DSKINFO:MIDALLOC ALLOCATION MIN FOR FILE EXTENSION
BBEC 0002      1289:                 RMB     2                       ; DSKINFO:MAPALGORITHM CODE TO SELECT LOGICAL TO PHYSICAL SECTO
               1290: 
               1291:                                                                 ; CONTAINS DISK ID FOR MOUNTED DISKS
BBEE 0001      1292:                 RMB     1                       ; DSKINFO:LOG2NBPS LOG BASE 2 OF DSKINFO:NBPS
BBEF 0002      1293:                 RMB     2                       ; DSKINFO:NBPSM1 = NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
BBF1 0003      1294:                 RMB     LSN.SIZE                ; DSKINFO:NLSN   NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
BBF4 0002      1295:                 RMB     LCN.SIZE                ; DSKINFO:NLCN   NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
BBF6 0002      1296:                 RMB     2                       ; DSKINFO:NBPC   NUMBER OF BYTES PER CLUSTER
BBF8 0002      1297:                 RMB     LCN.SIZE                ; DSKINFO:RANDMAP "RANDOM" LCN TO DISTRIBUTE NEW FILES
BBFA 0003      1298:                 RMB     LSN.SIZE                ; DSKINFO:MAPLSN LSN OF 1ST SECTOR IN DISK...
               1299: 
               1300:                                                                 ; ALLOCATION MAP CLUSTER
BBFD 0002      1301:                 RMB     2                       ; DSKINFO:DIRFCB POINTER TO FCB FOR $DIRECTORY FILE
BBFF 0002      1302:                 RMB     2                       ; DSKINFO:MAPFCB POINTER TO FCB FOR $DISKMAP FILE
BC01 0002      1303:                 RMB     2                       ; DSKINFO:SECTORDB POINTER TO RDSI CONTAINING LSN, ADDRESS PARA
BC03 0003      1304:                 RMB     LSN.SIZE                ; DSKINFO:BADLSN LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SE
BC06 0000      1305:                 FDB     0                       ; DSKINFO:SEEKERRCNT # SEEK ERRORS SINCE MOUNT
BC08 0000      1306:                 FDB     0                       ; DSKINFO:SEEKERRSTS 16 BITS OF LAST "SEEK" STATUS IN ERROR
BC0A 0000      1307:                 FDB     0                       ; DSKINFO:WRITEERRCNT # WRITE ERRORS SINCE MOUNT
BC0C 0000      1308:                 FDB     0                       ; DSKINFO:WRITEERRSTS 16 BITS OF LAST "WRITE" STATUS IN ERROR
BC0E 0000      1309:                 FDB     0                       ; DSKINFO:READERRCNT # READ ERRORS SINCE MOUNT
BC10 0000      1310:                 FDB     0                       ; DSKINFO:READERRSTS 16 BITS OF LAST "READ" STATUS IN ERROR
BC12 000000    1311:                 FCB     0,0,0                   ; DSKINFO:OPSCOUNT 24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
BC15 0003      1312:                 RMB     LSN.SIZE                ; DSKINFO:ERRLSN LSN CAUSING ANY SOFT OR HARD ERROR
BC18 0001      1313:                 RMB     1                       ; DSKINFO:WRITEPROTSTATE 0 --> WRITEABLE
BC19 02        1314:                 FCB     2                       ; FDUNIT         Drive number 
               1315: 
               1316: 
BC1A 44333A    1317: dcbname.D3      fcc     'D3:'
BC1D 00        1318:                 fcb     0
BC1E 01        1319: DCB.D3          FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
BC1F 0000      1320:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO




ASM/6800 1.4A0: BC21                    
08/16/82 00:00:00; Page 26; Form 1      
IOSWTPC6800.ASM
BC21 BC1A      1321:                 FDB     dcbname.D3              ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
BC23 BE76      1322:                 FDB     DCB.HD                  ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
BC25 BC62      1323:                 FDB     DSKDRIVER               ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
               1324: 
               1325:                                                                 ; DISK GEOMETRY
BC27 0080      1326:                 FDB     128                     ; DSKINFO:NBPS  ; NUMBER OF BYTES PER SECTOR
BC29 0012      1327:                 FDB     18                      ; DSKINFO:NSPT  ; NUMBER OF SECTORS PER TRACK
BC2B 0002      1328:                 FDB     2                       ; DSKINFO:NTPC  ; NUMBER OF TRACKS PER CYLINDER
BC2D 0023      1329:                 FDB     35                      ; DSKINFO:NCYL  ; NUMBER OF CYLINDERS PER DRIVE
               1330: 
               1331:                                                                 ; THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
BC2F 0001      1332:                 RMB     1                       ; DSKINFO:NSPC   NUMBER OF SECTORS PER CLUSTER
BC30 0002      1333:                 RMB     LCN.SIZE                ; DSKINFO:MINALLOC ALLOCATION MINIMUM FOR NEW FILES
BC32 0002      1334:                 RMB     LCN.SIZE                ; DSKINFO:MIDALLOC ALLOCATION MIN FOR FILE EXTENSION
BC34 0002      1335:                 RMB     2                       ; DSKINFO:MAPALGORITHM CODE TO SELECT LOGICAL TO PHYSICAL SECTO
               1336: 
               1337:                                                                 ; CONTAINS DISK ID FOR MOUNTED DISKS
BC36 0001      1338:                 RMB     1                       ; DSKINFO:LOG2NBPS LOG BASE 2 OF DSKINFO:NBPS
BC37 0002      1339:                 RMB     2                       ; DSKINFO:NBPSM1 = NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
BC39 0003      1340:                 RMB     LSN.SIZE                ; DSKINFO:NLSN   NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
BC3C 0002      1341:                 RMB     LCN.SIZE                ; DSKINFO:NLCN   NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
BC3E 0002      1342:                 RMB     2                       ; DSKINFO:NBPC   NUMBER OF BYTES PER CLUSTER
BC40 0002      1343:                 RMB     LCN.SIZE                ; DSKINFO:RANDMAP "RANDOM" LCN TO DISTRIBUTE NEW FILES
BC42 0003      1344:                 RMB     LSN.SIZE                ; DSKINFO:MAPLSN LSN OF 1ST SECTOR IN DISK...
               1345: 
               1346:                                                                 ; ALLOCATION MAP CLUSTER
BC45 0002      1347:                 RMB     2                       ; DSKINFO:DIRFCB POINTER TO FCB FOR $DIRECTORY FILE
BC47 0002      1348:                 RMB     2                       ; DSKINFO:MAPFCB POINTER TO FCB FOR $DISKMAP FILE
BC49 0002      1349:                 RMB     2                       ; DSKINFO:SECTORDB POINTER TO RDSI CONTAINING LSN, ADDRESS PARA
BC4B 0003      1350:                 RMB     LSN.SIZE                ; DSKINFO:BADLSN LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SE
BC4E 0000      1351:                 FDB     0                       ; DSKINFO:SEEKERRCNT # SEEK ERRORS SINCE MOUNT
BC50 0000      1352:                 FDB     0                       ; DSKINFO:SEEKERRSTS 16 BITS OF LAST "SEEK" STATUS IN ERROR
BC52 0000      1353:                 FDB     0                       ; DSKINFO:WRITEERRCNT # WRITE ERRORS SINCE MOUNT
BC54 0000      1354:                 FDB     0                       ; DSKINFO:WRITEERRSTS 16 BITS OF LAST "WRITE" STATUS IN ERROR
BC56 0000      1355:                 FDB     0                       ; DSKINFO:READERRCNT # READ ERRORS SINCE MOUNT
BC58 0000      1356:                 FDB     0                       ; DSKINFO:READERRSTS 16 BITS OF LAST "READ" STATUS IN ERROR
BC5A 000000    1357:                 FCB     0,0,0                   ; DSKINFO:OPSCOUNT 24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
BC5D 0003      1358:                 RMB     LSN.SIZE                ; DSKINFO:ERRLSN LSN CAUSING ANY SOFT OR HARD ERROR
BC60 0001      1359:                 RMB     1                       ; DSKINFO:WRITEPROTSTATE 0 --> WRITEABLE
BC61 03        1360:                 FCB     3                       ; FDUNIT         Drive number 
               1361: 
               1362:                 
               1363: ; DEVICE DRIVER BLOCK FOR FLOPPY DISK
               1364: 
BC62 BD5A      1365: DSKDRIVER       FDB     DSKRESTORE              ; DRIVER:DISKRESET RESET THIS DISK DRIVER
BC64 BD18      1366:                 FDB     DSKREAD                 ; DRIVER:DISKREAD INITIATE A DISK SECTOR READ
BC66 BD25      1367:                 FDB     DSKWRITE                ; DRIVER:DISKWRITE INITIATE A DISK SECTOR WRITE
BC68 BD5A      1368:                 FDB     DSKWAITDONE             ; DRIVER:DISKWAIT WAIT FOR DISK I/O COMPLETE
BC6A B4B8      1369:                 FDB     ILLDEVICEOP             ; DRIVER:DISKSTATUS STATUS handled completely by SDOS1.1
BC6C BC74      1370:                 FDB     DSKCONTROL              ; DRIVER:DISKCONTROL PERFORM DISK-SPECIFIC CONTROL OPERATION
BC6E B4B8      1371:                 FDB     ILLDEVICEOP             ; DRIVER:DISKWRITEPROTQ DETERMINE IF DISK IS WRITE PROTECTED
BC70 B4B8      1372:                 FDB     ILLDEVICEOP             ; DRIVER:DISKVERIFY INITIATE A DISK SECTOR VERIFY
BC72 B4B8      1373:                 FDB     ILLDEVICEOP             ; DRIVER:DISKLSNTOPSN CONVERT LSN TO PHYSICAL CYLINDER, TRACK A
               1374: 
               1375: ; FLOPPY DISK LOW LEVEL I/O




ASM/6800 1.4A0: BC72                    
08/16/82 00:00:00; Page 27; Form 1      
IOSWTPC6800.ASM
               1376: 
BC74 8111      1377: DSKCONTROL      CMPA    #CC.DISMOUNTDISK        ; SINCE SDOS PASSES THIS THRU
BC76 2703      1378:                 BEQ     DSKDISMOUNT             ; B/ ITS A DISMOUNT!
BC78 7EB4B8    1379:                 JMP     ILLDEVICEOP             ; NOT A LEGAL CONTROL CALL
BC7B 5F        1380: DSKDISMOUNT     CLRB                            ; CLEAR THE CARRY
BC7C 39        1381:                 RTS
               1382:                 
               1383: ;
               1384: ;       Take RDSI:LSN and split it up into RDSI:CYLINDER,
               1385: ;       RDSI:TRACK, and RDSI:SECTOR, 
               1386: ;       mapalg NOT IMPLEMENTED 
               1387: ;
BC7D FEBD5C    1388: FDTEARLSN       LDX     RDSIPOINTER
BC80 6F0E      1389:                 CLR     RDSI.SECTOR,X           ; CLEAR MSB OF SECTOR, TRACK AND CYL
BC82 6F10      1390:                 CLR     RDSI.TRACK,X
BC84 6F11      1391:                 CLR     RDSI.TRACK+1,X
BC86 6F12      1392:                 CLR     RDSI.CYLINDER,X
               1393: 
               1394: ;        ASSERT RDSI:LSN ALREADY CHECKED FOR LEGAL BY SDOS
               1395: ; 
               1396: ;        The formulae for computing the DCB parameters as a function
               1397: ;        of number of sides, single density (SD) or double density (DD)
               1398: ;        first track, SD or DD on other than first track, and number of
               1399: ;        tracks on the drive are:
               1400: ; 
               1401: ;                SS/SD   NBPS = 128 bytes per sector
               1402: ;                        NSPT = 18  sectors per track
               1403: ;                        NTPC = 1 (See note 1) tracks per cylinder
               1404: ;                        NCYL = #sides * #tracks (See note 2)
               1405: ; 
               1406: ;                note 1: This is a lie to SDOS in the case of a double
               1407: ;                        sided disk, but it makes the NLSN (NSPT*NTPC*NCYL)
               1408: ;                        work out to be correct.
               1409: ;                note 2: #tracks is the number of tracks on the disk, including
               1410: ;                        double tracks on a double track disk.
               1411: ; 
               1412: ;      +-------------------------------------------+
               1413: ;      |        5" DRIVE       |   SINGLE SIDED    |
               1414: ;      | # TRACKS ON DRIVE --> | 35   40   70   80 |
               1415: ;      |         NSPT NBPS NTPC|NCYL NCYL NCYL NCYL|
               1416: ;      |-----------------------+-------------------+
               1417: ;      |   SS/SD  18   128    1| 35   40   70   80 |
               1418: ;      |   DS/SD              2|                   |
               1419: ;      +-------------------------------------------+
               1420: ; 
               1421: ;       To compute the sector, track and cylinder, use this formula:
               1422: ;                LSN/18 --> REM --> SECTOR#
               1423: ;                       --> /2  --> REM -> TRACK (HEAD)
               1424: ;                               --> CYLINDER
               1425: ;       where REM is the remainder from the previous step. 
               1426: 
BC88 A603      1427:                 LDAA    RDSI.LSN+1,X            ; SO DISCARD HIGHER LSN BYTE
BC8A E604      1428:                 LDAB    RDSI.LSN+2,X            
BC8C 01        1429:                 NOP                             ; .*echo Read_LSN:D
BC8D BDBC99    1430:                 JSR     DIV18                   ; GO DO THE FAST DIVIDE BY NSPT




ASM/6800 1.4A0: BC90                    
08/16/82 00:00:00; Page 28; Form 1      
IOSWTPC6800.ASM
BC90 4C        1431:                 INCA                            ; SECTORS ON PHYSICAL DISK ARE NUMBERED 1..18
BC91 A70F      1432:                 STAA    RDSI.SECTOR+1,X         ; A CONTAINS SECTOR = (LSN MOD 18)+1
BC93 54        1433:                 LSRB                            ; B CONTAINS CYL = INT(LSN/18) / 2, bit0 -> carry
BC94 E713      1434:                 STAB    RDSI.CYLINDER+1,X       
BC96 6911      1435:                 ROL     RDSI.TRACK+1,X          ; TRACK (HEAD) = INT(LSN/18) MOD 2, head<-carry 0/1
BC98 39        1436:                 RTS
               1437: ;
               1438: ;       Fancy divide algorithm takes (A,B) and divides by NSPT (18).
               1439: ;       If we have 35 track, double side,
               1440: ;       18 sectors/track this is 35*2*18 LSNs =0..1259, with a max
               1441: ;       quotient of 69.
               1442: ;
               1443: ;       Divide (A,B) by 18 (NSPT), quotient in B, remainder in A
               1444: ;
BC99 58        1445: DIV18           ASLB
BC9A 49        1446:                 ROLA
BC9B 8BEE      1447:                 ADDA    #-18                    ; ADD -NSPT TO GENERATE QUOTIENT BIT
BC9D 2502      1448:                 BCS     DIV18.1                 ; B/ Q BIT IS ONE
BC9F 80EE      1449:                 SUBA    #-18                    ; RESTORE BY ADDING DIVISOR; LEAVE CARRY=0
BCA1 59        1450: DIV18.1         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
BCA2 49        1451:                 ROLA
BCA3 8BEE      1452:                 ADDA    #-18
BCA5 2502      1453:                 BCS     DIV18.2
BCA7 80EE      1454:                 SUBA    #-18
BCA9 59        1455: DIV18.2         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
BCAA 49        1456:                 ROLA
BCAB 8BEE      1457:                 ADDA    #-18
BCAD 2502      1458:                 BCS     DIV18.3
BCAF 80EE      1459:                 SUBA    #-18
BCB1 59        1460: DIV18.3         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
BCB2 49        1461:                 ROLA
BCB3 8BEE      1462:                 ADDA    #-18
BCB5 2502      1463:                 BCS     DIV18.4
BCB7 80EE      1464:                 SUBA    #-18
BCB9 59        1465: DIV18.4         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
BCBA 49        1466:                 ROLA
BCBB 8BEE      1467:                 ADDA    #-18
BCBD 2502      1468:                 BCS     DIV18.5
BCBF 80EE      1469:                 SUBA    #-18
BCC1 59        1470: DIV18.5         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
BCC2 49        1471:                 ROLA
BCC3 8BEE      1472:                 ADDA    #-18
BCC5 2502      1473:                 BCS     DIV18.6
BCC7 80EE      1474:                 SUBA    #-18
BCC9 59        1475: DIV18.6         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
BCCA 49        1476:                 ROLA
BCCB 8BEE      1477:                 ADDA    #-18
BCCD 2502      1478:                 BCS     DIV18.7
BCCF 80EE      1479:                 SUBA    #-18
BCD1 59        1480: DIV18.7         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
BCD2 49        1481:                 ROLA
BCD3 8BEE      1482:                 ADDA    #-18
BCD5 2502      1483:                 BCS     DIV18.8
BCD7 80EE      1484:                 SUBA    #-18
BCD9 59        1485: DIV18.8         ROLB




ASM/6800 1.4A0: BCDA                    
08/16/82 00:00:00; Page 29; Form 1      
IOSWTPC6800.ASM
BCDA 39        1486:                 RTS
               1487: 
BCDB 6C3E      1488: DSKOPSCOUNT     INC     DSKINFO.OPSCOUNT+2,X    ; COUNT # OPERATIONS ISSUED TO disk
BCDD 2606      1489:                 BNE     DSKOPSCOUNT1
BCDF 6C3D      1490:                 INC     DSKINFO.OPSCOUNT+1,X
BCE1 2602      1491:                 BNE     DSKOPSCOUNT1
BCE3 6C3C      1492:                 INC     DSKINFO.OPSCOUNT,X
BCE5 39        1493: DSKOPSCOUNT1    rts
               1494: 
               1495: ; PREPARE A SINGLE SECTOR TRANSFER
               1496: 
BCE6 DE06      1497: DSKPREP         LDX     DCBPOINTER              ; GET DCB POINTER
BCE8 BDBCDB    1498:                 jsr     DSKOPSCOUNT             ; incr count of I/O operations done
BCEB A643      1499:                 LDAA    dcb.fdunit,X            ; get this dcb drive number
BCED B7BD5E    1500:                 STAA    DRV
BCF0 6F01      1501:                 CLR     DCB.LASTERROR,X         ; CLEAR ANY ERROR
BCF2 6F02      1502:                 CLR     DCB.LASTERROR+1,X
BCF4 EE2B      1503:                 LDX     DSKINFO.SECTORDB,X      ; GET RDSI POINTER
BCF6 FFBD5C    1504:                 STX     RDSIPOINTER             ; SAVE IT
BCF9 BDBC7D    1505:                 JSR     FDTEARLSN               ; CONVERT RDSI:LSR -> RDSI:TRACK/CYLINDER/SECTOR
BCFC A605      1506:                 LDAA    RDSI.SECTORBASE,X       ; POINTER TO ACTUAL SECTOR CONTENTS
BCFE E606      1507:                 LDAB    RDSI.SECTORBASE+1,X
BD00 B7BD62    1508:                 STAA    DDATA
BD03 F7BD63    1509:                 STAB    DDATA+1
BD06 A613      1510:                 LDAA    RDSI.CYLINDER+1,X       
BD08 B7BD5F    1511:                 STAA    TRK
BD0B A60F      1512:                 LDAA    RDSI.SECTOR+1,X 
BD0D B7BD60    1513:                 STAA    SECT
BD10 A611      1514:                 LDAA    RDSI.TRACK+1,X  
BD12 B7BD61    1515:                 STAA    SIDE
BD15 6F0C      1516:                 CLR     RDSI.STATE,X            ; RESET SECTOR STATE TO "IDLE"
BD17 39        1517:                 RTS
               1518:                 
               1519: ; READ/WRITE -- DO SINGLE SECTOR TRANSFER
               1520: 
BD18 BDBCE6    1521: DSKREAD         JSR     DSKPREP
BD1B BDBD7D    1522:                 JSR     RDSEC                   ; DO I/O OPERATION WITH ACTIVE WAIT: NO INTERRUPTS :-(
BD1E 2612      1523:                 BNE     DSKERR
BD20 FEBD62    1524:                 LDX     DDATA                   
BD23 0C        1525:                 CLC                             ; .*mX-80:RdSec
BD24 39        1526:                 RTS
               1527: 
BD25 BDBCE6    1528: DSKWRITE        JSR     DSKPREP
BD28 BDBD8C    1529:                 JSR     WRSEC                   ; DO I/O OPERATION WITH ACTIVE WAIT: NO INTERRUPTS :-(
BD2B 2605      1530:                 BNE     DSKERR
BD2D FEBD62    1531:                 LDX     DDATA                   
BD30 0C        1532:                 CLC                             ; .*mX-80:WrSec
BD31 39        1533:                 RTS
               1534:                 
BD32 CE0417    1535: DSKERR          LDX     #ERR.DISKSEEK
BD35 8510      1536:                 BITA    #$10
BD37 2611      1537:                 bne     dskerr1                 ; seek error reported by controler status reg
BD39 CE0416    1538:                 LDX     #ERR.DISKWRITE
BD3C 8520      1539:                 BITA    #$20                    
BD3E 260A      1540:                 bne     dskerr1                 ; WRITE FAULT reported by controler status reg




ASM/6800 1.4A0: BD40                    
08/16/82 00:00:00; Page 30; Form 1      
IOSWTPC6800.ASM
BD40 CE0418    1541:                 LDX     #ERR.DSKWRTPROT
BD43 8540      1542:                 BITA    #$40                    
BD45 2603      1543:                 bne     dskerr1                 ; WRITE PROTECT reported by controler status reg
BD47 CE0415    1544:                 LDX     #ERR.DISKREAD           ; ELSE ASUME LOST DATA OR CRC ERROR HAS BEEN reported by contro
BD4A DF00      1545: DSKERR1         STX     $00                     ; TXAB X=SDOS ERROR CODE (16 BITS) -> (A,B)
BD4C 9600      1546:                 LDAA    $00
BD4E D601      1547:                 LDAB    $01             
BD50 DE06      1548:                 LDX     DCBPOINTER              ; GET DCB POINTER
BD52 A701      1549:                 STAA    DCB.LASTERROR,X         ; SAVE THE ERROR
BD54 E702      1550:                 STAB    DCB.LASTERROR+1,X
BD56 DE00      1551:                 LDX     $00                     ; GET BACK ERROR IN X-REG
BD58 0D        1552:                 SEC
BD59 39        1553:                 RTS     
               1554:         
  BD5A         1555: DSKRESTORE
  BD5A         1556: DSKWAITDONE
BD5A 5F        1557:                 CLRB                           ; CLEAR THE CARRY
BD5B 39        1558:                 RTS
               1559: 
               1560: 
BD5C 0002      1561: RDSIPOINTER     RMB     2
               1562: 
               1563: 
               1564: ; DISK DRIVERS FOR SOUTHWEST TECHNICAL PRODUCTS MF-68
               1565: 
               1566: ; INPUT PARAMS
               1567: 
BD5E 0001      1568: DRV    RMB 1         ; DRIVE TO OPERATE ON
BD5F 0001      1569: TRK    RMB 1         ; TRACK TO READ/WRITE
BD60 0001      1570: SECT   RMB 1         ; SECTOR TO READ/WRITE
BD61 0001      1571: SIDE   RMB 1         ; SIDE TO READ/WRITE
BD62 0002      1572: DDATA  RMB 2         ; POINTER TO DATA BUFFER (MUST HAVE 128 BYTES)
               1573: 
               1574: ; COMMANDS FOR WD1771 CONTROLLER CHIP
               1575: ;
  000B         1576: FDRSC  EQU $0B       ; RESTORE
  001B         1577: FDSKI  EQU $1B       ; SEEK
  008C         1578: FDRDC  EQU $8C       ; READ A SECTOR
  00AC         1579: FDWRC  EQU $AC       ; WRITE A SECTOR
               1580: 
               1581: ; ADDR OF WD1771 CONTROLLER CHIP REGISTERS 
               1582: 
  0001         1583:         if RAM64K=1
               1584: 
  FF14         1585: DRVREG set $ff14
  FF18         1586: CMDREG set $ff18
  FF19         1587: TRKREG set $ff19
  FF1A         1588: SECREG set $ff1A
  FF1B         1589: DATREG set $ff1B
               1590: 
  0001         1591:         else
 *S*           1592:         
 *S*           1593: DRVREG EQU $8014
 *S*           1594: CMDREG EQU $8018
 *S*           1595: TRKREG EQU $8019




ASM/6800 1.4A0: BD62                    
08/16/82 00:00:00; Page 31; Form 1      
IOSWTPC6800.ASM
 *S*           1596: SECREG EQU $801A
 *S*           1597: DATREG EQU $801B
 *S*           1598: 
               1599:         fin
               1600: 
               1601: ; DRIVER VARS
               1602: 
BD64 FF        1603: CURDRV FCB $FF       ; PRESENTLY SELECTED DRIVE #
BD65 0004      1604: CTRK0  RMB 4         ; TRACK STATE TABLE
BD69 0001      1605: RCNT   RMB 1         ; RETRY COUNT
BD6A 0001      1606: SIDEBT RMB 1         ; SIDE SELECTION BIT
               1607: 
               1608: ; INIT THE DISK SYSTEM
               1609: 
BD6B 7FBD64    1610: INTDK  CLR CURDRV    ; ASSUME DRIVE 0 BOOTED
BD6E 86FF      1611:        LDAA #$FF
BD70 B7BD65    1612:        STAA CTRK0       
BD73 B7BD66    1613:        STAA CTRK0+1
BD76 B7BD67    1614:        STAA CTRK0+2       
BD79 B7BD68    1615:        STAA CTRK0+3
BD7C 39        1616: DUMMY  RTS       
               1617: 
               1618: ; READ A SECTOR
               1619: ;
BD7D BDBE49    1620: RDSEC  JSR SELDRV 
BD80 BDBD9B    1621: RDSEC1 JSR READ       ; GETA SECTOR
BD83 2715      1622:        BEQ QUIT10     ; OK
BD85 7ABD69    1623:        DEC RCNT       ; RETRY AGAIN?
BD88 26F6      1624:        BNE RDSEC1     ; YES
BD8A 200D      1625:        BRA QERR
               1626: 
               1627: ; WRITE A SECTOR
               1628: ;
BD8C BDBE49    1629: WRSEC  JSR SELDRV 
BD8F BDBDD1    1630: WTSEC1 JSR WRITE
BD92 2706      1631:        BEQ QUIT10     ; OK
BD94 7ABD69    1632:        DEC RCNT       ; TRY AGAIN?
BD97 26F6      1633:        BNE WTSEC1     ; YES
BD99 4D        1634: QERR   TSTA           ; A HAS THE STATUS BITS WITH ERROR 
BD9A 39        1635: QUIT10 RTS
               1636: 
               1637: ; READ A SECTOR (A=TRK, B=SECTOR, X=CTRKx)
               1638: ;
BD9B BDBE00    1639: READ   JSR SEEK
BD9E 868C      1640:        LDAA #FDRDC    ; READ
BDA0 BBBD6A    1641:        ADDA SIDEBT
BDA3 B7FF18    1642:        STAA CMDREG     
BDA6 BDBE29    1643:        JSR DEL56U     ; DELAY
BDA9 FEBD62    1644:        LDX DDATA      ; GET BUFFER ADDRESS
BDAC C680      1645:        LDAB #128      ; 128 BYTES/SECTOR     
BDAE B6FF18    1646: READ1  LDAA CMDREG     
BDB1 8502      1647:        BITA #$02      ; DATA REG FULL?
BDB3 2606      1648:        BNE READ2      ; YES
BDB5 8501      1649:        BITA #1        ; BUSY?
BDB7 26F5      1650:        BNE READ1      ; YES




ASM/6800 1.4A0: BDB9                    
08/16/82 00:00:00; Page 32; Form 1      
IOSWTPC6800.ASM
BDB9 200B      1651:        BRA READ3      ; ERROR
BDBB B6FF1B    1652: READ2  LDAA DATREG    ; GET A BYTE
BDBE A700      1653:        STAA 0,X       ; STORE IN BUFFER
BDC0 08        1654:        INX             
BDC1 5A        1655:        DECB            
BDC2 26EA      1656:        BNE READ1      ; DO AGAIN
BDC4 8D03      1657:        BSR WBUSY      ; WAIT TILL DONE
BDC6 841C      1658: READ3  ANDA #$1C      ; MASK OF STATUS BITS
BDC8 39        1659:        RTS             
               1660:                        
BDC9 B6FF18    1661: WBUSY  LDAA CMDREG     
BDCC 8501      1662:        BITA #1        ; BUSY?
BDCE 26F9      1663:        BNE WBUSY      ; YES
BDD0 39        1664:        RTS
               1665: 
               1666: ; WRITE A SECTOR (A=TRK, B=SECTOR, X=CTRKx)
               1667: 
BDD1 BDBE00    1668: WRITE  JSR SEEK
BDD4 86AC      1669:        LDAA #FDWRC    ; WRITE COMMAND
BDD6 BBBD6A    1670:        ADDA SIDEBT
BDD9 B7FF18    1671:        STAA CMDREG     
BDDC BDBE29    1672:        JSR DEL56U      
BDDF FEBD62    1673:        LDX DDATA      ; GET BUFFER ADDRESS
BDE2 C680      1674:        LDAB #128      ; 128 BYTES/SECTOR
BDE4 B6FF18    1675: WRITE1 LDAA CMDREG     
BDE7 8502      1676:        BITA #2        ; REG EMPTY?
BDE9 2606      1677:        BNE WRITE2     ; YES
BDEB 8501      1678:        BITA #1        ; BUSY?
BDED 26F5      1679:        BNE WRITE1     ; YES
BDEF 20A8      1680:        BRA QERR       ; ERROR
BDF1 A600      1681: WRITE2 LDAA 0,X       ; GET A BYTE
BDF3 B7FF1B    1682:        STAA DATREG     
BDF6 08        1683:        INX             
BDF7 5A        1684:        DECB            
BDF8 26EA      1685:        BNE WRITE1     ; DO AGAIN
BDFA BDBDC9    1686:        JSR WBUSY      ; WAIT FOR BUSY
BDFD 847C      1687: WRITE3 ANDA #$7C      ; MASK OFF STATUS BITS
BDFF 39        1688:        RTS
               1689: 
               1690: ; SEEK A=TRACK, B=SECTOR, X=CTRKx
               1691: 
BE00 B1FF19    1692: SEEK   CMPA TRKREG    ; ON TRACK?
BE03 2713      1693:        BEQ SEEK2      ; YES
BE05 B7FF1B    1694:        STAA DATREG    ; NO, STORE TRACK#
BE08 BDBE29    1695:        JSR DEL56U      
BE0B A700      1696:        STAA 0,X       ; SAVE CURRENT TRACK OF DRIVE
BE0D 861B      1697:        LDAA #FDSKI    ; SEEK COMMAND
BE0F B7FF18    1698:        STAA CMDREG     
BE12 BDBE29    1699:        JSR DEL56U      
BE15 BDBDC9    1700:        JSR WBUSY      ; WAIT FOR BUSY
BE18 F7FF1A    1701: SEEK2  STAB SECREG    ; SET SECTOR
BE1B BDBE29    1702:        JSR DEL56U
BE1E B6BD61    1703:        LDAA SIDE
BE21 2702      1704:        BEQ SEEK3
BE23 8608      1705:        LDAA #$08      ; SELECT SIDE 1




ASM/6800 1.4A0: BE25                    
08/16/82 00:00:00; Page 33; Form 1      
IOSWTPC6800.ASM
BE25 B7BD6A    1706: SEEK3  STAA SIDEBT       
BE28 39        1707:        RTS
               1708: 
               1709: ; DEL56U- DELAY 56us INCLUDING THE CALL TO DELAY56U
               1710: 
BE29 BDBE2C    1711: DEL56U JSR DELAY2
BE2C BDBE2F    1712: DELAY2 JSR DELAY3
BE2F 39        1713: DELAY3 RTS
               1714: 
               1715: ; FIND TRACK- RETURN X->TRACK TABLE FOR CURDRV
               1716: 
BE30 CEBD65    1717: FNDTRK LDX #CTRK0     ; POINT TO TABLE
BE33 B6BD64    1718:        LDAA CURDRV
BE36 2704      1719:        BEQ FNDTK3
BE38 08        1720: FNDTK2 INX
BE39 4A        1721:        DECA
BE3A 26FC      1722:        BNE FNDTK2
BE3C 39        1723: FNDTK3 RTS
               1724: 
               1725: ; RESTORE SEEK TRACK0
               1726: 
BE3D 860B      1727: RESTOR LDAA #FDRSC    ; RESTORE COMMAND
BE3F B7FF18    1728:        STAA CMDREG
BE42 BDBE29    1729:        JSR DEL56U
BE45 BDBDC9    1730:        JSR WBUSY
BE48 39        1731:        RTS
               1732: 
               1733: ; SELECT THE DRIVE
               1734: ; RETURN A=TRACK, B=SECTOR, X=CTRKx
               1735: 
BE49 8DE5      1736: SELDRV BSR FNDTRK     ; SAVE TRACK FOR CURRENT DRIVE
BE4B B6FF19    1737:        LDAA TRKREG     
BE4E A700      1738:        STAA 0,X        
BE50 B6BD5E    1739:        LDAA DRV       ; GET DRIVE 
BE53 B7BD64    1740:        STAA CURDRV     
BE56 B7FF14    1741:        STAA DRVREG    ; SELECT THE DRIVE
BE59 8DD5      1742:        BSR FNDTRK     ; LOAD TRACK FOR NEW DRIVE
BE5B A600      1743:        LDAA 0,X       ; A=CURRENT DRIVE TRACK
BE5D B7FF19    1744:        STAA TRKREG     
BE60 81FF      1745:        CMPA #$FF      ; INITIALIZED?
BE62 2602      1746:        BNE SELD1      ; YES
BE64 8DD7      1747:        BSR RESTOR     ; SEEK TRACK0
BE66 8605      1748: SELD1  LDAA #5        ; SET RETRY COUNT
BE68 B7BD69    1749:        STAA RCNT       
BE6B B6BD5F    1750:        LDAA TRK       ; GET TRACK#        
BE6E F6BD60    1751:        LDAB SECT      ; GET SECTOR#
BE71 39        1752:        RTS            
               1753: 
               1754: 
               1755: ; High level EMULATOR (HLE) for swtpc 6800 harddisk with
               1756: ; XIBEX S1410 Winchester Disk Controller and
               1757: ; TANDOM TM-602S 5MB DRIVE
               1758: 
               1759: 
BE72 48443A    1760: dcbname.hd      fcc     'HD:'




ASM/6800 1.4A0: BE75                    
08/16/82 00:00:00; Page 34; Form 1      
IOSWTPC6800.ASM
BE75 00        1761:                 fcb     0
BE76 01        1762: DCB.HD          FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
BE77 0000      1763:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
BE79 BE72      1764:                 FDB     dcbname.HD              ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
BE7B 0000      1765:                 FDB     0                       ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
BE7D BEBA      1766:                 FDB     HDDRIVER                ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
               1767: 
               1768:                                                                 ; DISK GEOMETRY
BE7F 0080      1769:                 FDB     128                     ; DSKINFO:NBPS  ; NUMBER OF BYTES PER SECTOR
BE81 0040      1770:                 FDB     64                      ; DSKINFO:NSPT  ; NUMBER OF SECTORS PER TRACK
BE83 0004      1771:                 FDB     4                       ; DSKINFO:NTPC  ; NUMBER OF TRACKS PER CYLINDER (=surfaces)
BE85 0099      1772:                 FDB     153                     ; DSKINFO:NCYL  ; NUMBER OF CYLINDERS PER DRIVE
               1773: 
               1774:                                                                 ; THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
BE87 0001      1775:                 RMB     1                       ; DSKINFO:NSPC   NUMBER OF SECTORS PER CLUSTER
BE88 0002      1776:                 RMB     LCN.SIZE                ; DSKINFO:MINALLOC ALLOCATION MINIMUM FOR NEW FILES
BE8A 0002      1777:                 RMB     LCN.SIZE                ; DSKINFO:MIDALLOC ALLOCATION MIN FOR FILE EXTENSION
BE8C 0002      1778:                 RMB     2                       ; DSKINFO:MAPALGORITHM CODE TO SELECT LOGICAL TO PHYSICAL SECTO
               1779: 
               1780:                                                                 ; CONTAINS DISK ID FOR MOUNTED DISKS
BE8E 0001      1781:                 RMB     1                       ; DSKINFO:LOG2NBPS LOG BASE 2 OF DSKINFO:NBPS
BE8F 0002      1782:                 RMB     2                       ; DSKINFO:NBPSM1 = NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
BE91 0003      1783:                 RMB     LSN.SIZE                ; DSKINFO:NLSN   NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
BE94 0002      1784:                 RMB     LCN.SIZE                ; DSKINFO:NLCN   NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
BE96 0002      1785:                 RMB     2                       ; DSKINFO:NBPC   NUMBER OF BYTES PER CLUSTER
BE98 0002      1786:                 RMB     LCN.SIZE                ; DSKINFO:RANDMAP "RANDOM" LCN TO DISTRIBUTE NEW FILES
BE9A 0003      1787:                 RMB     LSN.SIZE                ; DSKINFO:MAPLSN LSN OF 1ST SECTOR IN DISK...
               1788: 
               1789:                                                                 ; ALLOCATION MAP CLUSTER
BE9D 0002      1790:                 RMB     2                       ; DSKINFO:DIRFCB POINTER TO FCB FOR $DIRECTORY FILE
BE9F 0002      1791:                 RMB     2                       ; DSKINFO:MAPFCB POINTER TO FCB FOR $DISKMAP FILE
BEA1 0002      1792:                 RMB     2                       ; DSKINFO:SECTORDB POINTER TO RDSI CONTAINING LSN, ADDRESS PARA
BEA3 0003      1793:                 RMB     LSN.SIZE                ; DSKINFO:BADLSN LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SE
BEA6 0000      1794:                 FDB     0                       ; DSKINFO:SEEKERRCNT # SEEK ERRORS SINCE MOUNT
BEA8 0000      1795:                 FDB     0                       ; DSKINFO:SEEKERRSTS 16 BITS OF LAST "SEEK" STATUS IN ERROR
BEAA 0000      1796:                 FDB     0                       ; DSKINFO:WRITEERRCNT # WRITE ERRORS SINCE MOUNT
BEAC 0000      1797:                 FDB     0                       ; DSKINFO:WRITEERRSTS 16 BITS OF LAST "WRITE" STATUS IN ERROR
BEAE 0000      1798:                 FDB     0                       ; DSKINFO:READERRCNT # READ ERRORS SINCE MOUNT
BEB0 0000      1799:                 FDB     0                       ; DSKINFO:READERRSTS 16 BITS OF LAST "READ" STATUS IN ERROR
BEB2 000000    1800:                 FCB     0,0,0                   ; DSKINFO:OPSCOUNT 24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
BEB5 0003      1801:                 RMB     LSN.SIZE                ; DSKINFO:ERRLSN LSN CAUSING ANY SOFT OR HARD ERROR
BEB8 0001      1802:                 RMB     1                       ; DSKINFO:WRITEPROTSTATE 0 --> WRITEABLE
BEB9 00        1803:                 FCB     0                       ; FDUNIT         Drive number 
               1804: 
               1805: 
               1806: ; DEVICE DRIVER BLOCK FOR HARD DISK
               1807: 
BEBA BD5A      1808: HDDRIVER        FDB     DSKRESTORE              ; DRIVER:DISKRESET RESET THIS DISK DRIVER
BEBC BF5A      1809:                 FDB     HDREAD                  ; DRIVER:DISKREAD INITIATE A DISK SECTOR READ
BEBE BF74      1810:                 FDB     HDWRITE                 ; DRIVER:DISKWRITE INITIATE A DISK SECTOR WRITE
BEC0 BD5A      1811:                 FDB     DSKWAITDONE             ; DRIVER:DISKWAIT WAIT FOR DISK I/O COMPLETE
BEC2 B4B8      1812:                 FDB     ILLDEVICEOP             ; DRIVER:DISKSTATUS STATUS handled completely by SDOS1.1
BEC4 BC74      1813:                 FDB     DSKCONTROL              ; DRIVER:DISKCONTROL PERFORM DISK-SPECIFIC CONTROL OPERATION
BEC6 B4B8      1814:                 FDB     ILLDEVICEOP             ; DRIVER:DISKWRITEPROTQ DETERMINE IF DISK IS WRITE PROTECTED
BEC8 B4B8      1815:                 FDB     ILLDEVICEOP             ; DRIVER:DISKVERIFY INITIATE A DISK SECTOR VERIFY




ASM/6800 1.4A0: BECA                    
08/16/82 00:00:00; Page 35; Form 1      
IOSWTPC6800.ASM
BECA B4B8      1816:                 FDB     ILLDEVICEOP             ; DRIVER:DISKLSNTOPSN CONVERT LSN TO PHYSICAL CYLINDER, TRACK A
               1817: 
  0001         1818: HDCMD.HEARTBEAT EQU     $01
  0002         1819: HDCMD.SELDRV    EQU     $02
  0003         1820: HDCMD.SETSECT   EQU     $03
  0004         1821: HDCMD.SETSURF   EQU     $04
  0005         1822: HDCMD.SETTRACK  EQU     $05
  0006         1823: HDCMD.SETADDRH  EQU     $06
  0007         1824: HDCMD.SETADDRL  EQU     $07
  0008         1825: HDCMD.READ      EQU     $08
  0009         1826: HDCMD.WRITE     EQU     $09
               1827: 
               1828: 
  0001         1829:                 if ram64k=1
               1830: 
  FF10         1831: HDCMD           EQU     $FF10   ; PORTS FOR HARD DISK HIGH LEVEL EMULATOR INTERFACE
  FF11         1832: HDDATA          EQU     $FF11           
               1833: 
  0001         1834:                 else
 *S*           1835: 
 *S*           1836: HDCMD           EQU     $8010   ; PORTS FOR HARD DISK HIGH LEVEL EMULATOR INTERFACE
 *S*           1837: HDDATA          EQU     $8011           
 *S*           1838: 
               1839:                 fin
               1840: 
               1841: 
BECC 8655      1842: HDPREP          LDAA    #$55                    ; TEST IF HD HLE CONTROLER IS RESPONDING
BECE B7FF11    1843:                 STAA    HDDATA
BED1 8601      1844:                 LDAA    #HDCMD.HEARTBEAT        
BED3 B7FF10    1845:                 STAA    HDCMD
BED6 B6FF11    1846:                 LDAA    HDDATA
BED9 8167      1847:                 CMPa    #$67                    ; SHOULD GET THIS REPLY 
BEDB 2705      1848:                 BEQ     HDHLEOK
BEDD CE0424    1849:                 LDX     #ERR.DEVICENOTREADY     ; WE ARE RUNNING WITH HD DISABLED OR IN ANOTHER SIMULATOR 
BEE0 0D        1850:                 SEC                             ; WITHOUT HLE HARD DRIVE EMULATOR, OR EVEN IN REAL HW!
BEE1 39        1851:                 RTS                             ; IN ANY CASE, THERE IS NO HARD DISK -> SIGNALS DEVICE NOT READ
BEE2 DE06      1852: HDHLEOK         LDX     DCBPOINTER              ; GET DCB POINTER
BEE4 BDBCDB    1853:                 jsr     DSKOPSCOUNT             ; incr count of I/O operations done
BEE7 A643      1854:                 LDAA    dcb.fdunit,X            ; get this dcb drive number
BEE9 C602      1855:                 LDAB    #HDCMD.SELDRV           ; HD COMMAND: SELECT DRIVE
BEEB F7FF10    1856:                 STAB    HDCMD
BEEE B7FF11    1857:                 STAA    HDDATA
BEF1 6F01      1858:                 CLR     DCB.LASTERROR,X         ; CLEAR ANY ERROR
BEF3 6F02      1859:                 CLR     DCB.LASTERROR+1,X
BEF5 EE2B      1860:                 LDX     DSKINFO.SECTORDB,X      ; GET RDSI POINTER
BEF7 FFBD5C    1861:                 STX     RDSIPOINTER             ; SAVE IT
               1862:                                                 ; CONVERT RDSI:LSR -> RDSI:CYLINDER/SECTOR
BEFA FEBD5C    1863:                 LDX     RDSIPOINTER
BEFD 6F0E      1864:                 CLR     RDSI.SECTOR,X           ; CLEAR MSB OF SECTOR, TRACK 
BEFF 6F10      1865:                 CLR     RDSI.TRACK,X
BF01 6F12      1866:                 CLR     RDSI.CYLINDER,X 
               1867: 
BF03 A603      1868:                 LDAA    RDSI.LSN+1,X            ; DISCARD HIGHER LSN BYTE
BF05 E604      1869:                 LDAB    RDSI.LSN+2,X            
BF07 37        1870:                 PSHB




ASM/6800 1.4A0: BF08                    
08/16/82 00:00:00; Page 36; Form 1      
IOSWTPC6800.ASM
BF08 C43F      1871:                 ANDB    #63                     ; SECTOR = LSN AND 63
BF0A E70F      1872:                 STAB    RDSI.SECTOR+1,X         ; B CONTAINS SECTOR = 0..63
BF0C F7FF11    1873:                 STAB    HDDATA
BF0F C603      1874:                 LDAB    #HDCMD.SETSECT          ; HD COMMAND: SET SECTOR
BF11 F7FF10    1875:                 STAB    HDCMD
BF14 33        1876:                 PULB
BF15 44        1877:                 LSRA                            ; LSN = LSN DIV 64
BF16 56        1878:                 RORB
BF17 44        1879:                 LSRA                            
BF18 56        1880:                 RORB
BF19 44        1881:                 LSRA                            
BF1A 56        1882:                 RORB
BF1B 44        1883:                 LSRA                            
BF1C 56        1884:                 RORB
BF1D 44        1885:                 LSRA                            
BF1E 56        1886:                 RORB
BF1F 44        1887:                 LSRA                            
BF20 56        1888:                 RORB
BF21 37        1889:                 PSHB
BF22 C403      1890:                 ANDB    #3                      ; SURFACE = LSN AND 3
BF24 E711      1891:                 STAB    RDSI.TRACK+1,X          ; B CONTAINS SURFACE = 0..3
BF26 F7FF11    1892:                 STAB    HDDATA
BF29 C604      1893:                 LDAB    #HDCMD.SETSURF          ; HD COMMAND: SET SURFACE
BF2B F7FF10    1894:                 STAB    HDCMD
BF2E 33        1895:                 PULB                            ; LSN = LSN DIV 4
BF2F 44        1896:                 LSRA                            
BF30 56        1897:                 RORB
BF31 44        1898:                 LSRA                            
BF32 56        1899:                 RORB
BF33 E713      1900:                 STAB    RDSI.CYLINDER+1,X       ; B CONTAINS TRACK 0..152
BF35 F7FF11    1901:                 STAB    HDDATA
BF38 C605      1902:                 LDAB    #HDCMD.SETTRACK         ; HD COMMAND: SET TRACK
BF3A F7FF10    1903:                 STAB    HDCMD
               1904: 
BF3D A605      1905:                 LDAA    RDSI.SECTORBASE,X       ; POINTER TO ACTUAL SECTOR CONTENTS
BF3F B7BD62    1906:                 STAA    DDATA
BF42 B7FF11    1907:                 STAA    HDDATA
BF45 8606      1908:                 LDAA    #HDCMD.SETADDRH         ; HD COMMAND: SET ADDR (MSB)
BF47 B7FF10    1909:                 STAA    HDCMD
BF4A E606      1910:                 LDAB    RDSI.SECTORBASE+1,X     ; POINTER TO ACTUAL SECTOR CONTENTS
BF4C F7BD63    1911:                 STAB    DDATA+1
BF4F F7FF11    1912:                 STAB    HDDATA
BF52 C607      1913:                 LDAB    #HDCMD.SETADDRL         ; HD COMMAND: SET ADDR (LSB)
BF54 F7FF10    1914:                 STAB    HDCMD
               1915: 
BF57 6F0C      1916:                 CLR     RDSI.STATE,X            ; RESET SECTOR STATE TO "IDLE"
BF59 39        1917:                 RTS
               1918: 
BF5A BDBECC    1919: HDREAD          JSR     HDPREP
BF5D 250D      1920:                 BCS     HDERR
BF5F 8608      1921:                 LDAA    #HDCMD.READ             ; HD COMMAND: READ SECTOR
BF61 B7FF10    1922:                 STAA    HDCMD
BF64 B6FF11    1923:                 LDAA    HDDATA                  ; retried status of hd operation
BF67 2706      1924:                 BEQ     HDRDOK
BF69 CE0415    1925:                 LDX     #ERR.DISKREAD




ASM/6800 1.4A0: BF6C                    
08/16/82 00:00:00; Page 37; Form 1      
IOSWTPC6800.ASM
BF6C 7EBD4A    1926: HDERR           JMP     DSKERR1
BF6F FEBD62    1927: HDRDOK          LDX     DDATA                   
BF72 0C        1928:                 CLC                             ; .*mX-80:HdSec
BF73 39        1929:                 RTS
               1930:                 
BF74 BDBECC    1931: HDWRITE         JSR     HDPREP
BF77 25F3      1932:                 BCS     HDERR
BF79 8609      1933:                 LDAA    #HDCMD.WRITE            ; HD COMMAND: WRITE SECTOR
BF7B B7FF10    1934:                 STAA    HDCMD
BF7E B6FF11    1935:                 LDAA    HDDATA
BF81 27EC      1936:                 BEQ     HDRDOK
BF83 CE0416    1937:                 LDX     #ERR.DISKWRITE
BF86 20E4      1938:                 BRA     HDERR
               1939:                 
               1940: 
               1941: 
               1942: ; DEVICE CONTROL BLOCK FOR CLOCK 
               1943: 
BF88 434C4F43  1944: CLOCKSTR        FCC     'CLOCK:'
BF8E 00        1945:                 fcb     0
               1946: 
BF8F 01        1947: CLOCKDCB        FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE.
BF90 0000      1948:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
BF92 BF88      1949:                 FDB     CLOCKSTR                ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
BF94 0000      1950:                 FDB     0                       ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
BF96 BF98      1951:                 FDB     CLOCKDRIVER             ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
               1952: 
               1953: ; DEVICE DRIVER BLOCK FOR CLOCK CONSOLE
               1954: 
BF98 BFB2      1955: CLOCKDRIVER     FDB     CLOCKOPEN       ; DRIVER:OPEN   OPEN FILE
BF9A BFB2      1956:                 FDB     CLOCKCLOSE      ; DRIVER:CLOSE  CLOSE FILE
BF9C BFF2      1957:                 FDB     CLOCKREADA      ; DRIVER:READA  READ ASCII
BF9E B4B8      1958:                 FDB     ILLDEVICEOP     ; DRIVER:WRITEA WRITE ASCII WRITEA IS A NO-NO
BFA0 BFD0      1959:                 FDB     CLOCKREADB      ; DRIVER:READB  READ BINARY
BFA2 BFCD      1960:                 FDB     CLOCKWRITEB     ; DRIVER:WRITEB WRITE BINARY
BFA4 B4B8      1961:                 FDB     ILLDEVICEOP     ; DRIVER:CREATE CREATE FILE YOU UPDATE THE CLOCK, NOT REBUILD IT (CREAT
BFA6 B4B8      1962:                 FDB     ILLDEVICEOP     ; DRIVER:RENAME RENAME FILE RENAME IT TO WHAT? CLOCK-RADIO: ???
BFA8 B4B8      1963:                 FDB     ILLDEVICEOP     ; DRIVER:DELETE DELETE FILE YOU CAN'T GET RID OF THE CLOCK, NEITHER
BFAA B4B8      1964:                 FDB     ILLDEVICEOP     ; DRIVER:CONTROL NO CONTROL FUNCTIONS
BFAC BFB8      1965:                 FDB     CLOCKSTATUS     ; DRIVER:STATUS READ DEVICE (DRIVER) STATUS SAY "I'M A CLOCK, TICK-TOCK
BFAE BFCD      1966:                 FDB     CLOCKRESET      ; DRIVER:RESET  RESET DRIVER (ON BOOT)
BFB0 BFB2      1967:                 FDB     CLOCKPFRESTART  ; DRIVER:STARTIO        WHO UNPLUGGED ME???
               1968: 
  0000         1969: TEMPX           EQU     0
               1970: 
  BFB2         1971: CLOCKOPEN       EQU     *               ; HOW ABOUT LOOKING AT YOUR $9 TI CHEAPIE, MAC!
  BFB2         1972: CLOCKCLOSE      EQU     *               ; WHAT AM I SUPPOSED TO DO, PUT THE CLOCK AWAY??
  BFB2         1973: CLOCKPFRESTART  EQU     *               ; AM I SUPPOSED TO KEEP TIME WITH NO POWER???
BFB2 7EB4B6    1974:                 JMP     OKRTS           ; TOUGH!
               1975: 
BFB5 7EB4B8    1976: CLOCKSPRUNG     JMP     ILLDEVICEOP
BFB8 8104      1977: CLOCKSTATUS     CMPA    #SC.GETTYPE     ; The only status syscall accepted is SC:GETTYP, which returns DVTYF.CL
BFBA 26F9      1978:                 BNE     CLOCKSPRUNG     ; 
BFBC FECE07    1979:                 LDX     SDOS+SDOS.IOBLOCKPTR
BFBF BDCE36    1980:                 JSR     SDOS+SDOS.CHECKRDLEN    ; HAS HE GOT A BYTE SPACE




ASM/6800 1.4A0: BFC2                    
08/16/82 00:00:00; Page 38; Form 1      
IOSWTPC6800.ASM
BFC2 0001      1981:                 FDB     1
BFC4 EE0A      1982:                 LDX     SCBLK.RDBUF,X   ; GET THE BUFFER POINTER (where syscall return values are to be set)
BFC6 860B      1983:                 LDAA    #DVTYP.CLOCK    ; I'M ALIVE AND TICKING (HOPEFULLY!)
BFC8 A700      1984:                 STAA    0,X     
BFCA 7EB4B6    1985:                 JMP     OKRTS
  BFCD         1986: CLOCKWRITEB     EQU     *
  BFCD         1987: CLOCKRESET      EQU     *
BFCD 7EB4B6    1988:                 JMP     OKRTS
               1989: 
BFD0 BDCE36    1990: CLOCKREADB      JSR     SDOS+SDOS.CHECKRDLEN
BFD3 0006      1991:                 FDB     6               ; HE BETTER HAVE 6 BYTES AT LEAST
BFD5 CECE00    1992:                 LDX     #SDOS           ; READ CURRENT CLOCK SETTING
BFD8 C606      1993:                 LDAB    #6              ; TO STACK
BFDA A60B      1994: CLOCKRB1        LDAA    SDOS.CLOCK,X
BFDC 08        1995:                 INX
BFDD 36        1996:                 PSHA
BFDE 5A        1997:                 DECB
BFDF 26F9      1998:                 BNE     CLOCKRB1
BFE1 FECE07    1999:                 LDX     SDOS+SDOS.IOBLOCKPTR
BFE4 EE0A      2000:                 LDX     SCBLK.RDBUF,X
BFE6 C606      2001:                 LDAB    #6              ; PUT CLOCK IN READ BUFFER
BFE8 32        2002: CLOCKRB2        PULA
BFE9 A705      2003:                 STAA    5,X
BFEB 09        2004:                 DEX
BFEC 5A        2005:                 DECB
BFED 26F9      2006:                 BNE     CLOCKRB2
BFEF 7EB4B6    2007:                 JMP     OKRTS
               2008: 
BFF2 BDCE36    2009: CLOCKREADA      JSR     SDOS+SDOS.CHECKRDLEN
BFF5 0011      2010:                 FDB     17              ; ENOUGH FOR HH:MM:SS MM/DD/YY
BFF7 FECE07    2011:                 LDX     SDOS+SDOS.IOBLOCKPTR
BFFA A60C      2012:                 LDAA    SCBLK.RDLEN,X   ; SEE IF ENOUGH SPACE FOR CR
BFFC 2606      2013:                 BNE     CLOCKREADA0
BFFE E60D      2014:                 LDAB    SCBLK.RDLEN+1,X 
C000 C112      2015:                 CMPB    #18
C002 2502      2016:                 BLO     CLOCKREADA1     ; B/ NO
C004 6C09      2017: CLOCKREADA0     INC     SCBLK.RPLEN+1,X ; YES, INCLUDE THE CR IN THE COUNT
C006 EE0A      2018: CLOCKREADA1     LDX     SCBLK.RDBUF,X
C008 2504      2019:                 BLO     CLOCKREADA2     ; B/ CR NOT INCLUDED
C00A 860D      2020:                 LDAA    #13             ; <CR>
C00C A711      2021:                 STAA    17,X
C00E 8611      2022: CLOCKREADA2     LDAA    #17
C010 DF00      2023:                 STX     TEMPX
C012 CEC029    2024:                 LDX     #TIMESTR
C015 E600      2025: CLOCKREADA3     LDAB    0,X
C017 08        2026:                 INX
C018 DF02      2027:                 STX     TEMPX+2
C01A DE00      2028:                 LDX     TEMPX
C01C E700      2029:                 STAB    0,X
C01E 08        2030:                 INX
C01F DF00      2031:                 STX     TEMPX
C021 DE02      2032:                 LDX     TEMPX+2
C023 4A        2033:                 DECA
C024 26EF      2034:                 BNE     CLOCKREADA3
C026 7EB4B6    2035:                 JMP     OKRTS




ASM/6800 1.4A0: C026                    
08/16/82 00:00:00; Page 39; Form 1      
IOSWTPC6800.ASM
               2036: 
C029 30303A30  2037: TIMESTR         FCC     '00:00:00 08/16/82'
               2038:   
  C03A         2039: ATTNCHECK       
  C03A         2040: DEBUGSYSCALL    
C03A 7EB4B6    2041:                 jmp     okrts
               2042: 
               2043: 
  0000         2044:                 if *>>IOBUF
 *S*           2045:                 ? IO package too big! overlaps IOBUF
               2046:                 fin
               2047:                 
               2048:                 end




ASM/6800 1.4A0: C03A                    
08/16/82 00:00:00; Page 40; Form 1      Symbols Sorted by Name
IOSWTPC6800.ASM
Symbols Sorted by Name:

*ABORTBIT/0080   ACIAIN/B609     ACIAPORT/FF04   ACIOU1/B5EF     ACIOUT/B5EB     ACTIVATIONCHARSENSED/B5DF
 ACTIVATIONCHARSVECTOR/B5CF      ACTIVBYTE/B877  ACTIVCHAR/B882  APORT.MODE/BA5F                 ATTNCHECK/C03A  BACKSPACE/B889
 BACKSPC1/B8A5   BACKSPC2/B8AA   BADINTERRUPTCOUNT/B44E          BASICDEBUGFLAGS/C080            BASICFLAGS/B5CB
 BREAKBIT/0020   CC.ACTIVATIONCK/001D            CC.DISMOUNTDISK/0011            CC.ECHO/0010    CC.NOECHO/0011  CC.SETACTBLOCK/0014
 CH/B989         CL1/B9BA        CL2/B9C9        CL3/B9DB        CLOCKCLOSE/BFB2                 CLOCKDCB/BF8F   CLOCKDRIVER/BF98
 CLOCKOPEN/BFB2  CLOCKPFRESTART/BFB2             CLOCKRB1/BFDA   CLOCKRB2/BFE8   CLOCKREADA/BFF2                 CLOCKREADA0/C004
 CLOCKREADA1/C006                CLOCKREADA2/C00E                CLOCKREADA3/C015                CLOCKREADB/BFD0
 CLOCKRESET/BFCD                 CLOCKSPRUNG/BFB5                CLOCKSTATUS/BFB8                CLOCKSTR/BF88   CLOCKWRITEB/BFCD
 CLOSE.PORT/B9B2                 CLOSE.TTY/B677  CMDREG/FF18     CNFGTABLE/B403  CONSOLEDRIVER/B49C              CONTROL.PORT/B98A
 CONTROL.TTY/B6AB                CR0/BA85        CR1/BA73        CR2/BA80        CRFLAG/B5CE     CTRK0/BD65      CTRLCNUM/B5CC
 CURDRV/BD64     DACTIVATION1/B6DE               DACTIVATIONCK/B6D1              DATREG/FF1B    *DCB.CLEARIN/00CA
*DCB.D0/BB46     DCB.D1/BB8E     DCB.D2/BBD6     DCB.D3/BC1E    *DCB.DONEFLAG/0000              *DCB.DRIVER/0007
 DCB.FDUNIT/0043                 DCB.HD/BE76    *DCB.INPUTTOBLK/00A9             DCB.LASTERROR/0001             *DCB.LINEBUF/0067
*DCB.LINEBUFLEN/007A            *DCB.NAME/0003  *DCB.NEXTDCB/0005               *DCB.OILQUIESCENT/0013
*DCB.OUTPUTTOBLK/00A1            DCB.PORT/B965  *DCB.PROFILE/0028               *DCB.RESET/00B5 *DCB.RINGINBASE/004D
*DCB.RINGOUTBASE/0059           *DCB.RINGOUTTHRESHOLD/005D      *DCB.TASKSTACK/00B3             *DCB.TCB/00B1   *DCB.TLBUFFER/007D
 DCB.TTY/B493   *DCB.VTSIZE/00FD                 DCBNAME.D0/BB42                 DCBNAME.D1/BB8A                 DCBNAME.D2/BBD2
 DCBNAME.D3/BC1A                 DCBNAME.HD/BE72                 DCBNAME.PORT/B95F               DCBNAME.TTY/B48A
 DCBPOINTER/0006                 DDATA/BD62      DEBUGSYSCALL/C03A               DECHO/B6C3      DEL56U/BE29     DELAY1K/B9DE
 DELAY1KB/B9E1   DELAY2/BE2C     DELAY3/BE2F     DISKDCBS/BB46   DIV18/BC99      DIV18.1/BCA1    DIV18.2/BCA9    DIV18.3/BCB1
 DIV18.4/BCB9    DIV18.5/BCC1    DIV18.6/BCC9    DIV18.7/BCD1    DIV18.8/BCD9    DNOECHO/B6CB    DRIVERBASE/B400
 DRV/BD5E        DRVREG/FF14     DSETACT1/B6EC   DSETACTIVATION/B6E1             DSKBUFFERPOOL/C660              DSKCONTROL/BC74
 DSKDISMOUNT/BC7B                DSKDRIVER/BC62  DSKERR/BD32     DSKERR1/BD4A    DSKINFO.OPSCOUNT/003C
 DSKINFO.SECTORDB/002B           DSKOPSCOUNT/BCDB                DSKOPSCOUNT1/BCE5               DSKPOOLSIZE/079E
 DSKPREP/BCE6    DSKREAD/BD18    DSKRESTORE/BD5A                 DSKWAITDONE/BD5A                DSKWRITE/BD25  *DUMMY/BD7C
 DVTYP.CLOCK/000B                DVTYP.STAPE/0002               *DVTYP.TYPE/0000                 ECHOFLAG/B5C9   EOFFLAG/B5C8
 ERR.ACTIVATIONNOTINBUFFER/0773  ERR.ACTIVATIONRECEIVED/0775     ERR.DEVICENOTREADY/0424        *ERR.DEVICETIMEDOUT/0412
 ERR.DISKREAD/0415               ERR.DISKSEEK/0417               ERR.DISKWRITE/0416              ERR.DSKWRTPROT/0418
 ERR.EOFHIT/03E9                 ERR.ILLDEVICEOP/040A            ERR.PROGRAMKILLED/0411         *ERR.WRONGDISKTYPE/076E
*ERRETX/B4BD     EXPANDTABFLAG/B5CD              FCB.SIZE/001A   FCBS/C081       FDRDC/008C      FDRSC/000B      FDSKI/001B
 FDTEARLSN/BC7D  FDWRC/00AC      FNDTK2/BE38     FNDTK3/BE3C     FNDTRK/BE30     FUSEBURNEDUP/B458               GETREADPARAMS/B704
 GETWRITEPARAMS/B8AB             GOBIT/0008      HDCMD/FF10      HDCMD.HEARTBEAT/0001            HDCMD.READ/0008
 HDCMD.SELDRV/0002               HDCMD.SETADDRH/0006             HDCMD.SETADDRL/0007             HDCMD.SETSECT/0003
 HDCMD.SETSURF/0004              HDCMD.SETTRACK/0005             HDCMD.WRITE/0009                HDDATA/FF11     HDDRIVER/BEBA
 HDERR/BF6C      HDHLEOK/BEE2    HDPREP/BECC     HDRDOK/BF6F     HDREAD/BF5A     HDWRITE/BF74    IGN/0000        ILLDEVICEOP/B4B8
 INBYTE/BA05     INBYTEEOF/BA15  INCH/B64E       INEEE/B5FB      INNYB1/B9F5     INNYB4/B9FD     INNYBLE/B9E5    INPUTBUF/B4CA
 INPUTBUFLEN/00FA                INPUTBUFP0/B5C4                 INPUTBUFP1/B5C6                 INTDISABLE/B43A
 INTDK/BD6B      INTENABLE/B43C  INTERRUPTSTACK/C61F             INTRTI/B43F     INTSETUP/B427   INTSTACKTOP/C65F
 IOBUF/C080      IOBUFEND/CE00   IOCB.SIZE/0022  IOCBPOINTERS/C5F9               IOCBS/C373      IOINTPOLL/B440  IRQINT/B43E
 IRQVECTOR/FFF8  LCN.SIZE/0002   LEN/B4C4        LMODE/B4C3      LSN.SIZE/0003  *M6800/0001     *M6801/0000     *M6809/0000
 NCOL/B5CA       NDRIVES/0004    NIOCHANNELS/0013                NMAGICFCBS/0002                 NOTIMERINT/B444
 OFS/2000        OKRTS/B4B6      OPEN.PORT/B9AA  OPEN.TTY/B653   OPEN.TTY1/B668  OUTEEE/B5E1     OUTNYBLE/BB37   OUTNYBLE1/BB3F
 PDATA/B4C6      PNCHOFF/B623    PNCHON/B61F     PORECH/B5E0     PORTDRIVER/B96E                 PORTMODE/B988   PRT1/B639
*PRT2/B633       PRT3/B636       PRT4/B641       PRTCH/B627      PRTCH2/B943     QERR/BD99       QUIT10/BD9A     RAM64K/0001
 RBACKSPACE/B80A                 RBAS/B831       RCNT/BD69      *RCTRLC/B7ED    *RCTRLD/B813     RD1NCOL/B7A3    RD2NCOL/B7A6
 RDOFF/B61B      RDON/B617       RDSEC/BD7D      RDSEC1/BD80    *RDSI.BLINK/0009                 RDSI.CYLINDER/0012
*RDSI.DISKINFO/0000             *RDSI.FLINK/0007                 RDSI.LSN/0002  *RDSI.MODIFIED/000B
*RDSI.RETRYCOUNT/000D            RDSI.SECTOR/000E                RDSI.SECTORBASE/0005           *RDSI.SIZE/0014  RDSI.STATE/000C
 RDSI.TRACK/0010                 RDSIPOINTER/BD5C               *RDSISTATE.IDLE/0000            *RDSISTATE.READING/0001
*RDSISTATE.VERIFYING/0003       *RDSISTATE.WRITING/0002          READ/BD9B       READ.PORT/BA21  READ1/BDAE      READ2/BDBB
 READ3/BDC6      READA.PORT/BA17                 READA.TTY/B751  READA1/B761     READA2/B76B     READA3/B776     READA4/B77C
 READA5/B7BA     READA6/B7C7     READAPORT/BA63  READB.PORT/BA1E                 READB.TTY/B72F  READB1/B738     READB2/B74F
 READBPORT/BA92  READINPUTBUF/B7D1               RENDOFINPUT/B888                RES/B5F7        RESET.TTY/B6C0  RESTOR/BE3D




ASM/6800 1.4A0: C03A                    
08/16/82 00:00:00; Page 41; Form 1      Symbols Sorted by Name
IOSWTPC6800.ASM
 RI1/B7FF        RI2/B80F        RI3/B819        RI4/B839        RI5/B861        RI6/B866        RI7/B86D        RINBUF/B7DA
 RINCH/B7E3      RP1/BA46        RP1A/BA5B       RP1EOF/BABE     RP1START/BA4D   RPIN/BA53       RPLEN/B4C8      RSTORECH/B846
 SAVEREADPORTCH/BAA9             SC.GETCOL/0001  SC.GETEOF/0002  SC.GETLINEFLAGS/002C            SC.GETTYPE/0004
*SCBLK.DATA/000E                *SCBLK.OPCODE/0000               SCBLK.PARAMS/0002               SCBLK.RDBUF/000A
 SCBLK.RDLEN/000C                SCBLK.RPLEN/0008               *SCBLK.WLEN/0001                 SCBLK.WRBUF/0004
 SCBLK.WRLEN/0006                SDOS/CE00       SDOS.CHECKRDLEN/0036            SDOS.CLOCK/000B                 SDOS.ERROR/002D
 SDOS.ERRORED/0033               SDOS.ERRORSAVE/0030             SDOS.IOBLOCKPTR/0007            SDOS.RTI/0015   SDOS.WAITEVENT/002A
 SECREG/FF1A     SECT/BD60       SEEK/BE00       SEEK2/BE18      SEEK3/BE25      SELD1/BE66      SELDRV/BE49     SETRPLEN/B721
 SIDE/BD61       SIDEBT/BD6A     SINIT1/3003     SINIT2/300F    *SPECIALFN.CLEAR/0082           *SPECIALFN.EEOL/0083
*SPECIALFN.POSN/0081             SSTEPBIT/0010   ST0/B690        ST1/B699        ST2/B6A2        STATUS.PORT/B994
 STATUS.TTY/B67A                 STATUSRET1/B6A4                 STPO1/B9A1      STPO2/B9A3      SWTPCINIT/3000 *SYSCALL.CHAIN/0006
*SYSCALL.CLOSE/0002             *SYSCALL.CONTROL/000E           *SYSCALL.CREATE/0001            *SYSCALL.DEBUG/0018
*SYSCALL.DELETE/0004            *SYSCALL.DISPERROR/0015         *SYSCALL.ERROREXIT/0012         *SYSCALL.EXIT/0011
*SYSCALL.GETERROR/0014          *SYSCALL.OPEN/0000              *SYSCALL.READA/000A             *SYSCALL.READB/000B
*SYSCALL.RENAME/0003            *SYSCALL.SETERROR/0013          *SYSCALL.STATUS/000F            *SYSCALL.WRITEA/000C
*SYSCALL.WRITEB/000D             SYSCALLIO/B400  TASKQUEUE/B45C  TASKSETUP/B482  TASKSTACKINIT/B478             *TASKSTACKTOP/B480
 TASKWAKEUPFLAG/B481             TEMPX/0000      TIMEOUTQUEUE/B450               TIMESTR/C029    TRACEBIT/0040   TRK/BD5F
 TRKREG/FF19     WBUSY/BDC9      WP0/BAF8        WP1/BAFD        WP1A/BB0C       WP1START/BB04   WPOUT/BB04      WR1NCOL/B94F
 WR2NCOL/B952    WR3NCOL/B955    WR4NCOL/B95A    WRITE/BDD1      WRITE.0/B8CC    WRITE.1/B8D4    WRITE.2/B8E6    WRITE.3/B8E9
 WRITE.9/B8F2    WRITE.CHCR.ECHO/B8F5            WRITE.CR.ECHO/B8F8              WRITE.MODE/B8DD                 WRITE.PORT/BAD0
 WRITE1/BDE4     WRITE2/BDF1    *WRITE3/BDFD     WRITEA.CH/B900  WRITEA.CH.ECHO/B8FA             WRITEA.CH1/B908
 WRITEA.CH2/B915                 WRITEA.CH2A/B927                WRITEA.CH2B/B932                WRITEA.CH2C/B936
 WRITEA.CH3/B93F                 WRITEA.CH4/B942                 WRITEA.PORT/BAC3                WRITEA.TTY/B8BC
*WRITEAPORT/BB1E                 WRITEB.PORT/BACD                WRITEB.TTY/B8C6                 WRITEBPORT/BB23
 WRSEC/BD8C      WTSEC1/BD8F




ASM/6800 1.4A0: C03A                    
08/16/82 00:00:00; Page 42; Form 1      Symbols Sorted by Value
IOSWTPC6800.ASM
Symbols Sorted by Value:

*DCB.DONEFLAG/0000              *DVTYP.TYPE/0000                 IGN/0000       *M6801/0000     *M6809/0000     *RDSI.DISKINFO/0000
*RDSISTATE.IDLE/0000            *SCBLK.OPCODE/0000              *SYSCALL.OPEN/0000               TEMPX/0000      DCB.LASTERROR/0001
 HDCMD.HEARTBEAT/0001           *M6800/0001      RAM64K/0001    *RDSISTATE.READING/0001          SC.GETCOL/0001 *SCBLK.WLEN/0001
*SYSCALL.CREATE/0001             DVTYP.STAPE/0002                HDCMD.SELDRV/0002               LCN.SIZE/0002   NMAGICFCBS/0002
 RDSI.LSN/0002  *RDSISTATE.WRITING/0002          SC.GETEOF/0002  SCBLK.PARAMS/0002              *SYSCALL.CLOSE/0002
*DCB.NAME/0003   HDCMD.SETSECT/0003              LSN.SIZE/0003  *RDSISTATE.VERIFYING/0003       *SYSCALL.RENAME/0003
 HDCMD.SETSURF/0004              NDRIVES/0004    SC.GETTYPE/0004                 SCBLK.WRBUF/0004               *SYSCALL.DELETE/0004
*DCB.NEXTDCB/0005                HDCMD.SETTRACK/0005             RDSI.SECTORBASE/0005            DCBPOINTER/0006
 HDCMD.SETADDRH/0006             SCBLK.WRLEN/0006               *SYSCALL.CHAIN/0006             *DCB.DRIVER/0007
 HDCMD.SETADDRL/0007            *RDSI.FLINK/0007                 SDOS.IOBLOCKPTR/0007            GOBIT/0008      HDCMD.READ/0008
 SCBLK.RPLEN/0008                HDCMD.WRITE/0009               *RDSI.BLINK/0009                 SCBLK.RDBUF/000A
*SYSCALL.READA/000A              DVTYP.CLOCK/000B                FDRSC/000B     *RDSI.MODIFIED/000B              SDOS.CLOCK/000B
*SYSCALL.READB/000B              RDSI.STATE/000C                 SCBLK.RDLEN/000C               *SYSCALL.WRITEA/000C
*RDSI.RETRYCOUNT/000D           *SYSCALL.WRITEB/000D             RDSI.SECTOR/000E               *SCBLK.DATA/000E
*SYSCALL.CONTROL/000E           *SYSCALL.STATUS/000F             CC.ECHO/0010    RDSI.TRACK/0010                 SSTEPBIT/0010
 CC.DISMOUNTDISK/0011            CC.NOECHO/0011 *SYSCALL.EXIT/0011               RDSI.CYLINDER/0012
*SYSCALL.ERROREXIT/0012         *DCB.OILQUIESCENT/0013           NIOCHANNELS/0013               *SYSCALL.SETERROR/0013
 CC.SETACTBLOCK/0014            *RDSI.SIZE/0014 *SYSCALL.GETERROR/0014           SDOS.RTI/0015  *SYSCALL.DISPERROR/0015
*SYSCALL.DEBUG/0018              FCB.SIZE/001A   FDSKI/001B      CC.ACTIVATIONCK/001D            BREAKBIT/0020   IOCB.SIZE/0022
*DCB.PROFILE/0028                SDOS.WAITEVENT/002A             DSKINFO.SECTORDB/002B           SC.GETLINEFLAGS/002C
 SDOS.ERROR/002D                 SDOS.ERRORSAVE/0030             SDOS.ERRORED/0033               SDOS.CHECKRDLEN/0036
 DSKINFO.OPSCOUNT/003C           TRACEBIT/0040   DCB.FDUNIT/0043                *DCB.RINGINBASE/004D
*DCB.RINGOUTBASE/0059           *DCB.RINGOUTTHRESHOLD/005D      *DCB.LINEBUF/0067               *DCB.LINEBUFLEN/007A
*DCB.TLBUFFER/007D              *ABORTBIT/0080  *SPECIALFN.POSN/0081            *SPECIALFN.CLEAR/0082           *SPECIALFN.EEOL/0083
 FDRDC/008C     *DCB.OUTPUTTOBLK/00A1           *DCB.INPUTTOBLK/00A9             FDWRC/00AC     *DCB.TCB/00B1   *DCB.TASKSTACK/00B3
*DCB.RESET/00B5 *DCB.CLEARIN/00CA                INPUTBUFLEN/00FA               *DCB.VTSIZE/00FD                 ERR.EOFHIT/03E9
 ERR.ILLDEVICEOP/040A            ERR.PROGRAMKILLED/0411         *ERR.DEVICETIMEDOUT/0412         ERR.DISKREAD/0415
 ERR.DISKWRITE/0416              ERR.DISKSEEK/0417               ERR.DSKWRTPROT/0418             ERR.DEVICENOTREADY/0424
*ERR.WRONGDISKTYPE/076E          ERR.ACTIVATIONNOTINBUFFER/0773  ERR.ACTIVATIONRECEIVED/0775     DSKPOOLSIZE/079E
 OFS/2000        SWTPCINIT/3000  SINIT1/3003     SINIT2/300F     DRIVERBASE/B400                 SYSCALLIO/B400  CNFGTABLE/B403
 INTSETUP/B427   INTDISABLE/B43A                 INTENABLE/B43C  IRQINT/B43E     INTRTI/B43F     IOINTPOLL/B440  NOTIMERINT/B444
 BADINTERRUPTCOUNT/B44E          TIMEOUTQUEUE/B450               FUSEBURNEDUP/B458               TASKQUEUE/B45C  TASKSTACKINIT/B478
*TASKSTACKTOP/B480               TASKWAKEUPFLAG/B481             TASKSETUP/B482  DCBNAME.TTY/B48A                DCB.TTY/B493
 CONSOLEDRIVER/B49C              OKRTS/B4B6      ILLDEVICEOP/B4B8               *ERRETX/B4BD     LMODE/B4C3      LEN/B4C4
 PDATA/B4C6      RPLEN/B4C8      INPUTBUF/B4CA   INPUTBUFP0/B5C4                 INPUTBUFP1/B5C6                 EOFFLAG/B5C8
 ECHOFLAG/B5C9   NCOL/B5CA       BASICFLAGS/B5CB                 CTRLCNUM/B5CC   EXPANDTABFLAG/B5CD              CRFLAG/B5CE
 ACTIVATIONCHARSVECTOR/B5CF      ACTIVATIONCHARSENSED/B5DF       PORECH/B5E0     OUTEEE/B5E1     ACIOUT/B5EB     ACIOU1/B5EF
 RES/B5F7        INEEE/B5FB      ACIAIN/B609     RDON/B617       RDOFF/B61B      PNCHON/B61F     PNCHOFF/B623    PRTCH/B627
*PRT2/B633       PRT3/B636       PRT1/B639       PRT4/B641       INCH/B64E       OPEN.TTY/B653   OPEN.TTY1/B668  CLOSE.TTY/B677
 STATUS.TTY/B67A                 ST0/B690        ST1/B699        ST2/B6A2        STATUSRET1/B6A4                 CONTROL.TTY/B6AB
 RESET.TTY/B6C0  DECHO/B6C3      DNOECHO/B6CB    DACTIVATIONCK/B6D1              DACTIVATION1/B6DE               DSETACTIVATION/B6E1
 DSETACT1/B6EC   GETREADPARAMS/B704              SETRPLEN/B721   READB.TTY/B72F  READB1/B738     READB2/B74F     READA.TTY/B751
 READA1/B761     READA2/B76B     READA3/B776     READA4/B77C     RD1NCOL/B7A3    RD2NCOL/B7A6    READA5/B7BA     READA6/B7C7
 READINPUTBUF/B7D1               RINBUF/B7DA     RINCH/B7E3     *RCTRLC/B7ED     RI1/B7FF        RBACKSPACE/B80A
 RI2/B80F       *RCTRLD/B813     RI3/B819        RBAS/B831       RI4/B839        RSTORECH/B846   RI5/B861        RI6/B866
 RI7/B86D        ACTIVBYTE/B877  ACTIVCHAR/B882  RENDOFINPUT/B888                BACKSPACE/B889  BACKSPC1/B8A5   BACKSPC2/B8AA
 GETWRITEPARAMS/B8AB             WRITEA.TTY/B8BC                 WRITEB.TTY/B8C6                 WRITE.0/B8CC    WRITE.1/B8D4
 WRITE.MODE/B8DD                 WRITE.2/B8E6    WRITE.3/B8E9    WRITE.9/B8F2    WRITE.CHCR.ECHO/B8F5            WRITE.CR.ECHO/B8F8
 WRITEA.CH.ECHO/B8FA             WRITEA.CH/B900  WRITEA.CH1/B908                 WRITEA.CH2/B915                 WRITEA.CH2A/B927
 WRITEA.CH2B/B932                WRITEA.CH2C/B936                WRITEA.CH3/B93F                 WRITEA.CH4/B942
 PRTCH2/B943     WR1NCOL/B94F    WR2NCOL/B952    WR3NCOL/B955    WR4NCOL/B95A    DCBNAME.PORT/B95F               DCB.PORT/B965
 PORTDRIVER/B96E                 PORTMODE/B988   CH/B989         CONTROL.PORT/B98A               STATUS.PORT/B994
 STPO1/B9A1      STPO2/B9A3      OPEN.PORT/B9AA  CLOSE.PORT/B9B2                 CL1/B9BA        CL2/B9C9        CL3/B9DB




ASM/6800 1.4A0: C03A                    
08/16/82 00:00:00; Page 43; Form 1      Symbols Sorted by Value
IOSWTPC6800.ASM
 DELAY1K/B9DE    DELAY1KB/B9E1   INNYBLE/B9E5    INNYB1/B9F5     INNYB4/B9FD     INBYTE/BA05     INBYTEEOF/BA15  READA.PORT/BA17
 READB.PORT/BA1E                 READ.PORT/BA21  RP1/BA46        RP1START/BA4D   RPIN/BA53       RP1A/BA5B       APORT.MODE/BA5F
 READAPORT/BA63  CR1/BA73        CR2/BA80        CR0/BA85        READBPORT/BA92  SAVEREADPORTCH/BAA9             RP1EOF/BABE
 WRITEA.PORT/BAC3                WRITEB.PORT/BACD                WRITE.PORT/BAD0                 WP0/BAF8        WP1/BAFD
 WP1START/BB04   WPOUT/BB04      WP1A/BB0C      *WRITEAPORT/BB1E                 WRITEBPORT/BB23                 OUTNYBLE/BB37
 OUTNYBLE1/BB3F  DCBNAME.D0/BB42                *DCB.D0/BB46     DISKDCBS/BB46   DCBNAME.D1/BB8A                 DCB.D1/BB8E
 DCBNAME.D2/BBD2                 DCB.D2/BBD6     DCBNAME.D3/BC1A                 DCB.D3/BC1E     DSKDRIVER/BC62  DSKCONTROL/BC74
 DSKDISMOUNT/BC7B                FDTEARLSN/BC7D  DIV18/BC99      DIV18.1/BCA1    DIV18.2/BCA9    DIV18.3/BCB1    DIV18.4/BCB9
 DIV18.5/BCC1    DIV18.6/BCC9    DIV18.7/BCD1    DIV18.8/BCD9    DSKOPSCOUNT/BCDB                DSKOPSCOUNT1/BCE5
 DSKPREP/BCE6    DSKREAD/BD18    DSKWRITE/BD25   DSKERR/BD32     DSKERR1/BD4A    DSKRESTORE/BD5A                 DSKWAITDONE/BD5A
 RDSIPOINTER/BD5C                DRV/BD5E        TRK/BD5F        SECT/BD60       SIDE/BD61       DDATA/BD62      CURDRV/BD64
 CTRK0/BD65      RCNT/BD69       SIDEBT/BD6A     INTDK/BD6B     *DUMMY/BD7C      RDSEC/BD7D      RDSEC1/BD80     WRSEC/BD8C
 WTSEC1/BD8F     QERR/BD99       QUIT10/BD9A     READ/BD9B       READ1/BDAE      READ2/BDBB      READ3/BDC6      WBUSY/BDC9
 WRITE/BDD1      WRITE1/BDE4     WRITE2/BDF1    *WRITE3/BDFD     SEEK/BE00       SEEK2/BE18      SEEK3/BE25      DEL56U/BE29
 DELAY2/BE2C     DELAY3/BE2F     FNDTRK/BE30     FNDTK2/BE38     FNDTK3/BE3C     RESTOR/BE3D     SELDRV/BE49     SELD1/BE66
 DCBNAME.HD/BE72                 DCB.HD/BE76     HDDRIVER/BEBA   HDPREP/BECC     HDHLEOK/BEE2    HDREAD/BF5A     HDERR/BF6C
 HDRDOK/BF6F     HDWRITE/BF74    CLOCKSTR/BF88   CLOCKDCB/BF8F   CLOCKDRIVER/BF98                CLOCKCLOSE/BFB2
 CLOCKOPEN/BFB2  CLOCKPFRESTART/BFB2             CLOCKSPRUNG/BFB5                CLOCKSTATUS/BFB8                CLOCKRESET/BFCD
 CLOCKWRITEB/BFCD                CLOCKREADB/BFD0                 CLOCKRB1/BFDA   CLOCKRB2/BFE8   CLOCKREADA/BFF2
 CLOCKREADA0/C004                CLOCKREADA1/C006                CLOCKREADA2/C00E                CLOCKREADA3/C015
 TIMESTR/C029    ATTNCHECK/C03A  DEBUGSYSCALL/C03A               BASICDEBUGFLAGS/C080            IOBUF/C080      FCBS/C081
 IOCBS/C373      IOCBPOINTERS/C5F9               INTERRUPTSTACK/C61F             INTSTACKTOP/C65F                DSKBUFFERPOOL/C660
 IOBUFEND/CE00   SDOS/CE00       ACIAPORT/FF04   HDCMD/FF10      HDDATA/FF11     DRVREG/FF14     CMDREG/FF18     TRKREG/FF19
 SECREG/FF1A     DATREG/FF1B     IRQVECTOR/FFF8

439 Symbols.


 *** No Assembly Errors.
