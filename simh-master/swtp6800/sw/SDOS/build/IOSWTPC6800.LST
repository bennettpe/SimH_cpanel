



ASM/6800 1.4A0: 0000                    
08/16/82 00:00:00; Page 1; Form 0       
IOSWTPC6800.ASM
  0000            1: RAM64K   EQU  0 




ASM/6800 1.4A0: 0000                    
08/16/82 00:00:00; Page 2; Form 1       
IOSWTPC6800.ASM
                  1: 
                  2: ;*              I/O Package Configuraton for SimH SWTPC 6800 Simulator
                  3: ;*              should work on real hw too
                  4: 
                  5: ;*              (C) Roberto Sancho, Jun 2022
                  6: ;*              based on SSB I/O Package
                  7: 
                  8: ;*              features implemented: 
                  9: ;                            mapalg: Only supports mapping algorith 0001
                 10: ;                            I/O Implemented using active wait (no interruption based)
                 11: ;                            no clock interrupt
                 12: ;                            no vt terminal driver. Just a minimal subset
                 13: ;                                              BackSpace, Tab (converted to 8 spaces) 
                 14: ;                                              ^C to discard current input 
                 15: ;                                              ^C^C to kill current program
                 16: ;                                              <CR> is the only activation key allowed (cannot be changed)
                 17: ;                                              ^Z to signal end of file
                 18: ;                                              ^D to call monitor, J A080 to return to SDOS
                 19: ;                                              basic debug keys ^B, ^T, ^G, ^V
                 20: ;                            support for 4 floppy disk
                 21: ;                            only supported disk geometry: 5'25 floppy 2 sides x 35tr x 18 sec x 128 bytes
                 22: ;                            supports for HLE 5MB Hard Disk
                 23: ;                            PORT: device to read from PTR/punch to PTP
                 24: ;                           
                 25: 
  0004           26: NDRIVES         equ     4
  0013           27: NIOCHANNELS     equ     16+3    ; number of files that can be opened at same time
                 28: 
                 29:                                 ; SWTBUG ROM entry points
                 30: 
                 31:                 ; conditional assembly for SWTPC with 64K ram and
                 32:                 ; I/O address at FF00..FF1F instead of 8000..801F  
                 33: 
  0000           34:              if ram64k=1
 *S*             35: 
 *S*             36:                                 ; Memory Map
 *S*             37:                                 ; 0000..B3FF User RAM (46080 BYTES = 45 kB)
 *S*             38: DRIVERBASE      set     $B400   ; B400..BFFF SDOS I/O Driver for SWTPC 6800 
 *S*             39: IOBUF           EQU     $C080   ; C080..CDFF BUFFERS FOR I/O DRIVER
 *S*             40: IOBUFEND        EQU     $CE00
 *S*             41: SDOS            EQU     $CE00   ; CE00..EFFF SDOS Operating System (64K compile version)
 *S*             42:                                 ; FF00..FF1F IO MAPED MEMORY
 *S*             43: IRQVECTOR       equ     $FFF8   ; IRQ VECTOR IN HIGH MEM IS RAM
 *S*             44: 
                 45:               else
                 46:                                 ; Memory Map
                 47:                                 ; 0000..6FFF User RAM
  7000           48: DRIVERBASE      EQU     $7000   ; 7000..7FFF SDOS I/O Driver for SWTPC 6800
                 49:                                 ; 8000..9FFF IO MAPED MEMORY
                 50:                                 ; A000..A07F 6810 RAM (128 BYTES), used by SWTBUG ROM
  A080           51: IOBUF           EQU     $A080   ; A080..ADFF BUFFERS FOR I/O DRIVER
  AE00           52: IOBUFEND        EQU     $AE00   ;
  AE00           53: SDOS            EQU     $AE00   ; AE00..DFFF SDOS Operating System (56K compile version)
                 54:                                 ; E000..E7FF SWTBUG ROM
                 55:                                 ; E800..FFFF EPROM




ASM/6800 1.4A0: 0000                    
08/16/82 00:00:00; Page 3; Form 1       
IOSWTPC6800.ASM
                 56: 
  E1D1           57: OUTEEE          EQU     $E1D1   ; OUTPUT A CHAR USING SWTPC 6800 SWTBUG ROM
  E1AC           58: INEEE           equ     $E1AC   ; INPUT A CHAR (BLOCKING) USING SWTPC 6800 SWTBUG ROM
  E0D0           59: SWTMON          EQU     $E0D0   ; SWTBUG COLD START ENTRY POINT
  E337           60: RDON            equ     $E334+3 ; reader on (skip echo setting in rom)
  E347           61: RDOFF           equ     $E347   ; reader off
  E34D           62: PNCHON          equ     $E34d   ; punch on 
  E353           63: PNCHOFF         equ     $E353   ; punch off
  A00C           64: PORECH          equ     $A00C   ; swtbug echo flag (=0 -> echo, $FF -> no echo)
  A000           65: IRQVECTOR       equ     $A000   ; ON SWTBUG, A000=IRQ VECTOR IN RAM
                 66: 
                 67:              fin
                 68: 
                 69: 
                 70: ;*              Fill in the SDOS-TO-IOPACKAGE COMMUNICATION REGION
                 71: 
  AE00           72:                 ORG     SDOS
                 73: 
AE00 11          74:                 FCB     $11                  ; SDOS:VERSIONNUMBER SDOS VERSION NUMBER (=$AE00)
AE01 0000        75:                 FDB     0                    ; SDOS:LASTERROR    LAST ERROR ENCOUNTERED
AE03 7003        76:                 FDB     CNFGTABLE            ; SDOS:CONFIGURATION TELL SDOS WHERE ALL THE GOODIES ARE
AE05 0000        77:                 FDB     0                    ; SDOS:SERIALNUMBER SERIAL NUMBER
AE07 0000        78:                 FDB     0                    ; SDOS:IOBLOCKPTR   IOBLOCKPTR
AE09 0000        79:                 FDB     0                    ; SDOS:IOCBPOINTER  IOCB POINTER (FOR FILE-TYPE DEVICE DRIVERS)
AE0B 000000      80:                 FCB     0,0,0                ; SET CLOCK TO "MIDNITE"
AE0E 10          81:                 FCB     16                   ; DAY, LET COMMAND INTERPRETER KNOW
AE0F 08          82:                 FCB     8                    ; MONTH, THAT THE TIME HASN'T BEEN SET
AE10 82          83:                 FCB     $82                  ; YEAR 
                 84: 
                 85: 
                 86: ;* patches SDOSINIT AND SDOS O/S
                 87: 
  0000           88: OFS             EQU     SDOS-$AE00      ; Offset for pathing (0=for 56k compile)
                 89: 
  0000           90:              if ram64k=1                
 *S*             91:                 ; No need to apply any patch to loaded SDOS11G64K file. It is generated by 
 *S*             92:                 ; assembling SDOS11G.ASM and has already been edited to disable all the checksum/serial number
 *S*             93:                 ; validations
                 94:              else
                 95:                 ; patch the loaded original unmodified SDOS11G56K file, it is the build
                 96:                 ; for 56K RAM machine that comes from CHM and is generated by 
                 97:                 ; assembling SDOS11GPART1.ASM and SDOS11GPART2.ASM and    
                 98: 
  2027           99:                 ORG $2027
2027 01         100:                 NOP             ; SKIP CHECKSUM VERIFICATION. WILL NOT WORK BECAUSE
2028 01         101:                 NOP             ; SDOS IS BEING PATCHED AND ... WE TRUST THE HW!
  23E9          102:                 ORG $23E9
23E9 01         103:                 NOP             ; REMOVE STACK MESSED UP IF START CODE CHECKSUM
23EA 01         104:                 NOP             ; IS NOT ZERO BECAUSE IT HAS BEEN PATCHED, AS WE ARE DOING NOW!
  2031          105:                 ORG $2031
2031 01         106:                 NOP             ; PATCH ROM SERIAL NUMBER CHECHING TO DO NOTHING
2032 01         107:                 NOP
  217A          108:                 ORG $217A
217A 39         109:                 RTS             ; INMEDIATE RETURN ON CALL TO WRITERANDOM (DO NOT CHECK)
  B00F          110:                 ORG $B00F+OFS




ASM/6800 1.4A0: B00F                    
08/16/82 00:00:00; Page 4; Form 1       
IOSWTPC6800.ASM
B00F 34         111:                 DES             ; PATCH SAFEGUARD ROUTINE TO ITS FINAL FORM
B010 31         112:                 INS             ; AS IF IT WAS SET-UP BY SERIALNUMBER.SYS 
B011 39         113:                 RTS             ; THIS ALLOWS TO BYPASS SERIALNUMBER.SYS EXECUTION
B012 3B         114:                 RTI
B013 3B         115:                 RTI
B014 3B         116:                 RTI
B015 3B         117:                 RTI
  B408          118:                 ORG $B408+OFS
B408 8601       119:                 LDAA #$01       ; SET CHECKSUM ON COPYRIGHT STRING AS ALLWAYS OK
  DD82          120:                 ORG $DD82+OFS
DD82 01         121:                 NOP             ; PATCH TASK USER STACK POINTER 
DD83 01         122:                 NOP             ; SO IT NOT GET MESSED UP IF CHECKSUM DOES NOT MATCH
DD84 01         123:                 NOP
DD85 01         124:                 NOP
DD86 01         125:                 NOP
DD87 01         126:                 NOP
  B844          127:                 ORG $B844+OFS   ; PATCH SerialNumberLocation to Point to SerialNumber 
B844 FFF0       128:                 FDB $FFF0
  B837          129:                 ORG $B837+OFS   ; PATCH EXITCKSUML ROUTINE TO IGNORE CHECKSUM
B837 4F         130:                 CLRA
  C6F1          131:                 ORG $C6F1+OFS   ; PATCH ERRBOOTCKSUMFAIL, SO BOOT CHECKSUM IS IGNORED
C6F1 01         132:                 NOP
C6F2 01         133:                 NOP
  2138          134:                 ORG $2138       ; PATCH TO ALLOW LOAD A NON-ENCRYPTED SERIALNUMBER.SYS (OR WAHTERES IS THE FIRS
2138 01         135:                 NOP
2139 01         136:                 NOP
  2736          137:                 ORG $2736       ; PATH  FCC "SERIALNUMBER.SYS" FILENAME
2736 44454641   138:                 FCC "DEFAULTPROGRAM  "
                139:                                 ; INSTEAD OF RUNNING SERIALNUMBER.SYS ON STARTUP
                140:                                 ; JUST RUN DEFAULTPROGRAM (HOPEFULLY BEING A COPY 
                141:                                 ; OF SDOS USER COMMAND PROCESSOR)
                142:               fin
                143:               
  2000          144:                 ORG $2000       ; PATCH MAIN ENTRY POINT TO SET-UP PROPERLY 
2000 7E3000     145:                 JMP SWTPCINIT   ; DRIVER MEM
                146:                 
  0007          147: SDOS.IOBLOCKPTR EQU $07         ; POINTER TO I/O REQUEST (PASSED TO DRIVERS)
  0015          148: SDOS.RTI        equ $15         ; JMP TO "RETURN FROM INTERRUPT; NO EVENT"
  002D          149: SDOS.ERROR      equ $2D         ; ERROR SUBROUTINE; INLINE 2 BYTE ERROR CODE 
  0030          150: SDOS.ERRORSAVE  equ $30         ; ERROR CODE SAVE ROUTINE; SAVES (X) AS ERROR CODE 
  0033          151: SDOS.ERRORED    equ $33         ; "ERROR CAN'T BE HANDLED BY ME" ENTRY 
  002A          152: SDOS.WAITEVENT  equ $2A         ; JMP TO WAIT FOR EVENT SELECTED BY (X)
  0036          153: SDOS.CHECKRDLEN EQU $36
  000B          154: SDOS.CLOCK      EQU $0B
                155: 
  0000          156: SCBLK.OPCODE    equ $00         ; PRIMARY SYSCALL FUNCTION (OPEN, READ, ETC.)    
  0001          157: SCBLK.WLEN      equ $01         ; WAIT FLAG BIT (0=WAIT) AND SYSCALL BLOCK LENGTH (0..127)      
  0002          158: SCBLK.PARAMS    equ $02         ; PARAMETER BYTES TO OPCODE (SECONDARY OPCODE, CHANNEL #)    
  0004          159: SCBLK.WRBUF     equ $04         ; POINTER TO WRITE DATA BUFFER     
  0006          160: SCBLK.WRLEN     equ $06         ; NUMBER OF BYTES IN WRITE DATA BUFFER
  0008          161: SCBLK.RPLEN     equ $08         ; LENGTH OF REPLY (RESULT OF SYSCALL)    
  000A          162: SCBLK.RDBUF     equ $0A         ; POINTER TO READ DATA BUFFER (WHERE RESULT GOES)     
  000C          163: SCBLK.RDLEN     equ $0C         ; CEILING ON SIZE OF REPLY (READ DATA BUFFER)
  000E          164: SCBLK.DATA      EQU $0E         ; OTHER PARAMETERS FOR SYSCALL; UP TO 127-12 BYTES
                165:  




ASM/6800 1.4A0: 2000                    
08/16/82 00:00:00; Page 5; Form 1       
IOSWTPC6800.ASM
  0082          166: SPECIALFN.CLEAR equ $0082            
  0083          167: SPECIALFN.EEOL  equ $0083            
  0081          168: SPECIALFN.POSN  equ $0081
                169: 
  002B          170: DSKINFO.SECTORDB        EQU $2B
  003C          171: DSKINFO.OPSCOUNT        equ $3c
                172: 
                173: 
  001A          174: FCB.SIZE        equ $001A
  0022          175: IOCB.SIZE       EQU $0022
  0002          176: NMAGICFCBS      EQU     2       ; FOR ERRMSGFCB, SYSFCB
                177: 
                178: 
                179: ;*
                180: ;*      device errors 
                181: ;*
  03E9          182: ERR.EOFHIT                      EQU 1001
  040A          183: ERR.ILLDEVICEOP                 equ 1034
  0411          184: err.programkilled               EQU 1041
  0412          185: ERR.DEVICETIMEDOUT              equ 1042
  0415          186: ERR.DISKREAD                    equ 1045
  0416          187: ERR.DISKWRITE                   equ 1046
  0417          188: ERR.DISKSEEK                    equ 1047
  0418          189: ERR.DSKWRTPROT                  equ 1048                  
  0424          190: ERR.DEVICENOTREADY              equ 1060
  076E          191: ERR.WRONGDISKTYPE               equ 1902
  0773          192: ERR.ACTIVATIONNOTINBUFFER       EQU 1907
  0775          193: err.activationreceived          equ 1909
                194: 
                195: ;*
                196: ;*      DEVICE CONTROL BLOCK DISPLACEMENTS
                197: ;*
  0000          198: DCB.DONEFLAG    EQU     0       ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
  0001          199: DCB.LASTERROR   equ     1       ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NONE )
  0003          200: DCB.NAME        EQU     3       ; POINTER TO DEVICE NAME STRING TERMINATED BY ZERO BYTE
  0005          201: DCB.NEXTDCB     EQU     5       ; POINTER TO NEXT DCB IN LIST OR ZERO
  0007          202: DCB.DRIVER      EQU     7       ; POINTER TO DRIVER ENTRY POINT LIST
  0043          203: dcb.fdunit      equ     $43                     
                204: 
  0013          205: dcb.oilquiescent        equ     $13
  0028          206: dcb.profile             equ     $28
  004D          207: dcb.ringinbase          equ     $4d
  0059          208: dcb.ringoutbase         equ     $59
  005D          209: dcb.ringoutthreshold    equ     $5d
  0067          210: dcb.linebuf             equ     $67
  007A          211: dcb.linebuflen          equ     $7a
  007D          212: DCB.TLBUFFER            equ     $7D
  00A1          213: dcb.outputtoblk         equ     $a1
  00A9          214: dcb.inputtoblk          equ     $a9
  00B1          215: dcb.tcb                 equ     $b1
  00B3          216: dcb.taskstack           equ     $b3
  00B5          217: DCB.RESET               EQU     $B5
  00CA          218: dcb.clearin             equ     $ca
  00FD          219: dcb.vtsize              equ     $fd
                220: 




ASM/6800 1.4A0: 2000                    
08/16/82 00:00:00; Page 6; Form 1       
IOSWTPC6800.ASM
  0006          221: DCBPOINTER              EQU     $06     ; POINTER TO DEVICE CONTROL BLOCK
                222: 
                223: 
  0000          224: DVTYP.TYPE              EQU     $00
  000B          225: DVTYP.CLOCK             EQU     $0B
  0002          226: DVTYP.STAPE             equ     $02
                227: 
  0000          228: RDSI.DISKINFO           EQU     $00
  0002          229: RDSI.LSN                EQU     $02  
  0005          230: RDSI.SECTORBASE         EQU     $05           
  0007          231: RDSI.FLINK              EQU     $07                 
  0009          232: RDSI.BLINK              EQU     $09                 
  000B          233: RDSI.MODIFIED           EQU     $0B             
  000C          234: RDSI.STATE              EQU     $0C                 
  000D          235: RDSI.RETRYCOUNT         EQU     $0D            
  000E          236: RDSI.SECTOR             EQU     $0E
  0010          237: RDSI.TRACK              EQU     $10                
  0012          238: RDSI.CYLINDER           EQU     $12             
  0014          239: RDSI.SIZE               EQU     $14 
                240: 
  0000          241: RDSISTATE.IDLE          EQU     $00
  0001          242: RDSISTATE.READING       EQU     $01         
  0003          243: RDSISTATE.VERIFYING     EQU     $03        
  0002          244: RDSISTATE.WRITING       EQU     $02         
                245: 
  0011          246: CC.DISMOUNTDISK         EQU     $11     ; DEVICE CONTROL OPS: DISMOUNT THE DISK
  001D          247: cc.activationck         EQU     $1D
  0010          248: CC.ECHO                 EQU     $10
  0011          249: CC.NOECHO               EQU     $11
  0014          250: cc.SETACTBLOCK          EQU     $14
                251: 
                252: 
  0004          253: SC.GETTYPE              EQU     $04
  002C          254: SC.GETLINEFLAGS         EQU     $2C
  0001          255: SC.GETCOL               equ     $01
  0002          256: sc.geteof               equ     $02
                257: 
  0000          258: SYSCALL.OPEN            EQU     $00
  0001          259: SYSCALL.CREATE          EQU     $01            
  0002          260: SYSCALL.CLOSE           EQU     $02
  0003          261: SYSCALL.RENAME          EQU     $03
  0004          262: SYSCALL.DELETE          EQU     $04            
  0006          263: SYSCALL.CHAIN           EQU     $06             
  000A          264: SYSCALL.READA           EQU     $0A             
  000B          265: SYSCALL.READB           EQU     $0B             
  000C          266: SYSCALL.WRITEA          EQU     $0C
  000D          267: SYSCALL.WRITEB          EQU     $0D             
  000E          268: SYSCALL.CONTROL         EQU     $0E           
  000F          269: SYSCALL.STATUS          EQU     $0F            
  0011          270: SYSCALL.EXIT            EQU     $11              
  0012          271: SYSCALL.ERROREXIT       EQU     $12         
  0013          272: SYSCALL.SETERROR        EQU     $13
  0014          273: SYSCALL.GETERROR        EQU     $14
  0015          274: SYSCALL.DISPERROR       EQU     $15
  0018          275: SYSCALL.DEBUG           EQU     $18             




ASM/6800 1.4A0: 2000                    
08/16/82 00:00:00; Page 7; Form 1       
IOSWTPC6800.ASM
                276: 
  0008          277: GOBIT                   EQU     $08     ; GO FROM BREAKPOINT/SINGLE STEP
  0010          278: SSTEPBIT                EQU     $10     ; SINGLE STEP REQUEST
  0020          279: BREAKBIT                EQU     $20     ; REQUEST LINE NUMBER BREAKPOINT
  0040          280: TRACEBIT                EQU     $40     ; REQUEST LINE NUMBER TRACE
  0080          281: ABORTBIT                EQU     $80     ; REQUEST PROGRAM ABORT
                282: 
                283: ;*
                284: ;* ONE TIME START-UP INITIALIZATION 
                285: ;* FOR SWTPC 6800. NEEDED BECAUSE 
                286: ;* WE MUST INIT FCB/IOCBS TO ZERO
                287: ;* WE MUST SET UP IOCBPOINTERS PROPERLY
                288: 
  3000          289:                         ORG     $3000
                290: 
3000 CEA084     291: SWTPCINIT       LDX     #FCBS           ; FCB/IOCBS TO ZERO
3003 6F00       292: SINIT1          CLR     0,X
3005 08         293:                 INX
3006 8CA5FC     294:                 CPX     #IOCBPOINTERS   
3009 26F8       295:                 BNE     SINIT1  
300B 86A3       296:                 LDAA    #(IOCBS/256)    ; SET UP IOCBPOINTERS PROPERLY
300D C676       297:                 LDAB    #(IOCBS&$FF)    ; EACH IOCBPOINTER POINTS TO
300F A700       298: SINIT2          STAA    0,X             ; THE CORRESPONDING IOCB
3011 E701       299:                 STAB    1,X
3013 CB22       300:                 ADDB    #(IOCB.SIZE&$FF)
3015 8900       301:                 ADCA    #(IOCB.SIZE/256)
3017 08         302:                 INX
3018 08         303:                 INX
3019 8CA622     304:                 CPX     #INTERRUPTSTACK
301C 26F1       305:                 BNE     SINIT2
301E 7FA083     306:                 CLR     BASICDEBUGFLAGS
                307:                 ; INIT DONE, RETURN TO SDOSINIT 
3021 FEAE03     308:                 LDX     $AE03+OFS       ; $AE03=CODE+SDOS:CONFIGURATION GET THE STACK POINTER
3024 7E2003     309:                 JMP     $2003
                310: 
                311: ;*              BUFFERS FOR I/O DRIVER
                312: ;*              MUST BE INITIALIZED!
                313: 
  A080          314:                 ORG     IOBUF           ; A080..AE00 
                315: 
  0000          316:              if ram64k=1
 *S*            317:                 ; ^D not available on RAM64K. SWTBUG ROM not present
                318:              else
A080 7E73D8     319: swtgo           jmp     swtret          ; return address from SWTBUG MONITOR
                320:                                         ; ^D -> enter to monitor, JA080 | JE480 return to sdos
                321:              fin
A083 00         322: BASICDEBUGFLAGS fcb     0               ; set basic debug flags  A083 | E483
                323: 
                324: 
A084 02F2       325: FCBS            RMB     FCB.SIZE*(NIOCHANNELS+2*NDRIVES+NMAGICFCBS) ; MUST PRECEDE IOCBS
A376 0286       326: IOCBS           RMB     IOCB.SIZE*NIOCHANNELS
A5FC 0026       327: IOCBPOINTERS    RMB     NIOCHANNELS*2
A622 0040       328: INTERRUPTSTACK  RMB     $40     ; STACK SPACE FOR INTERRUPT ROUTINES
A662 00         329: INTSTACKTOP     FCB     0
A663 00         330: DSKBUFFERPOOL   fcb     0




ASM/6800 1.4A0: A663                    
08/16/82 00:00:00; Page 8; Form 1       
IOSWTPC6800.ASM
  079B          331: DSKPOOLSIZE     equ     IOBUFEND-DSKBUFFERPOOL-2
                332: 
  7000          333:                 ORG     DRIVERBASE      
                334: 
                335:                                 ; THIS IS CODE+SDOS:CONFIGURATION ADDRESS    ; 
                336: 
7000 7E7000     337: SYSCALLIO       JMP     SYSCALLIO       ; SDOS SETS JMP ADDR TO ITS ENTRY POINT
                338: 
7003 76F4       339: CNFGTABLE       FDB     DISKDCBS        ; CNFG:DISKDCBS         DEFAULT DISK MUST BE FIRST
7005 7093       340:                 FDB     DCB.TTY         ; CNFG:DEVICEDCBS        CONSOLE MUST BE FIRST
7007 A5FC       341:                 FDB     IOCBPOINTERS    ; CNFG:IOCBPOINTERS     POINTER LIST TO IOCB'S
7009 13         342:                 FCB     NIOCHANNELS     ; CNFG:NIOCHANNELS      NUMBER OF I/O CHANNELS
700A A663       343:                 FDB     DSKBUFFERPOOL   ; CNFG:DSKBUFFERPOOL    POINTER TO THE DISK BUFFER POOL
700C 079B       344:                 FDB     DSKPOOLSIZE     ; CNFG:DSKPOOLSIZE      SIZE OF THE BUFFER POOL
700E 7BE8       345:                 FDB     ATTNCHECK       ; CNFG:ATTNCHECK        ADDRESS OF ATTENTION CHECK ROUTINE
7010 7BE8       346:                 FDB     DEBUGSYSCALL    ; CNFG:DEBUGGER RMB     ADDRESS OF DEBUGGER (0 IF NONE)
7012 7000       347:                 FDB     DRIVERBASE      ; CNFG:DRIVERBASE       LOWEST ADDRESS USED BY DRIVERS = END OF USER RA
7014 7027       348:                 FDB     INTSETUP        ; CNFG:INTSETUP         POINTER TO INTERRUPT SYSTEM SETUP ROUTINE
7016 7E703A     349:                 JMP     INTDISABLE      ; CNFG:INTDISABLE       SUBROUTINE (OR "JMP") TO DISABLE ALL INTERRUPTS
7019 7E703C     350:                 JMP     INTENABLE       ; CNFG:INTENABLE        SUBROUTINE (OR "JMP") TO ENABLE ALL INTERRUPTS
701C 7E703F     351:                 JMP     INTRTI          ; CNFG:INTRTI           CODE TO ENABLE PRIORITY INTERRUPT AND DO RTI (U
701F A662       352:                 FDB     INTSTACKTOP     ; CNFG:INTERRUPTSTACK   POINTER TO LAST BYTE OF INTERRUPT STACK SPACE
7021 7040       353:                 FDB     IOINTPOLL       ; CNFG:IOINTPOLL        POINTER TO I/O INTERRUPT SERVICE DEVICE POLL RO
7023 705C       354:                 FDB     TASKQUEUE       ; CNFG:TASKQUEUE        POINTER TO FIRST TASK IN TASK QUEUE
7025 7050       355:                 FDB     TIMEOUTQUEUE    ; CNFG:TIMEOUTLIST      POINTER TO CHAINED LIST OF TIMEOUT BLOCKS
                356: 
                357: 
7027 CE703E     358: INTSETUP        LDX #IRQINT
702A FFA000     359:                 STX IRQVECTOR           ; ON SWTBUG, A000=IRQ VECTOR IN RAM
702D BD7919     360:                 JSR INTDK               ; INIT THE DISK SYSTEM
7030 CE70CA     361:                 ldx     #InputBuf       ; init Input buf head and and pointerd
7033 FF71C4     362:                 stx     InputBufP0      ; to set as no chars has been typed yet (empty buf)
7036 FF71C6     363:                 stx     InputBufP1
7039 39         364:                 RTS
703A 0F         365: INTDISABLE      SEI
703B 39         366:                 RTS
703C 0E         367: INTENABLE       CLI
703D 39         368:                 RTS
703E 01         369: IRQINT          NOP
703F 3B         370: INTRTI          RTI     
                371: 
7040 4F         372: IOINTPOLL       CLRA
                373:                 ; LDA $8xxx                     ; No MP-T TIMER INTERRUPT
7041 46         374:                 RORA
7042 2400       375:                 BCC     NOTIMERINT
                376:                 ; LDX   #CLOCKDCB
                377:                 ; JMP   CLOCKSTATE
7044 FE704E     378: NOTIMERINT      LDX     BADINTERRUPTCOUNT       ; CAN'T FIGURE OUT WHO IT IS...
7047 08         379:                 INX                             ; BUMP CRAZY INTERRRUPT COUNTER
7048 FF704E     380:                 STX     BADINTERRUPTCOUNT   
704B 7EAE15     381:                 JMP     SDOS+SDOS.RTI           ; AND HOPE IT WENT AWAY !   
                382: 
704E 0000       383: BADINTERRUPTCOUNT       FDB     0               ; # OF INTERRUPTS FROM UNKNOWN DEVICES
                384: 
7050 0000       385: TIMEOUTQUEUE    FDB     0                       ; TIMEOUT:LINK   POINTER TO NEXT TIMEOUTBLOCK




ASM/6800 1.4A0: 7052                    
08/16/82 00:00:00; Page 9; Form 1       
IOSWTPC6800.ASM
7052 0000       386:                 FDB     0                       ; TIMEOUT:FUSE.  16 BIT TIMEOUT COUNT (1/60 SEC UNITS); 0--> NO
7054 7058       387:                 FDB     FUSEBURNEDUP            ; TIMEOUT:ROUTINE POINTER TO TIMEOUT INTERRUPT ROUTINE FOR DEVI
7056 7093       388:                 FDB     DCB.TTY                 ; TIMEOUT:DCB    POINTER TO DCB BEING TIMED OUT
                389: 
7058 01         390: FUSEBURNEDUP    NOP
                391:                 ; BSR     ABORTQUANTUM
7059 7EAE15     392:                 JMP     SDOS+SDOS.RTI
                393: 
  0000          394: IGN             EQU     0                       ; IGNORE VALUE
                395: 
705C 0000       396: TASKQUEUE       FDB     0                       ; TCB:LNK        POINTER TO NEXT TCB IN QUEUE
705E 7078       397:                 FDB     TASKSTACKINIT           ; TCB:STACK      STACK POINTER FOR TASK
7060 0000       398:                 FDB     0                       ; TCB:COND       TASK'S WAKE UP ROUTINE
7062 0000       399:                 FDB     0                       ; TCB:PARAM      PARAMETER TO TCB:COND ROUTINE
7064 00000000   400:                 FCB     0,0,0,0,0,0,0,0         ; TCB:SCRATCHPAD SPACE FOR TASK'S SCRATCHPAD (LOCATIONS 0-7)
706C 7093       401:                 FDB     DCB.TTY                 
706E 000A       402:                 RMB     10
7078 00000000   403: TASKSTACKINIT   FCB     0,0,IGN,IGN,IGN,IGN     ; ZERO CC SO INTERRUPTS ARE ENABLED
707E 7082       404:                 FDB     TASKSETUP               ; INITIAL PC OF FIRST TASK
7080 00         405: TASKSTACKTOP    FCB     0               
7081 00         406: TASKWAKEUPFLAG  FCB     0                       ; TASK IS SLEEPING
7082 CE7081     407: TASKSETUP       LDX     #TASKWAKEUPFLAG
7085 BDAE2A     408:                 JSR     SDOS+SDOS.WAITEVENT     ; WAIT FOR EVENT (X) TO GO NON-ZERO
7088 20F8       409:                 BRA     TASKSETUP
                410: 
                411: 
                412: ; DEVICE CONTROL BLOCK FOR TTY CONSOLE
                413: 
708A 434F4E53   414: dcbname.tty     fcc     'CONSOLE:'
7092 00         415:                 fcb     0
                416: 
7093 01         417: DCB.TTY         FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
7094 0000       418:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
7096 708A       419:                 FDB     dcbname.tty             ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
7098 7513       420:                 FDB     DCB.PORT                ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
709A 709C       421:                 FDB     CONSOLEDRIVER           ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
                422: 
                423: ; DEVICE DRIVER BLOCK FOR TTY CONSOLE
                424: 
709C 720F       425: CONSOLEDRIVER   FDB     OPEN.TTY        ; DRIVER:OPEN   OPEN FILE
709E 7233       426:                 FDB     CLOSE.TTY       ; DRIVER:CLOSE  CLOSE FILE
70A0 730D       427:                 FDB     READA.TTY       ; DRIVER:READA  READ ASCII
70A2 7486       428:                 FDB     WRITEA.TTY      ; DRIVER:WRITEA WRITE ASCII
70A4 72EB       429:                 FDB     READB.TTY       ; DRIVER:READB  READ BINARY
70A6 7490       430:                 FDB     WRITEB.TTY      ; DRIVER:WRITEB WRITE BINARY
70A8 720F       431:                 FDB     OPEN.TTY        ; DRIVER:CREATE CREATE FILE
70AA 70B8       432:                 FDB     ILLDEVICEOP     ; DRIVER:RENAME RENAME FILE
70AC 70B8       433:                 FDB     ILLDEVICEOP     ; DRIVER:DELETE DELETE FILE
70AE 7267       434:                 FDB     CONTROL.TTY     ; DRIVER:CONTROL        DO CONTROL OPERATION
70B0 7236       435:                 FDB     STATUS.TTY      ; DRIVER:STATUS READ DEVICE (DRIVER) STATUS
70B2 727C       436:                 FDB     RESET.TTY       ; DRIVER:RESET  RESET DRIVER (ON BOOT)
70B4 70B8       437:                 FDB     ILLDEVICEOP     ; DRIVER:STARTIO        power-fail restart--dream on!
                438: 
70B6 0C         439: OKRTS           CLC
70B7 39         440:                 RTS




ASM/6800 1.4A0: 70B7                    
08/16/82 00:00:00; Page 10; Form 1      
IOSWTPC6800.ASM
                441: 
70B8 BDAE2D     442: ILLDEVICEOP     JSR     SDOS+SDOS.ERROR
70BB 040A       443:                 FDB     ERR.ILLDEVICEOP
70BD BDAE30     444: ERRETX          JSR     SDOS+SDOS.ERRORSAVE
70C0 7EAE33     445:                 JMP     SDOS+SDOS.ERRORED
                446: 
                447: 
70C3 0001       448: LMODE           RMB     1               ; =0 -> reada in non-line mode, >0 -> reada line mode 
70C4 0002       449: LEN             RMB     2               ; DATA BUFFER LENGTH
70C6 0002       450: PDATA           RMB     2               ; ADDR OF DATA 
70C8 0002       451: RPLEN           RMB     2               ; REPLY DATA BUFFER LENGTH
                452: 
  00FA          453: InputBufLen     EQU     250             ; length of input buffer (max 255)
70CA 00FA       454: InputBuf        RMB     InputBufLen     ; input buffer ADDR
71C4 0002       455: InputBufP0      RMB     2               ; addr of next char into InputBuffer TO BE PROCESSED (HEAD OF BUFFER)
71C6 0002       456: InputBufP1      RMB     2               ; addr of next free char into InputBuffer (END OF BUFFER)
                457: 
71C8 0001       458: EOFFLAG         RMB     1               ; =1 -> EOF = input line processed
71C9 0001       459: ECHOFLAG        rmb     1               ; =0 -> NO ECHO 
71CA 0001       460: ncol            rmb     1               ; number of chars printed in the current line
71CB 0001       461: basicflags      rmb     1               ; flags for basic control chars for debugging
71CC 0001       462: CTRLCNUM        RMB     1               ; NUMBER OF CONTROL-C TYPED IN SEQUENCE
71CD 0001       463: expandtabflag   rmb     1
71CE 0001       464: crflag          rmb     1               ;1=if prev char recv in port: was a <CR>
                465: 
71CF 0010       466: ACTIVATIONCHARSVECTOR   RMB 16          ; Activation Chars vector
71DF 0001       467: ActivationCharSensed    rmb 1           ; Activation Char typed by user
                468: 
  0000          469:              if ram64k=1
 *S*            470:                 ; on 64K RAM machine, SWTBUG rom not present. Here goes the console I/O routines
 *S*            471: ACIAPORT        EQU     $FF04   ; ACIA PORT IN SWTBUG 64K RAM
 *S*            472: PORECH          FCB     0       ; ECHO (=0 -> echo, $FF -> no echo)
 *S*            473: 
 *S*            474:                 ; *OUTPUT ONE CHARACTER
 *S*            475: OUTEEE          PSHB            ; SAVE ACC B
 *S*            476:                 STX     $00     ; STORE INDEX REGISTER
 *S*            477:                 LDX     #ACIAPORT
 *S*            478:                 LDAB    1,X
 *S*            479:                 CMPB    3,X
 *S*            480: ACIOUT          LDAB    #$11
 *S*            481:                 STAB    0,X
 *S*            482: ACIOU1          LDAB    0,X
 *S*            483:                 ASRB
 *S*            484:                 ASRB
 *S*            485:                 BCC     ACIOU1  ; ACIA NOT READY
 *S*            486:                 STAA    1,X     ; OUTPUT CHARACTER **log OUTCH:A
 *S*            487: RES             PULB            ; RESTORE ACC B
 *S*            488:                 LDX     $00
 *S*            489:                 RTS
 *S*            490: 
 *S*            491:                 ; *INPUT ONE CHAR INTO ACC B
 *S*            492: INEEE           PSHB            ; SAVE ACC B
 *S*            493:                 STX     $00     ; STORE INDEX REGISTER
 *S*            494:                 LDX     #ACIAPORT
 *S*            495:                 LDAB    1,X




ASM/6800 1.4A0: 71DF                    
08/16/82 00:00:00; Page 11; Form 1      
IOSWTPC6800.ASM
 *S*            496:                 CMPB    3,X
 *S*            497:                 LDAA    #$15    ; RECONFIG FOR 8 BIT, 1 SB
 *S*            498:                 STAA    0,X     ;             **troff
 *S*            499: ACIAIN          LDAA    0,X
 *S*            500:                 ASRA
 *S*            501:                 BCC     ACIAIN  ; NOT READY
 *S*            502:                 LDAA    1,X     ; LOAD CHAR   **tron
 *S*            503:                 LDAB    PORECH
 *S*            504:                 BEQ     ACIOUT  ; ECHO
 *S*            505:                 BRA     RES     ; DON'T ECHO
 *S*            506: 
 *S*            507: RDON            LDAA    #$11    ; RON CHAR.
 *S*            508:                 BRA     OUTEEE
 *S*            509: RDOFF           LDAA    #$13    ; TURN READER OFF
 *S*            510:                 BRA     OUTEEE
 *S*            511: PNCHON          LDAA    #$12    ; punch on 
 *S*            512:                 BRA     OUTEEE
 *S*            513: PNCHOFF         LDAA    #$14    ; punch off
 *S*            514:                 BRA     OUTEEE
 *S*            515:                 
                516:              else
                517:                 ; use SWTBUG rom for INEEE and OUTEEE, and so ... 
                518:              fin
                519: 
                520:                 ; print a char 
                521: 
71E0 810D       522: prtch           cmpa    #13             ; <CR> RESET COLUMN COUNT
71E2 270E       523:                 beq     prt1
71E4 8108       524:                 cmpa    #8              ; backSpace
71E6 2712       525:                 beq     prt4            
71E8 853C       526:                 bita    #60             ; DO NOT INCR NCOL ON CONTROL CHARS
71EA 2703       527:                 BEQ     PRT3
71EC 7C71CA     528: prt2            inc     ncol            ; INCR NCOL ON REGULAR $20-$7F
71EF 7EE1D1     529: prt3            jmp     outeee
71F2 7F71CA     530: prt1            clr     ncol
71F5 7A71CA     531:                 dec     ncol
71F8 20F5       532:                 bra     prt3
71FA BDE1D1     533: prt4            jsr     outeee
71FD 8620       534:                 ldaa    #32
71FF BDE1D1     535:                 jsr     outeee
7202 7A71CA     536:                 dec     ncol
7205 8608       537:                 ldaa    #8
7207 7EE1D1     538:                 jmp     outeee
                539: 
                540:                 ; read keyboard key pressed 
                541: 
720A 01         542: inch            nop                             ; **troff
720B BDE1AC     543:                 jsr     ineee                   ; read the keyboard (blocking)
720E 39         544:                 rts                             ; **tron
                545: 
720F 7F71C8     546: OPEN.TTY        CLR     EOFFLAG         ; RESET EOF FLAG
7212 8601       547:                 LDAA    #1
7214 B771C9     548:                 STAA    ECHOFLAG        ; set ECHO ON (to be done by this iopackage)
7217 86FF       549:                 ldaa    #255
7219 B7A00C     550:                 staa    PORECH          ; DISABLE ECHO into swtbug 




ASM/6800 1.4A0: 721C                    
08/16/82 00:00:00; Page 12; Form 1      
IOSWTPC6800.ASM
721C 7F71CA     551:                 clr     ncol            ; init numbers of chars printed in line
721F CE71CF     552:                 LDX     #ACTIVATIONCHARSVECTOR
7222 8610       553:                 LDAA    #16
7224 6F00       554: OPEN.TTY1       CLR     0,X             ; reset the 16 bytes of Activation Char vector
7226 08         555:                 INX
7227 4A         556:                 DECA
7228 26FA       557:                 BNE     OPEN.TTY1       
722A 7F71CC     558:                 CLR     CTRLCNUM        ; INIT ^c COUNT
722D 7F71CB     559:                 clr     basicflags
7230 7E70B6     560:                 JMP     OKRTS           ; TTY IS ALWAYS OPEN
                561: 
7233 7E70B6     562: CLOSE.TTY       JMP     OKRTS           ; AND TTY CANNOT BE CLOSED
                563: 
                564: 
7236 FEAE07     565: STATUS.TTY      ldx     SDOS+SDOS.IOBLOCKPTR
7239 8600       566:                 ldaa    #0  ; vt:sclen
723B E603       567:                 ldab    scblk.params+1,x        ; get sc status opcode
723D C12C       568:                 cmpb    #SC.GETLINEFLAGS
723F 260B       569:                 bne     st0
7241 B671CB     570:                 ldaa    basicflags              ; get the basic flags
                571: 
7244 BAA083     572:                 oraa    BASICDEBUGFLAGS         ; or basic debug flags 
                573: ;               oraa #TRACEBIT                  ; turn on basic trace 
                574: 
7247 7F71CB     575:                 clr     basicflags              ; ans clear them
724A 2014       576:                 bra     statusret1
724C C101       577: st0             cmpb    #SC.GETCOL
724E 2605       578:                 bne     st1
7250 B671CA     579:                 ldaa    ncol                    ; get the number of columns used in current line
7253 200B       580:                 bra     statusret1
7255 C102       581: st1             cmpb    #sc.geteof
7257 2605       582:                 bne     st2             
7259 B671C8     583:                 ldaa    eofflag
725C 2002       584:                 bra     statusret1
725E 8600       585: st2             ldaa    #0                      ; any other request returns 0
7260 EE0A       586: statusret1      LDX     scblk.rdbuf,x           ; return 1 byte status
7262 A700       587:                 staa    0,X                     ; STORE IN RDBUF
7264 7E70B6     588:                 JMP     OKRTS 
                589: 
7267 FEAE07     590: CONTROL.TTY     ldx     sdos+sdos.ioblockptr
726A E603       591:                 ldab    scblk.params+1,x
726C C11D       592:                 cmpb    #cc.activationck
726E 271D       593:                 beq     dactivationck
7270 C110       594:                 cmpb    #cc.ECHO
7272 270B       595:                 beq     dECHO
7274 C111       596:                 cmpb    #cc.NOECHO
7276 270F       597:                 beq     dnoecho
7278 C114       598:                 cmpb    #cc.SETACTBLOCK
727A 2721       599:                 beq     dsetactivation
727C 7E70B6     600: RESET.TTY       JMP     OKRTS           ; TTY DOES NOT NEED RESET
                601: 
727F 8601       602: DECHO           LDAA    #1
7281 B771C9     603:                 STAA    ECHOFLAG
7284 7E70B6     604:                 JMP     OKRTS
7287 7F71C9     605: DNOECHO         CLR     ECHOFLAG




ASM/6800 1.4A0: 728A                    
08/16/82 00:00:00; Page 13; Form 1      
IOSWTPC6800.ASM
728A 7E70B6     606:                 JMP     OKRTS           
                607:                 
728D FE71C4     608: dactivationck   ldx     InputBufp0              ; Is input Buf empty?
7290 BC71C6     609:                 cpx     InputBufP1
7293 2705       610:                 beq     dactivation1            ; br if so (reada will block)
7295 BDAE2D     611:                 jsr     sdos+sdos.error         ; something in input buffer
7298 0775       612:                 fdb     err.activationreceived  ; signal it (reada will not block)
729A 7E70B6     613: dactivation1    JMP     OKRTS                   
                614: 
                615: 
729D BD7475     616: dsetactivation  jsr     GETWRITEPARAMS          ; set the activation chars vector
72A0 CE71CF     617:                 ldx     #ACTIVATIONCHARSVECTOR  
72A3 FF7910     618:                 stx     ddata
72A6 C610       619:                 ldab    #16
72A8 FE70C6     620: dsetact1        ldx     pdata
72AB A600       621:                 ldaa    0,x
72AD 08         622:                 inx
72AE FF70C6     623:                 stx     pdata
72B1 FE7910     624:                 ldx     ddata
72B4 A700       625:                 staa    0,x     
72B6 08         626:                 inx
72B7 FF7910     627:                 stx     ddata
72BA 5A         628:                 decb
72BB 26EB       629:                 bne     dsetact1
72BD 7E70B6     630:                 jmp     okrts
                631: 
                632:                 ; read params from READA/B SYSCALL
                633:                 ; set LMODE, PDATA, LEN, clears RPLEN
                634: 
72C0 FEAE07     635: getreadparams   ldx     sdos+sdos.ioblockptr
72C3 A603       636:                 ldaa    scblk.params+1,x        ; if LMODE=0 -> reada in non-line mode, >0 -> reada line mode 
72C5 B770C3     637:                 staa    LMODE
72C8 EE0C       638:                 LDX     scblk.rdlen,x           ; LEN=reada/B SYSCALL buffer length
72CA FF70C4     639:                 stX     LEN
72CD FEAE07     640:                 LDX     SDOS+SDOS.IOBLOCKPTR    ; INIT RPLEN TO ZERO (ACTUAL CHARS READ INTO SYSCALL BUFFER)
72D0 6F08       641:                 CLR     scblk.RPLEN,x
72D2 6F09       642:                 CLR     scblk.RPLEN+1,x
72D4 FEAE07     643:                 LDX     SDOS+SDOS.IOBLOCKPTR    ; PDATA=addr of INPUT buffer 
72D7 EE0A       644:                 LDX     scblk.rdbuf,x
72D9 FF70C6     645:                 STX     PDATA
72DC 39         646:                 rts
                647:                 
                648:                 ; save x-reg as rplen (numb of chars read) as syscall return 
72DD DF00       649: setrplen        stx     $00
72DF 9600       650:                 ldaa    $00
72E1 D601       651:                 ldab    $01
72E3 FEAE07     652:                 LDX     SDOS+SDOS.IOBLOCKPTR    
72E6 A708       653:                 staa    scblk.RPLEN,x
72E8 E709       654:                 stab    scblk.RPLEN+1,x
72EA 39         655:                 rts
                656: 
72EB BD72C0     657: readb.TTY       jsr     getreadparams           ; get syscall params
72EE FE70C4     658:                 ldx     len                     ; readb will read
72F1 BD72DD     659:                 jsr     setrplen                ; exactly len chars from keyboard
72F4 FE70C4     660: readb1          ldx     len                     ; input buf full? (remaining len=0)




ASM/6800 1.4A0: 72F7                    
08/16/82 00:00:00; Page 14; Form 1      
IOSWTPC6800.ASM
72F7 2712       661:                 beq     readb2                  ; br if buf full
72F9 09         662:                 dex                             ; no, decr remaining len
72FA FF70C4     663:                 stx     len
72FD BD720A     664:                 jsr     inch                    ; read char from keyboard
7300 FE70C6     665:                 ldx     pdata                   ; input buf addr
7303 A700       666:                 staa    0,x                     ; store into input buf
7305 08         667:                 inx
7306 FF70C6     668:                 stx     pdata
7309 20E9       669:                 bra     readb1
730B 0C         670: readb2          clc
730C 39         671:                 rts             
                672: 
730D BD72C0     673: reada.TTY       jsr     getreadparams           ; get syscall params
7310 B670C3     674:                 LDAA    LMODE                   ; CHECK IF NON-LINE MODE READ BUT BUF LEN > 0
7313 2608       675:                 BNE     reada1                  ; BR BECAUSE IN LINE MODE
7315 FE70C4     676:                 LDX     LEN
7318 2703       677:                 BEQ     reada1
731A 7E70B8     678:                 jmp     ILLDEVICEOP             ; ERROR BECAUSE NON-LINE MODE READ BUT BUF LEN > 0
731D FE70C4     679: reada1          LDX     LEN                     ; IS BUFFER IS ZERO BYTES
7320 2605       680:                 BNE     READA2                  ; THE JUST RETURN FROM READ 
7322 BDAE2D     681:                 jsr     sdos+sdos.error         ; signaling "Activation not in buffer" error
7325 0773       682:                 fdb     ERR.ACTIVATIONNOTINBUFFER                 
7327 FE71C4     683: READA2          ldx     InputBufp0              ; LEN IS >0 -> CHECK Is input Buf empty?
732A BC71C6     684:                 cpx     InputBufP1
732D 2603       685:                 bne     reada3                  ; br if not
732F BD738D     686:                 jsr     readInputBuf            ; input buffer empty -> read it from keyboard
7332 CE0000     687: reada3          LDX     #0
7335 FF70C8     688:                 STX     RPLEN                   ; INIT RPLEN
7338 FE71C4     689: READA4          LDX     iNPUTBUFP0              ; CHECK IF INPUT BUF IS EMPTY
733B BC71C6     690:                 CPX     iNPUTBUFP1              
733E 2743       691:                 BEq     READA6                  ; BR IF EMPTY 
7340 FE71C4     692:                 LDX     iNPUTBUFP0              ; GET CHAR FROM INPUT BUFFER
7343 A600       693:                 LDAA    0,X                                     
7345 08         694:                 INX
7346 FF71C4     695:                 STX     INPUTBUFP0
7349 811A       696:                 cmpa    #26                     ; char is ^Z ? 
734B 2736       697:                 beq     reada6                  ; br if so to signal eof
734D FE70C6     698:                 LDX     PDATA                   ; STORE CHAR IN SYSCALL BUFFER
7350 A700       699:                 STAA    0,X
7352 08         700:                 INX     
7353 FF70C6     701:                 STX     PDATA
7356 810D       702:                 cmpa    #13                     ; <cr> resets ncol to 0
7358 2605       703:                 bne     rd1ncol
735A 7F71CA     704:                 clr     ncol
735D 2003       705:                 bra     rd2ncol
735F 7C71CA     706: rd1ncol         inc     ncol                    ; incr ncol chars processed    
7362 FE70C8     707: rd2ncol         LDX     RPLEN                   ; INCR RPLEN NUM OF BYTES STORED
7365 08         708:                 INX                             ; IN SYSCALL BUFFER
7366 FF70C8     709:                 STX     RPLEN
7369 36         710:                 psha
736A BD72DD     711:                 JSR     setrplen                
736D 32         712:                 pula
736E B171DF     713:                 CMPA    ActivationCharSensed    ; CHAR IS activation char sensed ?
7371 2603       714:                 BNE     READA5                  ; BR IF NOT
7373 7E70B6     715:                 JMP     OKRTS                   ; YES! ACTIVATION CHAR IN READ BUFFER -> EXIT FROM SYSCALL, NO 




ASM/6800 1.4A0: 7376                    
08/16/82 00:00:00; Page 15; Form 1      
IOSWTPC6800.ASM
7376 FE70C8     716: READA5          LDX     RPLEN                   ; CHECK IF SYSCALL BUFFER
7379 BC70C4     717:                 CPX     LEN                     ; IS FULL
737C 26BA       718:                 BNE     READA4                  ; BR IF NOT ...
737E BDAE2D     719:                 jsr     sdos+sdos.error         ; BUFFER IS FULL -> RETURN FROM SYSCALL 
7381 0773       720:                 fdb     ERR.ACTIVATIONNOTINBUFFER ; signaling "Activation not in buffer" error
7383 8601       721: READA6          LDAA    #1                      ; SIGNAL EOF FLAG
7385 B771C8     722:                 STAA    EOFFLAG
7388 BDAE2D     723:                 jsr     sdos+sdos.error         ; NO MORE CHARS IN INPUT BUFFER
738B 03E9       724:                 fdb     err.eofhit              ; return from read signaling eof CONDITION
                725:                 
                726:                 
738D 7F71CC     727: ReadInputBuf    CLR     CTRLCNUM
7390 7F71DF     728:                 CLR     ActivationCharSensed    ; no activation char sensed
7393 7F71CD     729:                 clr     expandtabflag           ; tabs should be echoed as ^I if echo is enabled
7396 CE70CA     730: RINBUF          ldx     #InputBuf               ; init Input buf head and and pointer
7399 FF71C4     731:                 stx     InputBufP0              ; to set as no chars has been typed yet (empty buf)
739C FF71C6     732:                 stx     InputBufP1
739F BD720A     733: RINCH           jsr     inch                    ; READ KEY FROM KEYBOARD
73A2 B77537     734:                 staa    ch                      ; save
73A5 8103       735:                 CMPa    #3                      ; is ^C (BREAK)
73A7 2612       736:                 BNE     RI1
73A9 BD74BF     737: RCTRLC          jsr     write.chcr.echo         ; if echo set, write ^C on screen, then <cr><LF>
73AC 7C71CC     738:                 INC     CTRLCNUM                ; INC COUNTER OF ^c'S ISSUED
73AF B671CC     739:                 LDAA    CTRLCNUM
73B2 8102       740:                 CMPA    #2      
73B4 26E0       741:                 BNE     rINBUF                  ; BR IF IS THE FIRST ONE: DISCARD CURRENT LINE
73B6 BDAE2D     742:                 jsr     sdos+sdos.error         ; TWO ^C IN SEQUENCE
73B9 0411       743:                 FDB     err.programkilled       ; KILL THE CURRENT PROGRAM
73BB 7F71CC     744: RI1             CLR     CTRLCNUM                ; KEY READ IS NOT ^c -> RESET COUNT
73BE 8108       745:                 CMPA    #8                      ; IS ^H (BACKSPACE)
73C0 2704       746:                 BEQ     RBACKSPACE
73C2 817F       747:                 CMPA    #127                    ; OR IS ROUBOUT/DEL
73C4 2605       748:                 BNE     RI2                     ;    BR IF NOT
73C6 BD7453     749: RBACKSPACE      JSR     BACKSPACE               ; DEL LAST TYPED CHAR FROM INPUTBUF AND (IF ECHO ENABLED) FROM 
73C9 20D4       750:                 BRA     RINCH                   ; IF SO, IGNORE THE BACKSPACE KEY AND BR TO KEEP READING KEYBOA
73CB 8104       751: RI2             CMPA    #4                      ; IS ^D ? (GO TO DEBUG MONITOR)   
73CD 2614       752:                 BNE     RI3
73CF BD74BF     753: RCTRLD          jsr     write.chcr.echo         ; if echo set, write ^D on screen, then <cr><LF>
  0000          754:              if ram64k=1
 *S*            755:                 JMP     RINCH                   ; RAM64K does not uses SWTBUG ROM, so ^D does nothing
                756:              else
73D2 BF73D9     757:                 STS     SWTRET+1                ; SAVE STACK POINTER
73D5 7EE0D0     758:                 JMP     SWTMON                  ; JUMP TO SWTBUG monitor. return from monitor with JA080 comman
73D8 8EA07F     759: SWTRET          LDS     #$A07F                  ; SWTBUG MONITOR GO COMMAND RETURNS HERE. RESTORE STACK POINTER
73DB 86FF       760:                 ldaa    #255
73DD B7A00C     761:                 staa    PORECH                  ; DISABLE ECHO FOR ACIA
73E0 7E739F     762:                 JMP     RINCH                   ; JMP TO KEEP READING KEYBOARD AS NOTHING HAPPEND
                763:              fin
73E3 C620       764: RI3             ldab    #BREAKBIT               ; 
73E5 8102       765:                 CMPA    #2                      ; IS ^B? (REQUEST LINE NUMBER BREAKPOINT in a basic program)
73E7 2712       766:                 BEQ     Rbas                    ;    br if SO ...
73E9 C610       767:                 ldab    #SSTEPBIT       
73EB 8116       768:                 cmpa    #$16                    ; IS ^V? (REQUEST SINGLE STEP in a basic program)
73ED 270C       769:                 BEQ     Rbas                    ;    br if SO ...
73EF C640       770:                 ldab    #TRACEBIT               




ASM/6800 1.4A0: 73F1                    
08/16/82 00:00:00; Page 16; Form 1      
IOSWTPC6800.ASM
73F1 8114       771:                 cmpa    #$14                    ; IS ^T? (REQUEST LINE NUMBER TRACE in a basic program)
73F3 2706       772:                 BEQ     Rbas                    ;    br if SO ...
73F5 C608       773:                 ldab    #GOBIT          
73F7 8107       774:                 cmpa    #7                      ; IS ^G? (GO FROM BREAKPOINT/SINGLE STEP in a basic program)
73F9 2608       775:                 Bne     RI4                     ;    br if SO ...
73FB FA71CB     776: RBAS            orab    basicflags              ; add current basic flags
73FE CA01       777:                 orab    #1                      ; SET BASIC KEYB POLL ACTIVE ON SC:GETLINEFLAGS
7400 F771CB     778:                 stab    basicflags              ; store back
  7403          779: RI4                                             
7403 FE71C6     780:                 LDX     INPUTBUFP1              ; CHECK IF INPUTBUF IS FULL
7406 8C71C3     781:                 CPX     #INPUTBUF+INPUTBUFLEN-1
7409 2605       782:                 BNE     RSTORECH                ; BR IF BUF HAS ROOM LEFT TO STORE THE TYPED CHAR
740B 36         783:                 PSHA                            ; IF INPUTBUF FULL, THEN ...
740C BD7453     784:                 JSR     BACKSPACE               ; ... DEL LAST TYPED CHAR FROM INPUTBUF AND (IF ECHO ENABLED) F
740F 32         785:                 PULA                            ; TO REPLACE IT WITH NEW TYPED CHAR
7410 FE71C6     786: RSTORECH        LDX     INPUTBUFP1              
7413 A700       787:                 STAA    0,X                     ; STORE CHAR IN INPUTBUF
7415 08         788:                 inx
7416 FF71C6     789:                 stx     inputbufp1
7419 36         790:                 psha
741A BD74C4     791:                 JSR     WRITEA.CH.echo          ; ECHO IT TO SCREEN 
741D 32         792:                 pula
741E 810D       793:                 CMPa    #13                     ; IS <CR> ? 
7420 272A       794:                 BEQ     ActivChar               ;   BR IF SO ...
7422 811A       795:                 CMPa    #26                     ; IS ^Z ? 
7424 2605       796:                 bne     ri5                     ;   BR IF NOT ...
7426 BD74C2     797:                 jsr     write.cr.echo           ; write a <cr> after ^Z
7429 2027       798:                 Bra     Rendofinput             ; then end reading the line
742B 36         799: ri5             psha                            ; now check if the char in a-reg is an activation char
742C 8407       800:                 anda    #7
742E C601       801:                 ldab    #1                      ; set to 1 the bit number
7430 4D         802: ri6             tsta                            ; corresponding to (char & 7)
7431 2704       803:                 beq     ri7
7433 58         804:                 aslb            
7434 4A         805:                 deca
7435 20F9       806:                 bra     ri6
7437 32         807: ri7             pula
7438 47         808:                 asra                            ; a=byte index on ACTIVATIONCHARSVECTOR
7439 47         809:                 asra                            ; b=bit mask 
743A 47         810:                 asra
743B B77442     811:                 staa    ActivByte+1     
743E CE71CF     812:                 ldx     #ACTIVATIONCHARSVECTOR  ; check ACTIVATIONCHARSVECTOR to 
7441 A600       813: ActivByte       ldaa    0,X                     ; determine if char is an activation char
7443 D700       814:                 stab    $00
7445 9400       815:                 anda    $00
7447 2603       816:                 bne     ActivChar               ; BR if char is an activation char
7449 7E739F     817:                 JMP     RINCH
744C B67537     818: ActivChar       ldaa    ch
744F B771DF     819:                 staa    ActivationCharSensed    ; save the activation char sensed
7452 39         820: Rendofinput     RTS                             ; > READ LINE FROM KEYBOARD TERMINATED
                821:                 
                822:                 
                823: 
7453 FE71C6     824: BACKSPACE       LDX     InputBufP1              ; DEL LAST TYPED CHAR FROM INPUTBUF AND (IF ECHO ENABLED) FROM 
7456 8C70CA     825:                 CPX     #iNPUTbUF               




ASM/6800 1.4A0: 7459                    
08/16/82 00:00:00; Page 17; Form 1      
IOSWTPC6800.ASM
7459 2719       826:                 BEQ     BACKSPC2
745B 09         827:                 DEX
745C FF71C6     828:                 STX     iNPUTBUFP1              ; BACKSPACE TO ERASE LAST CHAR TYPED FROM INPUTBUF
745F 7D71C9     829:                 TST     ECHOflag
7462 2710       830:                 BEQ     BACKSPC2                ; IF NO ECHO, BR TO KEEP READING KEYBOARD
7464 A600       831:                 LDAA    0,X                     ; GET CHAR THAT HAS BEEN ERASED
7466 8120       832:                 CMPA    #32                     ; IS A CONTROL CHAR?
7468 2405       833:                 BCC     BACKSPC1                ; BR IF A >= 32 
746A 8608       834:                 LDAA    #8                      ; IS A CONTROL CHAR -> ISSUE TWO BACKSPACES
746C BD71E0     835:                 JSR     PRTCH                   ; TO DELETE ^x FROM SCREEN
746F 8608       836: BACKSPC1        LDAA    #8
7471 BD71E0     837:                 JSR     PRTCH
7474 39         838: BACKSPC2        RTS
                839: 
7475 FEAE07     840: GETWRITEPARAMS  LDX     SDOS+SDOS.IOBLOCKPTR    ; get number of chars to write form syscall
7478 EE06       841:                 LDX     scblk.wrlen,x           
747A FF70C4     842:                 STX     LEN                     
747D FEAE07     843:                 LDX     SDOS+SDOS.IOBLOCKPTR    ; get addr of chars to write
7480 EE04       844:                 LDX     scblk.wrbuf,x
7482 FF70C6     845:                 STX     PDATA
7485 39         846:                 RTS
                847: 
                848: 
7486 8601       849: WRITEA.TTY      LDAa    #1
7488 B774A8     850:                 STaA    write.MODE+1
748B B771CD     851:                 staa    expandtabflag           ; signal tabs should be expanded to spaces
748E 2006       852:                 BRA     WRITE.0
7490 7F74A8     853: WRITEB.TTY      CLR     write.MODE+1
7493 7F71CA     854:                 clr     ncol
7496 BD7475     855: WRITE.0         JSR     GETWRITEPARAMS 
7499 FE70C4     856:                 LDX     LEN                     
749C 271E       857:                 BEQ     WRITE.9                 ; exit because writing zero chars
749E FE70C6     858: WRITE.1         LDX     PDATA                   ; get next char to write.
74A1 A600       859:                 LDAA    0,X
74A3 08         860:                 INX                             ; .*echo wrtch:a
74A4 FF70C6     861:                 STX     PDATA
74A7 C600       862: write.MODE      ldab    #0                      ; if not ascii mode (that means, we are executing a writeb)
74A9 2705       863:                 BEQ     WRITE.2                 ; br to print char without any further processing  
74AB BD74CA     864:                 JSR     WRITEA.CH               ; convert char <CR> -> <CR><LF>, ctrol char -> ^X
74AE 2003       865:                 bra     write.3
74B0 BD71E0     866: WRITE.2         JSR     prtch                   ; send char to console via swtbug
74B3 FE70C4     867: write.3         LDX     LEN
74B6 09         868:                 DEX
74B7 FF70C4     869:                 STX     LEN
74BA 26E2       870:                 BNE     WRITE.1
74BC 7E70B6     871: WRITE.9         JMP     OKRTS
                872: 
                873: 
74BF BD74C4     874: write.chcr.echo jsr     WRITEA.CH.echo  
74C2 860D       875: write.cr.echo   ldaa    #13
74C4 7D71C9     876: WRITEA.CH.echo  tst     echoflag                ; write char only if echo set and expand tabs. 
74C7 2609       877:                 bne     writea.ch1              ; this is called from ReadInputBuf
74C9 39         878:                 rts
74CA 810C       879: WRITEA.CH       cmpa    #12                     ; ^L -> do not print
74CC 273E       880:                 beq     WRITEA.CH4




ASM/6800 1.4A0: 74CE                    
08/16/82 00:00:00; Page 18; Form 1      
IOSWTPC6800.ASM
74CE 8107       881:                 cmpa    #7                      ; ^G -> do not print
74D0 273A       882:                 beq     WRITEA.CH4
74D2 847F       883: writea.ch1      andA    #$7f            
74D4 810D       884:                 CMPA    #13
74D6 2607       885:                 BNE     WRITEA.CH2              ; SEND A <LF> AFTER EACH <CR>
74D8 BD71E0     886:                 JSR     prtch
74DB 860A       887:                 LDAA    #10
74DD 202A       888:                 bra     WRITEA.CH3      
74DF 8109       889: WRITEA.CH2      cmpa    #9                      ; check for <TAB> (char 9 dec)
74E1 2619       890:                 bne     WRITEA.CH2b
74E3 7D71CD     891:                 tst     expandtabflag           ; tabs should be expanded to spaces?
74E6 2718       892:                 beq     WRITEA.CH2c             ; br if not to print tab as ^I
74E8 F671CA     893:                 ldab    ncol                    ; tab converted to 1-8 spaces depending on ncol
74EB C407       894:                 andb    #7
74ED 8608       895:                 ldaa    #8
74EF 10         896:                 sba
74F0 16         897:                 tab                             ; b=spaces that replaces tab=8-ncol
74F1 37         898: WRITEA.CH2a     pshb
74F2 8620       899:                 ldaa    #32
74F4 BD71E0     900:                 jsr     prtch
74F7 33         901:                 pulb
74F8 5A         902:                 decb
74F9 26F6       903:                 bne     WRITEA.CH2a
74FB 39         904:                 rts
74FC 8120       905: WRITEA.CH2b     cmpa    #32                     ; if ch < 32, print it as control char "^ch"
74FE 2409       906:                 bcC     WRITEA.CH3              ; BR IF A-REG >= 32
7500 36         907: WRITEA.CH2c     psha
7501 865E       908:                 ldaa    #'^
7503 BD71E0     909:                 JSR     prtch
7506 32         910:                 pula
7507 8B40       911:                 adda    #'@
7509 BD71E0     912: WRITEA.CH3      jsr     prtch
750C 39         913: WRITEA.CH4      RTS
                914:                 
                915: ; DEVICE CONTROL BLOCK FOR SIMH IO VIRTUAL PORT
                916: 
750D 504F5254   917: dcbname.port    fcc     'PORT:'
7512 00         918:                 fcb     0
                919: 
7513 01         920: DCB.PORT        FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
7514 0000       921:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
7516 750D       922:                 FDB     dcbname.port            ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
7518 7B3D       923:                 FDB     CLOCKDCB                ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
751A 751C       924:                 FDB     PORTDRIVER              ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
                925: 
                926: ; DEVICE DRIVER FOR IO PORT (for simh PTR and PTP)
                927: 
751C 7558       928: PORTDRIVER      FDB     OPEN.PORT       ; DRIVER:OPEN   OPEN FILE
751E 7560       929:                 FDB     CLOSE.PORT      ; DRIVER:CLOSE  CLOSE FILE
7520 75C5       930:                 FDB     READA.PORT      ; DRIVER:READA  READ ASCII
7522 7671       931:                 FDB     WRITEA.PORT     ; DRIVER:WRITEA WRITE ASCII
7524 75CC       932:                 FDB     READB.PORT      ; DRIVER:READB  READ BINARY
7526 767B       933:                 FDB     WRITEB.PORT     ; DRIVER:WRITEB WRITE BINARY
7528 7558       934:                 FDB     OPEN.PORT       ; DRIVER:CREATE CREATE FILE
752A 70B8       935:                 FDB     ILLDEVICEOP     ; DRIVER:RENAME RENAME FILE




ASM/6800 1.4A0: 752C                    
08/16/82 00:00:00; Page 19; Form 1      
IOSWTPC6800.ASM
752C 70B8       936:                 FDB     ILLDEVICEOP     ; DRIVER:DELETE DELETE FILE
752E 7538       937:                 FDB     control.port    ; DRIVER:CONTROL        DO CONTROL OPERATION
7530 7542       938:                 FDB     status.port     ; DRIVER:STATUS READ DEVICE (DRIVER) STATUS
7532 70B6       939:                 FDB     OKRTS           ; DRIVER:RESET  RESET DRIVER (ON BOOT)
7534 70B8       940:                 FDB     ILLDEVICEOP     ; DRIVER:STARTIO        power-fail restart--dream on!
                941: 
7536 FF         942: PORTMODE        FCB     $FF             ; =1 -> READING FROM PTR, =2 -> READING FROM PTP
7537 0001       943: ch              rmb     1               ; char read/write
                944: 
7538 FEAE07     945: control.port    ldx     sdos+sdos.ioblockptr
753B E603       946:                 ldab    scblk.params+1,x
753D C11D       947:                 cmpb    #cc.activationck
753F 7E70B6     948:                 jmp     okrts
                949: 
7542 FEAE07     950: status.port     ldx     SDOS+SDOS.IOBLOCKPTR
7545 E603       951:                 ldab    scblk.params+1,x        ; get sc status opcode
7547 C104       952:                 cmpb    #sc.gettype
7549 2604       953:                 bne     stpo1
754B 8602       954:                 ldaa    #DVTYP.STAPE
754D 2002       955:                 bra     stpo2
754F 8600       956: stpo1           ldaa    #0                      ; any other request returns 0
7551 EE0A       957: stpo2           LDX     scblk.rdbuf,x           ; return 1 byte status
7553 A700       958:                 staa    0,X                     ; STORE IN RDBUF
7555 7E70B6     959:                 JMP     OKRTS 
                960: 
                961: 
7558 8600       962: OPEN.PORT       LDAA    #0
755A B77536     963:                 STAA    PORTMODE        ; =0 -> ready for read/write
755D 7E70B6     964:                 JMP     OKRTS
                965: 
7560 B67536     966: CLOSE.PORT      ldaa    portmode
7563 2603       967:                 bne     cl1
7565 7E70B6     968:                 jmp     okrts           ; just close after open
7568 8101       969: cl1             cmpa    #1              
756A 260B       970:                 bne     cl2
                971:                                         ; close ptr
756C BDE347     972:                 jsr     RDOFF           ; PTR off (^S)
756F 86FF       973:                 ldaa    #$ff            ; set mode as closed
7571 B77536     974:                 staa    portmode
7574 7E70B6     975:                 JMP     OKRTS
  7577          976: cl2                                     
7577 8102       977:                 cmpa    #2
7579 260E       978:                 bne     cl3
                979:                                         ; close ptp
757B BDE353     980:                 jsr     PNCHOFF         ; PTR off (^T)
757E 86FF       981:                 ldaa    #$ff            ; set mode as closed
7580 B77536     982:                 staa    portmode
7583 7E70B6     983:                 JMP     OKRTS
                984: 
7586 7E70B6     985:                 JMP     OKRTS
7589 7E70B8     986: cl3             JMP     ILLDEVICEOP     
                987: 
758C CE0032     988: delay1k         ldx     #50             ; **troff
758F 09         989: delay1kb        dex
7590 26FD       990:                 bne     delay1kb




ASM/6800 1.4A0: 7592                    
08/16/82 00:00:00; Page 20; Form 1      
IOSWTPC6800.ASM
7592 39         991:                 rts                     ; **tron
                992: 
7593 BD758C     993: innyble         jsr     delay1k         ; RECEIVE A BYTE FROM PTR AS TWO ASCII NYBLLES TO FORM A BYTE
7596 BD720A     994:                 jsr     inch            ; EXAMPLE: RECIVE CHARS "3A" -> RECV BYTE = $3A
7599 8130       995:                 cmpa    #'0             ; .*echo inch:a
759B 2406       996:                 BCC     innyb1          ; BR IF A >= '0'
759D 811A       997:                 cmpa    #26
759F 26F2       998:                 bne     innyble         ; invalid char -> read next 
75A1 0D         999:                 sec                     ; RECEIVED ^Z
75A2 39        1000:                 rts                     ; return carry set -> eof
75A3 8030      1001: innyb1          suba    #'0
75A5 810A      1002:                 cmpa    #10
75A7 2402      1003:                 bcc     innyb4          ; br if a >= 10
75A9 0C        1004:                 clc
75AA 39        1005:                 rts                     ; return nyble 0..9
75AB 8007      1006: innyb4          suba    #7
75AD 8110      1007:                 cmpa    #16
75AF 24E2      1008:                 bcc     innyble         ; br if a >= 16 -> invalid nyble -> read next
75B1 0C        1009:                 clc
75B2 39        1010:                 rts
               1011: 
75B3 BD758C    1012: INBYTE          jsr     delay1k         ; RECEIVE AN ASCII CHAR FROM PTR 
75B6 BD720A    1013:                 jsr     inch            
75B9 8100      1014:                 CMPA    #0              ; RECV $00 CHAR -> END OF FILE
75BB 2706      1015:                 BEQ     INBYTEEOF
75BD 811A      1016:                 CMPA    #26             ; RECV ^Z -> END OF FILE
75BF 2702      1017:                 BEQ     INBYTEEOF
75C1 0C        1018:                 CLC
75C2 39        1019:                 RTS
75C3 0D        1020: INBYTEEOF       SEC                     ; SET CARRY TO SIGNAL END OF FILE TO CALLER
75C4 39        1021:                 RTS
               1022: 
               1023: 
75C5 8601      1024: READA.PORT      LDAa    #1
75C7 B7760E    1025:                 STaA    APORT.MODE+1
75CA 2003      1026:                 BRA     READ.PORT
75CC 7F760E    1027: READB.PORT      CLR     APORT.MODE+1
75CF BD72C0    1028: READ.PORT       jsr     getreadparams   ; get syscall params
75D2 CE0000    1029:                 ldx     #0
75D5 BD72DD    1030:                 jsr     setrplen        ; set reply len size
75D8 B67536    1031:                 LDAA    PORTMODE
75DB 2617      1032:                 BNE     RP1
75DD 8601      1033:                 LDAA    #1              ; start reading from ptr
75DF B77536    1034:                 STAA    PORTMODE        ; 
75E2 7F71CE    1035:                 clr     crflag
75E5 BDE337    1036:                 jsr     RDON            ; ACTIVATE PTR on (^Q)
75E8 B6760E    1037:                 LDAA    APORT.MODE+1    ; GET PORT READA/READB MODE
75EB 260E      1038:                 BNE     rp1start        ; BR IF READA
75ED 8681      1039:                 LDAA    #129            ; ACTIVATE PTR bin mode (129)
75EF BD71E0    1040:                 JSR     PRTCH   
75F2 2007      1041:                 bra     rp1start
75F4 8101      1042: rp1             cmpa    #1
75F6 2703      1043:                 beq     rp1start        ; br read port input
75F8 7E70B8    1044:                 jmp     ILLDEVICEOP     
75FB CE0000    1045: rp1start        ldx     #0




ASM/6800 1.4A0: 75FE                    
08/16/82 00:00:00; Page 21; Form 1      
IOSWTPC6800.ASM
75FE FF70C8    1046:                 stx     rplen
7601 FE70C4    1047: rpin            ldx     len
7604 2603      1048:                 bne     rp1a
7606 7E70B6    1049:                 jmp     okrts           ; input buffer full -> terminate read
7609 09        1050: rp1a            dex
760A FF70C4    1051:                 stx     len
760D 8600      1052: APORT.MODE      LDAA    #0
760F 272F      1053:                 BEQ     READBPORT
7611 BD75B3    1054: READAPORT       JSR     INBYTE  
7614 2556      1055:                 bcs     rp1eof          ; br if eof
               1056:                 ; now handle the end of line: DOS <CR><LF>, Unix <LF>, Mac/SDOS <CR>
7616 810D      1057:                 cmpa    #13
7618 2607      1058:                 bne     cr1             ; if <CR> -> set crflag
761A C601      1059:                 ldab    #1
761C F771CE    1060:                 stab    crflag
761F 2012      1061:                 bra     cr0
7621 810A      1062: cr1             cmpa    #10             ; if <LF> after a <CR> -> ignore <LF>
7623 2609      1063:                 bne     cr2             ; if <LF> NOT after a <CR> -> convert to <CR>
7625 7D71CE    1064:                 tst     crflag
7628 26E7      1065:                 bne     READAPORT       
762A 860D      1066:                 ldaa    #13
762C 2005      1067:                 bra     cr0
762E 7F71CE    1068: cr2             clr     crflag          ; not <cr>/<l> -> clear cr flag 
7631 2024      1069:                 bra     SAVEREADPORTCH  ; and br to store char
7633 7D70C3    1070: cr0             tst     lmode
7636 271F      1071:                 beq     SAVEREADPORTCH  ; if not line mode br to store char
7638 7F70C4    1072:                 clr     len             ; recv <cR> in line more -> set len to zero so reada is terminated
763B 7F70C5    1073:                 clr     len+1
763E 2017      1074:                 BRA     SAVEREADPORTCH
7640 BD7593    1075: READBPORT       jsr     innyble
7643 2527      1076:                 bcs     rp1eof          ; br if eof
7645 48        1077:                 asla
7646 48        1078:                 asla
7647 48        1079:                 asla
7648 48        1080:                 asla
7649 B77537    1081:                 staa    ch              ; save hi nyble
764C BD7593    1082:                 jsr     innyble
764F 251B      1083:                 bcs     rp1eof          ; br if eof
7651 BB7537    1084:                 adda    ch
7654 B77537    1085:                 staa    ch              ; binary char composed
7657 FE70C6    1086: SAVEREADPORTCH  ldx     pdata           ; input buf addr
765A A700      1087:                 staa    0,x             ; store into input buf
765C 08        1088:                 inx                     ; .*echo inbyte:a
765D FF70C6    1089:                 stx     pdata
7660 FE70C8    1090:                 ldx     rplen
7663 08        1091:                 inx
7664 FF70C8    1092:                 stx     rplen
7667 BD72DD    1093:                 jsr     setrplen        ; set reply len size = num of bytes read
766A 2095      1094:                 bra     rpin
               1095: 
766C BDAE2D    1096: rp1eof          jsr     sdos+sdos.error ; .*echo eof
766F 03E9      1097:                 fdb     err.eofhit      ; return from read signaling eof CONDITION
               1098: 
7671 8601      1099: WRITEA.PORT     LDAa    #1
7673 B7760E    1100:                 STaA    APORT.MODE+1




ASM/6800 1.4A0: 7676                    
08/16/82 00:00:00; Page 22; Form 1      
IOSWTPC6800.ASM
7676 B771CD    1101:                 staa    expandtabflag   ; signal tabs should be expanded to spaces
7679 2003      1102:                 BRA     WRITE.PORT
767B 7F760E    1103: WRITEB.PORT     CLR     APORT.MODE+1
767E BD7475    1104: WRITE.PORT      JSR     GETWRITEPARAMS 
7681 B67536    1105:                 LDAA    PORTMODE
7684 2625      1106:                 BNE     WP1
7686 8602      1107:                 LDAA    #2              ; start WRITING AT ptP
7688 B77536    1108:                 STAA    PORTMODE        ; 
768B BDE34D    1109:                 jsr     PNCHON          ; ACTIVATE PTP on (^R)
768E 8682      1110:                 ldaa    #130            ; ACTIVATE PTP ascii (130)
7690 F6760E    1111:                 LDAb    APORT.MODE+1    ; GET PORT WRITEA/WRITEB MODE
7693 2611      1112:                 BNE     Wp0             ; BR IF writeA
7695 8683      1113:                 LDAA    #131            ; ACTIVATE PTP bin mode (131)
7697 BD71E0    1114:                 JSR     PRTCH   
769A 8620      1115:                 LDAA    #32
769C BD71E0    1116:                 JSR     PRTCH           ; SEND A SPACEs TO SYNC
769F 8620      1117:                 LDAA    #32
76A1 BD71E0    1118:                 JSR     PRTCH           
76A4 8620      1119:                 LDAA    #32
76A6 BD71E0    1120: wp0             JSR     PRTCH           
76A9 2007      1121:                 bra     Wp1start
76AB 8102      1122: Wp1             cmpa    #2
76AD 2703      1123:                 beq     Wp1start        ; br read port input
76AF 7E70B8    1124:                 jmp     ILLDEVICEOP     
  76B2         1125: Wp1start        
76B2 FE70C4    1126: WpOUT           ldx     len
76B5 2603      1127:                 bne     Wp1a
76B7 7E70B6    1128:                 jmp     okrts           ; input buffer full -> terminate read
76BA 09        1129: Wp1a            dex
76BB FF70C4    1130:                 stx     len
76BE FE70C6    1131:                 LDX     PDATA           ; get next char to write.
76C1 A600      1132:                 LDAA    0,X
76C3 08        1133:                 INX                     ; .*echo wrtch:a
76C4 FF70C6    1134:                 STX     PDATA
76C7 F6760E    1135:                 LDAB    APORT.MODE+1
76CA 2705      1136:                 BEQ     WRITEBPORT
76CC BD74CA    1137: WRITEAPORT      JSR     WRITEA.CH       ; convert char <CR> -> <CR><LF>, cTRol char -> ^X
76CF 20E1      1138:                 BRA     WPOUT
76D1 B77537    1139: WRITEBPORT      STAA    CH
76D4 44        1140:                 LSRA
76D5 44        1141:                 LSRA
76D6 44        1142:                 LSRA
76D7 44        1143:                 LSRA
76D8 BD76E5    1144:                 JSR     OUTNYBLE
76DB B67537    1145:                 LDAA    CH
76DE 840F      1146:                 ANDa    #$0F
76E0 BD76E5    1147:                 JSR     OUTNYBLE
76E3 20CD      1148:                 BRA     WPOUT
               1149: 
76E5 8B30      1150: OUTNYBLE        ADDA    #'0
76E7 813A      1151:                 CMPA    #'9+1
76E9 2502      1152:                 BCS     OUTNYBLE1       ; BR IF A<'9'+1
76EB 8B07      1153:                 ADDA    #7              ; 7='A'-'0'-10
76ED 7E71E0    1154: OUTNYBLE1       jMP     PRTCH
               1155: 




ASM/6800 1.4A0: 76ED                    
08/16/82 00:00:00; Page 23; Form 1      
IOSWTPC6800.ASM
               1156: 
               1157: 
               1158: 
               1159: 
               1160: 
               1161: 
               1162: 
               1163: ; DEVICE CONTROL BLOCK FOR MF-68 FLOPPY DISK
               1164: 
  0003         1165: LSN.SIZE        EQU     3       ; # BYTES OCCUPIED BY AN LSN
  0002         1166: LCN.SIZE        EQU     2       ; # BYTES OCCUPIED BY AN LCN
               1167: 
76F0 44303A    1168: dcbname.D0      fcc     'D0:'
76F3 00        1169:                 fcb     0
  76F4         1170: DISKDCBS        
76F4 01        1171: DCB.D0          FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
76F5 0000      1172:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
76F7 76F0      1173:                 FDB     dcbname.D0              ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
76F9 773C      1174:                 FDB     dcb.d1                  ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
76FB 7810      1175:                 FDB     DSKDRIVER               ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
               1176: 
               1177:                                                                 ; DISK GEOMETRY
76FD 0080      1178:                 FDB     128                     ; DSKINFO:NBPS  ; NUMBER OF BYTES PER SECTOR
76FF 0012      1179:                 FDB     18                      ; DSKINFO:NSPT  ; NUMBER OF SECTORS PER TRACK
7701 0002      1180:                 FDB     2                       ; DSKINFO:NTPC  ; NUMBER OF TRACKS PER CYLINDER
7703 0023      1181:                 FDB     35                      ; DSKINFO:NCYL  ; NUMBER OF CYLINDERS PER DRIVE
               1182: 
               1183:                                                                 ; THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
7705 0001      1184:                 RMB     1                       ; DSKINFO:NSPC   NUMBER OF SECTORS PER CLUSTER
7706 0002      1185:                 RMB     LCN.SIZE                ; DSKINFO:MINALLOC ALLOCATION MINIMUM FOR NEW FILES
7708 0002      1186:                 RMB     LCN.SIZE                ; DSKINFO:MIDALLOC ALLOCATION MIN FOR FILE EXTENSION
770A 0002      1187:                 RMB     2                       ; DSKINFO:MAPALGORITHM CODE TO SELECT LOGICAL TO PHYSICAL SECTO
               1188: 
               1189:                                                                 ; CONTAINS DISK ID FOR MOUNTED DISKS
770C 0001      1190:                 RMB     1                       ; DSKINFO:LOG2NBPS LOG BASE 2 OF DSKINFO:NBPS
770D 0002      1191:                 RMB     2                       ; DSKINFO:NBPSM1 = NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
770F 0003      1192:                 RMB     LSN.SIZE                ; DSKINFO:NLSN   NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
7712 0002      1193:                 RMB     LCN.SIZE                ; DSKINFO:NLCN   NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
7714 0002      1194:                 RMB     2                       ; DSKINFO:NBPC   NUMBER OF BYTES PER CLUSTER
7716 0002      1195:                 RMB     LCN.SIZE                ; DSKINFO:RANDMAP "RANDOM" LCN TO DISTRIBUTE NEW FILES
7718 0003      1196:                 RMB     LSN.SIZE                ; DSKINFO:MAPLSN LSN OF 1ST SECTOR IN DISK...
               1197: 
               1198:                                                                 ; ALLOCATION MAP CLUSTER
771B 0002      1199:                 RMB     2                       ; DSKINFO:DIRFCB POINTER TO FCB FOR $DIRECTORY FILE
771D 0002      1200:                 RMB     2                       ; DSKINFO:MAPFCB POINTER TO FCB FOR $DISKMAP FILE
771F 0002      1201:                 RMB     2                       ; DSKINFO:SECTORDB POINTER TO RDSI CONTAINING LSN, ADDRESS PARA
7721 0003      1202:                 RMB     LSN.SIZE                ; DSKINFO:BADLSN LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SE
7724 0000      1203:                 FDB     0                       ; DSKINFO:SEEKERRCNT # SEEK ERRORS SINCE MOUNT
7726 0000      1204:                 FDB     0                       ; DSKINFO:SEEKERRSTS 16 BITS OF LAST "SEEK" STATUS IN ERROR
7728 0000      1205:                 FDB     0                       ; DSKINFO:WRITEERRCNT # WRITE ERRORS SINCE MOUNT
772A 0000      1206:                 FDB     0                       ; DSKINFO:WRITEERRSTS 16 BITS OF LAST "WRITE" STATUS IN ERROR
772C 0000      1207:                 FDB     0                       ; DSKINFO:READERRCNT # READ ERRORS SINCE MOUNT
772E 0000      1208:                 FDB     0                       ; DSKINFO:READERRSTS 16 BITS OF LAST "READ" STATUS IN ERROR
7730 000000    1209:                 FCB     0,0,0                   ; DSKINFO:OPSCOUNT 24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
7733 0003      1210:                 RMB     LSN.SIZE                ; DSKINFO:ERRLSN LSN CAUSING ANY SOFT OR HARD ERROR




ASM/6800 1.4A0: 7736                    
08/16/82 00:00:00; Page 24; Form 1      
IOSWTPC6800.ASM
7736 0001      1211:                 RMB     1                       ; DSKINFO:WRITEPROTSTATE 0 --> WRITEABLE
7737 00        1212:                 FCB     0                       ; FDUNIT         Drive number 
               1213: 
7738 44313A    1214: dcbname.D1      fcc     'D1:'
773B 00        1215:                 fcb     0
773C 01        1216: DCB.D1          FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
773D 0000      1217:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
773F 7738      1218:                 FDB     dcbname.D1              ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
7741 7784      1219:                 FDB     dcb.d2                  ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
7743 7810      1220:                 FDB     DSKDRIVER               ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
               1221: 
               1222:                                                                 ; DISK GEOMETRY
7745 0080      1223:                 FDB     128                     ; DSKINFO:NBPS  ; NUMBER OF BYTES PER SECTOR
7747 0012      1224:                 FDB     18                      ; DSKINFO:NSPT  ; NUMBER OF SECTORS PER TRACK
7749 0002      1225:                 FDB     2                       ; DSKINFO:NTPC  ; NUMBER OF TRACKS PER CYLINDER
774B 0023      1226:                 FDB     35                      ; DSKINFO:NCYL  ; NUMBER OF CYLINDERS PER DRIVE
               1227: 
               1228:                                                                 ; THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
774D 0001      1229:                 RMB     1                       ; DSKINFO:NSPC   NUMBER OF SECTORS PER CLUSTER
774E 0002      1230:                 RMB     LCN.SIZE                ; DSKINFO:MINALLOC ALLOCATION MINIMUM FOR NEW FILES
7750 0002      1231:                 RMB     LCN.SIZE                ; DSKINFO:MIDALLOC ALLOCATION MIN FOR FILE EXTENSION
7752 0002      1232:                 RMB     2                       ; DSKINFO:MAPALGORITHM CODE TO SELECT LOGICAL TO PHYSICAL SECTO
               1233: 
               1234:                                                                 ; CONTAINS DISK ID FOR MOUNTED DISKS
7754 0001      1235:                 RMB     1                       ; DSKINFO:LOG2NBPS LOG BASE 2 OF DSKINFO:NBPS
7755 0002      1236:                 RMB     2                       ; DSKINFO:NBPSM1 = NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
7757 0003      1237:                 RMB     LSN.SIZE                ; DSKINFO:NLSN   NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
775A 0002      1238:                 RMB     LCN.SIZE                ; DSKINFO:NLCN   NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
775C 0002      1239:                 RMB     2                       ; DSKINFO:NBPC   NUMBER OF BYTES PER CLUSTER
775E 0002      1240:                 RMB     LCN.SIZE                ; DSKINFO:RANDMAP "RANDOM" LCN TO DISTRIBUTE NEW FILES
7760 0003      1241:                 RMB     LSN.SIZE                ; DSKINFO:MAPLSN LSN OF 1ST SECTOR IN DISK...
               1242: 
               1243:                                                                 ; ALLOCATION MAP CLUSTER
7763 0002      1244:                 RMB     2                       ; DSKINFO:DIRFCB POINTER TO FCB FOR $DIRECTORY FILE
7765 0002      1245:                 RMB     2                       ; DSKINFO:MAPFCB POINTER TO FCB FOR $DISKMAP FILE
7767 0002      1246:                 RMB     2                       ; DSKINFO:SECTORDB POINTER TO RDSI CONTAINING LSN, ADDRESS PARA
7769 0003      1247:                 RMB     LSN.SIZE                ; DSKINFO:BADLSN LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SE
776C 0000      1248:                 FDB     0                       ; DSKINFO:SEEKERRCNT # SEEK ERRORS SINCE MOUNT
776E 0000      1249:                 FDB     0                       ; DSKINFO:SEEKERRSTS 16 BITS OF LAST "SEEK" STATUS IN ERROR
7770 0000      1250:                 FDB     0                       ; DSKINFO:WRITEERRCNT # WRITE ERRORS SINCE MOUNT
7772 0000      1251:                 FDB     0                       ; DSKINFO:WRITEERRSTS 16 BITS OF LAST "WRITE" STATUS IN ERROR
7774 0000      1252:                 FDB     0                       ; DSKINFO:READERRCNT # READ ERRORS SINCE MOUNT
7776 0000      1253:                 FDB     0                       ; DSKINFO:READERRSTS 16 BITS OF LAST "READ" STATUS IN ERROR
7778 000000    1254:                 FCB     0,0,0                   ; DSKINFO:OPSCOUNT 24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
777B 0003      1255:                 RMB     LSN.SIZE                ; DSKINFO:ERRLSN LSN CAUSING ANY SOFT OR HARD ERROR
777E 0001      1256:                 RMB     1                       ; DSKINFO:WRITEPROTSTATE 0 --> WRITEABLE
777F 01        1257:                 FCB     1                       ; FDUNIT         Drive number 
               1258: 
7780 44323A    1259: dcbname.D2      fcc     'D2:'
7783 00        1260:                 fcb     0
7784 01        1261: DCB.D2          FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
7785 0000      1262:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
7787 7780      1263:                 FDB     dcbname.D2              ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
7789 77CC      1264:                 FDB     dcb.d3                  ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
778B 7810      1265:                 FDB     DSKDRIVER               ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST




ASM/6800 1.4A0: 778B                    
08/16/82 00:00:00; Page 25; Form 1      
IOSWTPC6800.ASM
               1266: 
               1267:                                                                 ; DISK GEOMETRY
778D 0080      1268:                 FDB     128                     ; DSKINFO:NBPS  ; NUMBER OF BYTES PER SECTOR
778F 0012      1269:                 FDB     18                      ; DSKINFO:NSPT  ; NUMBER OF SECTORS PER TRACK
7791 0002      1270:                 FDB     2                       ; DSKINFO:NTPC  ; NUMBER OF TRACKS PER CYLINDER
7793 0023      1271:                 FDB     35                      ; DSKINFO:NCYL  ; NUMBER OF CYLINDERS PER DRIVE
               1272: 
               1273:                                                                 ; THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
7795 0001      1274:                 RMB     1                       ; DSKINFO:NSPC   NUMBER OF SECTORS PER CLUSTER
7796 0002      1275:                 RMB     LCN.SIZE                ; DSKINFO:MINALLOC ALLOCATION MINIMUM FOR NEW FILES
7798 0002      1276:                 RMB     LCN.SIZE                ; DSKINFO:MIDALLOC ALLOCATION MIN FOR FILE EXTENSION
779A 0002      1277:                 RMB     2                       ; DSKINFO:MAPALGORITHM CODE TO SELECT LOGICAL TO PHYSICAL SECTO
               1278: 
               1279:                                                                 ; CONTAINS DISK ID FOR MOUNTED DISKS
779C 0001      1280:                 RMB     1                       ; DSKINFO:LOG2NBPS LOG BASE 2 OF DSKINFO:NBPS
779D 0002      1281:                 RMB     2                       ; DSKINFO:NBPSM1 = NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
779F 0003      1282:                 RMB     LSN.SIZE                ; DSKINFO:NLSN   NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
77A2 0002      1283:                 RMB     LCN.SIZE                ; DSKINFO:NLCN   NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
77A4 0002      1284:                 RMB     2                       ; DSKINFO:NBPC   NUMBER OF BYTES PER CLUSTER
77A6 0002      1285:                 RMB     LCN.SIZE                ; DSKINFO:RANDMAP "RANDOM" LCN TO DISTRIBUTE NEW FILES
77A8 0003      1286:                 RMB     LSN.SIZE                ; DSKINFO:MAPLSN LSN OF 1ST SECTOR IN DISK...
               1287: 
               1288:                                                                 ; ALLOCATION MAP CLUSTER
77AB 0002      1289:                 RMB     2                       ; DSKINFO:DIRFCB POINTER TO FCB FOR $DIRECTORY FILE
77AD 0002      1290:                 RMB     2                       ; DSKINFO:MAPFCB POINTER TO FCB FOR $DISKMAP FILE
77AF 0002      1291:                 RMB     2                       ; DSKINFO:SECTORDB POINTER TO RDSI CONTAINING LSN, ADDRESS PARA
77B1 0003      1292:                 RMB     LSN.SIZE                ; DSKINFO:BADLSN LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SE
77B4 0000      1293:                 FDB     0                       ; DSKINFO:SEEKERRCNT # SEEK ERRORS SINCE MOUNT
77B6 0000      1294:                 FDB     0                       ; DSKINFO:SEEKERRSTS 16 BITS OF LAST "SEEK" STATUS IN ERROR
77B8 0000      1295:                 FDB     0                       ; DSKINFO:WRITEERRCNT # WRITE ERRORS SINCE MOUNT
77BA 0000      1296:                 FDB     0                       ; DSKINFO:WRITEERRSTS 16 BITS OF LAST "WRITE" STATUS IN ERROR
77BC 0000      1297:                 FDB     0                       ; DSKINFO:READERRCNT # READ ERRORS SINCE MOUNT
77BE 0000      1298:                 FDB     0                       ; DSKINFO:READERRSTS 16 BITS OF LAST "READ" STATUS IN ERROR
77C0 000000    1299:                 FCB     0,0,0                   ; DSKINFO:OPSCOUNT 24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
77C3 0003      1300:                 RMB     LSN.SIZE                ; DSKINFO:ERRLSN LSN CAUSING ANY SOFT OR HARD ERROR
77C6 0001      1301:                 RMB     1                       ; DSKINFO:WRITEPROTSTATE 0 --> WRITEABLE
77C7 02        1302:                 FCB     2                       ; FDUNIT         Drive number 
               1303: 
               1304: 
77C8 44333A    1305: dcbname.D3      fcc     'D3:'
77CB 00        1306:                 fcb     0
77CC 01        1307: DCB.D3          FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
77CD 0000      1308:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
77CF 77C8      1309:                 FDB     dcbname.D3              ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
77D1 7A24      1310:                 FDB     DCB.HD                  ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
77D3 7810      1311:                 FDB     DSKDRIVER               ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
               1312: 
               1313:                                                                 ; DISK GEOMETRY
77D5 0080      1314:                 FDB     128                     ; DSKINFO:NBPS  ; NUMBER OF BYTES PER SECTOR
77D7 0012      1315:                 FDB     18                      ; DSKINFO:NSPT  ; NUMBER OF SECTORS PER TRACK
77D9 0002      1316:                 FDB     2                       ; DSKINFO:NTPC  ; NUMBER OF TRACKS PER CYLINDER
77DB 0023      1317:                 FDB     35                      ; DSKINFO:NCYL  ; NUMBER OF CYLINDERS PER DRIVE
               1318: 
               1319:                                                                 ; THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
77DD 0001      1320:                 RMB     1                       ; DSKINFO:NSPC   NUMBER OF SECTORS PER CLUSTER




ASM/6800 1.4A0: 77DE                    
08/16/82 00:00:00; Page 26; Form 1      
IOSWTPC6800.ASM
77DE 0002      1321:                 RMB     LCN.SIZE                ; DSKINFO:MINALLOC ALLOCATION MINIMUM FOR NEW FILES
77E0 0002      1322:                 RMB     LCN.SIZE                ; DSKINFO:MIDALLOC ALLOCATION MIN FOR FILE EXTENSION
77E2 0002      1323:                 RMB     2                       ; DSKINFO:MAPALGORITHM CODE TO SELECT LOGICAL TO PHYSICAL SECTO
               1324: 
               1325:                                                                 ; CONTAINS DISK ID FOR MOUNTED DISKS
77E4 0001      1326:                 RMB     1                       ; DSKINFO:LOG2NBPS LOG BASE 2 OF DSKINFO:NBPS
77E5 0002      1327:                 RMB     2                       ; DSKINFO:NBPSM1 = NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
77E7 0003      1328:                 RMB     LSN.SIZE                ; DSKINFO:NLSN   NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
77EA 0002      1329:                 RMB     LCN.SIZE                ; DSKINFO:NLCN   NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
77EC 0002      1330:                 RMB     2                       ; DSKINFO:NBPC   NUMBER OF BYTES PER CLUSTER
77EE 0002      1331:                 RMB     LCN.SIZE                ; DSKINFO:RANDMAP "RANDOM" LCN TO DISTRIBUTE NEW FILES
77F0 0003      1332:                 RMB     LSN.SIZE                ; DSKINFO:MAPLSN LSN OF 1ST SECTOR IN DISK...
               1333: 
               1334:                                                                 ; ALLOCATION MAP CLUSTER
77F3 0002      1335:                 RMB     2                       ; DSKINFO:DIRFCB POINTER TO FCB FOR $DIRECTORY FILE
77F5 0002      1336:                 RMB     2                       ; DSKINFO:MAPFCB POINTER TO FCB FOR $DISKMAP FILE
77F7 0002      1337:                 RMB     2                       ; DSKINFO:SECTORDB POINTER TO RDSI CONTAINING LSN, ADDRESS PARA
77F9 0003      1338:                 RMB     LSN.SIZE                ; DSKINFO:BADLSN LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SE
77FC 0000      1339:                 FDB     0                       ; DSKINFO:SEEKERRCNT # SEEK ERRORS SINCE MOUNT
77FE 0000      1340:                 FDB     0                       ; DSKINFO:SEEKERRSTS 16 BITS OF LAST "SEEK" STATUS IN ERROR
7800 0000      1341:                 FDB     0                       ; DSKINFO:WRITEERRCNT # WRITE ERRORS SINCE MOUNT
7802 0000      1342:                 FDB     0                       ; DSKINFO:WRITEERRSTS 16 BITS OF LAST "WRITE" STATUS IN ERROR
7804 0000      1343:                 FDB     0                       ; DSKINFO:READERRCNT # READ ERRORS SINCE MOUNT
7806 0000      1344:                 FDB     0                       ; DSKINFO:READERRSTS 16 BITS OF LAST "READ" STATUS IN ERROR
7808 000000    1345:                 FCB     0,0,0                   ; DSKINFO:OPSCOUNT 24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
780B 0003      1346:                 RMB     LSN.SIZE                ; DSKINFO:ERRLSN LSN CAUSING ANY SOFT OR HARD ERROR
780E 0001      1347:                 RMB     1                       ; DSKINFO:WRITEPROTSTATE 0 --> WRITEABLE
780F 03        1348:                 FCB     3                       ; FDUNIT         Drive number 
               1349: 
               1350:                 
               1351: ; DEVICE DRIVER BLOCK FOR FLOPPY DISK
               1352: 
7810 7908      1353: DSKDRIVER       FDB     DSKRESTORE              ; DRIVER:DISKRESET RESET THIS DISK DRIVER
7812 78C6      1354:                 FDB     DSKREAD                 ; DRIVER:DISKREAD INITIATE A DISK SECTOR READ
7814 78D3      1355:                 FDB     DSKWRITE                ; DRIVER:DISKWRITE INITIATE A DISK SECTOR WRITE
7816 7908      1356:                 FDB     DSKWAITDONE             ; DRIVER:DISKWAIT WAIT FOR DISK I/O COMPLETE
7818 70B8      1357:                 FDB     ILLDEVICEOP             ; DRIVER:DISKSTATUS STATUS handled completely by SDOS1.1
781A 7822      1358:                 FDB     DSKCONTROL              ; DRIVER:DISKCONTROL PERFORM DISK-SPECIFIC CONTROL OPERATION
781C 70B8      1359:                 FDB     ILLDEVICEOP             ; DRIVER:DISKWRITEPROTQ DETERMINE IF DISK IS WRITE PROTECTED
781E 70B8      1360:                 FDB     ILLDEVICEOP             ; DRIVER:DISKVERIFY INITIATE A DISK SECTOR VERIFY
7820 70B8      1361:                 FDB     ILLDEVICEOP             ; DRIVER:DISKLSNTOPSN CONVERT LSN TO PHYSICAL CYLINDER, TRACK A
               1362: 
               1363: ; FLOPPY DISK LOW LEVEL I/O
               1364: 
7822 8111      1365: DSKCONTROL      CMPA    #CC.DISMOUNTDISK        ; SINCE SDOS PASSES THIS THRU
7824 2703      1366:                 BEQ     DSKDISMOUNT             ; B/ ITS A DISMOUNT!
7826 7E70B8    1367:                 JMP     ILLDEVICEOP             ; NOT A LEGAL CONTROL CALL
7829 5F        1368: DSKDISMOUNT     CLRB                            ; CLEAR THE CARRY
782A 39        1369:                 RTS
               1370:                 
               1371: ;
               1372: ;       Take RDSI:LSN and split it up into RDSI:CYLINDER,
               1373: ;       RDSI:TRACK, and RDSI:SECTOR, 
               1374: ;       mapalg NOT IMPLEMENTED 
               1375: ;




ASM/6800 1.4A0: 782B                    
08/16/82 00:00:00; Page 27; Form 1      
IOSWTPC6800.ASM
782B FE790A    1376: FDTEARLSN       LDX     RDSIPOINTER
782E 6F0E      1377:                 CLR     RDSI.SECTOR,X           ; CLEAR MSB OF SECTOR, TRACK AND CYL
7830 6F10      1378:                 CLR     RDSI.TRACK,X
7832 6F11      1379:                 CLR     RDSI.TRACK+1,X
7834 6F12      1380:                 CLR     RDSI.CYLINDER,X
               1381: 
               1382: ;        ASSERT RDSI:LSN ALREADY CHECKED FOR LEGAL BY SDOS
               1383: ; 
               1384: ;        The formulae for computing the DCB parameters as a function
               1385: ;        of number of sides, single density (SD) or double density (DD)
               1386: ;        first track, SD or DD on other than first track, and number of
               1387: ;        tracks on the drive are:
               1388: ; 
               1389: ;                SS/SD   NBPS = 128 bytes per sector
               1390: ;                        NSPT = 18  sectors per track
               1391: ;                        NTPC = 1 (See note 1) tracks per cylinder
               1392: ;                        NCYL = #sides * #tracks (See note 2)
               1393: ; 
               1394: ;                note 1: This is a lie to SDOS in the case of a double
               1395: ;                        sided disk, but it makes the NLSN (NSPT*NTPC*NCYL)
               1396: ;                        work out to be correct.
               1397: ;                note 2: #tracks is the number of tracks on the disk, including
               1398: ;                        double tracks on a double track disk.
               1399: ; 
               1400: ;      +-------------------------------------------+
               1401: ;      |        5" DRIVE       |   SINGLE SIDED    |
               1402: ;      | # TRACKS ON DRIVE --> | 35   40   70   80 |
               1403: ;      |         NSPT NBPS NTPC|NCYL NCYL NCYL NCYL|
               1404: ;      |-----------------------+-------------------+
               1405: ;      |   SS/SD  18   128    1| 35   40   70   80 |
               1406: ;      |   DS/SD              2|                   |
               1407: ;      +-------------------------------------------+
               1408: ; 
               1409: ;       To compute the sector, track and cylinder, use this formula:
               1410: ;                LSN/18 --> REM --> SECTOR#
               1411: ;                       --> /2  --> REM -> TRACK (HEAD)
               1412: ;                               --> CYLINDER
               1413: ;       where REM is the remainder from the previous step. 
               1414: 
7836 A603      1415:                 LDAA    RDSI.LSN+1,X            ; SO DISCARD HIGHER LSN BYTE
7838 E604      1416:                 LDAB    RDSI.LSN+2,X            
783A 01        1417:                 NOP                             ; .*echo Read_LSN:D
783B BD7847    1418:                 JSR     DIV18                   ; GO DO THE FAST DIVIDE BY NSPT
783E 4C        1419:                 INCA                            ; SECTORS ON PHYSICAL DISK ARE NUMBERED 1..18
783F A70F      1420:                 STAA    RDSI.SECTOR+1,X         ; A CONTAINS SECTOR = (LSN MOD 18)+1
7841 54        1421:                 LSRB                            ; B CONTAINS CYL = INT(LSN/18) / 2, bit0 -> carry
7842 E713      1422:                 STAB    RDSI.CYLINDER+1,X       
7844 6911      1423:                 ROL     RDSI.TRACK+1,X          ; TRACK (HEAD) = INT(LSN/18) MOD 2, head<-carry 0/1
7846 39        1424:                 RTS
               1425: ;
               1426: ;       Fancy divide algorithm takes (A,B) and divides by NSPT (18).
               1427: ;       If we have 35 track, double side,
               1428: ;       18 sectors/track this is 35*2*18 LSNs =0..1259, with a max
               1429: ;       quotient of 69.
               1430: ;




ASM/6800 1.4A0: 7846                    
08/16/82 00:00:00; Page 28; Form 1      
IOSWTPC6800.ASM
               1431: ;       Divide (A,B) by 18 (NSPT), quotient in B, remainder in A
               1432: ;
7847 58        1433: DIV18           ASLB
7848 49        1434:                 ROLA
7849 8BEE      1435:                 ADDA    #-18                    ; ADD -NSPT TO GENERATE QUOTIENT BIT
784B 2502      1436:                 BCS     DIV18.1                 ; B/ Q BIT IS ONE
784D 80EE      1437:                 SUBA    #-18                    ; RESTORE BY ADDING DIVISOR; LEAVE CARRY=0
784F 59        1438: DIV18.1         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
7850 49        1439:                 ROLA
7851 8BEE      1440:                 ADDA    #-18
7853 2502      1441:                 BCS     DIV18.2
7855 80EE      1442:                 SUBA    #-18
7857 59        1443: DIV18.2         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
7858 49        1444:                 ROLA
7859 8BEE      1445:                 ADDA    #-18
785B 2502      1446:                 BCS     DIV18.3
785D 80EE      1447:                 SUBA    #-18
785F 59        1448: DIV18.3         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
7860 49        1449:                 ROLA
7861 8BEE      1450:                 ADDA    #-18
7863 2502      1451:                 BCS     DIV18.4
7865 80EE      1452:                 SUBA    #-18
7867 59        1453: DIV18.4         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
7868 49        1454:                 ROLA
7869 8BEE      1455:                 ADDA    #-18
786B 2502      1456:                 BCS     DIV18.5
786D 80EE      1457:                 SUBA    #-18
786F 59        1458: DIV18.5         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
7870 49        1459:                 ROLA
7871 8BEE      1460:                 ADDA    #-18
7873 2502      1461:                 BCS     DIV18.6
7875 80EE      1462:                 SUBA    #-18
7877 59        1463: DIV18.6         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
7878 49        1464:                 ROLA
7879 8BEE      1465:                 ADDA    #-18
787B 2502      1466:                 BCS     DIV18.7
787D 80EE      1467:                 SUBA    #-18
787F 59        1468: DIV18.7         ROLB                            ; SHIFT QUOTIENT BIT INTO QUOTIENT
7880 49        1469:                 ROLA
7881 8BEE      1470:                 ADDA    #-18
7883 2502      1471:                 BCS     DIV18.8
7885 80EE      1472:                 SUBA    #-18
7887 59        1473: DIV18.8         ROLB
7888 39        1474:                 RTS
               1475: 
7889 6C3E      1476: DSKOPSCOUNT     INC     DSKINFO.OPSCOUNT+2,X    ; COUNT # OPERATIONS ISSUED TO disk
788B 2606      1477:                 BNE     DSKOPSCOUNT1
788D 6C3D      1478:                 INC     DSKINFO.OPSCOUNT+1,X
788F 2602      1479:                 BNE     DSKOPSCOUNT1
7891 6C3C      1480:                 INC     DSKINFO.OPSCOUNT,X
7893 39        1481: DSKOPSCOUNT1    rts
               1482: 
               1483: ; PREPARE A SINGLE SECTOR TRANSFER
               1484: 
7894 DE06      1485: DSKPREP         LDX     DCBPOINTER              ; GET DCB POINTER




ASM/6800 1.4A0: 7896                    
08/16/82 00:00:00; Page 29; Form 1      
IOSWTPC6800.ASM
7896 BD7889    1486:                 jsr     DSKOPSCOUNT             ; incr count of I/O operations done
7899 A643      1487:                 LDAA    dcb.fdunit,X            ; get this dcb drive number
789B B7790C    1488:                 STAA    DRV
789E 6F01      1489:                 CLR     DCB.LASTERROR,X         ; CLEAR ANY ERROR
78A0 6F02      1490:                 CLR     DCB.LASTERROR+1,X
78A2 EE2B      1491:                 LDX     DSKINFO.SECTORDB,X      ; GET RDSI POINTER
78A4 FF790A    1492:                 STX     RDSIPOINTER             ; SAVE IT
78A7 BD782B    1493:                 JSR     FDTEARLSN               ; CONVERT RDSI:LSR -> RDSI:TRACK/CYLINDER/SECTOR
78AA A605      1494:                 LDAA    RDSI.SECTORBASE,X       ; POINTER TO ACTUAL SECTOR CONTENTS
78AC E606      1495:                 LDAB    RDSI.SECTORBASE+1,X
78AE B77910    1496:                 STAA    DDATA
78B1 F77911    1497:                 STAB    DDATA+1
78B4 A613      1498:                 LDAA    RDSI.CYLINDER+1,X       
78B6 B7790D    1499:                 STAA    TRK
78B9 A60F      1500:                 LDAA    RDSI.SECTOR+1,X 
78BB B7790E    1501:                 STAA    SECT
78BE A611      1502:                 LDAA    RDSI.TRACK+1,X  
78C0 B7790F    1503:                 STAA    SIDE
78C3 6F0C      1504:                 CLR     RDSI.STATE,X            ; RESET SECTOR STATE TO "IDLE"
78C5 39        1505:                 RTS
               1506:                 
               1507: ; READ/WRITE -- DO SINGLE SECTOR TRANSFER
               1508: 
78C6 BD7894    1509: DSKREAD         JSR     DSKPREP
78C9 BD792B    1510:                 JSR     RDSEC                   ; DO I/O OPERATION WITH ACTIVE WAIT: NO INTERRUPTS :-(
78CC 2612      1511:                 BNE     DSKERR
78CE FE7910    1512:                 LDX     DDATA                   
78D1 0C        1513:                 CLC                             ; .*mX-80:RdSec
78D2 39        1514:                 RTS
               1515: 
78D3 BD7894    1516: DSKWRITE        JSR     DSKPREP
78D6 BD793A    1517:                 JSR     WRSEC                   ; DO I/O OPERATION WITH ACTIVE WAIT: NO INTERRUPTS :-(
78D9 2605      1518:                 BNE     DSKERR
78DB FE7910    1519:                 LDX     DDATA                   
78DE 0C        1520:                 CLC                             ; .*mX-80:WrSec
78DF 39        1521:                 RTS
               1522:                 
78E0 CE0417    1523: DSKERR          LDX     #ERR.DISKSEEK
78E3 8510      1524:                 BITA    #$10
78E5 2611      1525:                 bne     dskerr1                 ; seek error reported by controler status reg
78E7 CE0416    1526:                 LDX     #ERR.DISKWRITE
78EA 8520      1527:                 BITA    #$20                    
78EC 260A      1528:                 bne     dskerr1                 ; WRITE FAULT reported by controler status reg
78EE CE0418    1529:                 LDX     #ERR.DSKWRTPROT
78F1 8540      1530:                 BITA    #$40                    
78F3 2603      1531:                 bne     dskerr1                 ; WRITE PROTECT reported by controler status reg
78F5 CE0415    1532:                 LDX     #ERR.DISKREAD           ; ELSE ASUME LOST DATA OR CRC ERROR HAS BEEN reported by contro
78F8 DF00      1533: DSKERR1         STX     $00                     ; TXAB X=SDOS ERROR CODE (16 BITS) -> (A,B)
78FA 9600      1534:                 LDAA    $00
78FC D601      1535:                 LDAB    $01             
78FE DE06      1536:                 LDX     DCBPOINTER              ; GET DCB POINTER
7900 A701      1537:                 STAA    DCB.LASTERROR,X         ; SAVE THE ERROR
7902 E702      1538:                 STAB    DCB.LASTERROR+1,X
7904 DE00      1539:                 LDX     $00                     ; GET BACK ERROR IN X-REG
7906 0D        1540:                 SEC




ASM/6800 1.4A0: 7907                    
08/16/82 00:00:00; Page 30; Form 1      
IOSWTPC6800.ASM
7907 39        1541:                 RTS     
               1542:         
  7908         1543: DSKRESTORE
  7908         1544: DSKWAITDONE
7908 5F        1545:                 CLRB                           ; CLEAR THE CARRY
7909 39        1546:                 RTS
               1547: 
               1548: 
790A 0002      1549: RDSIPOINTER     RMB     2
               1550: 
               1551: 
               1552: ; DISK DRIVERS FOR SOUTHWEST TECHNICAL PRODUCTS MF-68
               1553: 
               1554: ; INPUT PARAMS
               1555: 
790C 0001      1556: DRV    RMB 1         ; DRIVE TO OPERATE ON
790D 0001      1557: TRK    RMB 1         ; TRACK TO READ/WRITE
790E 0001      1558: SECT   RMB 1         ; SECTOR TO READ/WRITE
790F 0001      1559: SIDE   RMB 1         ; SIDE TO READ/WRITE
7910 0002      1560: DDATA  RMB 2         ; POINTER TO DATA BUFFER (MUST HAVE 128 BYTES)
               1561: 
               1562: ; COMMANDS FOR WD1771 CONTROLLER CHIP
               1563: ;
  000B         1564: FDRSC  EQU $0B       ; RESTORE
  001B         1565: FDSKI  EQU $1B       ; SEEK
  008C         1566: FDRDC  EQU $8C       ; READ A SECTOR
  00AC         1567: FDWRC  EQU $AC       ; WRITE A SECTOR
               1568: 
               1569: ; ADDR OF WD1771 CONTROLLER CHIP REGISTERS 
               1570: 
  0000         1571:         if RAM64K=1
 *S*           1572: 
 *S*           1573: DRVREG set $ff14
 *S*           1574: CMDREG set $ff18
 *S*           1575: TRKREG set $ff19
 *S*           1576: SECREG set $ff1A
 *S*           1577: DATREG set $ff1B
 *S*           1578: 
               1579:         else
               1580:         
  8014         1581: DRVREG EQU $8014
  8018         1582: CMDREG EQU $8018
  8019         1583: TRKREG EQU $8019
  801A         1584: SECREG EQU $801A
  801B         1585: DATREG EQU $801B
               1586: 
               1587:         fin
               1588: 
               1589: ; DRIVER VARS
               1590: 
7912 FF        1591: CURDRV FCB $FF       ; PRESENTLY SELECTED DRIVE #
7913 0004      1592: CTRK0  RMB 4         ; TRACK STATE TABLE
7917 0001      1593: RCNT   RMB 1         ; RETRY COUNT
7918 0001      1594: SIDEBT RMB 1         ; SIDE SELECTION BIT
               1595: 




ASM/6800 1.4A0: 7918                    
08/16/82 00:00:00; Page 31; Form 1      
IOSWTPC6800.ASM
               1596: ; INIT THE DISK SYSTEM
               1597: 
7919 7F7912    1598: INTDK  CLR CURDRV    ; ASSUME DRIVE 0 BOOTED
791C 86FF      1599:        LDAA #$FF
791E B77913    1600:        STAA CTRK0       
7921 B77914    1601:        STAA CTRK0+1
7924 B77915    1602:        STAA CTRK0+2       
7927 B77916    1603:        STAA CTRK0+3
792A 39        1604: DUMMY  RTS       
               1605: 
               1606: ; READ A SECTOR
               1607: ;
792B BD79F7    1608: RDSEC  JSR SELDRV 
792E BD7949    1609: RDSEC1 JSR READ       ; GETA SECTOR
7931 2715      1610:        BEQ QUIT10     ; OK
7933 7A7917    1611:        DEC RCNT       ; RETRY AGAIN?
7936 26F6      1612:        BNE RDSEC1     ; YES
7938 200D      1613:        BRA QERR
               1614: 
               1615: ; WRITE A SECTOR
               1616: ;
793A BD79F7    1617: WRSEC  JSR SELDRV 
793D BD797F    1618: WTSEC1 JSR WRITE
7940 2706      1619:        BEQ QUIT10     ; OK
7942 7A7917    1620:        DEC RCNT       ; TRY AGAIN?
7945 26F6      1621:        BNE WTSEC1     ; YES
7947 4D        1622: QERR   TSTA           ; A HAS THE STATUS BITS WITH ERROR 
7948 39        1623: QUIT10 RTS
               1624: 
               1625: ; READ A SECTOR (A=TRK, B=SECTOR, X=CTRKx)
               1626: ;
7949 BD79AE    1627: READ   JSR SEEK
794C 868C      1628:        LDAA #FDRDC    ; READ
794E BB7918    1629:        ADDA SIDEBT
7951 B78018    1630:        STAA CMDREG     
7954 BD79D7    1631:        JSR DEL56U     ; DELAY
7957 FE7910    1632:        LDX DDATA      ; GET BUFFER ADDRESS
795A C680      1633:        LDAB #128      ; 128 BYTES/SECTOR     
795C B68018    1634: READ1  LDAA CMDREG     
795F 8502      1635:        BITA #$02      ; DATA REG FULL?
7961 2606      1636:        BNE READ2      ; YES
7963 8501      1637:        BITA #1        ; BUSY?
7965 26F5      1638:        BNE READ1      ; YES
7967 200B      1639:        BRA READ3      ; ERROR
7969 B6801B    1640: READ2  LDAA DATREG    ; GET A BYTE
796C A700      1641:        STAA 0,X       ; STORE IN BUFFER
796E 08        1642:        INX             
796F 5A        1643:        DECB            
7970 26EA      1644:        BNE READ1      ; DO AGAIN
7972 8D03      1645:        BSR WBUSY      ; WAIT TILL DONE
7974 841C      1646: READ3  ANDA #$1C      ; MASK OF STATUS BITS
7976 39        1647:        RTS             
               1648:                        
7977 B68018    1649: WBUSY  LDAA CMDREG     
797A 8501      1650:        BITA #1        ; BUSY?




ASM/6800 1.4A0: 797C                    
08/16/82 00:00:00; Page 32; Form 1      
IOSWTPC6800.ASM
797C 26F9      1651:        BNE WBUSY      ; YES
797E 39        1652:        RTS
               1653: 
               1654: ; WRITE A SECTOR (A=TRK, B=SECTOR, X=CTRKx)
               1655: 
797F BD79AE    1656: WRITE  JSR SEEK
7982 86AC      1657:        LDAA #FDWRC    ; WRITE COMMAND
7984 BB7918    1658:        ADDA SIDEBT
7987 B78018    1659:        STAA CMDREG     
798A BD79D7    1660:        JSR DEL56U      
798D FE7910    1661:        LDX DDATA      ; GET BUFFER ADDRESS
7990 C680      1662:        LDAB #128      ; 128 BYTES/SECTOR
7992 B68018    1663: WRITE1 LDAA CMDREG     
7995 8502      1664:        BITA #2        ; REG EMPTY?
7997 2606      1665:        BNE WRITE2     ; YES
7999 8501      1666:        BITA #1        ; BUSY?
799B 26F5      1667:        BNE WRITE1     ; YES
799D 20A8      1668:        BRA QERR       ; ERROR
799F A600      1669: WRITE2 LDAA 0,X       ; GET A BYTE
79A1 B7801B    1670:        STAA DATREG     
79A4 08        1671:        INX             
79A5 5A        1672:        DECB            
79A6 26EA      1673:        BNE WRITE1     ; DO AGAIN
79A8 BD7977    1674:        JSR WBUSY      ; WAIT FOR BUSY
79AB 847C      1675: WRITE3 ANDA #$7C      ; MASK OFF STATUS BITS
79AD 39        1676:        RTS
               1677: 
               1678: ; SEEK A=TRACK, B=SECTOR, X=CTRKx
               1679: 
79AE B18019    1680: SEEK   CMPA TRKREG    ; ON TRACK?
79B1 2713      1681:        BEQ SEEK2      ; YES
79B3 B7801B    1682:        STAA DATREG    ; NO, STORE TRACK#
79B6 BD79D7    1683:        JSR DEL56U      
79B9 A700      1684:        STAA 0,X       ; SAVE CURRENT TRACK OF DRIVE
79BB 861B      1685:        LDAA #FDSKI    ; SEEK COMMAND
79BD B78018    1686:        STAA CMDREG     
79C0 BD79D7    1687:        JSR DEL56U      
79C3 BD7977    1688:        JSR WBUSY      ; WAIT FOR BUSY
79C6 F7801A    1689: SEEK2  STAB SECREG    ; SET SECTOR
79C9 BD79D7    1690:        JSR DEL56U
79CC B6790F    1691:        LDAA SIDE
79CF 2702      1692:        BEQ SEEK3
79D1 8608      1693:        LDAA #$08      ; SELECT SIDE 1
79D3 B77918    1694: SEEK3  STAA SIDEBT       
79D6 39        1695:        RTS
               1696: 
               1697: ; DEL56U- DELAY 56us INCLUDING THE CALL TO DELAY56U
               1698: 
79D7 BD79DA    1699: DEL56U JSR DELAY2
79DA BD79DD    1700: DELAY2 JSR DELAY3
79DD 39        1701: DELAY3 RTS
               1702: 
               1703: ; FIND TRACK- RETURN X->TRACK TABLE FOR CURDRV
               1704: 
79DE CE7913    1705: FNDTRK LDX #CTRK0     ; POINT TO TABLE




ASM/6800 1.4A0: 79E1                    
08/16/82 00:00:00; Page 33; Form 1      
IOSWTPC6800.ASM
79E1 B67912    1706:        LDAA CURDRV
79E4 2704      1707:        BEQ FNDTK3
79E6 08        1708: FNDTK2 INX
79E7 4A        1709:        DECA
79E8 26FC      1710:        BNE FNDTK2
79EA 39        1711: FNDTK3 RTS
               1712: 
               1713: ; RESTORE SEEK TRACK0
               1714: 
79EB 860B      1715: RESTOR LDAA #FDRSC    ; RESTORE COMMAND
79ED B78018    1716:        STAA CMDREG
79F0 BD79D7    1717:        JSR DEL56U
79F3 BD7977    1718:        JSR WBUSY
79F6 39        1719:        RTS
               1720: 
               1721: ; SELECT THE DRIVE
               1722: ; RETURN A=TRACK, B=SECTOR, X=CTRKx
               1723: 
79F7 8DE5      1724: SELDRV BSR FNDTRK     ; SAVE TRACK FOR CURRENT DRIVE
79F9 B68019    1725:        LDAA TRKREG     
79FC A700      1726:        STAA 0,X        
79FE B6790C    1727:        LDAA DRV       ; GET DRIVE 
7A01 B77912    1728:        STAA CURDRV     
7A04 B78014    1729:        STAA DRVREG    ; SELECT THE DRIVE
7A07 8DD5      1730:        BSR FNDTRK     ; LOAD TRACK FOR NEW DRIVE
7A09 A600      1731:        LDAA 0,X       ; A=CURRENT DRIVE TRACK
7A0B B78019    1732:        STAA TRKREG     
7A0E 81FF      1733:        CMPA #$FF      ; INITIALIZED?
7A10 2602      1734:        BNE SELD1      ; YES
7A12 8DD7      1735:        BSR RESTOR     ; SEEK TRACK0
7A14 8605      1736: SELD1  LDAA #5        ; SET RETRY COUNT
7A16 B77917    1737:        STAA RCNT       
7A19 B6790D    1738:        LDAA TRK       ; GET TRACK#        
7A1C F6790E    1739:        LDAB SECT      ; GET SECTOR#
7A1F 39        1740:        RTS            
               1741: 
               1742: 
               1743: ; High level EMULATOR (HLE) for swtpc 6800 harddisk with
               1744: ; XIBEX S1410 Winchester Disk Controller and
               1745: ; TANDOM TM-602S 5MB DRIVE
               1746: 
               1747: 
7A20 48443A    1748: dcbname.hd      fcc     'HD:'
7A23 00        1749:                 fcb     0
7A24 01        1750: DCB.HD          FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
7A25 0000      1751:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
7A27 7A20      1752:                 FDB     dcbname.HD              ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
7A29 0000      1753:                 FDB     0                       ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
7A2B 7A68      1754:                 FDB     HDDRIVER                ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
               1755: 
               1756:                                                                 ; DISK GEOMETRY
7A2D 0080      1757:                 FDB     128                     ; DSKINFO:NBPS  ; NUMBER OF BYTES PER SECTOR
7A2F 0040      1758:                 FDB     64                      ; DSKINFO:NSPT  ; NUMBER OF SECTORS PER TRACK
7A31 0004      1759:                 FDB     4                       ; DSKINFO:NTPC  ; NUMBER OF TRACKS PER CYLINDER (=surfaces)
7A33 0099      1760:                 FDB     153                     ; DSKINFO:NCYL  ; NUMBER OF CYLINDERS PER DRIVE




ASM/6800 1.4A0: 7A33                    
08/16/82 00:00:00; Page 34; Form 1      
IOSWTPC6800.ASM
               1761: 
               1762:                                                                 ; THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
7A35 0001      1763:                 RMB     1                       ; DSKINFO:NSPC   NUMBER OF SECTORS PER CLUSTER
7A36 0002      1764:                 RMB     LCN.SIZE                ; DSKINFO:MINALLOC ALLOCATION MINIMUM FOR NEW FILES
7A38 0002      1765:                 RMB     LCN.SIZE                ; DSKINFO:MIDALLOC ALLOCATION MIN FOR FILE EXTENSION
7A3A 0002      1766:                 RMB     2                       ; DSKINFO:MAPALGORITHM CODE TO SELECT LOGICAL TO PHYSICAL SECTO
               1767: 
               1768:                                                                 ; CONTAINS DISK ID FOR MOUNTED DISKS
7A3C 0001      1769:                 RMB     1                       ; DSKINFO:LOG2NBPS LOG BASE 2 OF DSKINFO:NBPS
7A3D 0002      1770:                 RMB     2                       ; DSKINFO:NBPSM1 = NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
7A3F 0003      1771:                 RMB     LSN.SIZE                ; DSKINFO:NLSN   NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
7A42 0002      1772:                 RMB     LCN.SIZE                ; DSKINFO:NLCN   NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
7A44 0002      1773:                 RMB     2                       ; DSKINFO:NBPC   NUMBER OF BYTES PER CLUSTER
7A46 0002      1774:                 RMB     LCN.SIZE                ; DSKINFO:RANDMAP "RANDOM" LCN TO DISTRIBUTE NEW FILES
7A48 0003      1775:                 RMB     LSN.SIZE                ; DSKINFO:MAPLSN LSN OF 1ST SECTOR IN DISK...
               1776: 
               1777:                                                                 ; ALLOCATION MAP CLUSTER
7A4B 0002      1778:                 RMB     2                       ; DSKINFO:DIRFCB POINTER TO FCB FOR $DIRECTORY FILE
7A4D 0002      1779:                 RMB     2                       ; DSKINFO:MAPFCB POINTER TO FCB FOR $DISKMAP FILE
7A4F 0002      1780:                 RMB     2                       ; DSKINFO:SECTORDB POINTER TO RDSI CONTAINING LSN, ADDRESS PARA
7A51 0003      1781:                 RMB     LSN.SIZE                ; DSKINFO:BADLSN LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SE
7A54 0000      1782:                 FDB     0                       ; DSKINFO:SEEKERRCNT # SEEK ERRORS SINCE MOUNT
7A56 0000      1783:                 FDB     0                       ; DSKINFO:SEEKERRSTS 16 BITS OF LAST "SEEK" STATUS IN ERROR
7A58 0000      1784:                 FDB     0                       ; DSKINFO:WRITEERRCNT # WRITE ERRORS SINCE MOUNT
7A5A 0000      1785:                 FDB     0                       ; DSKINFO:WRITEERRSTS 16 BITS OF LAST "WRITE" STATUS IN ERROR
7A5C 0000      1786:                 FDB     0                       ; DSKINFO:READERRCNT # READ ERRORS SINCE MOUNT
7A5E 0000      1787:                 FDB     0                       ; DSKINFO:READERRSTS 16 BITS OF LAST "READ" STATUS IN ERROR
7A60 000000    1788:                 FCB     0,0,0                   ; DSKINFO:OPSCOUNT 24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
7A63 0003      1789:                 RMB     LSN.SIZE                ; DSKINFO:ERRLSN LSN CAUSING ANY SOFT OR HARD ERROR
7A66 0001      1790:                 RMB     1                       ; DSKINFO:WRITEPROTSTATE 0 --> WRITEABLE
7A67 00        1791:                 FCB     0                       ; FDUNIT         Drive number 
               1792: 
               1793: 
               1794: ; DEVICE DRIVER BLOCK FOR HARD DISK
               1795: 
7A68 7908      1796: HDDRIVER        FDB     DSKRESTORE              ; DRIVER:DISKRESET RESET THIS DISK DRIVER
7A6A 7B08      1797:                 FDB     HDREAD                  ; DRIVER:DISKREAD INITIATE A DISK SECTOR READ
7A6C 7B22      1798:                 FDB     HDWRITE                 ; DRIVER:DISKWRITE INITIATE A DISK SECTOR WRITE
7A6E 7908      1799:                 FDB     DSKWAITDONE             ; DRIVER:DISKWAIT WAIT FOR DISK I/O COMPLETE
7A70 70B8      1800:                 FDB     ILLDEVICEOP             ; DRIVER:DISKSTATUS STATUS handled completely by SDOS1.1
7A72 7822      1801:                 FDB     DSKCONTROL              ; DRIVER:DISKCONTROL PERFORM DISK-SPECIFIC CONTROL OPERATION
7A74 70B8      1802:                 FDB     ILLDEVICEOP             ; DRIVER:DISKWRITEPROTQ DETERMINE IF DISK IS WRITE PROTECTED
7A76 70B8      1803:                 FDB     ILLDEVICEOP             ; DRIVER:DISKVERIFY INITIATE A DISK SECTOR VERIFY
7A78 70B8      1804:                 FDB     ILLDEVICEOP             ; DRIVER:DISKLSNTOPSN CONVERT LSN TO PHYSICAL CYLINDER, TRACK A
               1805: 
  0001         1806: HDCMD.HEARTBEAT EQU     $01
  0002         1807: HDCMD.SELDRV    EQU     $02
  0003         1808: HDCMD.SETSECT   EQU     $03
  0004         1809: HDCMD.SETSURF   EQU     $04
  0005         1810: HDCMD.SETTRACK  EQU     $05
  0006         1811: HDCMD.SETADDRH  EQU     $06
  0007         1812: HDCMD.SETADDRL  EQU     $07
  0008         1813: HDCMD.READ      EQU     $08
  0009         1814: HDCMD.WRITE     EQU     $09
               1815: 




ASM/6800 1.4A0: 7A78                    
08/16/82 00:00:00; Page 35; Form 1      
IOSWTPC6800.ASM
               1816: 
  0000         1817:                 if ram64k=1
 *S*           1818: 
 *S*           1819: HDCMD           EQU     $FF10   ; PORTS FOR HARD DISK HIGH LEVEL EMULATOR INTERFACE
 *S*           1820: HDDATA          EQU     $FF11           
 *S*           1821: 
               1822:                 else
               1823: 
  8010         1824: HDCMD           EQU     $8010   ; PORTS FOR HARD DISK HIGH LEVEL EMULATOR INTERFACE
  8011         1825: HDDATA          EQU     $8011           
               1826: 
               1827:                 fin
               1828: 
               1829: 
7A7A 8655      1830: HDPREP          LDAA    #$55                    ; TEST IF HD HLE CONTROLER IS RESPONDING
7A7C B78011    1831:                 STAA    HDDATA
7A7F 8601      1832:                 LDAA    #HDCMD.HEARTBEAT        
7A81 B78010    1833:                 STAA    HDCMD
7A84 B68011    1834:                 LDAA    HDDATA
7A87 8167      1835:                 CMPa    #$67                    ; SHOULD GET THIS REPLY 
7A89 2705      1836:                 BEQ     HDHLEOK
7A8B CE0424    1837:                 LDX     #ERR.DEVICENOTREADY     ; WE ARE RUNNING WITH HD DISABLED OR IN ANOTHER SIMULATOR 
7A8E 0D        1838:                 SEC                             ; WITHOUT HLE HARD DRIVE EMULATOR, OR EVEN IN REAL HW!
7A8F 39        1839:                 RTS                             ; IN ANY CASE, THERE IS NO HARD DISK -> SIGNALS DEVICE NOT READ
7A90 DE06      1840: HDHLEOK         LDX     DCBPOINTER              ; GET DCB POINTER
7A92 BD7889    1841:                 jsr     DSKOPSCOUNT             ; incr count of I/O operations done
7A95 A643      1842:                 LDAA    dcb.fdunit,X            ; get this dcb drive number
7A97 C602      1843:                 LDAB    #HDCMD.SELDRV           ; HD COMMAND: SELECT DRIVE
7A99 F78010    1844:                 STAB    HDCMD
7A9C B78011    1845:                 STAA    HDDATA
7A9F 6F01      1846:                 CLR     DCB.LASTERROR,X         ; CLEAR ANY ERROR
7AA1 6F02      1847:                 CLR     DCB.LASTERROR+1,X
7AA3 EE2B      1848:                 LDX     DSKINFO.SECTORDB,X      ; GET RDSI POINTER
7AA5 FF790A    1849:                 STX     RDSIPOINTER             ; SAVE IT
               1850:                                                 ; CONVERT RDSI:LSR -> RDSI:CYLINDER/SECTOR
7AA8 FE790A    1851:                 LDX     RDSIPOINTER
7AAB 6F0E      1852:                 CLR     RDSI.SECTOR,X           ; CLEAR MSB OF SECTOR, TRACK 
7AAD 6F10      1853:                 CLR     RDSI.TRACK,X
7AAF 6F12      1854:                 CLR     RDSI.CYLINDER,X 
               1855: 
7AB1 A603      1856:                 LDAA    RDSI.LSN+1,X            ; DISCARD HIGHER LSN BYTE
7AB3 E604      1857:                 LDAB    RDSI.LSN+2,X            
7AB5 37        1858:                 PSHB
7AB6 C43F      1859:                 ANDB    #63                     ; SECTOR = LSN AND 63
7AB8 E70F      1860:                 STAB    RDSI.SECTOR+1,X         ; B CONTAINS SECTOR = 0..63
7ABA F78011    1861:                 STAB    HDDATA
7ABD C603      1862:                 LDAB    #HDCMD.SETSECT          ; HD COMMAND: SET SECTOR
7ABF F78010    1863:                 STAB    HDCMD
7AC2 33        1864:                 PULB
7AC3 44        1865:                 LSRA                            ; LSN = LSN DIV 64
7AC4 56        1866:                 RORB
7AC5 44        1867:                 LSRA                            
7AC6 56        1868:                 RORB
7AC7 44        1869:                 LSRA                            
7AC8 56        1870:                 RORB




ASM/6800 1.4A0: 7AC9                    
08/16/82 00:00:00; Page 36; Form 1      
IOSWTPC6800.ASM
7AC9 44        1871:                 LSRA                            
7ACA 56        1872:                 RORB
7ACB 44        1873:                 LSRA                            
7ACC 56        1874:                 RORB
7ACD 44        1875:                 LSRA                            
7ACE 56        1876:                 RORB
7ACF 37        1877:                 PSHB
7AD0 C403      1878:                 ANDB    #3                      ; SURFACE = LSN AND 3
7AD2 E711      1879:                 STAB    RDSI.TRACK+1,X          ; B CONTAINS SURFACE = 0..3
7AD4 F78011    1880:                 STAB    HDDATA
7AD7 C604      1881:                 LDAB    #HDCMD.SETSURF          ; HD COMMAND: SET SURFACE
7AD9 F78010    1882:                 STAB    HDCMD
7ADC 33        1883:                 PULB                            ; LSN = LSN DIV 4
7ADD 44        1884:                 LSRA                            
7ADE 56        1885:                 RORB
7ADF 44        1886:                 LSRA                            
7AE0 56        1887:                 RORB
7AE1 E713      1888:                 STAB    RDSI.CYLINDER+1,X       ; B CONTAINS TRACK 0..152
7AE3 F78011    1889:                 STAB    HDDATA
7AE6 C605      1890:                 LDAB    #HDCMD.SETTRACK         ; HD COMMAND: SET TRACK
7AE8 F78010    1891:                 STAB    HDCMD
               1892: 
7AEB A605      1893:                 LDAA    RDSI.SECTORBASE,X       ; POINTER TO ACTUAL SECTOR CONTENTS
7AED B77910    1894:                 STAA    DDATA
7AF0 B78011    1895:                 STAA    HDDATA
7AF3 8606      1896:                 LDAA    #HDCMD.SETADDRH         ; HD COMMAND: SET ADDR (MSB)
7AF5 B78010    1897:                 STAA    HDCMD
7AF8 E606      1898:                 LDAB    RDSI.SECTORBASE+1,X     ; POINTER TO ACTUAL SECTOR CONTENTS
7AFA F77911    1899:                 STAB    DDATA+1
7AFD F78011    1900:                 STAB    HDDATA
7B00 C607      1901:                 LDAB    #HDCMD.SETADDRL         ; HD COMMAND: SET ADDR (LSB)
7B02 F78010    1902:                 STAB    HDCMD
               1903: 
7B05 6F0C      1904:                 CLR     RDSI.STATE,X            ; RESET SECTOR STATE TO "IDLE"
7B07 39        1905:                 RTS
               1906: 
7B08 BD7A7A    1907: HDREAD          JSR     HDPREP
7B0B 250D      1908:                 BCS     HDERR
7B0D 8608      1909:                 LDAA    #HDCMD.READ             ; HD COMMAND: READ SECTOR
7B0F B78010    1910:                 STAA    HDCMD
7B12 B68011    1911:                 LDAA    HDDATA                  ; retried status of hd operation
7B15 2706      1912:                 BEQ     HDRDOK
7B17 CE0415    1913:                 LDX     #ERR.DISKREAD
7B1A 7E78F8    1914: HDERR           JMP     DSKERR1
7B1D FE7910    1915: HDRDOK          LDX     DDATA                   
7B20 0C        1916:                 CLC                             ; .*mX-80:HdSec
7B21 39        1917:                 RTS
               1918:                 
7B22 BD7A7A    1919: HDWRITE         JSR     HDPREP
7B25 25F3      1920:                 BCS     HDERR
7B27 8609      1921:                 LDAA    #HDCMD.WRITE            ; HD COMMAND: WRITE SECTOR
7B29 B78010    1922:                 STAA    HDCMD
7B2C B68011    1923:                 LDAA    HDDATA
7B2F 27EC      1924:                 BEQ     HDRDOK
7B31 CE0416    1925:                 LDX     #ERR.DISKWRITE




ASM/6800 1.4A0: 7B34                    
08/16/82 00:00:00; Page 37; Form 1      
IOSWTPC6800.ASM
7B34 20E4      1926:                 BRA     HDERR
               1927:                 
               1928: 
               1929: 
               1930: ; DEVICE CONTROL BLOCK FOR CLOCK 
               1931: 
7B36 434C4F43  1932: CLOCKSTR        FCC     'CLOCK:'
7B3C 00        1933:                 fcb     0
               1934: 
7B3D 01        1935: CLOCKDCB        FCB     1                       ; DCB:DONEFLAG  ; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE.
7B3E 0000      1936:                 FDB     0                       ; DCB:LASTERROR ; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NO
7B40 7B36      1937:                 FDB     CLOCKSTR                ; DCB:NAME      ; POINTER TO DEVICE NAME STRING TERMINATED BY Z
7B42 0000      1938:                 FDB     0                       ; DCB:NEXTDCB   ; POINTER TO NEXT DCB IN LIST OR ZERO
7B44 7B46      1939:                 FDB     CLOCKDRIVER             ; DCB:DRIVER    ; POINTER TO DRIVER ENTRY POINT LIST
               1940: 
               1941: ; DEVICE DRIVER BLOCK FOR CLOCK CONSOLE
               1942: 
7B46 7B60      1943: CLOCKDRIVER     FDB     CLOCKOPEN       ; DRIVER:OPEN   OPEN FILE
7B48 7B60      1944:                 FDB     CLOCKCLOSE      ; DRIVER:CLOSE  CLOSE FILE
7B4A 7BA0      1945:                 FDB     CLOCKREADA      ; DRIVER:READA  READ ASCII
7B4C 70B8      1946:                 FDB     ILLDEVICEOP     ; DRIVER:WRITEA WRITE ASCII WRITEA IS A NO-NO
7B4E 7B7E      1947:                 FDB     CLOCKREADB      ; DRIVER:READB  READ BINARY
7B50 7B7B      1948:                 FDB     CLOCKWRITEB     ; DRIVER:WRITEB WRITE BINARY
7B52 70B8      1949:                 FDB     ILLDEVICEOP     ; DRIVER:CREATE CREATE FILE YOU UPDATE THE CLOCK, NOT REBUILD IT (CREAT
7B54 70B8      1950:                 FDB     ILLDEVICEOP     ; DRIVER:RENAME RENAME FILE RENAME IT TO WHAT? CLOCK-RADIO: ???
7B56 70B8      1951:                 FDB     ILLDEVICEOP     ; DRIVER:DELETE DELETE FILE YOU CAN'T GET RID OF THE CLOCK, NEITHER
7B58 70B8      1952:                 FDB     ILLDEVICEOP     ; DRIVER:CONTROL NO CONTROL FUNCTIONS
7B5A 7B66      1953:                 FDB     CLOCKSTATUS     ; DRIVER:STATUS READ DEVICE (DRIVER) STATUS SAY "I'M A CLOCK, TICK-TOCK
7B5C 7B7B      1954:                 FDB     CLOCKRESET      ; DRIVER:RESET  RESET DRIVER (ON BOOT)
7B5E 7B60      1955:                 FDB     CLOCKPFRESTART  ; DRIVER:STARTIO        WHO UNPLUGGED ME???
               1956: 
  0000         1957: TEMPX           EQU     0
               1958: 
  7B60         1959: CLOCKOPEN       EQU     *               ; HOW ABOUT LOOKING AT YOUR $9 TI CHEAPIE, MAC!
  7B60         1960: CLOCKCLOSE      EQU     *               ; WHAT AM I SUPPOSED TO DO, PUT THE CLOCK AWAY??
  7B60         1961: CLOCKPFRESTART  EQU     *               ; AM I SUPPOSED TO KEEP TIME WITH NO POWER???
7B60 7E70B6    1962:                 JMP     OKRTS           ; TOUGH!
               1963: 
7B63 7E70B8    1964: CLOCKSPRUNG     JMP     ILLDEVICEOP
7B66 8104      1965: CLOCKSTATUS     CMPA    #SC.GETTYPE     ; The only status syscall accepted is SC:GETTYP, which returns DVTYF.CL
7B68 26F9      1966:                 BNE     CLOCKSPRUNG     ; 
7B6A FEAE07    1967:                 LDX     SDOS+SDOS.IOBLOCKPTR
7B6D BDAE36    1968:                 JSR     SDOS+SDOS.CHECKRDLEN    ; HAS HE GOT A BYTE SPACE
7B70 0001      1969:                 FDB     1
7B72 EE0A      1970:                 LDX     SCBLK.RDBUF,X   ; GET THE BUFFER POINTER (where syscall return values are to be set)
7B74 860B      1971:                 LDAA    #DVTYP.CLOCK    ; I'M ALIVE AND TICKING (HOPEFULLY!)
7B76 A700      1972:                 STAA    0,X     
7B78 7E70B6    1973:                 JMP     OKRTS
  7B7B         1974: CLOCKWRITEB     EQU     *
  7B7B         1975: CLOCKRESET      EQU     *
7B7B 7E70B6    1976:                 JMP     OKRTS
               1977: 
7B7E BDAE36    1978: CLOCKREADB      JSR     SDOS+SDOS.CHECKRDLEN
7B81 0006      1979:                 FDB     6               ; HE BETTER HAVE 6 BYTES AT LEAST
7B83 CEAE00    1980:                 LDX     #SDOS           ; READ CURRENT CLOCK SETTING




ASM/6800 1.4A0: 7B86                    
08/16/82 00:00:00; Page 38; Form 1      
IOSWTPC6800.ASM
7B86 C606      1981:                 LDAB    #6              ; TO STACK
7B88 A60B      1982: CLOCKRB1        LDAA    SDOS.CLOCK,X
7B8A 08        1983:                 INX
7B8B 36        1984:                 PSHA
7B8C 5A        1985:                 DECB
7B8D 26F9      1986:                 BNE     CLOCKRB1
7B8F FEAE07    1987:                 LDX     SDOS+SDOS.IOBLOCKPTR
7B92 EE0A      1988:                 LDX     SCBLK.RDBUF,X
7B94 C606      1989:                 LDAB    #6              ; PUT CLOCK IN READ BUFFER
7B96 32        1990: CLOCKRB2        PULA
7B97 A705      1991:                 STAA    5,X
7B99 09        1992:                 DEX
7B9A 5A        1993:                 DECB
7B9B 26F9      1994:                 BNE     CLOCKRB2
7B9D 7E70B6    1995:                 JMP     OKRTS
               1996: 
7BA0 BDAE36    1997: CLOCKREADA      JSR     SDOS+SDOS.CHECKRDLEN
7BA3 0011      1998:                 FDB     17              ; ENOUGH FOR HH:MM:SS MM/DD/YY
7BA5 FEAE07    1999:                 LDX     SDOS+SDOS.IOBLOCKPTR
7BA8 A60C      2000:                 LDAA    SCBLK.RDLEN,X   ; SEE IF ENOUGH SPACE FOR CR
7BAA 2606      2001:                 BNE     CLOCKREADA0
7BAC E60D      2002:                 LDAB    SCBLK.RDLEN+1,X 
7BAE C112      2003:                 CMPB    #18
7BB0 2502      2004:                 BLO     CLOCKREADA1     ; B/ NO
7BB2 6C09      2005: CLOCKREADA0     INC     SCBLK.RPLEN+1,X ; YES, INCLUDE THE CR IN THE COUNT
7BB4 EE0A      2006: CLOCKREADA1     LDX     SCBLK.RDBUF,X
7BB6 2504      2007:                 BLO     CLOCKREADA2     ; B/ CR NOT INCLUDED
7BB8 860D      2008:                 LDAA    #13             ; <CR>
7BBA A711      2009:                 STAA    17,X
7BBC 8611      2010: CLOCKREADA2     LDAA    #17
7BBE DF00      2011:                 STX     TEMPX
7BC0 CE7BD7    2012:                 LDX     #TIMESTR
7BC3 E600      2013: CLOCKREADA3     LDAB    0,X
7BC5 08        2014:                 INX
7BC6 DF02      2015:                 STX     TEMPX+2
7BC8 DE00      2016:                 LDX     TEMPX
7BCA E700      2017:                 STAB    0,X
7BCC 08        2018:                 INX
7BCD DF00      2019:                 STX     TEMPX
7BCF DE02      2020:                 LDX     TEMPX+2
7BD1 4A        2021:                 DECA
7BD2 26EF      2022:                 BNE     CLOCKREADA3
7BD4 7E70B6    2023:                 JMP     OKRTS
               2024: 
7BD7 30303A30  2025: TIMESTR         FCC     '00:00:00 08/16/82'
               2026:   
  7BE8         2027: ATTNCHECK       
  7BE8         2028: DEBUGSYSCALL    
7BE8 7E70B6    2029:                 jmp     okrts
               2030: 
               2031: 
  0000         2032:                 if *>>IOBUF
 *S*           2033:                 ? IO package too big! overlaps IOBUF
               2034:                 fin
               2035:                 




ASM/6800 1.4A0: 7BE8                    
08/16/82 00:00:00; Page 39; Form 1      
IOSWTPC6800.ASM
               2036:                 end




ASM/6800 1.4A0: 7BE8                    
08/16/82 00:00:00; Page 40; Form 1      Symbols Sorted by Name
IOSWTPC6800.ASM
Symbols Sorted by Name:

*ABORTBIT/0080   ACTIVATIONCHARSENSED/71DF       ACTIVATIONCHARSVECTOR/71CF      ACTIVBYTE/7441  ACTIVCHAR/744C  APORT.MODE/760D
 ATTNCHECK/7BE8  BACKSPACE/7453  BACKSPC1/746F   BACKSPC2/7474   BADINTERRUPTCOUNT/704E          BASICDEBUGFLAGS/A083
 BASICFLAGS/71CB                 BREAKBIT/0020   CC.ACTIVATIONCK/001D            CC.DISMOUNTDISK/0011            CC.ECHO/0010
 CC.NOECHO/0011  CC.SETACTBLOCK/0014             CH/7537         CL1/7568        CL2/7577        CL3/7589        CLOCKCLOSE/7B60
 CLOCKDCB/7B3D   CLOCKDRIVER/7B46                CLOCKOPEN/7B60  CLOCKPFRESTART/7B60             CLOCKRB1/7B88   CLOCKRB2/7B96
 CLOCKREADA/7BA0                 CLOCKREADA0/7BB2                CLOCKREADA1/7BB4                CLOCKREADA2/7BBC
 CLOCKREADA3/7BC3                CLOCKREADB/7B7E                 CLOCKRESET/7B7B                 CLOCKSPRUNG/7B63
 CLOCKSTATUS/7B66                CLOCKSTR/7B36   CLOCKWRITEB/7B7B                CLOSE.PORT/7560                 CLOSE.TTY/7233
 CMDREG/8018     CNFGTABLE/7003  CONSOLEDRIVER/709C              CONTROL.PORT/7538               CONTROL.TTY/7267
 CR0/7633        CR1/7621        CR2/762E        CRFLAG/71CE     CTRK0/7913      CTRLCNUM/71CC   CURDRV/7912     DACTIVATION1/729A
 DACTIVATIONCK/728D              DATREG/801B    *DCB.CLEARIN/00CA               *DCB.D0/76F4     DCB.D1/773C     DCB.D2/7784
 DCB.D3/77CC    *DCB.DONEFLAG/0000              *DCB.DRIVER/0007                 DCB.FDUNIT/0043                 DCB.HD/7A24
*DCB.INPUTTOBLK/00A9             DCB.LASTERROR/0001             *DCB.LINEBUF/0067               *DCB.LINEBUFLEN/007A
*DCB.NAME/0003  *DCB.NEXTDCB/0005               *DCB.OILQUIESCENT/0013          *DCB.OUTPUTTOBLK/00A1            DCB.PORT/7513
*DCB.PROFILE/0028               *DCB.RESET/00B5 *DCB.RINGINBASE/004D            *DCB.RINGOUTBASE/0059
*DCB.RINGOUTTHRESHOLD/005D      *DCB.TASKSTACK/00B3             *DCB.TCB/00B1   *DCB.TLBUFFER/007D               DCB.TTY/7093
*DCB.VTSIZE/00FD                 DCBNAME.D0/76F0                 DCBNAME.D1/7738                 DCBNAME.D2/7780
 DCBNAME.D3/77C8                 DCBNAME.HD/7A20                 DCBNAME.PORT/750D               DCBNAME.TTY/708A
 DCBPOINTER/0006                 DDATA/7910      DEBUGSYSCALL/7BE8               DECHO/727F      DEL56U/79D7     DELAY1K/758C
 DELAY1KB/758F   DELAY2/79DA     DELAY3/79DD     DISKDCBS/76F4   DIV18/7847      DIV18.1/784F    DIV18.2/7857    DIV18.3/785F
 DIV18.4/7867    DIV18.5/786F    DIV18.6/7877    DIV18.7/787F    DIV18.8/7887    DNOECHO/7287    DRIVERBASE/7000
 DRV/790C        DRVREG/8014     DSETACT1/72A8   DSETACTIVATION/729D             DSKBUFFERPOOL/A663              DSKCONTROL/7822
 DSKDISMOUNT/7829                DSKDRIVER/7810  DSKERR/78E0     DSKERR1/78F8    DSKINFO.OPSCOUNT/003C
 DSKINFO.SECTORDB/002B           DSKOPSCOUNT/7889                DSKOPSCOUNT1/7893               DSKPOOLSIZE/079B
 DSKPREP/7894    DSKREAD/78C6    DSKRESTORE/7908                 DSKWAITDONE/7908                DSKWRITE/78D3  *DUMMY/792A
 DVTYP.CLOCK/000B                DVTYP.STAPE/0002               *DVTYP.TYPE/0000                 ECHOFLAG/71C9   EOFFLAG/71C8
 ERR.ACTIVATIONNOTINBUFFER/0773  ERR.ACTIVATIONRECEIVED/0775     ERR.DEVICENOTREADY/0424        *ERR.DEVICETIMEDOUT/0412
 ERR.DISKREAD/0415               ERR.DISKSEEK/0417               ERR.DISKWRITE/0416              ERR.DSKWRTPROT/0418
 ERR.EOFHIT/03E9                 ERR.ILLDEVICEOP/040A            ERR.PROGRAMKILLED/0411         *ERR.WRONGDISKTYPE/076E
*ERRETX/70BD     EXPANDTABFLAG/71CD              FCB.SIZE/001A   FCBS/A084       FDRDC/008C      FDRSC/000B      FDSKI/001B
 FDTEARLSN/782B  FDWRC/00AC      FNDTK2/79E6     FNDTK3/79EA     FNDTRK/79DE     FUSEBURNEDUP/7058               GETREADPARAMS/72C0
 GETWRITEPARAMS/7475             GOBIT/0008      HDCMD/8010      HDCMD.HEARTBEAT/0001            HDCMD.READ/0008
 HDCMD.SELDRV/0002               HDCMD.SETADDRH/0006             HDCMD.SETADDRL/0007             HDCMD.SETSECT/0003
 HDCMD.SETSURF/0004              HDCMD.SETTRACK/0005             HDCMD.WRITE/0009                HDDATA/8011     HDDRIVER/7A68
 HDERR/7B1A      HDHLEOK/7A90    HDPREP/7A7A     HDRDOK/7B1D     HDREAD/7B08     HDWRITE/7B22    IGN/0000        ILLDEVICEOP/70B8
 INBYTE/75B3     INBYTEEOF/75C3  INCH/720A       INEEE/E1AC      INNYB1/75A3     INNYB4/75AB     INNYBLE/7593    INPUTBUF/70CA
 INPUTBUFLEN/00FA                INPUTBUFP0/71C4                 INPUTBUFP1/71C6                 INTDISABLE/703A
 INTDK/7919      INTENABLE/703C  INTERRUPTSTACK/A622             INTRTI/703F     INTSETUP/7027   INTSTACKTOP/A662
 IOBUF/A080      IOBUFEND/AE00   IOCB.SIZE/0022  IOCBPOINTERS/A5FC               IOCBS/A376      IOINTPOLL/7040  IRQINT/703E
 IRQVECTOR/A000  LCN.SIZE/0002   LEN/70C4        LMODE/70C3      LSN.SIZE/0003  *M6800/0001     *M6801/0000     *M6809/0000
 NCOL/71CA       NDRIVES/0004    NIOCHANNELS/0013                NMAGICFCBS/0002                 NOTIMERINT/7044
 OFS/0000        OKRTS/70B6      OPEN.PORT/7558  OPEN.TTY/720F   OPEN.TTY1/7224  OUTEEE/E1D1     OUTNYBLE/76E5   OUTNYBLE1/76ED
 PDATA/70C6      PNCHOFF/E353    PNCHON/E34D     PORECH/A00C     PORTDRIVER/751C                 PORTMODE/7536   PRT1/71F2
*PRT2/71EC       PRT3/71EF       PRT4/71FA       PRTCH/71E0      QERR/7947       QUIT10/7948     RAM64K/0000     RBACKSPACE/73C6
 RBAS/73FB       RCNT/7917      *RCTRLC/73A9    *RCTRLD/73CF     RD1NCOL/735F    RD2NCOL/7362    RDOFF/E347      RDON/E337
 RDSEC/792B      RDSEC1/792E    *RDSI.BLINK/0009                 RDSI.CYLINDER/0012             *RDSI.DISKINFO/0000
*RDSI.FLINK/0007                 RDSI.LSN/0002  *RDSI.MODIFIED/000B             *RDSI.RETRYCOUNT/000D            RDSI.SECTOR/000E
 RDSI.SECTORBASE/0005           *RDSI.SIZE/0014  RDSI.STATE/000C                 RDSI.TRACK/0010                 RDSIPOINTER/790A
*RDSISTATE.IDLE/0000            *RDSISTATE.READING/0001         *RDSISTATE.VERIFYING/0003       *RDSISTATE.WRITING/0002
 READ/7949       READ.PORT/75CF  READ1/795C      READ2/7969      READ3/7974      READA.PORT/75C5                 READA.TTY/730D
 READA1/731D     READA2/7327     READA3/7332     READA4/7338     READA5/7376     READA6/7383     READAPORT/7611  READB.PORT/75CC
 READB.TTY/72EB  READB1/72F4     READB2/730B     READBPORT/7640  READINPUTBUF/738D               RENDOFINPUT/7452
 RESET.TTY/727C  RESTOR/79EB     RI1/73BB        RI2/73CB        RI3/73E3        RI4/7403        RI5/742B        RI6/7430




ASM/6800 1.4A0: 7BE8                    
08/16/82 00:00:00; Page 41; Form 1      Symbols Sorted by Name
IOSWTPC6800.ASM
 RI7/7437        RINBUF/7396     RINCH/739F      RP1/75F4        RP1A/7609       RP1EOF/766C     RP1START/75FB   RPIN/7601
 RPLEN/70C8      RSTORECH/7410   SAVEREADPORTCH/7657             SC.GETCOL/0001  SC.GETEOF/0002  SC.GETLINEFLAGS/002C
 SC.GETTYPE/0004                *SCBLK.DATA/000E                *SCBLK.OPCODE/0000               SCBLK.PARAMS/0002
 SCBLK.RDBUF/000A                SCBLK.RDLEN/000C                SCBLK.RPLEN/0008               *SCBLK.WLEN/0001
 SCBLK.WRBUF/0004                SCBLK.WRLEN/0006                SDOS/AE00       SDOS.CHECKRDLEN/0036            SDOS.CLOCK/000B
 SDOS.ERROR/002D                 SDOS.ERRORED/0033               SDOS.ERRORSAVE/0030             SDOS.IOBLOCKPTR/0007
 SDOS.RTI/0015   SDOS.WAITEVENT/002A             SECREG/801A     SECT/790E       SEEK/79AE       SEEK2/79C6      SEEK3/79D3
 SELD1/7A14      SELDRV/79F7     SETRPLEN/72DD   SIDE/790F       SIDEBT/7918     SINIT1/3003     SINIT2/300F
*SPECIALFN.CLEAR/0082           *SPECIALFN.EEOL/0083            *SPECIALFN.POSN/0081             SSTEPBIT/0010   ST0/724C
 ST1/7255        ST2/725E        STATUS.PORT/7542                STATUS.TTY/7236                 STATUSRET1/7260
 STPO1/754F      STPO2/7551     *SWTGO/A080      SWTMON/E0D0     SWTPCINIT/3000  SWTRET/73D8    *SYSCALL.CHAIN/0006
*SYSCALL.CLOSE/0002             *SYSCALL.CONTROL/000E           *SYSCALL.CREATE/0001            *SYSCALL.DEBUG/0018
*SYSCALL.DELETE/0004            *SYSCALL.DISPERROR/0015         *SYSCALL.ERROREXIT/0012         *SYSCALL.EXIT/0011
*SYSCALL.GETERROR/0014          *SYSCALL.OPEN/0000              *SYSCALL.READA/000A             *SYSCALL.READB/000B
*SYSCALL.RENAME/0003            *SYSCALL.SETERROR/0013          *SYSCALL.STATUS/000F            *SYSCALL.WRITEA/000C
*SYSCALL.WRITEB/000D             SYSCALLIO/7000  TASKQUEUE/705C  TASKSETUP/7082  TASKSTACKINIT/7078             *TASKSTACKTOP/7080
 TASKWAKEUPFLAG/7081             TEMPX/0000      TIMEOUTQUEUE/7050               TIMESTR/7BD7    TRACEBIT/0040   TRK/790D
 TRKREG/8019     WBUSY/7977      WP0/76A6        WP1/76AB        WP1A/76BA       WP1START/76B2   WPOUT/76B2      WRITE/797F
 WRITE.0/7496    WRITE.1/749E    WRITE.2/74B0    WRITE.3/74B3    WRITE.9/74BC    WRITE.CHCR.ECHO/74BF            WRITE.CR.ECHO/74C2
 WRITE.MODE/74A7                 WRITE.PORT/767E                 WRITE1/7992     WRITE2/799F    *WRITE3/79AB     WRITEA.CH/74CA
 WRITEA.CH.ECHO/74C4             WRITEA.CH1/74D2                 WRITEA.CH2/74DF                 WRITEA.CH2A/74F1
 WRITEA.CH2B/74FC                WRITEA.CH2C/7500                WRITEA.CH3/7509                 WRITEA.CH4/750C
 WRITEA.PORT/7671                WRITEA.TTY/7486                *WRITEAPORT/76CC                 WRITEB.PORT/767B
 WRITEB.TTY/7490                 WRITEBPORT/76D1                 WRSEC/793A      WTSEC1/793D




ASM/6800 1.4A0: 7BE8                    
08/16/82 00:00:00; Page 42; Form 1      Symbols Sorted by Value
IOSWTPC6800.ASM
Symbols Sorted by Value:

*DCB.DONEFLAG/0000              *DVTYP.TYPE/0000                 IGN/0000       *M6801/0000     *M6809/0000      OFS/0000
 RAM64K/0000    *RDSI.DISKINFO/0000             *RDSISTATE.IDLE/0000            *SCBLK.OPCODE/0000              *SYSCALL.OPEN/0000
 TEMPX/0000      DCB.LASTERROR/0001              HDCMD.HEARTBEAT/0001           *M6800/0001     *RDSISTATE.READING/0001
 SC.GETCOL/0001 *SCBLK.WLEN/0001                *SYSCALL.CREATE/0001             DVTYP.STAPE/0002                HDCMD.SELDRV/0002
 LCN.SIZE/0002   NMAGICFCBS/0002                 RDSI.LSN/0002  *RDSISTATE.WRITING/0002          SC.GETEOF/0002  SCBLK.PARAMS/0002
*SYSCALL.CLOSE/0002             *DCB.NAME/0003   HDCMD.SETSECT/0003              LSN.SIZE/0003  *RDSISTATE.VERIFYING/0003
*SYSCALL.RENAME/0003             HDCMD.SETSURF/0004              NDRIVES/0004    SC.GETTYPE/0004                 SCBLK.WRBUF/0004
*SYSCALL.DELETE/0004            *DCB.NEXTDCB/0005                HDCMD.SETTRACK/0005             RDSI.SECTORBASE/0005
 DCBPOINTER/0006                 HDCMD.SETADDRH/0006             SCBLK.WRLEN/0006               *SYSCALL.CHAIN/0006
*DCB.DRIVER/0007                 HDCMD.SETADDRL/0007            *RDSI.FLINK/0007                 SDOS.IOBLOCKPTR/0007
 GOBIT/0008      HDCMD.READ/0008                 SCBLK.RPLEN/0008                HDCMD.WRITE/0009               *RDSI.BLINK/0009
 SCBLK.RDBUF/000A               *SYSCALL.READA/000A              DVTYP.CLOCK/000B                FDRSC/000B     *RDSI.MODIFIED/000B
 SDOS.CLOCK/000B                *SYSCALL.READB/000B              RDSI.STATE/000C                 SCBLK.RDLEN/000C
*SYSCALL.WRITEA/000C            *RDSI.RETRYCOUNT/000D           *SYSCALL.WRITEB/000D             RDSI.SECTOR/000E
*SCBLK.DATA/000E                *SYSCALL.CONTROL/000E           *SYSCALL.STATUS/000F             CC.ECHO/0010    RDSI.TRACK/0010
 SSTEPBIT/0010   CC.DISMOUNTDISK/0011            CC.NOECHO/0011 *SYSCALL.EXIT/0011               RDSI.CYLINDER/0012
*SYSCALL.ERROREXIT/0012         *DCB.OILQUIESCENT/0013           NIOCHANNELS/0013               *SYSCALL.SETERROR/0013
 CC.SETACTBLOCK/0014            *RDSI.SIZE/0014 *SYSCALL.GETERROR/0014           SDOS.RTI/0015  *SYSCALL.DISPERROR/0015
*SYSCALL.DEBUG/0018              FCB.SIZE/001A   FDSKI/001B      CC.ACTIVATIONCK/001D            BREAKBIT/0020   IOCB.SIZE/0022
*DCB.PROFILE/0028                SDOS.WAITEVENT/002A             DSKINFO.SECTORDB/002B           SC.GETLINEFLAGS/002C
 SDOS.ERROR/002D                 SDOS.ERRORSAVE/0030             SDOS.ERRORED/0033               SDOS.CHECKRDLEN/0036
 DSKINFO.OPSCOUNT/003C           TRACEBIT/0040   DCB.FDUNIT/0043                *DCB.RINGINBASE/004D
*DCB.RINGOUTBASE/0059           *DCB.RINGOUTTHRESHOLD/005D      *DCB.LINEBUF/0067               *DCB.LINEBUFLEN/007A
*DCB.TLBUFFER/007D              *ABORTBIT/0080  *SPECIALFN.POSN/0081            *SPECIALFN.CLEAR/0082           *SPECIALFN.EEOL/0083
 FDRDC/008C     *DCB.OUTPUTTOBLK/00A1           *DCB.INPUTTOBLK/00A9             FDWRC/00AC     *DCB.TCB/00B1   *DCB.TASKSTACK/00B3
*DCB.RESET/00B5 *DCB.CLEARIN/00CA                INPUTBUFLEN/00FA               *DCB.VTSIZE/00FD                 ERR.EOFHIT/03E9
 ERR.ILLDEVICEOP/040A            ERR.PROGRAMKILLED/0411         *ERR.DEVICETIMEDOUT/0412         ERR.DISKREAD/0415
 ERR.DISKWRITE/0416              ERR.DISKSEEK/0417               ERR.DSKWRTPROT/0418             ERR.DEVICENOTREADY/0424
*ERR.WRONGDISKTYPE/076E          ERR.ACTIVATIONNOTINBUFFER/0773  ERR.ACTIVATIONRECEIVED/0775     DSKPOOLSIZE/079B
 SWTPCINIT/3000  SINIT1/3003     SINIT2/300F     DRIVERBASE/7000                 SYSCALLIO/7000  CNFGTABLE/7003  INTSETUP/7027
 INTDISABLE/703A                 INTENABLE/703C  IRQINT/703E     INTRTI/703F     IOINTPOLL/7040  NOTIMERINT/7044
 BADINTERRUPTCOUNT/704E          TIMEOUTQUEUE/7050               FUSEBURNEDUP/7058               TASKQUEUE/705C  TASKSTACKINIT/7078
*TASKSTACKTOP/7080               TASKWAKEUPFLAG/7081             TASKSETUP/7082  DCBNAME.TTY/708A                DCB.TTY/7093
 CONSOLEDRIVER/709C              OKRTS/70B6      ILLDEVICEOP/70B8               *ERRETX/70BD     LMODE/70C3      LEN/70C4
 PDATA/70C6      RPLEN/70C8      INPUTBUF/70CA   INPUTBUFP0/71C4                 INPUTBUFP1/71C6                 EOFFLAG/71C8
 ECHOFLAG/71C9   NCOL/71CA       BASICFLAGS/71CB                 CTRLCNUM/71CC   EXPANDTABFLAG/71CD              CRFLAG/71CE
 ACTIVATIONCHARSVECTOR/71CF      ACTIVATIONCHARSENSED/71DF       PRTCH/71E0     *PRT2/71EC       PRT3/71EF       PRT1/71F2
 PRT4/71FA       INCH/720A       OPEN.TTY/720F   OPEN.TTY1/7224  CLOSE.TTY/7233  STATUS.TTY/7236                 ST0/724C
 ST1/7255        ST2/725E        STATUSRET1/7260                 CONTROL.TTY/7267                RESET.TTY/727C  DECHO/727F
 DNOECHO/7287    DACTIVATIONCK/728D              DACTIVATION1/729A               DSETACTIVATION/729D             DSETACT1/72A8
 GETREADPARAMS/72C0              SETRPLEN/72DD   READB.TTY/72EB  READB1/72F4     READB2/730B     READA.TTY/730D  READA1/731D
 READA2/7327     READA3/7332     READA4/7338     RD1NCOL/735F    RD2NCOL/7362    READA5/7376     READA6/7383     READINPUTBUF/738D
 RINBUF/7396     RINCH/739F     *RCTRLC/73A9     RI1/73BB        RBACKSPACE/73C6                 RI2/73CB       *RCTRLD/73CF
 SWTRET/73D8     RI3/73E3        RBAS/73FB       RI4/7403        RSTORECH/7410   RI5/742B        RI6/7430        RI7/7437
 ACTIVBYTE/7441  ACTIVCHAR/744C  RENDOFINPUT/7452                BACKSPACE/7453  BACKSPC1/746F   BACKSPC2/7474   GETWRITEPARAMS/7475
 WRITEA.TTY/7486                 WRITEB.TTY/7490                 WRITE.0/7496    WRITE.1/749E    WRITE.MODE/74A7
 WRITE.2/74B0    WRITE.3/74B3    WRITE.9/74BC    WRITE.CHCR.ECHO/74BF            WRITE.CR.ECHO/74C2              WRITEA.CH.ECHO/74C4
 WRITEA.CH/74CA  WRITEA.CH1/74D2                 WRITEA.CH2/74DF                 WRITEA.CH2A/74F1                WRITEA.CH2B/74FC
 WRITEA.CH2C/7500                WRITEA.CH3/7509                 WRITEA.CH4/750C                 DCBNAME.PORT/750D
 DCB.PORT/7513   PORTDRIVER/751C                 PORTMODE/7536   CH/7537         CONTROL.PORT/7538               STATUS.PORT/7542
 STPO1/754F      STPO2/7551      OPEN.PORT/7558  CLOSE.PORT/7560                 CL1/7568        CL2/7577        CL3/7589
 DELAY1K/758C    DELAY1KB/758F   INNYBLE/7593    INNYB1/75A3     INNYB4/75AB     INBYTE/75B3     INBYTEEOF/75C3  READA.PORT/75C5
 READB.PORT/75CC                 READ.PORT/75CF  RP1/75F4        RP1START/75FB   RPIN/7601       RP1A/7609       APORT.MODE/760D




ASM/6800 1.4A0: 7BE8                    
08/16/82 00:00:00; Page 43; Form 1      Symbols Sorted by Value
IOSWTPC6800.ASM
 READAPORT/7611  CR1/7621        CR2/762E        CR0/7633        READBPORT/7640  SAVEREADPORTCH/7657             RP1EOF/766C
 WRITEA.PORT/7671                WRITEB.PORT/767B                WRITE.PORT/767E                 WP0/76A6        WP1/76AB
 WP1START/76B2   WPOUT/76B2      WP1A/76BA      *WRITEAPORT/76CC                 WRITEBPORT/76D1                 OUTNYBLE/76E5
 OUTNYBLE1/76ED  DCBNAME.D0/76F0                *DCB.D0/76F4     DISKDCBS/76F4   DCBNAME.D1/7738                 DCB.D1/773C
 DCBNAME.D2/7780                 DCB.D2/7784     DCBNAME.D3/77C8                 DCB.D3/77CC     DSKDRIVER/7810  DSKCONTROL/7822
 DSKDISMOUNT/7829                FDTEARLSN/782B  DIV18/7847      DIV18.1/784F    DIV18.2/7857    DIV18.3/785F    DIV18.4/7867
 DIV18.5/786F    DIV18.6/7877    DIV18.7/787F    DIV18.8/7887    DSKOPSCOUNT/7889                DSKOPSCOUNT1/7893
 DSKPREP/7894    DSKREAD/78C6    DSKWRITE/78D3   DSKERR/78E0     DSKERR1/78F8    DSKRESTORE/7908                 DSKWAITDONE/7908
 RDSIPOINTER/790A                DRV/790C        TRK/790D        SECT/790E       SIDE/790F       DDATA/7910      CURDRV/7912
 CTRK0/7913      RCNT/7917       SIDEBT/7918     INTDK/7919     *DUMMY/792A      RDSEC/792B      RDSEC1/792E     WRSEC/793A
 WTSEC1/793D     QERR/7947       QUIT10/7948     READ/7949       READ1/795C      READ2/7969      READ3/7974      WBUSY/7977
 WRITE/797F      WRITE1/7992     WRITE2/799F    *WRITE3/79AB     SEEK/79AE       SEEK2/79C6      SEEK3/79D3      DEL56U/79D7
 DELAY2/79DA     DELAY3/79DD     FNDTRK/79DE     FNDTK2/79E6     FNDTK3/79EA     RESTOR/79EB     SELDRV/79F7     SELD1/7A14
 DCBNAME.HD/7A20                 DCB.HD/7A24     HDDRIVER/7A68   HDPREP/7A7A     HDHLEOK/7A90    HDREAD/7B08     HDERR/7B1A
 HDRDOK/7B1D     HDWRITE/7B22    CLOCKSTR/7B36   CLOCKDCB/7B3D   CLOCKDRIVER/7B46                CLOCKCLOSE/7B60
 CLOCKOPEN/7B60  CLOCKPFRESTART/7B60             CLOCKSPRUNG/7B63                CLOCKSTATUS/7B66                CLOCKRESET/7B7B
 CLOCKWRITEB/7B7B                CLOCKREADB/7B7E                 CLOCKRB1/7B88   CLOCKRB2/7B96   CLOCKREADA/7BA0
 CLOCKREADA0/7BB2                CLOCKREADA1/7BB4                CLOCKREADA2/7BBC                CLOCKREADA3/7BC3
 TIMESTR/7BD7    ATTNCHECK/7BE8  DEBUGSYSCALL/7BE8               HDCMD/8010      HDDATA/8011     DRVREG/8014     CMDREG/8018
 TRKREG/8019     SECREG/801A     DATREG/801B     IRQVECTOR/A000  PORECH/A00C     IOBUF/A080     *SWTGO/A080
 BASICDEBUGFLAGS/A083            FCBS/A084       IOCBS/A376      IOCBPOINTERS/A5FC               INTERRUPTSTACK/A622
 INTSTACKTOP/A662                DSKBUFFERPOOL/A663              IOBUFEND/AE00   SDOS/AE00       SWTMON/E0D0     INEEE/E1AC
 OUTEEE/E1D1     RDON/E337       RDOFF/E347      PNCHON/E34D     PNCHOFF/E353

432 Symbols.


 *** No Assembly Errors.
