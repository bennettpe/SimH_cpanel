/*	EDITED 4/15/82 1730 HOURS (SEE also "Compiled by..." clauses)
/*	METAPLUS (V1.4) SYNTAX EQUATIONS FOR "SD BASIC"
/*	COPYRIGHT (C) 1977 SOFTWARE DYNAMICS
/*	ALL RIGHTS RESERVED

/*	BASIC14I 4/15/82
/*		1) COMMON vars now yell if initialized
/*		2) THEN subrname\ is now diagnosed as misuse of label name
/*		3) RIGHT$, MID$, LEFT$ now take any string expression on rhs
/*		4) Using a variable name as an argument causes compiler to
/*			assume the variable WILL be modified
/*			(i.e., CALL S(Q) ... PRINT Q ... will no longer
/*			 give "Undef Sym Q" error at assembly time)
/*		5) Optional comments of the form ...\ REM text <CR>
/*			may be placed after DIM, COMMON, INCLUDE, FORMAT,
/*			CONCAT..., DATA and PROGRAM ORIGIN statements, and
/*			on the declaration line (after parameter list) and
/*			after ENDs of SUBROUTINE or (DEF) function definitions.
/*		6) An initialized vector may be set up by:
/*			DIM name/value,value,..../
/*			First value is placed in name[0]; LEN(name)=# values-1
/*		7) Floating point numbers generate FFC requests to ASM,
/*			so conversions are no longer delayed until execution.
/*		8) REMarks may now be indefinitely "wide". (14h limited them
/*			to about 128 characters)
/*
/*	Things that would be nice to do:
/*	Handle ...IF...THEN subrname\clause... neatly
/*	Optimize token parsers to '09 assembly code
/*	Make ...\ Rem ...comment <CR> be identical to <CR>

.SYNTAX BASIC 'Software Dynamics BASIC Compiler Version 1.4i (C) 1982'

ATTRIBUTES	= STRVAR, VECTOR, ARRAY, FUNCTION, STRINGFUNCTION,
		  SCALAR, FREFLABEL, ISLABEL,
		  POTENTIALLABEL, COMMONSCALAR, INFORLOOP, STEPLIMALLOCATED,
		  TYPESUBROUTINE, PARAMETER, FREFSUBROUTINE, STRARRAY ;

/*	STRVAR IS A STRING VARIABLE
/*	VECTOR SAYS "ONLY ONE SUBSCRIPT ALLOWED"
/*	ARRAY SAYS "ONLY TWO SUBSCRIPTS ALLOWED"
/*	FUNCTION IS A DEFINED FUNCTION NAME
/*	SCALAR SAYS "SCALAR" (ALLOCATED IN THE SCALAR POOL)
/*	STRINGFUNCTION IS A DEFINED FUNCTION THAT RETURNS A STRING AS A VALUE
/*	FREFLABEL SAYS "USED IN THE CONTEXT OF A LABEL, BEFORE
/*		BEING DEFINED AS A LABEL"
/*	ISLABEL SAYS "APPEARED AS A LINE LABEL"
/*	POTENTIALLABEL SAYS "APPEARED IN AN EXPRESSION, IT MAY BE
/*		A LABEL OR A SCALAR (HAS NOT YET BEEN DEFINED
/*		AS ONE OR THE OTHER)
/*	COMMONSCALAR SAY "THIS GUY IS A SCALAR, BUT SPACE WAS ALLOCATED
/*		IN THE NON-POOL AREA"
/*		NOTE THAT "COMMONSCALAR" MAY ALSO BE A "POTENTIALLABEL"
/*	INFORLOOP SAYS "THIS VARIABLE IS CURRENT AN INDEX VARIABLE OF A FOR
/*	STEPLIMALLOCATED SAYS "STEP/LIMIT STORAGE FOR THIS INDEX VARIABLE
/*		 HAS ALREADY BEEN ALLOCATED"
/*	STRARRAY SAYS THIS IS THE NAME OF A STRING ARRAY
/*	PARAMETER SAYS THIS VARIABLE IS A PARAMETER FOR A FUNCTION/SUBROUTINE

/*	COMPILER FIXUPS STILL NEEDED:
/*	3) INSTALL "EXTERNAL" VARIABLES
/*	5) ALLOW INITZD ARRAYS, W/ FP NUMS
/*	7) TEST DIMS IN LOCAL SUBRS/FUNS
/**** WISH LIST ****
/*	READ/DATA/RESTORE statements
/*	CASE statement
/*	 DIM A=constant
/*	 LOCAL VARIABLES
/*	 READ/WRITE ARRAYS
/*	 IF...DEBUG...THEN
/*	Printusing: leading zero force/trailing zero suppress
/*	easy way to code program and data origin for COMMON
/*	break character in long names
/*	EOF when looking for NEXT is also singularly non-helpful
/*	 "NEXT" SEEN OUT OF CONTEXT, A BETTER MSG THAN "SYNTAX" ERR SHOULD APPEAR

KEYWORDS	= DIM COMMON REM PROGRAM DATA CONCATENATION
	INCLUDE
	ON ERROR GOTO ELN
	GOSUB POP RETURN
	FOR TO STEP CYCLE NEXT
	LET
	PRINT USING FORMAT TAB INPUT READ WRITE
	STOP EXIT
	WHILE UNTIL DO END
	REPEAT UNLESS WHEN
	IF THEN ELSE ELSEIF FI
	POSITION RESTORE OPEN CREATE CLOSE DELETE RENAME CHAIN
	CALL POKE DEBUG SYSCALL
	SUBROUTINE DEF EXTERNAL
	LEN MAXLEN LEFT$ MID$ RIGHT$ ASC CHR$
	COM ATN SIN COS	TAN LOG EXP SQR INT ABS SGN COL VAL PEEK FIND
	RND ERR PI AND OR NOT EOF ROWS COLUMNS
	TRUE FALSE XOR
	CAT DATE$ TIME$ COPYRIGHT$ NUM$ NUMF$ HEX$ UPPERCASE$ LOWERCASE$
	; /* WHEW!!!!

STATEVARIABLES	=
	COMPILEPHASE( COMPILINGPGMORIGIN COMPILINGCATSIZE
		      COMPILINGDATAORIGIN COMPILINGCOMMON COMPILINGDIMS
		      COMPILINGSTMTS COMPILEDONE )
	RESULT( NUMORBOOLTYPE NUMERICTYPE BOOLTYPE NUMBOOLORSTRTYPE
		NUMORSTRTYPE STRINGTYPE ADDRESSANYTYPE ADDRESSSCALARTYPE
		ADDRESSARRAYTYPE )
	;

ERRORRULE:
!*	Error Handler
!*	Scan until <CR> or '\ is seen
!*
!	IF	M6800!M6801
!SUCCESS	EQU	$0D
!FAILURE	EQU	$0C
!	ELSE	(M6809)
!SUCCESS	EQU	$1A01	SET CARRY
!FAILURE	EQU	$1CFE	RESET CARRY
!	FIN
!
!ERRORTOKEN
!	JSR	GETTOKENCHAR	GO GET A CHARACTER
!	PSHA
!	JSR	EATTOKEN	YUM!
!	PULA
!	CMPA	#'\	CHECK FOR END OF STATEMENT
!	BEQ	ERRORSKIPPED	B/ THAT'S ENOUGH...
!	CMPA	#$0D	END OF LINE MARK ?
!	BNE	ERRORTOKEN	B/ NO, GO EAT SOME MORE
!ERRORSKIPPED	JSR	GETTOKENCHAR	NOW EAT UP ALL EMPTY LINES
!	CMPA	#$D	ANOTHER END OF LINE ?
!	BNE	ERRORSKIPPED1	B/ NO, MIGHT BE TIME TO LEAVE
!ERRORSKIPPED2	JSR	EATTOKEN	YES, SWALLOW IT WHOLE...
!	BRA	ERRORSKIPPED	AND LOOP
!ERRORSKIPPED1	CMPA	#$C	ALLOW FORM FEED HERE, TOO...
!	BEQ	ERRORSKIPPED2	B/ GO EAT
!	JSR	BACKUP	OOPS, WENT TOO FAR...
!ERRORDONE	FAILURE		(HE SEZ, WITH A SMIRK ON HIS FACE...)
!	RTS
;

DEBLANK:
!*	DEBLANK THE INPUT
!*
!DEBLANKL	JSR	EATTOKEN	MAKE THE BLANK DISAPPEAR
!DEBLANKTOKEN	JSR	GETTOKENCHAR	GET NEXT INPUT BYTE
!	CMPA	#' 	A BLANK ?
!	BEQ	DEBLANKL	B/ YES, "GULP!"
!	CMPA	#$9	TAB ?
!	BEQ	DEBLANKL	B/ YES, EAT THESE, TOO!
!	CMPA	#'.	LINE CONTINUATION MARK?
!	BNE	DEBLANK1	B/ NOPE, END OF BLANKS ENCOUNTERED
!	JSR	GETTOKENCHAR	LOOKS LIKE START, SCAN A LITTLE FURTHER
!	CMPA	#'.	...?
!	BNE	DEBLANK2	B/ NOT CONTINUATION
!	JSR	GETTOKENCHAR	...?
!	CMPA	#'.	...?
!	BNE	DEBLANK3	B/ NOT CONTINUATION
!	JSR	GETTOKENCHAR	...?
!	CMPA	#$D	"...<CR>..."?
!	BNE	DEBLANK4
!	JSR	GETTOKENCHAR	...?
!	CMPA	#'&	COMPLETE "..."<0D>"&" SEQUENCE ?
!	BEQ	DEBLANKL	B/ YES, SWALLOW IT!
!DEBLANK4	JSR	BACKUP
!DEBLANK3	JSR	BACKUP
!DEBLANK2	JSR	BACKUP
!DEBLANK1	JSR	BACKUP
!	FAILURE		ANOTHER WHITE LIE...
!	RTS
;

KEYWORD:
!*	TEST FOR KEYWORD = SID OR NID
!*	'A'-'Z' $( 'A'-'Z' / '0'-'9' ) ( '$'  / .EMPTY );
!*
!KEYWORDTOKEN	; TELL METAMACHINE WHERE KEYWORD RULE IS
!	JSR	GETTOKENCHAR	GET ME AN INPUT CHARACTER
!	BSR	ISLETTER	CHECK FIRST CHARACTER
!	BCC	NIDFAIL	B/ ISN'T AN ID
!KEYLOOP	JSR	GETTOKENCHAR	APPARANTLY AN ID, FINISH SCAN
!	BSR	ISLETTER
!	BCS	KEYLOOP	B/ YES, KEEP GOING
!	BSR	ISDIGIT
!	BCS	KEYLOOP	B/ YES, KEEP GOING
!	CMPA	#'$	DOES IT APPEAR TO BE A STRING ID?
!	BEQ	KEYOK	B/ YEP, MUST BE A VALID NUMERIC ID
!	JSR	BACKUP	DON'T COUNT THE LAST CHARACTER
!KEYOK	SUCCESS		ALL IS WELL
!	RTS
;

NID:
!*	TEST FOR NUMERIC IDENTIFIER
!*	'A'-'Z' $( 'A'-'Z' / '0'-'9' ) #'$' ;
!*
!	JSR	GETTOKENCHAR	GET ME AN INPUT CHARACTER
!	BSR	ISLETTER	CHECK FIRST CHARACTER
!	BCC	NIDFAIL	B/ ISN'T AN ID
!NIDLOOP	JSR	GETTOKENCHAR	APPARANTLY AN ID, FINISH SCAN
!	BSR	ISLETTER
!	BCS	NIDLOOP	B/ YES, KEEP GOING
!	BSR	ISDIGIT
!	BCS	NIDLOOP	B/ YES, KEEP GOING
!	CMPA	#'$	DOES IT APPEAR TO BE A STRING ID?
!	BNE	NIDOK	B/ NOPE, MUST BE A VALID NUMERIC ID
!NIDFAIL	FAILURE		DON'T RECOGNIZE STRING IDs IN NUMERIC CONTEXT
!	RTS
!NIDOK	JSR	BACKUP	DON'T COUNT THE LAST CHARACTER
!	SUCCESS		ALL IS WELL
!	RTS
!*
!*	CHARACTER CHECK ROUTINES
!*
!ISLETTER	CMPA	#'A	IS IT A LETTER ?
!	BCS	ISNTLETTER
!	CMPA	#'Z+1
!	BCS	ISLETTERRTS
!	CMPA	#'A+$20	'a
!	BCS	ISNTLETTER
!	CMPA	#'Z+$21	'z+1
!ISLETTERRTS	RTS
!ISNTLETTER	CLC
!	RTS
;

SID:
!*	STRING ID TEST
!*	'A'-'Z' $( 'A'-'Z' / '0'-'9' ) '$' ;
!	JSR	GETTOKENCHAR	GET FIRST CHARACTER
!	BSR	ISLETTER
!	BCC	SIDFAIL	B/ ISN'T STRING ID
!SIDLOOP	JSR	GETTOKENCHAR	APPEARS TO BE STRING ID, CONTINUE SCAN
!	BSR	ISLETTER
!	BCS	SIDLOOP
!	BSR	ISDIGIT
!	BCS	SIDLOOP
!	CMPA	#'$	TRAILING '$' PRESENT ?
!	BNE	SIDFAIL	B/ NOT A STRING ID
!	SUCCESS		IS A STRING ID!
!	RTS
!SIDFAIL	FAILURE	
!	RTS
!*
!*	ISHEX -- CHECK (A) TO SEE IF A HEX DIGIT
!*	RETURNS CARRY SET IF YES
!*
!ISHEX	CMPA	#'A	IS IT A HEX DIGIT ?
!	BCS	ISDIGIT	B/ NOT THE LETTER TYPE
!	CMPA	#'F+1
!	BCS	ISDIGITRTS
!	CMPA	#'A+$20	'a
!	BCS	ISDIGITFAIL
!	CMPA	#'F+$21	'f+1
!	RTS
!*
!*	ISDIGIT -- CHECK (A) TO SEE IF A DIGIT
!*	RETURNS CARRY SET IF YES
!ISDIGIT	CMPA	#'0
!	BCS	ISDIGITFAIL
!	CMPA	#'9+1
!ISDIGITRTS	RTS
!ISDIGITFAIL	CLC
!	RTS
;

ONEDIGITNUM:
!*	TEST FOR SINGLE DIGIT NUMBER
!*	'0'-'9' #'0'-'9' #'.' #'E' #'e' ;
!	BSR	COLLECTINTEGER	GET THE VALUE OF AN INTEGER
!	TSTA		VALUE MUST BE 0-9 ONLY!
!	BNE	NUMBERFAIL	B/ MORE THAN 255!
!	CMPB	#9+1
!	BCC	NUMBERFAIL	B/ MORE THAN 9!
!VERIFYNOTFLOATING	JSR	GETTOKENCHAR	GET FOLLOWING CHARACTER
!	CMPA	#'.	DECIMAL POINT ?
!	BEQ	NUMBERFAIL	B/ YES, MUST BE FLOATING POINT
!	CMPA	#'E	EXPONENT PREFIX ?
!	BEQ	NUMBERFAIL	B/ YES, MUST BE FLOATING POINT
!	CMPA	#'E+$20	'e...?
!	BEQ	NUMBERFAIL	B/ YES, MUST BE FLOATING POINT
!	JSR	BACKUP	REJECT LAST CHARACTER
!	SUCCESS	
!	RTS
!NUMBERFAIL	FAILURE	
!	RTS
;

TENTO255:
!*	TEST FOR VALUE IN RANGE OF 10 TO 255
!*	THE BNF FOR THIS IS A MESS, SO I'LL SKIP IT...
!	BSR	COLLECTINTEGER
!	TSTA		CHECK FOR < 256...
!	BNE	NUMBERFAIL	B/ TOO BIG, REJECT IT
!	SUBB	#10	MAKE SURE VALUE IS >= 10...
!	SBCA	#0
!	BCC	VERIFYNOTFLOATING	B/ SEEMS TO BE PROPER SIZE
!	FAILURE		NO LUCK, QUIT NOW!
!	RTS
;

NUM:
!*	TEST FOR VALUE IN RANGE 0-65535
!*	AGAIN, THE BNF IS A MESS, SO YOU FIGURE IT OUT!
!*
!	BSR	COLLECTINTEGER
!	BRA	VERIFYNOTFLOATING
!*
!*	COLLECTINTEGER -- COLLECTS INTEGER VALUE NOT EXCEEDING 65535
!*	TAKES FAILURE IF NOT AN INTEGER OR > 65535
!*
!COLLECTINTEGER	LDX	#0	INITIAL VALUE
!	STX	INTEGER
!	JSR	GETTOKENCHAR
!	BSR	ISDIGIT
!	BCC	COLLECTINTEGERFAIL	B/ NOT AN INTEGER
!COLLECTINTEGERLOOP	EQU	*
!	SUBA	#'0	CONVERT INTEGER DIGIT TO BINARY
!	PSHA
!	LDAA	INTEGER	MULTIPLY OLD VALUE BY 10
!	LDAB	INTEGER+1
!	ASLB
!	ROLA		*2
!	BCS	COLLECTINTEGERFAIL1	B/ RESULT > 65535
!	ASLB
!	ROLA		*4
!	BCS	COLLECTINTEGERFAIL1	B/ RESULT > 65535
!	ADDB	INTEGER+1
!	ADCA	INTEGER	*5
!	BCS	COLLECTINTEGERFAIL1	B/ RESULT > 65535
!	ASLB
!	ROLA		*10
!	BCS	COLLECTINTEGERFAIL1	B/ RESULT > 65535
!	TSX
!	ADDB	0,X	ADD IN THE NEW DIGIT
!	ADCA	#0
!	BCS	COLLECTINTEGERFAIL1	B/ RESULT > 65535
!	INS		POP THE DIGIT OFF THE STACK
!	STAA	INTEGER
!	STAB	INTEGER+1
!	JSR	GETTOKENCHAR	GRAB THE NEXT INPUT STREAM CHARACTER
!	BSR	ISDIGIT	MEANT FOR US ?
!	BCS	COLLECTINTEGERLOOP	B/ YEP, GO PROCESS
!	JSR	BACKUP	NO, SO REJECT IT
!	LDAA	INTEGER	GET THE VALUE
!	LDAB	INTEGER+1
!	RTS
!
!COLLECTINTEGERFAIL1	INS		POP DIGIT FROM STACK
!COLLECTINTEGERFAIL	INS		POP RETURN ADDRESS FROM STACK
!	INS
!	FAILURE	
!	RTS
;

HEXNUM:
!*	HEXADECIMAL NUMBER TEST
!*
!	JSR	GETTOKENCHAR		GET 1ST CHARACTER
!	JSR	ISHEX
!	BCC	HEXNUMFAIL	B/ NOT HEX
!	JSR	GETTOKENCHAR
!	JSR	ISHEX
!	BCC	HEXNUMDONE
!	JSR	GETTOKENCHAR
!	JSR	ISHEX
!	BCC	HEXNUMDONE
!	JSR	GETTOKENCHAR
!	JSR	ISHEX
!	BCC	HEXNUMDONE
!	SUCCESS		GOT 4 DIGITS, THAT'S ENOUGH...
!	RTS
!
!HEXNUMDONE	JSR	BACKUP	REJECT NON-HEX CHARACTER
!	SUCCESS	
!	RTS
!HEXNUMFAIL	FAILURE	
!	RTS
;

STRINGGUTS:
!*	STRING GUTS
!*	$( #'"' #:D #"'" :0-:7F );
!STRINGGUTSL	JSR	GETTOKENCHAR
!	CMPA	#''	SINGLE QUOTE ?
!	BEQ	STRINGGUTSOK
!	CMPA	#'"	DOUBLE QUOTE ?
!	BEQ	STRINGGUTSOK
!	CMPA	#$D
!	BNE	STRINGGUTSL
!STRINGGUTSOK	JSR	BACKUP
!	SUCCESS
!	RTS
;

STRING: /* AND, NOT SO OBVIOUS, THE EMPTY STRING ( "" OR '' )
!*	STRING TEST
!*	"'" $( #"'" :0-:7F ) "'" / '"' $( #'"' :0-:7F ) '"' ;
!	JSR	GETTOKENCHAR
!	CMPA	#''	SINGLE QUOTE ?
!	BEQ	STRING1	B/ YES, LOOKS LIKE STRING
!	CMPA	#'"	DOUBLE QUOTE ?
!	BNE	STRINGFAIL	B/ NO
!STRING1
!	STAA	STRINGQUOTE
!STRINGLOOP
!	JSR	GETSTRINGBODYCHAR
!	BNE	STRINGLOOP
!STRINGEXIT	; CHECK FOR STRING TERMINATED PROPERLY
!	CMPA	STRINGQUOTE
!	BNE	STRINGFAIL
!	SUCCESS
!	RTS
!STRINGFAIL	FAILURE	
!	RTS
!
!GETSTRINGBODYCHAR
!	JSR	GETTOKENCHAR	GET A CHARACTER FROM THE STRING BODY
!	CMPA	#$D	MALFORMED STRING ?
!	BEQ	GETSTRINGBODYCHARXIT	B/ YES
!	CMPA	STRINGQUOTE	END OF STRING ?
!GETSTRINGBODYCHARXIT	RTS
!STRINGQUOTE	FCB	0
;

CHAR:
!*	SINGLE CHARACTER STRING TEST
!*
!*	"'" #:D :0-:7F "'" / '"' #:D :0-:7F '"' ;
!	JSR	GETTOKENCHAR
!	CMPA	#''	SINGLE QUOTE ?
!	BEQ	CHARSQ
!	CMPA	#'"	DOUBLE QUOTE ?
!	BEQ	CHARDQ
!	FAILURE	
!	RTS
!
!CHARSQ	JSR	GETTOKENCHAR
!	CMPA	#$D	CARRIAGE RETURN ?
!	BEQ	CHARFAIL
!	JSR	GETTOKENCHAR
!	CMPA	#''
!	BNE	CHARFAIL
!	SUCCESS	
!	RTS
!
!CHARDQ	JSR	GETTOKENCHAR
!	CMPA	#$D
!	BEQ	CHARFAIL
!	JSR	GETTOKENCHAR
!	CMPA	#'"
!	BNE	CHARFAIL
!	SUCCESS	
!	RTS
!CHARFAIL	FAILURE	
!	RTS
;

ANYCHAR:
!*	RECOGNIZES ANY NON-<CR> CHARACTER
!	JSR	GETTOKENCHAR
!	CMPA	#$D
!	BEQ	CHARFAIL
!	SUCCESS	
!	RTS
;

LABELID:
!*	TEST FOR PRESENCE OF LABEL
!*
!	JSR	GETTOKENCHAR
!	JSR	ISLETTER
!	BCC	LABELIDFAIL
!LABELIDLOOP	JSR	GETTOKENCHAR
!	JSR	ISLETTER
!	BCS	LABELIDLOOP
!	JSR	ISDIGIT
!	BCS	LABELIDLOOP
!	CMPA	#':
!	BNE	LABELIDFAIL
!	JSR	BACKUP	REJECT THE ':' SO WE ONLY GET ALPHANUM PART OF LABEL!
!	SUCCESS	
!	RTS
!
!LABELIDFAIL	FAILURE	
!	RTS
;

THENELSELABEL:
!*	TEST FOR PRESENCE OF LABEL IN "THEN..." OR "ELSE..." CONTEXT
!*	I.E., LOOKS LIKE: NID $BLANK -'(' -'[' -'=' -'$' ;
!	JSR	GETTOKENCHAR
!	JSR	ISLETTER
!	BCC	LABELIDFAIL
!THENELSELOOP	JSR	GETTOKENCHAR
!	JSR	ISLETTER
!	BCS	THENELSELOOP
!	JSR	ISDIGIT
!	BCS	THENELSELOOP
!	JSR	BACKUP
!	BSR	SKIPBLANKS
!	CMPA	#'=
!	BEQ	LABELIDFAIL
!	CMPA	#'(
!	BEQ	LABELIDFAIL
!	CMPA	#'[
!	BEQ	LABELIDFAIL
!	CMPA	#'$
!	BEQ	LABELIDFAIL
!	JSR	REJECTLOOKAHEAD
!	SUCCESS	
!	RTS
!*
!*	SKIPBLANKS -- SCAN OVER SPACE, TAB, '...' :D '&'
!*	COUNT BYTES FOR BACKUP PURPOSES
!*
!SKIPBLANKS	CLR	LOOKAHEADCOUNT	= # BYTES SCANNED OVER
!SKIPBLANKSL	JSR	GETLOOKAHEADCHARACTER
!	CMPA	#' 
!	BEQ	SKIPBLANKSL
!	CMPA	#$9	TAB ?
!	BEQ	SKIPBLANKSL
!	CMPA	#'.	LINE CONTINUATION ?
!	BNE	SKIPBLANKSRTS
!	JSR	GETLOOKAHEADCHARACTER
!	CMPA	#'.
!	BNE	SKIPBLANKS2
!	JSR	GETLOOKAHEADCHARACTER
!	CMPA	#'.
!	BNE	SKIPBLANKS3
!	JSR	GETLOOKAHEADCHARACTER
!	CMPA	#$D
!	BNE	SKIPBLANKS4
!	JSR	GETLOOKAHEADCHARACTER
!	CMPA	#'&
!	BEQ	SKIPBLANKSL
!	JSR	BACKUP
!	DEC	LOOKAHEADCOUNT
!SKIPBLANKS4	JSR	BACKUP
!	DEC	LOOKAHEADCOUNT
!SKIPBLANKS3	JSR	BACKUP
!	DEC	LOOKAHEADCOUNT
!SKIPBLANKS2	JSR	BACKUP
!	DEC	LOOKAHEADCOUNT
!	LDAA	#'.
!SKIPBLANKSRTS	RTS
;

FNUM:
!*	FLOATING POINT NUMBER TEST
!*	( '-' / .EMPTY )
!*	( '0'-'9' $( '0'-'9' ) ( '.' / .EMPTY ) / '.' '0'-'9' )
!*	( 'E' ( '+' / '-' / .EMPTY ) '0'-'9' $( '0'-'9' ) / .EMPTY ) ;
!*
!	JSR	GETTOKENCHAR	GET 1ST BYTE OF FNUM
!	CMPA	#'-	NEGATIVE SIGN ?
!	BNE	FNUM1	B/ NOPE
!	JSR	GETTOKENCHAR	ACCEPT "-", GET NEXT BYTE
!FNUM1	BSR	FDIGITS1	LOOK FOR DIGIT STRING
!	BCC	FNUMF	B/ NO LEAD DIGITS, MUST BE FRACTION SYNTAX
!	CMPA	#'.	DECIMAL POINT?
!	BNE	FNUM2	B/ NO DECIMAL POINT
!	BSR	FDIGITS	COLLECT FRACTIONAL PART
!FNUM2	CMPA	#'E
!	BEQ	FNUME	B/ LOOKS LIKE ONE COMING UP
!	CMPA	#'E+$20	'e
!	BNE	FNUMSUCCESS	NO EXPONET, GET OUT QUICK!
!FNUME	JSR	GETTOKENCHAR	SEE IF DIGITS FOLLOW EXPONENT "E"
!	CMPA	#'+	CHECK FOR SIGN
!	BEQ	FNUMES	B/ SIGN IS INCLUDED
!	CMPA	#'-	CHECK FOR - SIGN
!	BEQ	FNUMES	B/ SIGN IS INCLUDED
!	JSR	FDIGITS1	LOOK FOR DIGIT STRING
!FNUMSUCCESS	JSR	BACKUP	'E' NOT PART OF NUMBER
!	SUCCESS	
!	RTS
!
!FNUMES	JSR	FDIGITS	EXPONENT HAS SIGN, LOOK FOR DIGITS
!	BCS	FNUMSUCCESS	B/ GOOD EXPONENT FOUND
!	JSR	BACKUP	"E+<X>" IS APPARANTLY NOT AN EXPONENT
!	JSR	BACKUP
!	JSR	BACKUP
!	SUCCESS		BUT THE REST OF THE NUMBER LOOKS OK
!	RTS
!
!FNUMF	CMPA	#'.	MIGHT BE FRACTION ONLY F.P. NUMBER
!	BNE	FNUMFAIL	B/ NO SUCH LUCK.
!	JSR	FDIGITS	MUST HAVE DIGITS IN FRACTION PART
!	BCS	FNUM2	B/ GOT DIGITS, LOOKS OK
!FNUMFAIL	FAILURE		NOT AN F.P. NUMBER
!	RTS
!
!FDIGITS	JSR	GETTOKENCHAR	GET FIRST CHARACTER OF DIGIT STRING
!FDIGITS1	JSR	ISDIGIT	CHECK FOR DIGIT
!	BCC	FDIGITFAIL	B/ NOT A DIGIT STRING
!FDIGITSL	JSR	GETTOKENCHAR	GET NEXT CHARACTER OF DIGIT STRING
!	JSR	ISDIGIT	IS THIS A DIGIT TOO?
!	BCS	FDIGITSL	B/ YES, GO COLLECT SOME MORE
!	SEC		SAY "FOUND DIGIT STRING"
!	RTS
!
!FDIGITFAIL	CLC	SAY "DIDN'T FIND DIGIT STRING"
!	RTS
;

LOOKAHEADELSE:
!*	LOOK AHEAD FOR ELSE CLAUSE
!*	= :0D $BLANKS 'E' 'L' 'S' 'E' ;
!	BSR	GETLOOKAHEADCHARACTER
!	CMPA	#$D
!	BNE	LOOKAHEADELSEFAIL
!	JSR	SKIPBLANKS
!	CMPA	#'E
!	BNE	LOOKAHEADELSEFAIL
!	BSR	GETLOOKAHEADCHARACTER
!	CMPA	#'L
!	BNE	LOOKAHEADELSEFAIL
!	BSR	GETLOOKAHEADCHARACTER
!	CMPA	#'S
!	BNE	LOOKAHEADELSEFAIL
!	BSR	GETLOOKAHEADCHARACTER
!	CMPA	#'E
!	BNE	LOOKAHEADELSEFAIL
!LOOKAHEADELSETAILCHECK
!	BSR	GETLOOKAHEADCHARACTER
!	JSR	ISLETTER
!	BCS	LOOKAHEADELSEFAIL
!	JSR	ISDIGIT
!	BCS	LOOKAHEADELSEFAIL
!	CMPA	#'$
!	BEQ	LOOKAHEADELSEFAIL
!	BSR	REJECTLOOKAHEAD
!	SUCCESS	
!	RTS
!*
!*	REJECTLOOKAHEAD -- BACKUP OVER UNWANTED STUFF!
!*
!REJECTLOOKAHEAD	EQU	*	REJECT ALL BUT THE <CR>
!	JSR	BACKUP
!	DEC	LOOKAHEADCOUNT
!	BNE	REJECTLOOKAHEAD
!	RTS
!
!LOOKAHEADELSEFAIL	FAILURE	
!	RTS
!
!GETLOOKAHEADCHARACTER	INC	LOOKAHEADCOUNT
!	JSR	GETTOKENCHAR
!	CMPA	#'A+32	'a
!	BCS	GETLOOKAHEADRTS	B/ DON'T HAVE TO UPPERCASE THE CHARACTER
!	CMPA	#'Z+32+1	'z+1
!	BCC	GETLOOKAHEADRTS
!	SUBA	#32	FORCE LOWERCASE LETTER TO UPPERCASE
!GETLOOKAHEADRTS
!	RTS
!
!LOOKAHEADCOUNT	FCB	0	= # CHARACTERS SCANNED
;

LOOKAHEADELSEIF:
!*	LOOK AHEAD FOR ELSEIF CLAUSE
!*	= :0D $BLANKS 'E' 'L' 'S' 'E' 'I' 'F';
!	BSR	GETLOOKAHEADCHARACTER
!	CMPA	#$D
!	BNE	LOOKAHEADELSEFAIL
!	JSR	SKIPBLANKS
!	CMPA	#'E
!	BNE	LOOKAHEADELSEFAIL
!	BSR	GETLOOKAHEADCHARACTER
!	CMPA	#'L
!	BNE	LOOKAHEADELSEFAIL
!	BSR	GETLOOKAHEADCHARACTER
!	CMPA	#'S
!	BNE	LOOKAHEADELSEFAIL
!	BSR	GETLOOKAHEADCHARACTER
!	CMPA	#'E
!	BNE	LOOKAHEADELSEFAIL
!	BSR	GETLOOKAHEADCHARACTER
!	CMPA	#'I
!	BNE	LOOKAHEADELSEFAIL
!	BSR	GETLOOKAHEADCHARACTER
!	CMPA	#'F
!	BEQ	LOOKAHEADELSETAILCHECK
!	BRA	LOOKAHEADELSEFAIL
;

ZEROS:
!*	EAT UP LEADING ZEROS ON LINE NUMBERS
!*	= '0' $'0'
!
!	JSR	GETTOKENCHAR
!	CMPA	#'0
!	BNE	ZEROSFAIL
!ZEROSL
!	JSR	GETTOKENCHAR
!	CMPA	#'0
!	BEQ	ZEROSL
!	JSR	BACKUP	REJECT NON-ZERO CHARACTER
!	SUCCESS	
!	RTS
!ZEROSFAIL	FAILURE	
!	RTS
;

LB	= '[' / '(' ;	/* LEFT SUBSCRIPT BRACKET

RB	= ']' / ')' ;	/* RIGHT SUBSCRIPT BRACKET
BASIC	= OPTENDOFLINE	/* SO THINGS START OFF ON THE RIGHT FOOT
	  .OUT( '*	Compiled by 4/13/82 Software Dynamics BASIC Version 1.4i' /
		'.CATBUFSIZE	SET	$100' /	/* Default CATBUF size
		'.	SET	0' /	/* Forward Ref Label Chain generator
		'.NSV	SET	0'/	/* .NSV is number of scalar variables
	        '::	SET	0' /	/* :: is amount of non-scalar data space used
		ORIGIN '$2E00' )	/* ASSUMED ORIGIN
	  .SET COMPILEPHASE=COMPILINGPGMORIGIN
	  $$( COMPILEPHASE?COMPILINGPGMORIGIN
		( REMARKSTMT / INCLUDESTMT / PGMORIGINSTMT /
		  .EMPTY .SET COMPILEPHASE=COMPILINGCATSIZE ) )
	  $$( COMPILEPHASE?COMPILINGCATSIZE
		( REMARKSTMT / INCLUDESTMT / CATSIZESTMT PROGHEADER /
		  FUNCTIONCOMPILATION / SUBROUTINECOMPILATION /
		  .EMPTY PROGHEADER ) )
	  $$( COMPILEPHASE?COMPILINGDATAORIGIN
		( REMARKSTMT / INCLUDESTMT / DATAORIGINSTMT /
		  .EMPTY .SET COMPILEPHASE=COMPILINGCOMMON ) )
	  $$( COMPILEPHASE?COMPILINGCOMMON BASICCOMMON )
	  $$( COMPILEPHASE?COMPILINGDIMS BASICDIMS )
	  $$( COMPILEPHASE?COMPILINGSTMTS BASICSTMTS )
	  .OUT( OPEXIT /
	  '.PROGEND	EQU	*' /
	  '.FREFLBL	EQU	.' /	/* .FREFLBL is tail end of Fref Label list
	  '.TNSS	EQU	::'/	/* .TNSS is total non-scalar space used
	  '.TNSV	EQU	.NSV'/	/* .TNSV is total number of scalars used
	  '	IF	.TNSV>>64+256'/	/* Implementation limit on number of scalars
	  '	?Maximum of 320 Scalar variables has been exceeded?' /
	  '	FIN' /
	  '	IFUND	:' /	/* : is base of all data space
	  ':	EQU	*'/
	  	RES	'.TNSS+.TNSV*6' /
	  '	FIN' /
	  '	IF	.PROGEND>>:&.PROGEND<<:+.TNSS+.TNSV*6' /
	  '	? Data space overlaps end of code space' /
	  '	FIN' /
	  '	IF	.PROGSTART>>:&.PROGSTART<<:+.TNSS+.TNSV*6' /
	  '	? Data space overlaps beginning of code space' /
	  '	FIN' /
	  '	END	.PROGSTART' ) ;

PROGHEADER	=
	.OUT(   '.PROGSTART' EQUHERE /
		'	JSR	$100' /
	        BYTE '$14' /	/* VERSION NUMBER SO WE DON'T USE WRONG RTP
	        ADDR	'.FREFLBL' /	/* Forward Ref Label Chain pointer
		INTEGER	'.CATBUFSIZE' /	/* Concatenation Buffer Size
		DADDR	'.TNSS' /	/* Base of Scalar Variable Storage
		DADDR	'.TNSS+.TNSV*6' )	/* Pointer to 1st byte above data space
	.SET COMPILEPHASE=COMPILINGDATAORIGIN ;

PGMORIGINSTMT	= PROGRAM  ( 'ORIGIN' / 'origin' ) ':'
	 HEXNUM ENDOFLINEOPTCOMMENT .OUT( ORIGIN '$' *1 )
	.SET COMPILEPHASE=COMPILINGCATSIZE ;

CATSIZESTMT	=
	CONCATENATION ( 'BUFFER' / 'buffer' ) ( 'SIZE' / 'size' )
	'=' NUM ENDOFLINEOPTCOMMENT
	.OUT( '.CATBUFSIZE	SET	' *1 ) ;

SUBROUTINECOMPILATION = /* COMPILE AN EXTERNAL SUBROUTINE
    SUBROUTINE ( NID / SID ) +TYPESUBROUTINE
    PARAMETERDEFINITIONS EXTERNALSUBFUNHEADER[*1] ENDOFLINEOPTCOMMENT ;

FUNCTIONCOMPILATION = /* COMPILE AN EXTERNAL FUNCTION
    DEF
       ( NID +FUNCTION PARAMETERDEFINITIONS EXTERNALSUBFUNHEADER[*1]
             ( '=' NUMEXP .OUT( OPFUNRET ) .SET COMPILEPHASE=COMPILEDONE /
               .EMPTY ) /
         SID +FUNCTION PARAMETERDEFINITIONS EXTERNALSUBFUNHEADER[*1]
             ( '=' STREXP .OUT( OPFUNRET ) .SET COMPILEPHASE=COMPILEDONE /
               .EMPTY ) ) ENDOFLINEOPTCOMMENT ;

EXTERNALSUBFUNHEADER = /* Generate Header for external subroutine or function
    .OUT( '.PROGSTART' EQUHERE /
	   '	JSR	$106' / /* FUNCTION/SUBROUTINE ENTRY POINT TO RTP
          BYTE	'$14' /	/* Runtime Package Version Number
          ADDR '.FREFLBL' /	/* Forward Ref Label Chain pointer
          DADDR '::-6' /	/* Pointer to last argument variable
          DADDR '.TNSS' /	/* Pointer to Base of Scalar Variables
          DADDR '.TNSS+6*.TNSV' /	/* Pointer to 1st byte above data space
          BYTE	':NARGS' )	/*  Number of Arguments given in definition
    .SET COMPILEPHASE=COMPILINGDATAORIGIN ;

DATAORIGINSTMT	=
	DATA 'ORIGIN' ':' HEXNUM ENDOFLINEOPTCOMMENT
	.OUT( ':	EQU	$' *1 )
	.SET COMPILEPHASE=COMPILINGCOMMON ;

BASICCOMMON =
	COMMONSTMT / REMARKSTMT / INCLUDESTMT /
	DIMLABEL ( COMMONSTMT / REMARKSTMT / DIMSTMT / ENDOFLINE /
		   LABELLEDFIRSTEXECUTABLELINE[*1] ) /
	.EMPTY .SET COMPILEPHASE=COMPILINGDIMS ;

BASICDIMS =
	DIMSTMT / REMARKSTMT / INCLUDESTMT /
	DIMLABEL ( DIMSTMT / REMARKSTMT / ENDOFLINE / 
		   LABELLEDFIRSTEXECUTABLELINE[*1] ) /
	.EMPTY .SET COMPILEPHASE=COMPILINGSTMTS
		.OUT( CODEBODY EQUHERE ) ;

BASICSTMTS =
	LINELABEL ( LABELLEDBLOCK[*1] RESTOFCLAUSE ENDOFLINE /
		    LINEBODY /
		    FORMATLINE /
		    ENDOFLINE ) /
	LINEBODY / INCLUDESTMT ;

REMARKSTMT	= REMHEAD REMARK ENDOFLINE ;

REMHEAD	= 'REM' / 'Rem' / 'rem' / '!' ;

ENDOFLINE	= :D OPTENDOFLINE ;

OPTENDOFLINE	= $( :D / :C ) ;

ENDOFLINEOPTCOMMENT = '\' REMARKSTMT / ENDOFLINE ;

LINEBODY	=
	CLAUSE ENDOFLINE /
	FUNCTIONDEFN ENDOFLINEOPTCOMMENT /
	SUBROUTINEDEFN ENDOFLINEOPTCOMMENT /
	ENDSTMT :D ;

EXECUTABLELINE	= CLAUSE ENDOFLINE ;

LABELLEDFIRSTEXECUTABLELINE	= .SET COMPILEPHASE=COMPILINGSTMTS
	.OUT( CODEBODY EQUHERE )
	( LABELLEDBLOCK[*1] RESTOFCLAUSE ENDOFLINE / LINEBODY / FORMATLINE ) ;

LABELLEDBLOCK	=
	( IF IFSTMT / FOR FORSTMT / REPEAT REPEATSTMT /
	  WHILE WHILESTMT / UNTIL UNTILSTMT / DO DOSTMT )
	.OUT( 'E:' *1 EQUHERE ) ;

CLAUSE	= EXECUTABLESTMT RESTOFCLAUSE ;

RESTOFCLAUSE	= $( '\' OPTENDOFLINE EXECUTABLESTMT ) ;

DIMLABEL	=
	( LINENUM ( ?ISLABEL DOUBLEDEFLINE / .EMPTY +ISLABEL ) 
		  .OUT( OPJMP / ADDR GENLBL #1 /
		        LABEL *1 OPLINE / INTEGER *1 /
			OPJMP / ADDR CODEBODY / GENLBL #1 EQUHERE ) /
	  LABELID ':' .OUT( OPJMP / ADDR GENLBL #1 )
		LABELGEN[*1]
		.OUT( OPJMP / ADDR CODEBODY / GENLBL #1 EQUHERE ) )
	*1^ ;

LABELGEN =
	?ISLABEL DOUBLEDEFLINE /
	?POTENTIALLABEL -POTENTIALLABEL -COMMONSCALAR +ISLABEL
		/* Note: a POTENTIALLABEL is not placed in the scalar variable pool
		.OUT(   * EQUDATA /
			RESDATA '6' /
			LABEL * OPLFREFL /
			DADDR * /
			ADDR '.' /
			'.	SET	*-5' ) /
	?FREFLABEL -FREFLABEL +ISLABEL .OUT( LABEL * OPSETLABEL ) /
	DEFINED LABELUSEDASVAR /
	.EMPTY +ISLABEL .OUT( LABEL * OPSETLABEL ) ;

LINELABEL	=
	( LINENUM ( ?ISLABEL DOUBLEDEFLINE / .EMPTY +ISLABEL ) 
		  .OUT( LABEL *1 OPLINE / INTEGER *1 ) /
	  LABELID ':' LABELGEN[*1] ) *1^;

LINENUM	= ZEROS NUM *2^ / NUM *1^ ; /* IGNORES LEADING ZEROS ON LINENUMBERS

DEFINED	=
	?SCALAR / ?COMMONSCALAR / ?VECTOR / ?ARRAY / ?FUNCTION /
	?ISLABEL / ?FREFLABEL / ?TYPESUBROUTINE  / ?FREFSUBROUTINE ;

DEFINEDSTRINGQ	=
	?STRVAR / ?STRARRAY / ?STRINGFUNCTION /
	?TYPESUBROUTINE / ?FREFSUBROUTINE ;

LABELUSEDASVAR	= ??'Already defined as a variable' ;

DOUBLEDEFLINE	= ??'Doubly-defined line number' ;

SINGLESUBREQ	= ??'Single subscript required' ;

DOUBLESUBREQ	= ??'Double subscript required' ;

NOFUNCTSHERE	= ??'Function not allowed here' ;

DOUBLEDEFVAR	= ??'Use of name incompatible with previous use' ;

DOUBLEDEFSTR	= ??'Doubly defined string variable' ;

NOSUBVARS	= ??'No subscripted variables allowed here' ;

CANTSTORELABEL	= ??'Assignment to a label is not allowed' ;

UDFSID	= +STRVAR ??'Undefined string variable' ;

NOMATCHINGFOR	= ??"No enclosing FOR with same variable" ;

VARUSEDASLABEL	= ??"Can't use variable name for label" ;

NOPARAMETERSHERE = ??"Parameter variable not allowed here" ;

INCLUDESTMT	= INCLUDE ( '"' / "'" ) STRINGGUTS ( '"' / "'" )
		 .INCLUDE ENDOFLINEOPTCOMMENT ;

EXECUTABLESTMT	= REMHEAD REMARK / ASSIGNSTMT / KEYWORDSTMT ;

KEYWORDSTMT	= LET ASSIGNSTMT /
	  IF IFSTMT /
	  GOTO GOTOSTMT /
	  PRINT PRINTSTMT /
	  FOR FORSTMT /
	  CYCLE CYCLESTMT /
	  GOSUB GOSUBSTMT /
	  RETURN RETURNSTMT /
	  STOP STOPSTMT /
	  WHILE WHILESTMT /
	  UNTIL UNTILSTMT /
	  REPEAT REPEATSTMT /
	  DO DOSTMT /
	  INPUT INPUTSTMT /
	  READ READSTMT /
	  WRITE WRITESTMT /
	  ( POSITION / RESTORE ) POSITIONSTMT /
	  OPEN OPENSTMT /
	  CREATE CREATESTMT /
	  CLOSE CLOSESTMT /
	  DELETE DELETESTMT /
	  RENAME RENAMESTMT /
	  ON ONSTMT /
	  CHAIN CHAINSTMT /
	  CALL CALLSTMT /
	  POKE POKESTMT /
	  DEBUG DEBUGSTMT /
	  ERROR ERRSTMT /
	  SYSCALL SYSCALLSTMT /
	  EXIT EXITSTMT ;

ENDSTMT	= END .SET COMPILEPHASE=COMPILEDONE ;

COMMONSTMT	= COMMON DIMBODY ;

NOTLEGALIFCOMMON =
	COMPILEPHASE?COMPILINGCOMMON ??"Can't initialize a COMMON variable" /
	.EMPTY ;

DIMSTMT	= DIM .SET COMPILEPHASE=COMPILINGDIMS DIMBODY ;

DIMBODY	=  DIMOBJ $(',' DIMOBJ ) ENDOFLINEOPTCOMMENT ;

DIMOBJ	= SID ( DEFINEDSTRINGQ DOUBLEDEFSTR / .EMPTY )
		.OUT( * EQUDATA )
		( LB NUM RB
		     ( LB NUM RB *1+STRARRAY
				.OUT( OPSAINIT / DADDR "::" /
					INTEGER *2 / INTEGER *3 /
					RESDATA *2"*("*3"+4)+2" )  /
			( '/' NOTLEGALIFCOMMON
			      .OUT( INIT GENLBL #2 '-*-2	?Initializing string exceeds DIMension' /
				    INTEGER *2 /	/* = MAXLEN of string
				    INTEGER GENLBL #2 '-*-2' )	/* curLEN of string
			      BYTELST
			      .OUT( GENLBL #2 EQUHERE /
				    RESDATA '4+' *2 ) '/' /
			   COMPILEPHASE?COMPILINGCOMMON
				.OUT( INIT '2' / INTEGER * / RESDATA '4+'* ) /
		           .EMPTY .OUT( INIT '4' /  INTEGER * / INTEGER '0' /
				    RESDATA '4+' *) ) *1+STRVAR ) /
		  '/' NOTLEGALIFCOMMON
		      .OUT( INIT GENLBL #2 '-*-2'/
			    GENLBL #1 EQUHERE/
			    INTEGER GENLBL #2 '-*-4'/
			    INTEGER GENLBL #2 '-*-2')
		      BYTELST
		      .OUT( GENLBL #2 EQUHERE /
			    RESDATA '*-' GENLBL #1 ) '/' *1+STRVAR ) /
	  NID ( ( ?ISLABEL / ?FREFLABEL ) VARUSEDASLABEL /
		DEFINED DOUBLEDEFVAR /
	        .EMPTY )
		( LB .OUT( * EQUDATA ) NUM
			( RB *1+VECTOR
				 .OUT( INIT '2' /
				       INTEGER *2 /
				       RESDATA '8+6*' *2 ) /
			  ',' NUM RB *1+ARRAY
				.OUT( INIT '4' /
				      INTEGER *2 /
				      INTEGER *3 /
				      RESDATA '4+6*(' *2 '+1)*(' *3 '+1)' ) ) /
		  COMPILEPHASE?COMPILINGCOMMON .OUT( * EQUDATA )
			( '/' NOTLEGALIFCOMMON CONSTANT '/'
				 .OUT( OPSTORE / DADDR *1 ) /
			  .EMPTY ) *1+COMMONSCALAR .OUT( RESDATA '6' ) /
		  /* IF WE GET HERE, WE ARE COMPILING DIMS OR COMPILINGSTMTS
		  '/' ( NUM
			       ( ',' *1+VECTOR
				      .OUT( INITVECTORHEAD[#*1] /
					    SIXBYTEINTEGER[*2] )
				      VECTORINITLIST
				      .OUT( INITVECTORTAIL[#] ) /
				  .EMPTY *1+SCALAR
				      .OUT( INITSCALARHEAD /
					    SIXBYTEINTEGER[*2] /
					    *1 ALLOCATESCALAR ) ) /
			FNUM
			 	( ',' *1+VECTOR /* INITZ A VECTOR
				      .OUT( INITVECTORHEAD[#*1] /
					    SIXBYTEFNUM[*2] )
				      VECTORINITLIST
				      .OUT( INITVECTORTAIL[#] ) /
				  .EMPTY *1+SCALAR
					 .OUT( INITSCALARHEAD /
					       SIXBYTEFNUM[*2] /
					       *1 ALLOCATESCALAR ) ) /
			':' HEXNUM
				( ',' *1+VECTOR /* INITZ A VECTOR
				      .OUT( INITVECTORHEAD[#*1] /
					    SIXBYTEHEXINTEGER[*2] )
				      VECTORINITLIST
				      .OUT( INITVECTORTAIL[#] ) /
				  .EMPTY *1+SCALAR
				      .OUT( INITSCALARHEAD /
					    SIXBYTEHEXINTEGER[*2] /
					    *1 ALLOCATESCALAR ) ) ) '/' /
		  .EMPTY *1+SCALAR .OUT( *1 ALLOCATESCALAR ) ) ;
/* The fundamental difference between COMMON and DIM...
/* is that COMMON does not allocate scalars to the scalar pool
/* Note that all COMMON variables must come first!(?)

CONSTANT	=
	ONEDIGITNUM .OUT( OPLSMI * ) /
	TENTO255 .OUT( OPLBINT / BYTE * ) /
	NUM .OUT( OPLINT / INTEGER * ) /
/*	FNUM .OUT( OPLSC / BYTE GENLBL #1 '-*-1' /
/*		     TEXT "'" * "'" /
/*		     GENLBL #1 EQUHERE / OPVAL ) /
	FNUM .OUT( OPLFI / SIXBYTEFNUM[*] ) /
	':' HEXNUM .OUT( OPLINT / INTEGER '$'* );

BYTELST	= BYTEOBJ $(',' BYTEOBJ) ;

BYTEOBJ	= STRING .OUT( TEXT * ) /
	  NUM .OUT( BYTE * ) /
	  ':' HEXNUM .OUT( BYTE '$' * ) ;

VECTORINITLIST = /* PROCESS REST OF VECTOR
	VECTORINITVALUE $( ',' VECTORINITVALUE );

VECTORINITVALUE =
	NUM .OUT( SIXBYTEINTEGER[*] ) /
	FNUM .OUT( SIXBYTEFNUM[*] ) /
	':' HEXNUM .OUT( SIXBYTEHEXINTEGER[*] ) ;

FORMATLINE	= FORMAT STRING
		 .OUT(  OPJUC /
			BYTE GENLBL #1 '-*-1' /
			TEXT * /
			GENLBL #1 EQUHERE )
		  ENDOFLINEOPTCOMMENT ;

ASSIGNSTMT	=
	NID ( ?SCALAR NOSUBSCRIPTS EQUALNUMEXP OPSSCALAR[*1] /
	      ?POTENTIALLABEL -POTENTIALLABEL NOSUBSCRIPTS
			.OUT( * EQUDATA / RESDATA '6' )
			EQUALNUMEXP .OUT( OPSTORE / DADDR *1 ) /
	      ?COMMONSCALAR -POTENTIALLABEL NOSUBSCRIPTS
			( ?PARAMETER .OUT( OPLOAD / DADDR *1 )
				EQUALNUMEXP .OUT( OPST ) /
			  EQUALNUMEXP .OUT( OPSTORE / DADDR *1 ) ) /
	      ?VECTOR ONESUBSCRIPT
			( *1?PARAMETER .OUT( OPVPA / DADDR *1 )
				EQUALNUMEXP .OUT( OPST ) /
			  EQUALNUMEXP .OUT( OPVSS / DADDR *1 ) ) /
	      ?ARRAY TWOSUBSCRIPTS
			( *1?PARAMETER .OUT( OPAPA / DADDR *1 )
				EQUALNUMEXP .OUT( OPST ) /
			  EQUALNUMEXP .OUT( OPASS / DADDR *1 ) ) /
	      ( ?ISLABEL / ?FREFLABEL ) CANTSTORELABEL /
	      ?FUNCTION ARGUMENTLIST[#] '=' NUMERICARGUMENT
			.OUT( OPCALL / ADDR 'SET'*1 / BYTE GENLBL #1'+1' ) /
	      ( ?TYPESUBROUTINE / ?FREFSUBROUTINE )
			ARGUMENTLIST[#] .OUT( OPCALL / ADDR *1 / BYTE GENLBL #1 ) /
	      NOSUBSCRIPTS +SCALAR .OUT( * ALLOCATESCALAR )
			EQUALNUMEXP OPSSCALAR[*1] ) /
	OBVIOUSSTRINGTARGET '=' STREXP .OUT( OPSTS ) /
	SID ( STRVARREF[*1]
		    ( LB NUMEXP ( ',' NUMEXP RB .OUT( OPSS2 ) '=' STREXP .OUT( OPSTS ) /
				RB .OUT( OPSS1 ) EQUALNUMEXP .OUT( OPSTB ) ) /
		      '=' STREXP .OUT( OPSTS ) ) /
	      ?STRINGFUNCTION ARGUMENTLIST[#] '=' STRINGARGUMENT
			.OUT( OPCALL / ADDR 'SET'*1 / BYTE GENLBL #1'+1') /
	      UDFSID ) /
	LEN '(' DEFSID ')' EQUALNUMEXP .OUT( OPSSL ) /
	RND EQUALNUMEXP .OUT( OPSETSEED ) ;

EQUALNUMEXP = '=' NUMEXP ;

OBVIOUSSTRINGTARGET	=
	( LEFT$ '(' DEFSID .OUT( OPLSMI'+1' ) ',' NUMEXP ')' /
	  MID$ '(' DEFSID ',' NUMEXP ',' NUMEXP ')' ) .OUT( OPSS2 ) /
	RIGHT$ '(' DEFSID ',' NUMEXP ')' .OUT( OPRIGHT ) ;

STRVARREF	=
	?STRVAR
		( ?PARAMETER .OUT( OPLOAD / DADDR *1 ) /
		  .EMPTY .OUT( OPLSD / DADDR *1 ) ) /
	?STRARRAY
		( ?PARAMETER .OUT( OPLOAD ) / .EMPTY .OUT( OPLADDR ) )
		.OUT( DADDR *1 )
		( LB NUMEXP RB .OUT( OPSSA ) /
		  ??"String array requires subscript here" ) ;

GOTOSTMT	= ELN .OUT( OPGOELN ) / .EMPTY .OUT( OPJMP ) TARGET ;

TARGET	= LINENUM .OUT( ADDR LABEL * ) /
	  NID TARGETSUB ;

TARGETSUB	=
	( ?ISLABEL /
	  ?POTENTIALLABEL -COMMONSCALAR /
	  ?FREFLABEL /
	  DEFINED VARUSEDASLABEL /
	  .EMPTY +FREFLABEL ) .OUT( ADDR LABEL * ) ;

FORSTMT	= DEFSCALAR
	  ( ?INFORLOOP -INFORLOOP ??"Loop variable controls an enclosing FOR" /
	    ?PARAMETER ??"Can't use a parameter as FOR loop index" /
	    .EMPTY +INFORLOOP )
	  ( ?STEPLIMALLOCATED /
	    .EMPTY +STEPLIMALLOCATED .OUT( 'S:'*1 EQUDATA / RESDATA '12' ) )
	  EQUALNUMEXP TO NUMEXP ( STEP NUMEXP / .EMPTY .OUT( OPLSMI '1' ) )
	  .OUT( 'F:'*1 SETHERE / OPFOR / ADDR GENLBL #1 )
	  ( *1?SCALAR .OUT( SADDR *1 ) / *1?COMMONSCALAR .OUT( DADDR *1 ) )
	  .OUT(  DADDR 'S:'*1 )
	  ( ( UNTIL CONDITION .OUT( OPBF ) /
	      WHILE CONDITION .OUT( OPBT ) )
			.OUT( ADDR "*+5" / OPEXITLOOP / ADDR 'F:'*1 ) /
	    .EMPTY )
	  ( FORCLAUSE /
	    DO ( ENDOFLINE FORBLOCK /
		   CLAUSE ( END / .EMPTY ) ) )
	  *1-INFORLOOP
	 .OUT( OPNEXT / ADDR 'F:'*1 / GENLBL #1 EQUHERE ) ;

FORBLOCK	=
	LINELABEL ( LABELLEDBLOCK[*1] FORCLAUSE /
		    EXECUTABLESTMT FORCLAUSE /
		    FORMATLINE FORBLOCK /
		    ENDOFLINE FORBLOCK /
		    MUSTBENEXT ) /
	EXECUTABLESTMT FORCLAUSE /
	INCLUDESTMT FORBLOCK /
	MUSTBENEXT ;

FORCLAUSE	=
	'\' OPTENDOFLINE ( EXECUTABLESTMT FORCLAUSE / MUSTBENEXT ) /
	ENDOFLINE FORBLOCK ;

MUSTBENEXT	=
	NEXT NID ( ?INFORLOOP / NOMATCHINGFOR ) /
	END /
	??'Missing NEXT' ;

CYCLESTMT	=
	NID ( ?INFORLOOP / NOMATCHINGFOR )
		.OUT( OPNEXT / ADDR 'F:' *1 ) ;

GOSUBSTMT	= POP NUMEXP .OUT( OPGPOP ) / .EMPTY .OUT( OPGSB ) TARGET ;

RETURNSTMT	=
	SUBROUTINE .OUT( OPSUBRET ) /
	NUMORSTREXP .OUT( OPFUNRET ) /
	.EMPTY .OUT( OPRET ) ;

STOPSTMT	= .OUT( OPSTP ) ;

EXITSTMT	=
	NID ( ?INFORLOOP .OUT( OPEXITLOOP / ADDR 'F:'*1 ) /
	      ?ISLABEL .OUT( OPJMP / ADDR 'E:' * ) /	/* ?ISLOOPEXIT EXIT <label>
	      NOMATCHINGFOR ) /
	SUBROUTINE .OUT( OPSUBRET ) /
	NUM ( ?ISLABEL / ??"Must be loop label" ) .OUT( ADDR 'E:' * ) /
	.EMPTY .OUT( OPEXIT ) ;

ONSTMT	=
	ERROR
           ( GOTO .OUT( OPTRP ) ( '0' .OUT( ADDR '0' ) / TARGET ) /
             DO .OUT( OPTRP / ADDR '*+5' / OPJMP / ADDR GENLBL #1 )
                 DOSTMT .OUT( OPERRST / GENLBL #1 EQUHERE ) ) /
	NUMEXP ( GOTO .OUT( OPON ) / GOSUB .OUT( OPONG ) )
		.OUT( ADDR GENLBL #1 )
		TARGET $( ',' TARGET )
		.OUT( GENLBL #1 EQUHERE ) ;

REMARK	= $ REMARKCHAR ; /* TWO LEVEL PARSE PREVENTS STACKED STRING COUNT FROM EXCEEDING 128

REMARKCHAR = ANYCHAR ;

CHAINSTMT	= STREXP .OUT( OPCHAIN ) ;

CALLSTMT	=
	SYSCALL SYSCALLSTMT /
	( NID / SID )
		( ?TYPESUBROUTINE /
		  ?FREFSUBROUTINE /
		  ( DEFINED / DEFINEDSTRINGQ ) DOUBLEDEFVAR /
		  .EMPTY +FREFSUBROUTINE )
		ARGUMENTLIST[#]
		.OUT( OPCALL / ADDR *1 / BYTE GENLBL #1 ) ;

ARGUMENTLIST	=	/* NOTE: GENERALLY CALLED WITH CALLER'S LABEL # AS ARGUMENT
	.OUT(GENLBL #1'	SET	0')	/* GENLBL #1 is number of args for subroutine
	( '(' ARGUMENT .OUT(GENLBL #1'	SET	1+'GENLBL #1)
		$(',' ARGUMENT .OUT(GENLBL #1'	SET	1+'GENLBL #1) ) ')' /
	  .EMPTY ) ;

VARIABLEONLY	= -'+' -'-' -'!' -XOR -'**' -'*' -'/' -'&' -'^'
      -'<' -'<=' -'=' -'>=' -'>' -'<>' -CAT .EMPTY ;

PUSHPARAMTEMPADDR	=
	.OUT( GENLBL #1 EQUDATA / RESDATA '6' /
		    OPSTORE / DADDR GENLBL #1 /
		    OPLADDR / DADDR GENLBL #1 ;) ;

POKESTMT	= NUMEXP ',' NUMEXP .OUT( OPOKE ) ;

DEBUGSTMT	= .OUT( OPDBG ) ;

ERRSTMT	= NUMEXP .OUT( OPERRCAUSE ) / .EMPTY .OUT( OPERRST ) ;

FUNCTIONDEFN	= DEF
	(  NID ( DEFINED DOUBLEDEFVAR / .EMPTY +FUNCTION )
		PARAMETERDEFINITIONS
		( '=' .OUT( OPJMP / ADDR GENLBL #1 / *1 LOCALSUBFUNHEADER )
			NUMEXP .OUT( OPFUNRET / GENLBL #1 EQUHERE ) /
		  ROUTINEBODY[*1] ) /
	   SID ( DEFINEDSTRINGQ DOUBLEDEFSTR / .EMPTY +STRINGFUNCTION )
		PARAMETERDEFINITIONS
		( '=' .OUT( OPJMP / ADDR GENLBL #1 / *1 LOCALSUBFUNHEADER )
			STREXP .OUT( OPFUNRET / GENLBL #1 EQUHERE ) /
		  ROUTINEBODY[*1] ) ) ;

/*	NOTE: Subroutine names of form "SETxxxx" can be used as uniform ref assignments
SUBROUTINEDEFN	= SUBROUTINE  ( NID / SID )
	( ?FREFSUBROUTINE -FREFSUBROUTINE /
	  ( DEFINED / DEFINEDSTRINGQ ) DOUBLEDEFVAR /
	  .EMPTY )
	+TYPESUBROUTINE	PARAMETERDEFINITIONS ROUTINEBODY[*1] ;

ROUTINEBODY =
	EXTERNAL .OUT( RESDATA '-:NARGS*6' ) / /* Take back space allocated to parameters
	ENDOFLINEOPTCOMMENT .OUT( OPJMP / ADDR GENLBL #1 / *1 LOCALSUBFUNHEADER )
		$( REMARKSTMT / INCLUDESTMT / DIM DIMBODY )
		ROUTINEBLOCK .OUT( OPSTP / GENLBL #1 EQUHERE ) ;

ROUTINEBLOCK =
	LINELABEL ( LABELLEDBLOCK[*1] RESTOFCLAUSE ENDOFLINE ROUTINEBLOCK /
		    EXECUTABLELINE ROUTINEBLOCK /
		    FORMATLINE ROUTINEBLOCK /
		    ENDOFLINE ROUTINEBLOCK /
		    FUNCTIONDEFN ENDOFLINEOPTCOMMENT ROUTINEBLOCK /
		    SUBROUTINEDEFN ENDOFLINEOPTCOMMENT ROUTINEBLOCK /
		    MUSTBEEND ) /
	EXECUTABLELINE ROUTINEBLOCK /
	FUNCTIONDEFN ENDOFLINE ROUTINEBLOCK /
	SUBROUTINEDEFN ENDOFLINE ROUTINEBLOCK /
	INCLUDESTMT ROUTINEBLOCK /
	MUSTBEEND ;

PARAMETERDEFINITIONS	=
	.EMPTY
	.OUT(':NARGS	SET	0')
	( '(' NEWPARAMETER .OUT(':NARGS	SET	:NARGS+1')
		$( ',' NEWPARAMETER .OUT(':NARGS	SET	:NARGS+1') ) ')' /
	  .EMPTY ) ;

LOCALSUBFUNHEADER =
	.OUT('	JSR	$106'/
		BYTE	'$14'/	/* VERSION #
		ADDR	'0'/	/* FORWARD REF LABEL CHAIN
		DADDR	'::-6'/	/* POINTER TO LAST ARG VARIABLE
		DADDR	'.TNSS' /	/* POINTER TO BASE OF SCALAR VARIABLES
		DADDR	'.TNSS+6*.TNSV' /	/* Pointer to 1st byte above data space
		BYTE	':NARGS'; );	/* NUMBER OF ARGS GIVEN IN DEFINITION

NEWPARAMETER	=
	( NID ( DEFINED DOUBLEDEFVAR /
		LB '*' ( ',' '*' RB +ARRAY / RB +VECTOR ) /
		.EMPTY +COMMONSCALAR ) /
	  SID ( DEFINEDSTRINGQ DOUBLEDEFSTR /
		LB "*" RB *1+STRARRAY /
	        .EMPTY +STRVAR ) )
	+PARAMETER
	.OUT( * EQUDATA / RESDATA '6' ) ;

OPENSTMT	= CHNL ',' STREXP .OUT( OPOPN ) ;

CREATESTMT	= CHNL ',' STREXP .OUT( OPCREAT ) ;

CLOSESTMT	= CHNL .OUT ( OPCLS ) $( ',' CHNL .OUT( OPCLS ) ) ;

DELETESTMT	= STREXP .OUT( OPDEL ) ;

RENAMESTMT	= STREXP ',' STREXP .OUT( OPREN ) ;

POSITIONSTMT	= CHNL ( SETPOSITION / ',' NUMEXP .OUT( OPRESTR ) ) ;

SYSCALLSTMT	= ( CHNL ',' / .EMPTY .OUT( OPZCHN ) ) SYSCALL1 ;

SYSCALL1	= '(' SYSCALL2 ')' / SYSCALL2 ;

SYSCALL2	=
	 STREXP ( ',' STREXP ( ',' STREXP ( ',' NUMEXP .OUT( OPSYSCALL4ARG ) /
						.EMPTY .OUT( OPSYSCALL3ARG ) ) /
				.EMPTY .OUT( OPSYSCALL2ARG ) ) /
		.EMPTY .OUT( OPSYSCALL1ARG ) ) ;

CHNL	= '#' NUMEXP .OUT( OPCHNL ) ;

CHNLWOPTPOS	= CHNL ( SETPOSITION / .EMPTY ) ',' ;

INPUTSTMT	=
	( ( '""' / "''" ) .OUT( OPZCHN ) INPUTSETPOS /
	  STRCON .OUT( OPZCHN ) INPUTSETPOS .OUT( OPPS ) /
	  CHNLWOPTPOS /
	  .OUT( OPZCHN ) INPUTSETPOS .OUT( OPRMPT ) )
	.OUT( OPINL / ADDR GENLBL #1 ) INLIST .OUT( GENLBL #1 EQUHERE ) ;

INPUTSETPOS	= SETPOSITION ',' / .EMPTY ;

INLIST	= INSVAR / INNVAR (',' INLIST / .EMPTY ) ;

INSVAR	= OBVIOUSSTRINGTARGET .OUT( OPINS / OPSTS ) /
	  SID ( STRVARREF[*1]
			( LB NUMEXP ( ',' NUMEXP RB .OUT( OPSS2 / OPINS / OPSTS ) /
				   RB .OUT( OPSS1 / OPINP / OPSTB ) ) /
			  .EMPTY .OUT( OPINS / OPSTS ) ) /
		?STRINGFUNCTION ??"Not Implemented" /
		UDFSID ) ;

INNVAR	=
	NID ( ?SCALAR NOSUBSCRIPTS .OUT( OPINP ) OPSSCALAR[*1] /
	      ?POTENTIALLABEL -POTENTIALLABEL NOSUBSCRIPTS
			.OUT( * EQUDATA / RESDATA '6' )
			.OUT( OPINP / OPSTORE / DADDR *1 ) /
	      ?COMMONSCALAR -POTENTIALLABEL NOSUBSCRIPTS
			( ?PARAMETER .OUT( OPLOAD / DADDR *1 / OPINP / OPST ) /
			  .EMPTY .OUT( OPINP / OPSTORE / DADDR *1 ) ) /
	      ?VECTOR ONESUBSCRIPT
			( *1?PARAMETER .OUT( OPVPA / DADDR *1 / OPINP / OPST ) /
			  .EMPTY  .OUT( OPINP / OPVSS / DADDR *1 ) ) /
	      ?ARRAY TWOSUBSCRIPTS
			( *1?PARAMETER .OUT( OPAPA / DADDR *1 / OPINP / OPST ) /
			  .EMPTY .OUT( OPINP / OPASS / DADDR *1 ) ) /
	      ( ?ISLABEL / ?FREFLABEL ) CANTSTORELABEL /
	      ?FUNCTION ARGUMENTLIST[#] .OUT( OPINP / PUSHPARAMTEMPADDR )
			.OUT( OPCALL / ADDR 'SET'*1 / BYTE GENLBL #1'+1' ) /
	      NOSUBSCRIPTS +SCALAR .OUT( * ALLOCATESCALAR )
			.OUT( OPINP ) OPSSCALAR[*1] ) /
	LEN '(' DEFSID ')' .OUT( OPINP / OPSSL ) /
	RND .OUT( OPINP / OPSETSEED ) ;

PRINTSTMT	=
	CHNL ( SETPOSITION ( ',' ( USINGPART / PRINTLIST ) /
			     ';' /
			     .EMPTY .OUT( OPPCR ) ) /
	       ',' ( USINGPART / PRINTLIST ) /
	       .EMPTY .OUT( OPPCR ) ) /
	.EMPTY .OUT( OPZCHN )
		( SETPOSITION ( ',' ( USINGPART / PRINTLIST ) /
				';' /
				.EMPTY .OUT( OPPCR ) ) /
		  USINGPART /
		  PRINTLIST /
		  .EMPTY .OUT( OPPCR ) ) ;

PRINTLIST	=
	( TAB TERMGIVINGNUMERIC .OUT( OPTAB ) / SETPOSITION )
		';'  ( PRINTLIST / .EMPTY ) /
	NUMORSTREXP
		( RESULT?NUMERICTYPE PRINTV / RESULT?STRINGTYPE PRINTSTRING ) ;

SETPOSITION	= '@' NUMEXP .OUT( OPRESTR ) ;

PRINTSTRING	= .OUT( OPPS )
	  ( ',' .OUT( OPTABCOL ) ( PRINTLIST / .EMPTY ) /
	    ';' ( PRINTLIST / .EMPTY ) /
	    .EMPTY .OUT( OPPCR ) ) ;

PRINTV	= .OUT( OPPV )
	  ( ',' .OUT( OPTABCOL ) ( PRINTLIST / .EMPTY ) /
	    ';' .OUT( OPPSP ) ( PRINTLIST / .EMPTY ) /
	    .EMPTY .OUT( OPPCR ) ) ;

USINGPART	=
	USING ( STREXP .OUT( OPUSE ) / .EMPTY .OUT( OPUSL ) TARGET )
	( ',' USINGOBJECT $( ',' USINGOBJECT ) / .EMPTY )
	( ';' .OUT( OPPRUS ) / .EMPTY .OUT( OPPCR ) ) ;

USINGOBJECT	=
	NUMORSTREXP
		( RESULT?NUMERICTYPE .OUT( OPPV ) /
		  RESULT?STRINGTYPE .OUT( OPPS ) ) ;

READSTMT	= CHNLWOPTPOS RDVAR $(',' RDVAR) ;

RDVAR	=
	NID ( ?SCALAR NOSUBSCRIPTS .OUT( OPRV ) OPSSCALAR[*1] /
	      ?POTENTIALLABEL -POTENTIALLABEL NOSUBSCRIPTS
			.OUT( * EQUDATA / RESDATA '6' )
			.OUT( OPRV / OPSTORE / DADDR *1 ) /
	      ?COMMONSCALAR -POTENTIALLABEL NOSUBSCRIPTS
			( ?PARAMETER .OUT( OPLOAD / DADDR *1 / OPRV / OPST ) /
			  .EMPTY .OUT( OPRV / OPSTORE / DADDR *1 ) ) /
	      ?VECTOR ONESUBSCRIPT
			( *1?PARAMETER .OUT( OPVPA / DADDR *1 / OPRV / OPST ) /
			  .EMPTY  .OUT( OPRV / OPVSS / DADDR *1 ) ) /
	      ?ARRAY TWOSUBSCRIPTS
			( *1?PARAMETER .OUT( OPAPA / DADDR *1 / OPRV / OPST ) /
			  .EMPTY .OUT( OPRV / OPASS / DADDR *1 ) ) /
	      ( ?ISLABEL / ?FREFLABEL ) CANTSTORELABEL /
	      ?FUNCTION ARGUMENTLIST[#] .OUT( OPRV / PUSHPARAMTEMPADDR )
			.OUT( OPCALL / ADDR 'SET'*1 / BYTE GENLBL #1'+1' ) /
	      NOSUBSCRIPTS +SCALAR .OUT( * ALLOCATESCALAR )
			.OUT( OPRV ) OPSSCALAR[*1] ) /
	SID ( STRVARREF[*1]
		( LB NUMEXP ( ',' NUMEXP RB .OUT( OPSS2 / OPRS ) /
			    RB .OUT( OPSS1 / OPRV / OPSTB ) ) /
		  .EMPTY .OUT( OPRS ) ) /
	     ?STRINGFUNCTION ARGUMENTLIST[#] ??"HOW MUCH STRING SHOULD I READ??"
			.OUT( OPCALL / ADDR 'SET'*1 / BYTE GENLBL #1'+1' ) /
	     UDFSID ) /
	OBVIOUSSTRINGTARGET .OUT( OPRS ) /
	LEN '(' DEFSID ')' .OUT( OPRV / OPSSL ) /
	RND .OUT( OPRV / OPSETSEED ) ;

WRITESTMT	= CHNLWOPTPOS WRVAR $(',' WRVAR) ;

WRVAR =
	NUMORSTREXP
		( RESULT?NUMERICTYPE .OUT( OPWV ) /
		  RESULT?STRINGTYPE .OUT( OPWS ) ) ;

WHILESTMT	= .OUT( GENLBL #1 EQUHERE ) CONDITION DO
	.OUT( OPBF / ADDR GENLBL #2 )
	( CLAUSE OPTEND / ENDOFLINE DOBLOCK )
	.OUT( OPJMP / ADDR GENLBL #1 / GENLBL #2 EQUHERE ) ;

UNTILSTMT	= .OUT( GENLBL #1 EQUHERE ) CONDITION DO
	.OUT( OPBT / ADDR GENLBL #2 )
	( CLAUSE OPTEND / ENDOFLINE DOBLOCK )
	.OUT( OPJMP / ADDR GENLBL #1 / GENLBL #2 EQUHERE ) ;

DOSTMT	=
	CLAUSE OPTEND / ENDOFLINE DOBLOCK ;

DOBLOCK	=
	LINELABEL ( LABELLEDBLOCK[*1] RESTOFCLAUSE ENDOFLINE DOBLOCK /
		    EXECUTABLELINE DOBLOCK /
		    FORMATLINE DOBLOCK /
		    ENDOFLINE DOBLOCK /
		    MUSTBEEND ) /
	EXECUTABLELINE DOBLOCK /
	INCLUDESTMT DOBLOCK /
	MUSTBEEND ;

MUSTBEEND	=	END / ??"Missing Block END" ;

REPEATSTMT =
	.OUT( GENLBL #1 EQUHERE )
	( CLAUSE / ENDOFLINE REPEATBLOCK )
	( UNLESS CONDITION .OUT( OPBF ) OPTEND /
	  WHEN CONDITION .OUT( OPBT ) OPTEND /
	  OPTEND .OUT( OPJMP ) ) .OUT( ADDR GENLBL #1 ) ;

REPEATBLOCK	=
	LINELABEL ( LABELLEDBLOCK[*1] RESTOFCLAUSE ENDOFLINE REPEATBLOCK /
		    EXECUTABLELINE REPEATBLOCK /
		    FORMATLINE REPEATBLOCK /
		    ENDOFLINE REPEATBLOCK /
		    .EMPTY ) /
	EXECUTABLELINE REPEATBLOCK /
	INCLUDESTMT REPEATBLOCK /
	.EMPTY ;

OPTEND	= END / .EMPTY ;
IFSTMT	=
	ERROR WHEN .OUT( OPTRP / ADDR GENLBL #3 )
             ( CLAUSE OPTENDOFLINE / ENDOFLINE REPEATBLOCK )
             .OUT( OPTRP / ADDR '0' / OPJMP / ADDR GENLBL #1 )
             THEN .OUT( GENLBL #3 OPTRP / ADDR '0' )
			( ( LINENUM / THENELSELABELCHECK )
				 .OUT( OPJMP / ADDR LABEL * /
				       GENLBL #1 EQUHERE ) UNCONDELSE /
			  ELN .OUT( OPGOELN / GENLBL #1 EQUHERE ) UNCONDELSE /
			  ENDOFLINE IFBLOCK[#] /
			  IFCLAUSE[#] ) /
	CONDITION OPTENDOFLINE THEN
		( ( LINENUM / THENELSELABELCHECK )
			.OUT( OPBT / ADDR LABEL * ) UNCONDELSE /
		  ELN .OUT( OPBF / ADDR GENLBL #1 / OPGOELN /
			    GENLBL #1 EQUHERE ) UNCONDELSE /
		  ENDOFLINE .OUT( OPBF / ADDR GENLBL #1 ) IFBLOCK[#] /
		  .EMPTY .OUT( OPBF / ADDR GENLBL #1 ) IFCLAUSE[#] ) ;

THENELSELABELCHECK =
	THENELSELABEL
		( ?ISLABEL /
		  ?FREFLABEL /
		  ?POTENTIALLABEL -COMMONSCALAR /
		  ( ?SCALAR / ?COMMONSCALAR / ?VECTOR / ?ARRAY / ?STRARRAY )
			VARUSEDASLABEL /
		  ( ?TYPESUBROUTINE / ?FREFSUBROUTINE /
		    ?FUNCTION / ?STRINGFUNCTION )
			??"Can't use function or subroutine name as label" /
		  .EMPTY +FREFLABEL ) ;

IFBLOCK = REPEATBLOCK
	( ELSE .OUT( ELSEJMP[#] ) ELSEBODY .OUT( GENLBL #2 EQUHERE ) /
	  ELSEIF .OUT( ELSEJMP[#] ) IFSTMT .OUT( GENLBL #2 EQUHERE ) /
	  MUSTBEFI .OUT( GENLBL #1 EQUHERE ) ) ;

IFCLAUSE = CLAUSE
	( ELSEKEYWORD .OUT( ELSEJMP[#] ) ELSEBODY .OUT( GENLBL #2 EQUHERE ) /
	  ELSEIFKEYWORD .OUT( ELSEJMP[#] ) IFSTMT .OUT( GENLBL #2 EQUHERE ) /
	  OPTIONALFI .OUT( GENLBL #1 EQUHERE ) ) ;

ELSEJMP =  .OUT( OPJMP / ADDR GENLBL #2 / GENLBL #1 EQUHERE ;) ;

UNCONDELSE	=
	ELSEKEYWORD ELSEBODY /
	ELSEIFKEYWORD IFSTMT /
	OPTIONALFI ;

ELSEKEYWORD	= ELSE / LOOKAHEADELSE ELSE ;

ELSEIFKEYWORD	= ELSEIF / LOOKAHEADELSEIF ELSEIF ;

ELSEBODY	=
	( LINENUM / THENELSELABELCHECK )
		.OUT( OPJMP / ADDR LABEL * ) OPTIONALFI  /
	ELN .OUT( OPGOELN ) OPTIONALFI /
	ENDOFLINE REPEATBLOCK MUSTBEFI /
	CLAUSE OPTIONALFI ;

OPTIONALFI = FI / .EMPTY ;

MUSTBEFI = FI / ??"Missing FI" ;

/* THE EXPRESSION PARSER IS FORMED OF A SET OF RULES
/* EACH RULE IN THE EXPRESSION PARSER IS GIVEN A DESIRED RESULT TYPE
/* (SEE DEFINITION OF "RESULT" STATE VARIABLE)
/* THE RULE PARSES THE INPUT, AND DETERMINES THE RESULT TYPE
/* IF THE RESULT TYPE IS NOT ONE OF THE ALLOWABLE TYPES, THEN
/* IT IS EITHER CONVERTED TO AN ALLOWABLE TYPE OR A "TYPE" ERROR IS GIVEN
/* THE RESULT TYPE OF AN EXPRESSION RULE MUST BE A SPECIFIC INSTANCE OF
/* THE EXPECTED TYPES, I.E. IF THE INPUT IS RESULT=NUMORBOOLTYPE,
/* THE OUTPUT CAN BE NUMERICTYPE OR BOOLTYPE, BUT NOT NUMORBOOLTYPE!
/* THIS CAN BE SUMMARIZED AS "CONSTRAINTS FLOW INTO A RULE"
/* AND "CONSTRAINED RESULTS FLOW OUT OF A RULE"
/*
/* OPERATOR PRECEDENCE: (FROM LOW TO HIGH)
/*    EXPRESSION      OR
/*    CONJUNCT        AND
/*    RELATION        < <= = >= > <>
/*    SUM             + - ! XOR CAT
/*    PRODUCT         * / & **
/*    POWER           ^
/*    TERM            VARIABLE, FUNCTIONREF, CONSTANT

CONDITION = .SET RESULT=BOOLTYPE EXPRESSION ;

NUMEXP = NOTENDOFSTMT .SET RESULT=NUMERICTYPE EXPRESSION ;

NOTENDOFSTMT = -'\' -:D -ELSE -ELSEIF -END -FI .EMPTY ;

STREXP = NOTENDOFSTMTORTARGET .SET RESULT=STRINGTYPE EXPRESSION ;

NOTENDOFSTMTORTARGET = -NID -NUM NOTENDOFSTMT ;

NUMORSTREXP = NOTENDOFSTMT .SET RESULT=NUMORSTRTYPE EXPRESSION ;

ARGUMENT = .SET RESULT=ADDRESSANYTYPE EXPRESSION ;

NUMERICARGUMENT = .SET RESULT=ADDRESSSCALARTYPE EXPRESSION ;

STRINGARGUMENT = .SET RESULT=STRINGTYPE EXPRESSION ;

EXPRESSION =
    RESULT?NUMORBOOLTYPE CONJUNCT OPTDISJUNCT /
    RESULT?NUMERICTYPE .SET RESULT=NUMORBOOLTYPE CONJUNCT
        RESTOFDISJUNCTRETURNNUMERIC /
    RESULT?BOOLTYPE CONJUNCT OPTDISJUNCT /
    RESULT?NUMBOOLORSTRTYPE CONJUNCT OPTDISJUNCT /
    RESULT?NUMORSTRTYPE .SET RESULT=NUMBOOLORSTRTYPE CONJUNCT
        ( RESULT?STRINGTYPE / RESTOFDISJUNCTRETURNNUMERIC ) /
    RESULT?STRINGTYPE CONJUNCT /
    RESULT?ADDRESSANYTYPE CONJUNCT
          ( ( RESULT?NUMERICTYPE /
              RESULT?BOOLTYPE )
                  RESTOFDISJUNCTRETURNNUMERIC .OUT( PUSHPARAMTEMPADDR )
                  .SET RESULT=ADDRESSSCALARTYPE /
            .EMPTY ) / /* ==> ADDRESSSCALARTYPE, ARRAYTYPE OR STRINGTYPE
    RESULT?ADDRESSSCALARTYPE CONJUNCT
        ( RESULT?ADDRESSSCALARTYPE /
          RESTOFDISJUNCTRETURNNUMERIC .OUT( PUSHPARAMTEMPADDR )
             .SET RESULT=ADDRESSSCALARTYPE ) ;

OPTDISJUNCT = RESTOFDISJUNCT / .EMPTY ;

RESTOFDISJUNCT = /* RETURNS RESULT=BOOLTYPE
     OR CONVERTNUMERICTOBOOL
    .OUT( OPBT / ADDR GENLBL #1 ) CONJUNCT
    $( OR .OUT( OPBT / ADDR GENLBL #1 ) CONJUNCT )
    .OUT( GENLBL #1 EQUHERE ) ;

CONVERTNUMERICTOBOOL = /* INPUT NUMERIC OR BOOL TYPE; OUTPUT = BOOLTYPE
    ( RESULT?NUMERICTYPE .OUT( OPLSMI '0' / OPNE ) .SET RESULT=BOOLTYPE /
      RESULT?BOOLTYPE ) ;

RESTOFDISJUNCTRETURNNUMERIC = /* INPUT = NUMORBOOLTYPE
    /* RETURNS RESULT=NUMERICTYPE
    RESTOFDISJUNCT .OUT( OPLBOOL ) .SET RESULT=NUMERICTYPE /
    RESULT?NUMERICTYPE /
    RESULT?BOOLTYPE .OUT( OPLBOOL ) .SET RESULT=NUMERICTYPE ;

/* AT THE "CONJUNCT" LEVEL OF THE EXPRESSION PARSER AND LOWER,
/* ADDRESSANYTYPE, AND ADDRESSSCALARTYPE ARE PASSED DOWN AS CONSTRAINTS,
/* BUT THE RESULT RETURNED MAY BE ANYTHING IN
/* ADDRESSSCALARTYPE, ADDRESSARRAYTYPE, STRINGTYPE, NUMERICTYPE OR BOOLTYPE.

CONJUNCT =
    RELATION
    ( AND CONVERTNUMERICTOBOOL
      .OUT( OPBF / ADDR GENLBL #1 ) RELATION
      $( AND .OUT( OPBF / ADDR GENLBL #1 ) RELATION )
      .OUT( GENLBL #1 EQUHERE ) / .EMPTY ) ;

RELATION =
    RESULT?NUMORBOOLTYPE .SET RESULT=NUMBOOLORSTRTYPE SUM
        ( RESULT?BOOLTYPE / RESTOFRELATION /
          RESULT?NUMERICTYPE / WRONGTYPE ) /
    RESULT?BOOLTYPE .SET RESULT=NUMBOOLORSTRTYPE SUM
        ( RESULT?BOOLTYPE / RESTOFRELATION /
          CONVERTNUMERICTOBOOL / WRONGTYPE ) /
    RESULT?NUMBOOLORSTRTYPE SUM OPTRELATION /
    RESULT?STRINGTYPE SUM /
    RESULT?ADDRESSANYTYPE SUM OPTRELATION /
    RESULT?ADDRESSSCALARTYPE SUM OPTRELATION ;

OPTRELATION = RESTOFRELATION / .EMPTY ;

RESTOFRELATION = /* INPUT RESULT=NUMERICTYPE OR STRINGTYPE
    /* RETURNS RESULT=BOOLTYPE
    ( '='  ( RESULT?NUMERICTYPE SUM .OUT( OPEQ  ) /
             RESULT?STRINGTYPE  SUM .OUT( OPSEQ ) ) /
      '<>' ( RESULT?NUMERICTYPE SUM .OUT( OPNE  ) /
             RESULT?STRINGTYPE  SUM .OUT( OPSNE ) ) /
      '<=' ( RESULT?NUMERICTYPE SUM .OUT( OPLE  ) /
             RESULT?STRINGTYPE  SUM .OUT( OPSLE ) ) /
      '<'  ( RESULT?NUMERICTYPE SUM .OUT( OPLT  ) /
             RESULT?STRINGTYPE  SUM .OUT( OPSLT ) ) /
      '>=' ( RESULT?NUMERICTYPE SUM .OUT( OPGE  ) /
             RESULT?STRINGTYPE  SUM .OUT( OPSGE ) ) /
      '>'  ( RESULT?NUMERICTYPE SUM .OUT( OPGT  ) /
             RESULT?STRINGTYPE  SUM .OUT( OPSGT ) )
    ) .SET RESULT=BOOLTYPE ;

CONVERTBOOLTONUMERIC = /* INPUT NUMORBOOLTYPE, RETURN NUMERICTYPE
    RESULT?NUMERICTYPE /
    RESULT?BOOLTYPE .OUT( OPLBOOL ) .SET RESULT=NUMERICTYPE /
    WRONGTYPE ;

SUM =
    PRODUCT
    ( SUMOP $SUMOP /
      CAT ( RESULT?STRINGTYPE / WRONGTYPE ) .OUT( OPCIN )
          PRODUCT .OUT( OPCAT ) $( CAT PRODUCT .OUT( OPCAT ) ) .OUT( OPCND ) /
      .EMPTY ) ;

SUMOP =
    '+' CONVERTBOOLTONUMERIC PRODUCT .OUT( OPADD ) /
    '-' CONVERTBOOLTONUMERIC PRODUCT .OUT( OPSUB ) /
    '!' CONVERTBOOLTONUMERIC PRODUCT .OUT( OPIOR ) /
    XOR CONVERTBOOLTONUMERIC PRODUCT .OUT( OPXOR ) ;

PRODUCT =
    POWER $PRODUCTOP ;

PRODUCTOP =
    '**' CONVERTBOOLTONUMERIC POWER .OUT( OPSHF ) /
    '*'  CONVERTBOOLTONUMERIC POWER .OUT( OPMUL ) /
    '/'  CONVERTBOOLTONUMERIC POWER .OUT( OPDIV ) /
    '&'  CONVERTBOOLTONUMERIC POWER .OUT( OPAND ) ;

POWER =
    TERM
    ( '^' CONVERTBOOLTONUMERIC POWER .OUT( OPOWER ) /
      .EMPTY ) ;

TERM =
    RESULT?NUMORBOOLTYPE SYNTACTICTERM
        ( RESULT?NUMERICTYPE / RESULT?BOOLTYPE / WRONGTYPE ) /
    RESULT?NUMERICTYPE SYNTACTICTERM CONVERTBOOLTONUMERIC /
    RESULT?BOOLTYPE SYNTACTICTERM ( RESULT?BOOLTYPE / WRONGTYPE ) /
    RESULT?NUMBOOLORSTRTYPE SYNTACTICTERM
         ( RESULT?NUMERICTYPE / RESULT?BOOLTYPE / RESULT?STRINGTYPE /
           WRONGTYPE ) /
    RESULT?NUMORSTRTYPE .SET RESULT=NUMBOOLORSTRTYPE SYNTACTICTERM
        ( RESULT?STRINGTYPE / CONVERTBOOLTONUMERIC ) /
    RESULT?STRINGTYPE SYNTACTICTERM VERIFYSTRINGRESULT /
    ( RESULT?ADDRESSANYTYPE /
      RESULT?ADDRESSSCALARTYPE ) SYNTACTICTERM ;

VERIFYNUMERICRESULT = RESULT?NUMERICTYPE / WRONGTYPE ;

VERIFYSTRINGRESULT = RESULT?STRINGTYPE / WRONGTYPE ;

WRONGTYPE = ??"Wrong type of value" ;

TERMGIVINGNUMERIC =
    .SET RESULT=NUMERICTYPE SYNTACTICTERM CONVERTBOOLTONUMERIC ;

TERMGIVINGSTRING =
    .SET RESULT=STRINGTYPE SYNTACTICTERM VERIFYSTRINGRESULT ;

/* "SYNTACTICTERM" COMPILES AN EXPRESSION "TERM" ACCORDING TO ITS SYNTACTIC
/* STRUCTURE, AND SETS RESULT=TYPE OF THE SYNTACTIC TERM.
/* IF ITS SYNTACTIC STRUCTURE DOES NOT UNIQUELY DETERMINE THE RESULT TYPE,
/* THEN CONSTRAINTS FROM THE CALLER ARE USED TO DETERMINE WHAT TO COMPILE,
/* AND WHAT THE RESULT TYPE SHOULD BE. THE TYPE OF THE COMPILED RESULT
/* MUST BE CHECKED BY THE CALLER TO VERIFY COMPATIBILITY.

SYNTACTICTERM =
    NUMVARIABLEORUSERFUNCTIONREF /
    STRVARIABLEORUSERFUNCTIONREF /
    OBVIOUSLYNUMERICTERM /
    OBVIOUSLYSTRINGTERM /
    OBVIOUSLYBOOLEANTERM /
    NOTSOCLEARTERM ;

NUMVARIABLEORUSERFUNCTIONREF =
    NID
        ( ?SCALAR NOSUBSCRIPTS
              ( ( RESULT?ADDRESSANYTYPE / RESULT?ADDRESSSCALARTYPE )
                      ( VARIABLEONLY .OUT( OPLADDR / SADDR *1 )
                            .SET RESULT=ADDRESSSCALARTYPE /
                        .EMPTY OPLSCALAR[*1]
                            .SET RESULT=NUMERICTYPE ) /
                .EMPTY OPLSCALAR[*] .SET RESULT=NUMERICTYPE ) /
          ?VECTOR
              ( ( RESULT?ADDRESSANYTYPE / RESULT?ADDRESSSCALARTYPE )
                    ( LB NUMEXP ONESUB1
                          ( *1?PARAMETER .OUT( OPVPA / DADDR *1 )
                                ( VARIABLEONLY .SET RESULT=ADDRESSSCALARTYPE /
                                  .EMPTY .OUT( OPLV )
                                         .SET RESULT=NUMERICTYPE ) /
                            VARIABLEONLY .OUT( OPVSA / DADDR *1 )
                                         .SET RESULT=ADDRESSSCALARTYPE /
                            .EMPTY .OUT( OPVSV / DADDR *1 )
                                   .SET RESULT=NUMERICTYPE ) /
                      VARIABLEONLY
                          ( *1?PARAMETER .OUT( OPLOAD / DADDR *1 ) /
                            .EMPTY .OUT( OPLADDR / DADDR *1 ) )
                          .SET RESULT=ADDRESSARRAYTYPE ) /
                ONESUBSCRIPT
                          ( *1?PARAMETER .OUT( OPVPA / DADDR *1 / OPLV ) /
                            .EMPTY .OUT( OPVSV / DADDR *1 ) )
                          .SET RESULT=NUMERICTYPE ) /
          ?ARRAY
              ( ( RESULT?ADDRESSANYTYPE / RESULT?ADDRESSSCALARTYPE )
                    ( LB NUMEXP TWOSUB1
                          ( *1?PARAMETER .OUT( OPAPA / DADDR *1 )
                                ( VARIABLEONLY .SET RESULT=ADDRESSSCALARTYPE /
                                  .EMPTY .OUT( OPLV )
                                         .SET RESULT=NUMERICTYPE ) /
                            VARIABLEONLY .OUT( OPASA / DADDR *1 )
                                         .SET RESULT=ADDRESSSCALARTYPE /
                            .EMPTY .OUT( OPASV / DADDR *1 )
                                   .SET RESULT=NUMERICTYPE ) /
                      VARIABLEONLY
                          ( *1?PARAMETER .OUT( OPLOAD / DADDR *1 ) /
                            .EMPTY .OUT( OPLADDR / DADDR *1 ) )
                          .SET RESULT=ADDRESSARRAYTYPE ) /
                TWOSUBSCRIPTS
                          ( *1?PARAMETER .OUT( OPAPA / DADDR *1 / OPLV ) /
                            .EMPTY .OUT( OPASV / DADDR *1 ) )
                          .SET RESULT=NUMERICTYPE ) /
          ?FUNCTION FUNCTIONCALL[*1] .SET RESULT=NUMERICTYPE /
          ( ?ISLABEL / ?FREFLABEL )
                .OUT( OPLINT / ADDR LABEL * )
                .SET RESULT=NUMERICTYPE /
          ?PARAMETER NOSUBSCRIPTS .OUT( OPLOAD / DADDR *1 )
               ( ( RESULT?ADDRESSANYTYPE / RESULT?ADDRESSSCALARTYPE )
                       ( VARIABLEONLY .SET RESULT=ADDRESSSCALARTYPE /
                        .EMPTY .OUT( OPLV ) .SET RESULT=NUMERICTYPE ) /
                 .EMPTY .OUT( OPLV ) .SET RESULT=NUMERICTYPE ) /
          ( ( ?COMMONSCALAR / ?POTENTIALLABEL ) NOSUBSCRIPTS /
            NOSUBSCRIPTS +COMMONSCALAR +POTENTIALLABEL )
              ( ( RESULT?ADDRESSANYTYPE / RESULT?ADDRESSSCALARTYPE )
                      ( VARIABLEONLY .OUT( OPLADDR / DADDR *1 )
				/* HANDLE ...CALL X(T)\A=T+...GIVES "UNDEF SYM" AT ASSY TIME
				( ?POTENTIALLABEL -POTENTIALLABEL
					.OUT( *1 EQUDATA / RESDATA '6' ) /
				  .EMPTY )
                              .SET RESULT=ADDRESSSCALARTYPE /
                        .EMPTY .OUT( OPLOAD / DADDR *1 )
                             .SET RESULT=NUMERICTYPE ) /
                .EMPTY .OUT( OPLOAD / DADDR * ) .SET RESULT=NUMERICTYPE )
        ) ;

STRVARIABLEORUSERFUNCTIONREF =
    SID
        ( ?STRVAR
              ( ?PARAMETER .OUT( OPLOAD / DADDR *1 ) /
                .EMPTY .OUT( OPLSD / DADDR *1 ) ) SUBSTRING /
          ?STRARRAY
              ( ?PARAMETER .OUT( OPLOAD / DADDR *1 ) /
                .EMPTY .OUT( OPLADDR / DADDR *1 ) )
              ( LB NUMEXP ONESUB1 .OUT( OPSSA ) SUBSTRING /
                .EMPTY .SET RESULT=ADDRESSARRAYTYPE ) /
          ?STRINGFUNCTION FUNCTIONCALL[*1] SUBSTRING /
          UDFSID ) *1^ ;

FUNCTIONCALL =
     ARGUMENTLIST[#] .OUT( OPFNCALL / ADDR *1 / BYTE GENLBL #1 ) ;

NOTSOCLEARTERM =
    '(' ( ( RESULT?ADDRESSANYTYPE / RESULT?ADDRESSSCALARTYPE )
            .SET RESULT=NUMERICTYPE /
          .EMPTY ) EXPRESSION
		( ',' .OUT( OPLINT / INTEGER '256' / OPMUL ) EXPRESSION ')'
			.OUT( OPADD ) VARIABLEONLY /
		  ')' ) /
    BUILTINSTRFUN /
    IF ( ( RESULT?NUMORBOOLTYPE /
           RESULT?NUMERICTYPE /
           RESULT?ADDRESSSCALARTYPE ) CONDITIONBF[#] NUMEXP /
         ( RESULT?NUMBOOLORSTRTYPE /
           RESULT?ADDRESSANYTYPE ) CONDITIONBF[#] NUMORSTREXP /
         RESULT?STRINGTYPE CONDITIONBF[#] STREXP /
         WRONGTYPE )
       OPTENDOFLINE
       .OUT( OPJMP / ADDR GENLBL #2 / GENLBL #1 EQUHERE )
       ELSE EXPRESSION /* OF TYPE RESULT RETURNED BY THEN EXPRESSION
       FI .OUT( GENLBL #2 EQUHERE ) ;
    
CONDITIONBF = CONDITION OPTENDOFLINE .OUT( OPBF / ADDR GENLBL #1 ) THEN ;

NOTARITHOP =
    -'+' -'-' -'!' -XOR -'**' -'*' -'/' -'&' -'^' .EMPTY ;

OBVIOUSLYBOOLEANTERM =
    ( NOT .SET RESULT=BOOLTYPE RELATION .OUT( OPINV ) /
      EOF TERMGIVINGNUMERIC .OUT( OPEOF )
    ) .SET RESULT=BOOLTYPE ;

ARRAYREF = /* COMPILES REFERENCE TO ARRAY TYPE
    ( ARRAYREF1 / '(' ARRAYREF1 ')' ) *1^ ;

ARRAYREF1 = /* RETURNS TYPE OF ARRAY REF
    ( NID
          ( ?VECTOR / ?ARRAY / WRONGTYPE )
          ( ?PARAMETER .OUT( OPLOAD / DADDR  * ) /
            .EMPTY .OUT( OPLADDR / DADDR * ) )
          .SET RESULT=ADDRESSARRAYTYPE /
      STRVARIABLEORUSERFUNCTIONREF
          ( RESULT?STRINGTYPE / RESULT?ADDRESSARRAYTYPE / WRONGTYPE )
    ) *1^ ;

OBVIOUSLYNUMERICTERM =
    ( ONEDIGITNUM .OUT( OPLSMI * ) /
      TENTO255 .OUT( OPLBINT / BYTE * ) /
      NUM .OUT( OPLINT / INTEGER * ) /
/*      FNUM .OUT( OPLSC / BYTE GENLBL #1 '-*-1' /
/*                 TEXT "'" * "'" / GENLBL #1 EQUHERE / OPVAL ) /
      FNUM .OUT( OPLFI / SIXBYTEFNUM[*] ) /	/* TO AVOID THIS, WRITE - k OR -(k)
      ':' HEXNUM .OUT( OPLINT / INTEGER '$' * ) /
      '-' TERMGIVINGNUMERIC .OUT( OPNEG ) /
      LEN ARRAYREF
          ( *1?VECTOR .OUT( OPLENVECTOR ) /
            RESULT?STRINGTYPE .OUT( OPLEN ) /
	     RESULT?ADDRESSARRAYTYPE ( *1?STRARRAY / WRONGTYPE )
		.OUT( OPLENVECTOR ) /
            WRONGTYPE ) /
      MAXLEN ARRAYREF
          ( RESULT?STRINGTYPE /
            *1?STRARRAY ( RESULT?ADDRESSARRAYTYPE / WRONGTYPE )
                .OUT( OPLSMI '1' / OPSSA ) /
            WRONGTYPE ) .OUT( OPMAXLEN ) /
      ROWS ARRAYREF
          ( *1?ARRAY .OUT( OPROWSARRAY ) /
            WRONGTYPE ) /
      COLUMNS ARRAYREF ( *1?ARRAY / WRONGTYPE ) .OUT( OPCOLSARRAY ) /
      COM TERMGIVINGNUMERIC .OUT( OPCOM ) /
      ATN TERMGIVINGNUMERIC .OUT( OPATN ) /
      SIN TERMGIVINGNUMERIC .OUT( OPSIN ) /
      COS TERMGIVINGNUMERIC .OUT( OPCOS ) /
      TAN TERMGIVINGNUMERIC .OUT( OPTAN ) /
      LOG TERMGIVINGNUMERIC .OUT( OPLOG ) /
      EXP TERMGIVINGNUMERIC .OUT( OPEXP ) /
      SQR TERMGIVINGNUMERIC .OUT( OPSQR ) /
      INT TERMGIVINGNUMERIC .OUT( OPINT ) /
      ABS TERMGIVINGNUMERIC .OUT( OPABS ) /
      SGN TERMGIVINGNUMERIC .OUT( OPSGN ) /
      COL TERMGIVINGNUMERIC .OUT( OPCOL ) /
      VAL TERMGIVINGSTRING .OUT( OPVAL ) /
      PEEK TERMGIVINGNUMERIC .OUT( OPEEK ) /
      ASC TERMGIVINGSTRING .OUT( OPLDB ) /
      FIND '(' STREXP ',' STREXP ')' .OUT( OPFIND ) /
/*	ADDRESS FUNCTION ??? /
      RND .OUT( OPRND ) /
      ERR .OUT( OPERR ) /
      ELN .OUT( OPELN ) /
      PI .OUT( OPPI ) /
      TRUE  .OUT( OPLSMI '1' ) /
      FALSE .OUT( OPLSMI '0' ) /
      '+' TERMGIVINGNUMERIC
    ) .SET RESULT=NUMERICTYPE ;


DEFSCALAR = NID *1^
   ( ?SCALAR NOSUBSCRIPTS /
     ?PARAMETER NOPARAMETERSHERE /
     ( ?VECTOR / ?ARRAY ) NOSUBVARS /
     ( ?ISLABEL / ?FREFLABEL ) CANTSTORELABEL /
     ( ?POTENTIALLABEL -POTENTIALLABEL .OUT( * EQUDATA / RESDATA '6' ) /
       ?COMMONSCALAR ) NOSUBSCRIPTS /
     ?FUNCTION NOFUNCTSHERE /
     NOSUBSCRIPTS +SCALAR
    .OUT( * ALLOCATESCALAR ) ) ;

DEFSID = SID ( STRVARREF[*1] / UDFSID ) ;

NOSUBSCRIPTS = LB ??"Variable not DIM'ed as vector or array" / .EMPTY ;

ONESUBSCRIPT = LB NUMEXP ONESUB1 / SINGLESUBREQ ;

ONESUB1 = RB / SINGLESUBREQ ;

TWOSUBSCRIPTS = LB NUMEXP TWOSUB1 / DOUBLESUBREQ ;

TWOSUB1 = ',' NUMEXP TWOSUB2 / DOUBLESUBREQ ;

TWOSUB2 = RB / DOUBLESUBREQ ;

BUILTINSTRFUN =
   ( DATE$ .OUT( OPDAT ) /
     TIME$ .OUT( OPTIM ) /
     COPYRIGHT$ .OUT( OPCOPYRIGHT ) /
     NUM$ TERMGIVINGNUMERIC .OUT( OPNUM ) /
     NUMF$ '(' STREXP ',' NUMEXP ')' .OUT( OPNUMF ) /
     HEX$ TERMGIVINGNUMERIC .OUT( OPHEX ) /
     UPPERCASE$ '(' STREXP ')' .OUT( OPUPPERC ) /
     LOWERCASE$ '(' STREXP ')' .OUT( OPLOWERC ) /
     CHR$ TERMGIVINGNUMERIC .OUT( OPCHR ) ) SUBSTRING ;


OBVIOUSLYSTRINGTERM =
     ( STRING .OUT( OPLSC /
                    BYTE GENLBL #1 '-*-1' /
                    TEXT * /
                    GENLBL #1 EQUHERE ) /
       MID$ '(' STREXP ',' NUMEXP ',' NUMEXP ')' .OUT( OPSS2 ) /
       LEFT$ '(' STREXP ',' .OUT( OPLSMI'+1' ) NUMEXP ')' .OUT( OPSS2 ) /
       RIGHT$ '(' STREXP ',' NUMEXP ')' .OUT( OPRIGHT )
     ) .SET RESULT=STRINGTYPE ;

STRCON	=
     STRING .OUT( OPLSC /
                  BYTE GENLBL #1 '-*-1' /
                  TEXT * /
                  GENLBL #1 EQUHERE ) ;

SUBSTRING = /* INPUT RESULT = STRINGTYPE
    /* RETURN RESULT=STRINGTYPE OR NUMERIC TYPE
    LB NUMEXP
         ( ',' NUMEXP RB .OUT( OPSS2 ) .SET RESULT=STRINGTYPE /
           RB .OUT( OPSS1 / OPLDB ) .SET RESULT=NUMERICTYPE ) /
    .EMPTY .SET RESULT=STRINGTYPE ;
/*	CODE GENERATORS
/*	"OPXXX" MEANS BASIC MACHINE OPCODE "XXX"

/**************************************************************
/*	EDITOR MACRO USED TO SEQUENTIALLY NUMBER THE OPCODES
/*	#2 F';) ;\-U'	\ EU1/100EV2 (EU1-EU2*100)/10EV3 EU1-EU2*100-EU3*10EV4 1_I
/*	\#1 EU2+'0V EU3+'0V EU4+'0V 0TT 1L EU1+1EV1 2_
/******************************************************************

OPLSMI	= .OUT('	0+';) ;	/* LOAD SMALL INTEGER 0-9 (THIS IS 10 OPCODES)
OPLOAD	= .OUT('	010';) ;	/* LOAD VARIABLE VALUE
OPLV	= .OUT('	011';) ;	/* LOAD VALUE FROM ADDRESS ON TOP OF STACK
/*OPSESCALAR	= .OUT('	012';) ;	/* STORE: STORE EXTENDED SCALAR
OPLADDR = .OUT( OPLINT ; ) ;	/* LOAD: LOAD ADDRESS OF VARIABLE
OPLINT	= .OUT('	013';) ;	/* LOAD 16 BIT POSITIVE INTEGER CONSTANT
/*OPLESCALAR	= .OUT('	014';) ;	/* LOAD: LOAD EXTENDED SCALAR
OPLFI	= .OUT('	015';) ;	/* LOAD FLOATING IMMEDIATE
OPLDB	= .OUT('	016';) ;	/* LOAD BYTE FROM STRING DESCRIPTOR ON TOP OF STACK
OPDUP	= .OUT('	017';) ;	/* DUPLICATE ENTRY ON TOP OF STACK
OPLSD	= .OUT('	018';) ;	/* LOAD STRING DESCRIPTOR OF VARIABLE STRING
OPLSC	= .OUT('	019';) ;	/* LOAD STRING DESCRIPTOR OF IN-LINE CONSTANT STRING
OPLEN	= .OUT('	020';) ;	/* LOAD LENGTH OF STRING WHOSE ADDRESS IS IN LINE
OPSS1	= .OUT('	021';) ;	/* DO SINGLE STRING SUBSCRIPT
OPSS2	= .OUT('	022';) ;	/* DO DOUBLE STRING SUBSCRIPT
OPVSA	= .OUT('	023';) ;	/* DO VECTOR SUBSCRIPT AND PUSH ADDRESS
OPVSV	= .OUT('	024';) ;	/* DO VECTOR SUBSCRIPT AND PUSH VALUE
OPVSS	= .OUT('	025';) ;	/* DO VECTOR SUBSCRIPT AND STORE VALUE
OPVPA	= .OUT('	026';) ;	/* DO VECTOR SUBSCRIPT ON PARAMETER AND PUSH ADDRESS
OPASA	= .OUT('	027';) ;	/* DO ARRAY SUBSCRIPT AND PUSH ADDRESS
OPASV	= .OUT('	028';) ;	/* DO ARRAY SUBSCRIPT AND PUSH VALUE
OPASS	= .OUT('	029';) ;	/* DO ARRAY SUBSCRIPT AND STORE VALUE
OPAPA	= .OUT('	030';) ;	/* DO ARRAY SUBSCRIPT ON PARAMETER AND PUSH ADDRESS
OPST	= .OUT('	031';) ;	/* STORE VALUE ON TOS AT ADDRESS IN TOS-1
OPSTS	= .OUT('	032';) ;	/* STORE STRING TOS INTO STRING TOS-1
OPSTB	= .OUT('	033';) ;	/* STORE VALUE ON TOS INTO STRING BYTE TOS-1
OPADD	= .OUT('	034';) ;	/* ADD TOS TO TOS-1
OPSUB	= .OUT('	035';) ;	/* SUBTRACT TOS FROM TOS-1
OPNEG	= .OUT('	036';) ;	/* TAKE THE NEGATIVE OF TOS
OPMUL	= .OUT('	037';) ;	/* MULTIPLY TOS BY TOS-1
OPDIV	= .OUT('	038';) ;	/* DIVIDE TOS INTO TOS-1
OPAND	= .OUT('	039';) ;	/* AND (BITWISE) TOS INTO TOS-1
OPIOR	= .OUT('	040';) ;	/* OR (BITWISE) TOS INTO TOS-1
OPSHF	= .OUT('	041';) ;	/* SHIFT (LOGICALLY) TOS-1 BY TOS
OPCOM	= .OUT('	042';) ;	/* TAKE LOGICAL (BITWISE) COMPLEMENT OF TOS
OPEQ	= .OUT('	043';) ;	/* COMPARE TOS TO TOS-1 FOR EQUALITY
OPNE	= .OUT('	044';) ;	/* COMPARE TOS TO TOS-1 FOR INEQUALITY
OPLT	= .OUT('	045';) ;	/* COMPARE TOS-1:TOS FOR LESS THAN
OPLE	= .OUT('	046';) ;	/* COMPARE TOS-1:TOS FOR LESS OR EQUAL
OPGE	= .OUT('	047';) ;	/* COMPARE TOS-1:TOS FOR GREATER OR EQUAL
OPGT	= .OUT('	048';) ;	/* COMPARE TOS-1:TOS FOR GREATER THAN
OPBF	= .OUT('	049';) ;	/* BRANCH IF FLAG IS FALSE TO INLINE ADDRESS
OPBT	= .OUT('	050';) ;	/* BRANCH IF FLAG IS TRUE TO INLINE ADDRESS
OPINV	= .OUT('	051';) ;	/* INVERT THE FLAG
OPJMP	= .OUT('	052';) ;	/* JUMP TO INLINE ADDRESS
OPGSB	= .OUT('	053';) ;	/* DO GOSUB TO INLINE ADDRESS
OPRET	= .OUT('	054';) ;	/* RETURN FROM (GOSUB) SUBROUTINE
OPSTP	= .OUT('	055';) ;	/* STOP THE PROGRAM
OPLINE	= .OUT('	056';) ;	/* INLINE 16 BIT NUMBER MARKS BASIC LINE
OPCALL	= .OUT('	057';) ;	/* CALL ASSEMBLY LANGUAGE SUBROUTINE
OPPV	= .OUT('	058';) ;	/* PRINT VALUE ON TOS
OPPCR	= .OUT('	059';) ;	/* PRINT CR (:D) CHARACTER
OPPS	= .OUT('	060';) ;	/* PRINT STRING WHOSE DESCRIPTOR IS ON TOS
OPPSP	= .OUT('	061';) ;	/* PRINT SPACE (:20) CHARACTER
OPINS	= .OUT('	062';) ;	/* INVENT STRING DESCRIPTOR FOR INPUT STRING
OPCHNL	= .OUT('	063';) ;	/* SET CHANNEL NUMBER TO VALUE ON TOS
OPCIN	= .OUT('	064';) ;	/* CATENATE INITIALIZE (MAKE READY)
OPCAT	= .OUT('	065';) ;	/* CONCATENATE STRING TOS TO CATBUF
OPCND	= .OUT('	066';) ;	/* (CONCATENATE END) LOAD STRING DESCRIPTOR OF CATBUF
OPRIGHT	= .OUT('	067';) ;	/* TAKE RIGHT PART OF STRING TOS-1 STARTING AT TOS
OPRESTR	= .OUT('	068';) ;	/* RESTORE FILE TO POSITION SPECIFIED BY TOS
OPWV	= .OUT('	069';) ;	/* WRITE VALUE ON TOS TO FILE IN BINARY
OPWS	= .OUT('	070';) ;	/* WRITE STRING ON TOS TO FILE IN BINARY
OPRV	= .OUT('	071';) ;	/* READ VALUE (6 BYTES) FROM FILE IN BINARY ONTO TOS
OPRS	= .OUT('	072';) ;	/* READ BINARY BYTES FROM FILE TO FILL STRING TOS
OPFOR	= .OUT('	073';) ;	/* DO 'FOR' LOOP INITIALIZATION
OPNEXT	= .OUT('	074';) ;	/* DO A NEXT FOR VARIABLE WHOSE ADDRESS IS INLINE
OPTABCOL	= .OUT('	075';) ;	/* TAB TO NEXT PRINT COLUMN
OPINP	= .OUT('	076';) ;	/* INPUT A VALUE TO TOS
OPEOF	= .OUT('	077';) ;	/* CHECK FOR END OF FILE ON CHANNEL
OPINL	= .OUT('	078';) ;	/* INPUT LINE FROM FILE INTO CATBUF
OPTAB	= .OUT('	079';) ;	/* TAB TO SPECIFIED COLUMN
OPSEQ	= .OUT('	080';) ;	/* COMPARE FOR EQUAL STRINGS
OPSNE	= .OUT('	081';) ;	/* COMPARE FOR NOT EQUAL STRINGS
OPSLT	= .OUT('	082';) ;	/* COMPARE STRING TOS-1:STRING TOS FOR LESS THAN
OPSLE	= .OUT('	083';) ;	/* COMPARE STRING TOS-1:STRING TOS FOR LESS OR EQUAL
OPSGT	= .OUT('	084';) ;	/* COMPARE STRING TOS-1:STRING TOS FOR GREATER THAN
OPSGE	= .OUT('	085';) ;	/* COMPARE STRING TOS-1:STRING TOS FOR GREATER OR EQUAL
OPON	= .OUT('	086';) ;	/* DO ON-GOTO MULTIWAY BRANCH
OPXOR	= .OUT('	087';) ;	/* EXCLUSIVE-OR (BITWISE) TOS INTO TOS-1
OPOKE	= .OUT('	088';) ;	/* POKE BYTE VALUE OF TOS AT ADDRESS WHOSE VALUE IS TOS-1
OPEEK	= .OUT('	089';) ;	/* LOAD BYTE FROM MEMORY ADRESS WHOSE VALUE IS TOS
OPUSE	= .OUT('	090';) ;	/* SET USING STRING TO STRING ON TOS
OPRMPT	= .OUT('	091';) ;	/* OUTPUT STANDARD INPUT PROMPT
OPINT	= .OUT('	092';) ;	/* TAKE THE INTEGER PART OF TOS
OPERR	= .OUT('	093';) ;	/* PUT LAST ERROR NUMBER ON TOS
OPOPN	= .OUT('	094';) ;	/* OPEN FILE WHOSE NAME IS STRING TOS
OPCLS	= .OUT('	095';) ;	/* CLOSE CHANNEL ALREADY SELECTED
OPCREAT	= .OUT('	096';) ;	/* CREATE NEW FILE WHOSE NAME IS STRING TOS
OPCHAIN	= .OUT('	097';) ;	/* CHAIN (LOAD AND EXECUTE OVERLAY) TO FILE WHOSE NAME IS STRING TOS
OPLFREFL	= .OUT('	098';) ;	/* STORE LABEL ADDRESS IN THE ALLOCATED
/*		SCALAR AND BUMP BPC BY 5
OPELN	= .OUT('	099';) ;	/* LOAD LAST ERROR LINE NUMBER
OPPI	= .OUT('	100';) ;	/* LOAD "3.14159265" ONTO STACK
OPFIND	= .OUT('	101';) ;	/* FIND OCCURRENCE OF STRING TOS IN STRING TOS-1
OPUSL	= .OUT('	102';) ;	/* SET USING STRING TO FORMAT STRING
OPJUC	= .OUT('	103';) ;	/* JUMP AROUND USING (FORMAT) STRING
OPINIT	= .OUT('	104';) ;	/* INITIALIZE INLINE ADDRESS TO BYTE STRING
OPZCHN	= .OUT('	105';) ;	/* ZERO THE CHANNEL NUMBER
OPONG	= .OUT('	106';) ;	/* DO "ON ... GOSUB" MULTIWAY GOSUB
OPDEL	= .OUT('	107';) ;	/* DELETE FILE NAMED TOS
OPREN	= .OUT('	108';) ;	/* RENAME FILE NAMED TOS-1 TO TOS
OPSSL	= .OUT('	109';) ;	/* SET STRING LENGTH OF TOS-1 TO TOS
OPSTORE	= .OUT('	110';) ;	/* STORE VALUE TOS TO INLINE ADDRESS
OPSGN	= .OUT('	111';) ;	/* COMPUTE SIGN OF TOS
/*OPASM	= .OUT('	112';) ;	/* ENTER ASSEMBLY LANGUAGE AT .+1
OPLBOOL	= .OUT('	113';) ;	/* LOAD VALUE OF BOOLEAN
OPPRUS	= .OUT('	114';) ;	/* PRINT REST OF USING STRING
OPSETLABEL	= .OUT('	115';) ;	/* EQUIVALENT TO OPLINE, EXCEPT USED FOR LABELS
OPMAXLEN	= .OUT('	116';) ;	/* SIMILAR TO OPLINE
OPSYSCALL1ARG	= .OUT('	117';) ;	/* SYSCALL FUNCTION WITH 1 ARGUMENT
OPSYSCALL2ARG	= .OUT('	118';) ;	/* SYSCALL FUNCTION WITH 2 ARGUMENTS
OPSYSCALL3ARG	= .OUT('	119';) ;	/* SYSCALL FUNCTION WITH 3 ARGUMENTS
OPSYSCALL4ARG	= .OUT('	120';) ;	/* SYSCALL FUNCTION WITH 4 ARGUMENTS
OPCOPYRIGHT	= .OUT('	121';) ;	/* PUSH COPYRIGHT STRING DESCRIPTOR
OPEXTENDED	= .OUT('	122';) ;	/* FIRST BYTE OF 2-BYTE OPCODE
OPSUBRET	= .OUT('	123';) ;	/* RETURN FROM USER SUBROUTINE
OPFNCALL	= .OUT('	124';) ;	/* USER FUNCTION CALL
OPLBINT	= .OUT('	125';) ;	/* LOAD BYTE INTEGER (10-265)
OPEXITLOOP	= .OUT('	126';) ;	/* EXIT FOR LOOP
OPTRP	= .OUT('	127';) ;	/* SET ERROR TRAP ADDRESS
/****** EXTENDED OPCODES *******
OPATN	= .OUT( OPEXTENDED /'	000';) ;	/* TAKE ARC-TANGENT OF TOS
OPSIN	= .OUT( OPEXTENDED /'	001';) ;	/* TAKE TRIGONOMETRIC SIN OF TOS
OPCOS	= .OUT( OPEXTENDED /'	002';) ;	/* TAKE TRIGONOMETRIC COS OF TOS
OPLOG	= .OUT( OPEXTENDED /'	003';) ;	/* TAKE NATURAL LOGARITHM OF TOS
OPEXP	= .OUT( OPEXTENDED /'	004';) ;	/* COMPUTE E (2.71828...) TO THE POWER TOS
OPSQR	= .OUT( OPEXTENDED /'	005';) ;	/* TAKE THE SQUARE ROOT OF TOS
OPRND	= .OUT( OPEXTENDED /'	006';) ;	/* GENERATE A RANDOM NUMBER AND PLACE ON TOS
OPABS	= .OUT( OPEXTENDED /'	007';) ;	/* TAKE ABSOLUTE VALUE OF TOS
OPDBG	= .OUT( OPEXTENDED /'	008';) ;	/* TRANSFER CONTROL TO DEBUG$
OPOWER	= .OUT( OPEXTENDED /'	009';) ;	/* COMPUTE TOS-1 RAISED TO POWER TOS
OPERRST	= .OUT( OPEXTENDED /'	010';) ;	/* CAUSE ERROR THAT WAS TRAPPED BY "ON ERROR GOTO"
OPSETSEED	= .OUT( OPEXTENDED /'	011';) ;	/* SET SEED TO ...
OPCOL	= .OUT( OPEXTENDED /'	012';) ;	/* LOAD CURRENT COLUMN NUMBER OF FILE ONTO STACK
OPGPOP	= .OUT( OPEXTENDED /'	013';) ;	/* POP (OR REAM) THE GOSUB STACK BY TOS LEVELS
OPDAT	= .OUT( OPEXTENDED /'	014';) ;	/* LOAD STRING DESCRIPTOR OF CURRENT DATE
OPTIM	= .OUT( OPEXTENDED /'	015';) ;	/* LOAD STRING DESCRIPTOR OF CURRENT TIME
OPNUM	= .OUT( OPEXTENDED /'	016';) ;	/* CONVERT TOS VALUE TO STRING
OPNUMF	= .OUT( OPEXTENDED /'	017';) ;	/* CONVERT TOS TO STRING USING FORMAT TOS-1
OPVAL	= .OUT( OPEXTENDED /'	018';) ;	/* CONVERT TOS STRING INTO NUMBER
OPTAN	= .OUT( OPEXTENDED /'	019';) ;	/* COMPUTE TRIGONOMETRIC TANGENT OF TOS
/*OPPOLY	= .OUT( OPEXTENDED /'	020';) ;	/* EVALUATE INLINE POLYNOMIAL USING TOS
OPHEX	= .OUT( OPEXTENDED /'	021';) ;	/* GENERATE HEX STRING EQUIVALENT OF TOS
OPGOELN	= .OUT( OPEXTENDED /'	022';) ;	/* GOTO LINE CONTAINING LAST RUNTIME ERROR
OPUPPERC	= .OUT( OPEXTENDED /'	023';) ;	/* CONVERT STRING TO UPPERCASE
OPLOWERC	= .OUT( OPEXTENDED /'	024';) ;	/* CONVERT STRING TO LOWERCASE
OPEXIT	=	.OUT( OPEXTENDED /'	025';) ;	/* EXIT TO SYSTEM
OPLENVECTOR	= .OUT( OPEXTENDED /'	026';) ;	/* PUSH LENGTH OF VECTOR
OPROWSARRAY	= .OUT( OPEXTENDED /'	027';) ;	/* PUSH # ROWS IN ARRAY
OPCOLSARRAY	= .OUT( OPEXTENDED /'	028';) ;	/* PUSH # COLUMNS IN ARRAY
OPFUNRET	= .OUT( OPEXTENDED /'	029';) ;	/* RETURN FROM USER FUNCTION
OPCHR	= .OUT( OPEXTENDED /'	030';) ;	/* RETURN SINGLE BYTE STRING OF VALUE
OPERRCAUSE	= .OUT( OPEXTENDED /'	031';) ;	/* CAUSE ERROR CODE SPECIFIED BY TOS
OPSSA	= .OUT( OPEXTENDED /'	032';) ;	/* SUBSCRIPT STRING ARRAY
OPSAINIT	= .OUT( OPEXTENDED /'	033';) ;	/* STRING ARRAY INITIALIZE
/******** MISCELLANEOUS STUFF *******

/**** SINGLE BYTE LOAD SCALAR INSTRUCTION ****
OPLSCALAR	=
	.OUT( ,*1'+('*1'<64)*$80+('*1'>/64)*3520' ) ;

/**** SINGLE BYTE STORE SCALAR INSTRUCTION ****
OPSSCALAR	=
	.OUT( ,*1'+('*1'<64)*$C0+('*1'>/64)*3008' ) ;

ALLOCATESCALAR	=	.OUT('	EQU	.NSV'/'.NSV	SET	.NSV+1';);
/*	ALLOCATES SCALAR IN SCALAR SPACE
SADDR	=	.OUT( ADDR ':+.TNSS+6*';);	/* COMPUTES ADDRESS OF SCALAR VARIABLE

LABEL	= .OUT(':';) ;
GENLBL	= .OUT('::';) ;
EQUHERE	= .OUT('	EQU	*';) ;
SETHERE	= .OUT('	SET	*';) ;
EQUDATA	= .OUT('	EQU	::';) ;

INIT	= .OUT( OPINIT /
		  DADDR '::' /
		  INTEGER;) ;

RESDATA	= .OUT('::	SET	::+';) ;
DADDR	= .OUT( ADDR ':+';) ;

SIXBYTEINTEGER = .OUT( INTEGER '0' / INTEGER '0' / INTEGER *1 ;);
SIXBYTEFNUM = .OUT( '	FFC	' *1 ;);
SIXBYTEHEXINTEGER = .OUT( INTEGER '0' / INTEGER '0' / INTEGER '$'*1 ;);

INITSCALARHEAD = /* OUTPUT HEAD OF CODE TO INITIALIZE A SCALAR
	.OUT( OPINIT / SADDR '.NSV' / INTEGER '6' ;);

INITVECTORHEAD = /* OUTPUT HEAD OF CODE TO INITIALIZE A VECTOR
	.OUT( *1 EQUDATA /
	      GENLBL #1 EQUHERE'+7' /	/* ESTABLISH BASE OF CONSTANT VECTOR
	      INIT '(' GENLBL #2 ')*6+2' /
	      INTEGER GENLBL #2 '-1' ;);

INITVECTORTAIL = /* OUTPUT TAIL OF CODE TO INITIALIZE A VECTOR
	.OUT( GENLBL #2 '	EQU	(*-' GENLBL #1')/6' / /* # OF INITIALIZING VALUES
	      RESDATA GENLBL #2'*6+2' ;);

ORIGIN	= .OUT('	ORG	';) ;
BYTE	= .OUT('	+';) ;
RES	= .OUT('	RMB	';) ;
TEXT	= .OUT('	FCC	';) ;
ADDR	= .OUT('	#';) ;
INTEGER	= .OUT('	#';) ;
CODEBODY	= .OUT('.CODE';) ;

/*	COMPILED CODE SIZE SEEMS TO BE 50% OF TEXT SIZE, IGNORING VARIABLE SPACE
.END
