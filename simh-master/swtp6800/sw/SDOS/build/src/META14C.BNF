/*	EDITED 12/1/80
/*	METACOMPILER BNF FOR 6800 SERIES SYSTEMS
/*	COPYRIGHT (C) 1977 SOFTWARE DYNAMICS
/*	ALL RIGHTS RESERVED
/*
.SYNTAX METAPLUS 'METAPLUS Version 1.4c Copyright (c) 1979 Software Dynamics'

ATTRIBUTES	= ATTRIBUTE, TOKEN, SUBR, REFERENCED, DEFINED, STATEVARIABLE,
		KEYWORD, TYPENAME, STATEVALUE;

/* TYPES = ... ;

KEYWORDS	= ;

/*STATEVARIABLES	= .... ;

ERROR:

!*
!*	ERROR HANDLER
!*	LOOK FOR $(#';' :0-:7F) ';'
!*
!SUCCESS	EQU	$0D39
!FAILURE	EQU	$0C39
!LASTTIME	FCB	0	1 --> DON'T ACCEPT TOKEN THIS TIME
!ERRORTOKEN	LDAA	LASTTIME	DID WE SEE ';' LAST TIME THRU ?
!	BNE	ERRORTOKENDONE	B/ YES
!	JSR	GETTOKENCHAR	GO GET ONE
!	CMPA	#';	IS IT A SEMICOLON?
!	BNE	SAYWEGOTIT	B/ NOPE, EAT IT UP
!	INC	LASTTIME	THIS IS IT!
!	JSR	REMBLANKS	EAT UP ALL THE BLANKS, TOO
!SAYWEGOTIT	SEC
!	RTS		SAY THAT WE ARE HAPPY
!ERRORTOKENDONE	CLR	LASTTIME	SET UP FOR NEXT ERROR
!	CLC
!	RTS
;

ID:

!*
!*	ID TEST
!*	LOOK FOR 'A'-'Z' $('A'-'Z' / '0'-'9')
!*
!KEYWORDTOKEN	EQU	*
!	JSR	GETTOKENCHAR	GET ME AN INPUT CHAR
!	BSR	ISLETTER
!	BCC	ID3	B/ NO
!ID1	JSR	GETTOKENCHAR
!	BSR	ISLETTER
!	BCS	ID1	B/ YES, KEEP GOING
!	BSR	ISDIGIT
!	BCS	ID1	B/ YES, KEEP GOING
!	CMPA	#'$	TRAILING '$' ?
!	BEQ	ID2	B/ YES, ACCEPT IT
!	JSR	BACKUP	DON'T COUNT THE LAST CHAR
!ID2	SUCCESS		ALL IS WELL
!ID3	FAILURE		NOT AN ID
;

NUM:

!*
!*	NUM
!*	LOOK FOR '0'-'9' $('0'-'9')
!*
!	JSR	GETTOKENCHAR	GET ME A CHAR
!	BSR	ISDIGIT IS IT A DIGIT?
!	BCC	NUM2	B/ NO
!NUM1	JSR	GETTOKENCHAR	GET ME ANOTHER CHAR
!	BSR	ISDIGIT IS THIS A DIGIT?
!	BCS	NUM1	B/ YES, KEEP GOING
!	JSR	BACKUP	DON'T COUNT THE LAST CHAR
!	SUCCESS		ALL IS WELL
!NUM2	FAILURE	
;

STARQUERY:

!*
!*	STARQUERY
!*	LOOK FOR '*' '0'-'9' $('0'-'9') '?'
!*
!	JSR	GETTOKENCHAR
!	CMPA	#'*
!	BNE	STARQUERY2	B/ NO GOOD
!	JSR	GETTOKENCHAR
!	BSR	ISDIGIT IS IT A DIGIT?
!	BCC	STARQUERY2	B/ NO
!STARQUERY1	JSR	GETTOKENCHAR
!	BSR	ISDIGIT IS IT A DIGIT?
!	BCS	STARQUERY1	B/ YES, KEEP GOING
!	CMPA	#'?
!	BNE	STARQUERY2	B/NOT A TOKEN
!	SUCCESS		ALL IS WELL
!STARQUERY2	FAILURE	
!*
!*	CHARACTER CHECK ROUTINES
!*
!ISLETTER	CMPA	#'A	IS IT A LETTER?
!	BCS	ISLETTER1	B/ NO
!	CMPA	#'Z+1
!	RTS		C BIT ON IF YES, OFF IF NO
!ISLETTER1	CLC		NOT A LETTER
!	RTS
!*
!ISHEXDIGIT	CMPA	#'A	IS IT A HEX DIGIT?
!	BCS	ISDIGIT	B/ NO
!	CMPA	#'F+1
!	BCS	ISDIGIT1	B/ YES
!ISDIGIT	CMPA	#'0	IS IT A DIGIT?
!	BCS	ISLETTER1	B/ NO
!	CMPA	#'9+1
!ISDIGIT1	RTS		C BIT ON IF YES, OFF IF NO
;

HEXNUM:

!*
!*	HEXNUM
!*	LOOK FOR ('0'-'9' / 'A'-'F') $('0'-'9' / 'A'-'F')
!*
!	JSR	GETTOKENCHAR
!	BSR	ISHEXDIGIT	IS IT A HEX DIGIT?
!	BCC	HEXNUM2 B/ NO
!HEXNUM1	JSR	GETTOKENCHAR
!	BSR	ISHEXDIGIT	IS IT A HEX DIGIT?
!	BCS	HEXNUM1	B/ YES, KEEP GOING
!	JSR	BACKUP	DON'T COUNT THE LAST CHAR
!	SUCCESS		ALL IS WELL
!HEXNUM2	FAILURE		TOO BAD
;

NONBLANK:

!*
!*	NONBLANK
!*	LOOK FOR ANYTHING WHICH REMBLANK WON'T SWALLOW....
!
!	JSR	GETTOKENCHAR	GET FIRST CHARACTER OF "NONBLANK"
!	CMPA	#$20	A BLANK?
!	BEQ	NONBLANKFAIL
!	CMPA	#$9	TAB?
!	BEQ	NONBLANKFAIL
!	CMPA	#$D	CR?
!	BEQ	NONBLANKFAIL
!	CMPA	#$C	FORM?
!	BEQ	NONBLANKFAIL
!	CMPA	#';	END RULE ?
!	BEQ	NONBLANKFAIL
!	CMPA	#'/	BEGIN COMMENT ?
!	BNE	NONBLANKL	B/ NO, MUST BE WHAT WE WANT!
!	JSR	GETTOKENCHAR	LOOKS LIKE BEGIN COMMENT
!	CMPA	#'*	...?
!	BNE	NONBLANKL	B/ NOT BEGIN COMMENT!
!	JSR	BACKUP	IS BEGIN COMMENT, REJECT IT
!	JSR	BACKUP
!NONBLANKFAIL	FAILURE	
!NONBLANKL	JSR	GETTOKENCHAR	GET NEXT CHARACTER OF "NONBLANK"
!	CMPA	#$20	A BLANK?
!	BEQ	NONBLANKACCEPT
!	CMPA	#$9	TAB?
!	BEQ	NONBLANKACCEPT
!	CMPA	#$D	CR?
!	BEQ	NONBLANKACCEPT
!	CMPA	#$C	FORM?
!	BEQ	NONBLANKACCEPT
!	CMPA	#';	END RULE ?
!	BEQ	NONBLANKACCEPT
!	CMPA	#'/	BEGIN COMMENT ?
!	BNE	NONBLANKL	B/ NO, MUST BE WHAT WE WANT!
!	JSR	GETTOKENCHAR	LOOKS LIKE BEGIN COMMENT
!	CMPA	#'*	...?
!	BNE	NONBLANKL	B/ NOT BEGIN COMMENT!
!	JSR	BACKUP	IS BEGIN COMMENT, REJECT IT
!NONBLANKACCEPT	JSR	BACKUP
!	SUCCESS	
;

STRING:

!*
!*	STRING
!*	LOOK FOR	"'" $(#"'" ;0-:7F) "'" /
!*		'"' $(#'"' :0-:7F) '"'
!*
!	JSR	GETTOKENCHAR
!	CMPA	#''	SINGLE QUOTE?
!	BNE	STRING2	B/ NO
!STRING1	JSR	GETTOKENCHAR
!	CMPA	#''	SINGLE QUOTE?
!	BNE	STRING1	B/ NO, KEEP GOING
!	SUCCESS	
!STRING2	CMPA	#'"	DOUBLE QUOTE?
!	BNE	STRING5	B/ NO, IT'S NOT A STRING
!STRING3	JSR	GETTOKENCHAR
!	CMPA	#'"	DOUBLE QUOTE?
!	BNE	STRING3	B/ NO, KEEP GOING
!	SUCCESS		ALL IS WELL
!STRING5	FAILURE	
;

DEBLANK:
!DEBLANKTOKEN	CLC
!	RTS		WE HAVE EXPLICIT BLANK SURPRESSOR IN METAPLUS
;

EATBLANKS:
!*
!*	REMOVE BLANKS
!*	LOOK FOR $(' ' / :9 / :D / '/' '*' $(#:D :0-:7F) :D / :C)
!*
!	BSR	REMBLANKS
!	FAILURE		IN SPITE OF THE FACE THAT WE ATE A LOT OF STUFF
!*
!REMBLANKS	JSR	GETTOKENCHAR
!	CMPA	#$20	IS IT A BLANK?
!	BEQ	REMBLANK3	B/ YES, TRY FOR ANOTHER
!	CMPA	#$9	IS IT A TAB?
!	BEQ	REMBLANK3	B/ YES, TRY FOR ANOTHER
!	CMPA	#$D	IS IT A CR?
!	BEQ	REMBLANK3	B/ YES, TRY FOR ANOTHER
!	CMPA	#$C	FORM FEED ?
!	BEQ	REMBLANK3
!	CMPA	#'/	IS IT A COMMENT?
!	BNE	REMBLANK1	B/ NO
!	JSR	GETTOKENCHAR
!	CMPA	#'*
!	BEQ	REMBLANK2	B/ YES
!	JSR	BACKUP
!REMBLANK1	JSR	BACKUP
!	RTS
!REMBLANK2	JSR	GETTOKENCHAR
!	PSHA
!	JSR	EATTOKEN
!	PULA
!	CMPA	#$D	IS IT A CR?
!	BNE	REMBLANK2	B/ NO, KEEP GOING
!	BRA	REMBLANKS	B/ YES, TRY FOR ANOTHER
!REMBLANK3	JSR	EATTOKEN
!	BRA	REMBLANKS
;

NOTENDOFLINECHARACTER:
!*	RECOGNIZES ANYTHING EXCEPT END OF LINE
!	JSR	GETTOKENCHAR
!	CMPA	#$D
!	BNE	NOTENDOFLINES
!	FAILURE	
!NOTENDOFLINES	SUCCESS	
;

BLANKS	= EATBLANKS / .EMPTY ;	/* DIRTY TRICK TO SWALLOW ALL BLANKS

METAPLUS	= BLANKS '.SYNTAX' BLANKS ID BLANKS STRING BLANKS
	.OUT('	TABS	20,28,44,45' /
	'	WITH	WI=107,DE=51' /
	'* ' *1 ' COMPILED BY METAPLUS VERSION 1.4c' )
	( 'ATTRIBUTES' BLANKS '=' .OUT( SETLOADADDRESS '0' )
		ATTRIBUTEDEFINITION $( ',' ATTRIBUTEDEFINITION ) ';' /
	  .EMPTY )
	BLANKS
	( 'TYPES' BLANKS '=' .OUT( SETLOADADDRESS '1' ) /* TYPE 0 is 'Undefined'
		TYPEDEFINITION $( ',' TYPEDEFINITION ) ';' /
	  .EMPTY )
	.OUT(	SETLOADADDRESS '$104	METAMACHINE ENTRY POINTS' /
		'STARTTOKEN	RMB	3'/
		'GETTOKENCHAR	RMB	3'/
		'BACKUP	RMB	3'/
		'EATTOKEN	RMB	3'/
		'FINDSTAR	RMB	3'/
		'FINDSTARN	RMB	3'/
		'PUTCHAR	RMB	3'/
		'ENTERMETA	RMB	3'/

		SETLOADADDRESS '$C80' /
		'	JMP	DEBLANKTOKEN' /
		'	JMP	ERRORTOKEN' /
		'	JMP	KEYWORDTOKEN' /
		ADDRESS LABEL #2 /	/* POINTER TO END OF META PROGRAM
		ADDRESS '.KEYWORDLIST' /
		ADDRESS LABEL #3 /	/* POINTER TO BANNER STRING
		'.TA' EQUHERE'-6' /
		'.TC	SET	3' /
		'	RPT	29' /
		ADDRESS '0' /	/* POINTERS TO TOKEN-BUSTING ROUTINES INITZED TO ZERO
		'.SA' EQUHERE '-$C0*2' /
		'.SC	SET	$C0' /
		'	RPT	576' /
		ADDRESS '0' /	/* POINTERS TO SUBROUTINES INITZED TO ZERO
		LABEL #3 EQUHERE /
		BYTE LABEL #1'-*-1' /
		TEXT *2 /
		BYTE '$D' /
		LABEL #1 EQUHERE )
	SREF[ *1 ] .OUT( MBE / MFIN )
	.OUT( PREVIOUSKEYWORD SETEQU '0' )
	BLANKS
	( 'KEYWORDS' BLANKS '=' BLANKS $KEYWORDNAME ';' / .EMPTY )
	.OUT( '.KEYWORDLIST' EQUATE PREVIOUSKEYWORD )
	BLANKS
	.OUT( '.VC' SETEQU '0' )
	( 'STATEVARIABLES' BLANKS '=' BLANKS $STATEVARDEFINITION ';' / .EMPTY )
	BLANKS
	$$STMT '.END' .OUT(LABEL #2 EQUHERE / '	END' );

ATTRIBUTEDEFINITION = BLANKS ID +ATTRIBUTE .OUT(* RESERVE '1') BLANKS ;

TYPEDEFINITION = BLANKS ID +TYPENAME .OUT(* RESERVE '1') BLANKS ;

KEYWORDNAME	= ID +KEYWORD BLANKS
	.OUT( *1 EQUHERE )
	.OUT( LABEL #2 BYTE '0'/ BYTE '0'/	/* FLAG BITS
		BYTE '0' /
		ADDRESS PREVIOUSKEYWORD /
		BYTE '$80+' LABEL #1'-*-1' /
		TEXT '"' *1 '"' /
		LABEL #1 EQUHERE /
		PREVIOUSKEYWORD SETEQU LABEL #2 ) ;

STATEVARDEFINITION	= ID +STATEVARIABLE BLANKS
	.OUT( *1 EQUATE '.VC'/'.VC' SETEQU '.VC+1' / '.VV' SETEQU '0' )
	'(' BLANKS $ STATENAMEDEFINITION ')' BLANKS ;

STATENAMEDEFINITION	=
	ID +STATEVALUE .OUT( *1 EQUATE '.VV'/'.VV' SETEQU '.VV+1' ) BLANKS ;

STMT	= ID BLANKS ( '=' BLANKS SDEF[ *1 ]
		PHRASE $( '/' BLANKS .OUT( MRT ) PHRASE) .OUT( MR ) /
		':' TDEF[ *1 ] BLANKS ASSEMBLY $ASSEMBLY ) ';' BLANKS ;

ASSEMBLY	= '!'
	$( ASSEMBLYCHARACTER ) :D .OUT( ) ;

ASSEMBLYCHARACTER	= NOTENDOFLINECHARACTER .OUT( * ; ) ;

CHOICE	= PHRASE
	( '/' BLANKS .OUT(BRANCHTRUE #1 BTTAIL)
		PHRASE $( '/' BLANKS .OUT(BRANCHTRUE #1 BTTAIL) PHRASE)
		.OUT(LABEL #1 EQUHERE) / .EMPTY );

PHRASE	= ( ACTION PHTAIL /
	NOTTST .OUT(BRANCHFALSE #1 BFTAIL)
		$(NOTTST .OUT(BRANCHFALSE #1 BFTAIL) )
		( TEST .OUT(BRANCHFALSE #1 BFTAIL) / ACTION )
		PHTAIL
		.OUT(LABEL #1 EQUHERE) /
	TEST ( -'/' -')' -';' .OUT(BRANCHFALSE #1 BFTAIL) PHTAIL
		.OUT(LABEL #1 EQUHERE) /
		.EMPTY ) ) BLANKS ;

PHTAIL	= $( ACTION / TEST .OUT( MBE ) );

TEST	=
	( ID ( ?TOKEN TREF[ *1 ] /
	       ?STATEVARIABLE '?' ID
			( ?STATEVALUE .OUT( MQUERYSTATE *1 ',' *2 ) /
			  ??'Need State value name here' ) /
	       ?KEYWORD .OUT( MKEYWORDTEST *1 ) /
	       .EMPTY SREF[ *1 ]
			( '[' BLANKS ARGS ']' / .EMPTY ) ) /
	STRING .OUT( MTEST ) OUTSTRING[ *1 ] /
	':' HEXNUM .OUT( MTEST / BYTE '$80+$'*1 ) /
	'(' BLANKS CHOICE ')' /
	'?' ( ID ?ATTRIBUTE / NUM ) .OUT( MQUERY * ) /
	NOTTST /
	'*' NUM '?'
		 ( 'UNDEFINED' .OUT( MQUERYTYPEN *1 ',0' ) /
		   ID
			( ?ATTRIBUTE .OUT( MQUERYN *1 ',' *2 ) /
			  ?TYPENAME .OUT( MQUERYTYPEN *1 ',' *2 ) ) ) ) BLANKS ;

ARGS	= .OUT( MPARAMS )
	( '#' .OUT( BYTE LABEL #1 '-*-1+$80' ) / .EMPTY .OUT( BYTE LABEL #1 '-*-1' ) )
	$ ARG1
	.OUT( LABEL #1 EQUHERE );

ARG1	= '*' ( NUM .OUT( BYTE * ) / .EMPTY .OUT( BYTE '1') ) BLANKS ;

OUTSTRING	= .EMPTY .OUT( TEXT ; )
	.ASM(
!	LDAB	#1	GO FIND THE FIRST STRIN
!	JSR	FINDSTARN	RETURNS (X) POINTING TO STRING, (B) = STRING LENGTH
!	SUBB	#2	OUTPUT N-1 BYTES
!STRINGOUT1	LDAA	0,X	GET A CHARACTER
!	JSR	PUTCHAR	AND PUT IT OUT
!	INX
!	DECB		ARE WE ALMOST DONE ?
!	BNE	STRINGOUT1	B/ NO, MORE TO DO
!	LDAA	1,X	GET THE CLOSING QUOTE
!	JSR	PUTCHAR
!	LDAA	#$D
!	JSR	PUTCHAR	END THE LINE
!	LDAA	#$9
!	JSR	PUTCHAR
!	LDAA	#''
!	JSR	PUTCHAR
!	LDAA	0,X	GRAB THE LAST CHARACTER
!	JSR	PUTCHAR	AND PUT IT OUT
)	.OUT('+$80');

NOTTST	=
	( '-' ( STRING .OUT( MTEST ) OUTSTRING[ *1 ] .OUT( MNOTTEST ) /
		':' HEXNUM .OUT( MTEST / BYTE '$80+$'* / MNOTTEST ) /
		ID ( ?TOKEN TREF[ *1 ] .OUT( MNOTTEST ) /
		     ?KEYWORD .OUT( MKEYWORDTEST *1 / MNOTTEST ) /
		     ?ATTRIBUTE .OUT( MUNTAG *) ) ) ) BLANKS ;

ACTION	=
	( '.OUT' BLANKS '(' BLANKS $OUTOBJ
		( ';' BLANKS / .EMPTY .OUT( MCR ) ) ')' /
	  '.ASM' BLANKS '(' BLANKS .OUT( MASM ) ASSEMBLY $ ASSEMBLY ')'
		.OUT('	JSR	ENTERMETA' ) /
	  '.EMPTY' .OUT( MSET ) /
	  '$$' .OUT( MDRULE ) DOLLARLOOP /
	  '$' DOLLARLOOP /
	  '+' ( ID ?ATTRIBUTE / NUM ) .OUT( MTAG * ) /
	  '??' STRING .OUT( MERR ) OUTSTRING[ *1 ] /
	  '.SET' BLANKS ID
		( ?STATEVARIABLE '='
			ID ( ?STATEVALUE .OUT( MSETSTATE *1 ',' *2 ) /
			     ??'Need State value name here' ) /
		  ??'Need State variable name here' ) /
	  -STARQUERY '*' NUM
		( '+' ID ?ATTRIBUTE .OUT( MTAGN *1 ',' *2 ) /
		  '='	( 'UNDEFINED' .OUT( MSETTYPEN *1 ',0' ) / /* FOR COMPLETENESS
			  ID ?TYPENAME .OUT( MSETTYPEN *1 ',' *2 ) ) /
		  '-' ID ?ATTRIBUTE .OUT( MUNTAGN *1 ',' *2 ) /
		  '^' .OUT( MOVESTRINGUP *) ) /
	  '.INCLUDE' .OUT( MINCLUDE ) ) BLANKS;

DOLLARLOOP	=
	.OUT( LABEL #1 EQUHERE )
	BLANKS TEST
	.OUT( BRANCHTRUE #1 BTTAIL / MSET ) ;

OUTOBJ	=
	( STRING .OUT( MCL ) OUTSTRING[ *1 ] /
	  ID ( ?TOKEN TKNNOTLEGAL /
		.EMPTY SREF[ *1 ]
			( '[' BLANKS ARGS ']' / .EMPTY )  ) /
	  '#' NUM .OUT( MGENL * ) /
	  '*' ( NUM .OUT( MOUTN * ) / .EMPTY .OUT( MOUT ) ) /
	  ',' .OUT( MTAB ) /
	  '/' .OUT( MCR ) ) BLANKS ;

TKNNOTLEGAL	= ??'You cannot look for a token in the middle of a .OUT';

SDEF	=
	( *1?TOKEN ERRISTOKENALREADY / .EMPTY *1+SUBR)
	( *1?DEFINED ERRISALREADYDEFD / .EMPTY *1+DEFINED)
	( *1?REFERENCED / .EMPTY .OUT( *1 ASSIGNSUBRNUMBER ) )
	.OUT(	'.' SETEQU '*' /
		SETLOADADDRESS *1 '*2+.SA' /
		ADDRESS '.' /
		SETLOADADDRESS '.');

ASSIGNSUBRNUMBER	= .OUT( EQUATE '.SC' / '.SC' SETEQU '.SC+1';);

ERRISTOKENALREADY	= ??'Already defined as a token';

ERRISALREADYDEFD	= ??'Subroutine already defined';

SREF	=
	( *1?TOKEN ERRISTOKENALREADY / .EMPTY *1+SUBR )
	( *1?REFERENCED /
		( *1?DEFINED / .EMPTY .OUT( *1 ASSIGNSUBRNUMBER) ) )
	*1+REFERENCED .OUT( , *1 );	/* LET ASSEMBLER FIGURE OUT HOW MANY BYTES TO USE!

TDEF	=
	( *1?SUBR ERRALREADYISSUBR / .EMPTY *1+TOKEN)
	( *1?DEFINED ERRTOKENALREADYDEFD / .EMPTY *1+DEFINED )
	( *1?REFERENCED / .EMPTY .OUT( *1 ASSIGNTOKENNUMBER) )
	.OUT( '.' SETEQU '*'/
		SETLOADADDRESS *1 '*2+.TA' /
		ADDRESS '.' /
		SETLOADADDRESS '.');

ASSIGNTOKENNUMBER	= .OUT( EQUATE '.TC' / '.TC' SETEQU '.TC+1';);

ERRALREADYISSUBR	= ??'Already defined as a subroutine';

ERRTOKENALREADYDEFD	= ??'Token is already defined';

TREF	=
	( *1?SUBR ERRALREADYISSUBR / .EMPTY *1+TOKEN )
	( *1?REFERENCED /
		( *1?DEFINED / .EMPTY .OUT( *1 ASSIGNTOKENNUMBER ) ) )
	*1+REFERENCED .OUT( BYTE *1 );

/*	CODE GENERATORS
/*
EQUHERE	= .OUT( EQUATE '*';);
EQUATE	= .OUT('	EQU	';);
SETEQU	= .OUT('	SET	';);
SETLOADADDRESS	= .OUT('	ORG	';);
BYTE	= .OUT('	+';);
ADDRESS	= .OUT('	#';);
TEXT	= .OUT('	FCC	';);
LABEL	= .OUT(':';);
RESERVE	= .OUT('	RMB	';);
PREVIOUSKEYWORD	= .OUT( '.PK' ;);

BRANCHTRUE	= .OUT( '	((:';);
BTTAIL	= .OUT('-*)&$3FFF)+$4000';);

BRANCHFALSE	= .OUT( '	((:';);
BFTAIL	= .OUT('-*)&$3FFF)+$8000';);

MFIN	= .OUT('	0';);	/* ENDS METAMACHINE EXECUTION

MTEST	= .OUT('	$21';);	/* COMPARE INPUT TO STRING
MNOTTEST	= .OUT('	$22';);	/* INVERT TOKEN AND STRING TEST
MTAG	= .OUT('	$23,';);	/* TAG THE STAR STRING
MTAGN	= .OUT('	$24,';);	/* TAG THE NTH STRING
MUNTAG	= .OUT('	$25,';);	/* UNTAG THE STAR STRING
MUNTAGN	= .OUT('	$26,';);	/* UNTAG THE NTH STRING
MQUERY	= .OUT('	$27,';);	/* QUERY THE STAR STRING
MQUERYN	= .OUT('	$28,';);	/* QUERY THE NTH STRING
MR	= .OUT('	$29';);	/* RETURN FROM META SUBROUTINE
MRT	= .OUT('	$2A';);	/* RETURN IF TRUE
MRF	= .OUT('	$2B';);	/* RETURN IF FALSE
MBE	= .OUT('	$2C';);	/* COMPILATION ERROR IF FALSE
MERR	= .OUT('	$2D';);	/* DISPLAY ERROR STRING
MTAB	= .OUT('	$2E';);	/* OUTPUT 'TAB' CHARACTER
MCR	= .OUT('	$2F';);	/* OUTPUT 'CR' CHARACTER
MCL	= .OUT('	$30';);	/* COPY LITERAL (STAR STRING) TO OUTPUT
MOUT	= .OUT('	$31';);	/* OUTPUT STAR STRING
MOUTN	= .OUT('	$32,';);	/* OUTPUT NTH STRING
MGENL	= .OUT('	$33,';);	/* GENERATE LABEL NUMBER
MSET	= .OUT('	$34';);	/* SET THE FLAG
MDRULE	= .OUT('	$35';);	/* REMEMBER DISTINGUISHED RULE
MINCLUDE	= .OUT('	$36';);	/* OPEN * STRING AS NEW INPUT CHANNEL
MOVESTRINGUP	= .OUT('	$37,';);	/* PASS STRING TO CALLING ROUTINE
MPARAMS	= .OUT('	$38';);	/* PASS PARAMETERS
MASM	= .OUT('	$39';);	/* ENTER ASSEMBLY CODE
MSETSTATE	= .OUT('	$3A,';);	/* SET STATE VARIABLE
MQUERYSTATE	= .OUT('	$3B,';);	/* QUERY STATE VARIABLE
MSETTYPEN = .OUT('	$3C,';);	/* SET TYPE OF NTH STRING
MQUERYTYPEN = .OUT('	$3D,';);	/* QUERY NTH STRING FOR TYPE
MKEYWORDTEST =	.OUT('	$3E,#';);	/* TEST FOR KEYWORD

.END	!!!!!!!!
